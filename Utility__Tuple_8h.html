<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Hydra: Utility_Tuple.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo_Hydra2.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Hydra
   &#160;<span id="projectnumber">3.0.0</span>
   </div>
   <div id="projectbrief">A header-only templated C++ framework to perform data analysis on massively parallel platforms.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('Utility__Tuple_8h.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#namespaces">Namespaces</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Utility_Tuple.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;<a class="el" href="">hydra/detail/Config.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="">hydra/Types.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="">hydra/detail/utility/Generic.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="">hydra/detail/TagTraits.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="">hydra/detail/FunctorTraits.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="">hydra/Parameter.h</a>&gt;</code><br />
<code>#include &lt;hydra/detail/external/hydra_thrust/tuple.h&gt;</code><br />
<code>#include &lt;hydra/detail/external/hydra_thrust/detail/type_traits.h&gt;</code><br />
<code>#include &lt;hydra/detail/external/hydra_thrust/iterator/detail/tuple_of_iterator_references.h&gt;</code><br />
<code>#include &lt;type_traits&gt;</code><br />
<code>#include &lt;array&gt;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for Utility_Tuple.h:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="Utility__Tuple_8h__incl.svg" width="100%" height="600"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</div>
</div><div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="Utility__Tuple_8h__dep__incl.svg" width="100%" height="600"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</div>
</div>
<p><a href="">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1CompareTuples.html">hydra::detail::CompareTuples&lt; N, COM &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1is__homogeneous.html">hydra::detail::is_homogeneous&lt; A, Tuple &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1is__homogeneous__base.html">hydra::detail::is_homogeneous_base&lt; A, Tp, I &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1is__homogeneous__base_3_01A_00_01Tp_00_010_01_4.html">hydra::detail::is_homogeneous_base&lt; A, Tp, 0 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1detail_1_1references__tuple__type"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1references__tuple__type">hydra::detail::references_tuple_type&lt; N, T &gt;</a></td></tr>
<tr class="separator:structhydra_1_1detail_1_1references__tuple__type"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1detail_1_1tuple__cat__type"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1tuple__cat__type">hydra::detail::tuple_cat_type&lt; Tuple1, Tuple2 &gt;</a></td></tr>
<tr class="separator:structhydra_1_1detail_1_1tuple__cat__type"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1detail_1_1tuple__cat__type_3_01hydra__thrust_1_1detail_1_1tuple__of__iterator__re5bb9ebd0e2b48fed7e7ce237c7799785"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1tuple__cat__type_3_01hydra__thrust_1_1detail_1_1tuple__of__iterator__re5bb9ebd0e2b48fed7e7ce237c7799785">hydra::detail::tuple_cat_type&lt; hydra_thrust::detail::tuple_of_iterator_references&lt; T1... &gt;, hydra_thrust::detail::tuple_of_iterator_references&lt; T2... &gt; &gt;</a></td></tr>
<tr class="separator:structhydra_1_1detail_1_1tuple__cat__type_3_01hydra__thrust_1_1detail_1_1tuple__of__iterator__re5bb9ebd0e2b48fed7e7ce237c7799785"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1detail_1_1tuple__cat__type_3_01hydra__thrust_1_1tuple_3_01T1_8_8_8_01_4_00_01hydrfed0294bfa8beb4efb8ca45fc614f789"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1tuple__cat__type_3_01hydra__thrust_1_1tuple_3_01T1_8_8_8_01_4_00_01hydrfed0294bfa8beb4efb8ca45fc614f789">hydra::detail::tuple_cat_type&lt; hydra_thrust::tuple&lt; T1... &gt;, hydra_thrust::tuple&lt; T2... &gt; &gt;</a></td></tr>
<tr class="separator:structhydra_1_1detail_1_1tuple__cat__type_3_01hydra__thrust_1_1tuple_3_01T1_8_8_8_01_4_00_01hydrfed0294bfa8beb4efb8ca45fc614f789"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1detail_1_1tuple__type"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1tuple__type">hydra::detail::tuple_type&lt; N, T &gt;</a></td></tr>
<tr class="separator:structhydra_1_1detail_1_1tuple__type"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacehydra"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html">hydra</a></td></tr>
<tr class="memdesc:namespacehydra"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic policies definition. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacehydra_1_1detail"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html">hydra::detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacehydra_1_1detail_1_1utils"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail_1_1utils.html">hydra::detail::utils</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a02f4955fdb3b1d3d98c25b46369edbeb"><td class="memTemplParams" colspan="2">template&lt;typename R , typename T , size_t I&gt; </td></tr>
<tr class="memitem:a02f4955fdb3b1d3d98c25b46369edbeb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::detail::enable_if&lt;(I==hydra_thrust::tuple_size&lt; T &gt;::value), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a02f4955fdb3b1d3d98c25b46369edbeb">hydra::detail::_get_element</a> (const size_t, T &amp;, R *&amp;)</td></tr>
<tr class="separator:a02f4955fdb3b1d3d98c25b46369edbeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56f1616d93ab32d59a37fbb6b88c2eda"><td class="memTemplParams" colspan="2">template&lt;typename R , typename T , size_t I = 0&gt; </td></tr>
<tr class="memitem:a56f1616d93ab32d59a37fbb6b88c2eda"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::detail::enable_if&lt;(I&lt; hydra_thrust::tuple_size&lt; T &gt;::value), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a56f1616d93ab32d59a37fbb6b88c2eda">hydra::detail::_get_element</a> (const size_t index, T &amp;t, R *&amp;ptr)</td></tr>
<tr class="separator:a56f1616d93ab32d59a37fbb6b88c2eda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02fb5a0d9129f9528d830253d5144166"><td class="memTemplParams" colspan="2">template&lt;typename TupleType , typename ArrayType , size_t I&gt; </td></tr>
<tr class="memitem:a02fb5a0d9129f9528d830253d5144166"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::detail::enable_if&lt; I==hydra_thrust::tuple_size&lt; TupleType &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail_1_1utils.html#a02fb5a0d9129f9528d830253d5144166">hydra::detail::utils::_tuple_to_array</a> (TupleType const &amp;, ArrayType *)</td></tr>
<tr class="separator:a02fb5a0d9129f9528d830253d5144166"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a498be0db424a8fb9eb104c824560c620"><td class="memTemplParams" colspan="2">template&lt;typename Return_Type , typename ArgType , typename ... Tp, typename  = typename hydra_thrust::detail::enable_if&lt;std::is_convertible&lt;Return_Type, double&gt;::value || std::is_constructible&lt;hydra_thrust::complex&lt;double&gt;,Return_Type&gt;::value &gt;::type&gt; </td></tr>
<tr class="memitem:a498be0db424a8fb9eb104c824560c620"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> Return_Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a498be0db424a8fb9eb104c824560c620">hydra::detail::accumulate</a> (ArgType &amp;x, hydra_thrust::tuple&lt; Tp... &gt; &amp;t)</td></tr>
<tr class="separator:a498be0db424a8fb9eb104c824560c620"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ad8b6c8a043ca17c3c6571487a00af3"><td class="memTemplParams" colspan="2">template&lt;typename Return_Type , typename ArgType , typename ... Tp, typename  = typename hydra_thrust::detail::enable_if&lt;std::is_convertible&lt;Return_Type, double&gt;::value || std::is_constructible&lt;hydra_thrust::complex&lt;double&gt;,Return_Type&gt;::value &gt;::type&gt; </td></tr>
<tr class="memitem:a6ad8b6c8a043ca17c3c6571487a00af3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> Return_Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a6ad8b6c8a043ca17c3c6571487a00af3">hydra::detail::accumulate</a> (ArgType const &amp;x, hydra_thrust::tuple&lt; Tp... &gt; const &amp;t)</td></tr>
<tr class="separator:a6ad8b6c8a043ca17c3c6571487a00af3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab89cdc62576c0e346bbbf0e86c517e06"><td class="memTemplParams" colspan="2">template&lt;typename Return_Type , typename ArgType1 , typename ArgType2 , typename ... Tp, typename  = typename hydra_thrust::detail::enable_if&lt;std::is_convertible&lt;Return_Type, double&gt;::value || std::is_constructible&lt;hydra_thrust::complex&lt;double&gt;,Return_Type&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:ab89cdc62576c0e346bbbf0e86c517e06"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> Return_Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#ab89cdc62576c0e346bbbf0e86c517e06">hydra::detail::accumulate2</a> (ArgType1 &amp;x, ArgType2 &amp;y, hydra_thrust::tuple&lt; Tp... &gt; &amp;t)</td></tr>
<tr class="separator:ab89cdc62576c0e346bbbf0e86c517e06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7d3ac2f47956b582edbf82881afccb6"><td class="memTemplParams" colspan="2">template&lt;typename Return_Type , typename ArgType1 , typename ArgType2 , typename ... Tp, typename  = typename hydra_thrust::detail::enable_if&lt;std::is_convertible&lt;Return_Type, double&gt;::value || std::is_constructible&lt;hydra_thrust::complex&lt;double&gt;,Return_Type&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:ad7d3ac2f47956b582edbf82881afccb6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> Return_Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#ad7d3ac2f47956b582edbf82881afccb6">hydra::detail::accumulate2</a> (ArgType1 const &amp;x, ArgType2 const &amp;y, hydra_thrust::tuple&lt; Tp... &gt; const &amp;t)</td></tr>
<tr class="separator:ad7d3ac2f47956b582edbf82881afccb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4a03e1acf7793aeeb625d420ac67e23"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename ... Tp&gt; </td></tr>
<tr class="memitem:aa4a03e1acf7793aeeb625d420ac67e23"><td class="memTemplItemLeft" align="right" valign="top">hydra_thrust::detail::enable_if&lt; I==sizeof...(Tp), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#aa4a03e1acf7793aeeb625d420ac67e23">hydra::detail::add_parameters_in_tuple</a> (std::vector&lt; <a class="el" href="group__fit.html#structhydra_1_1Parameter">hydra::Parameter</a> *&gt; &amp;, hydra_thrust::tuple&lt; Tp... &gt; &amp;)</td></tr>
<tr class="separator:aa4a03e1acf7793aeeb625d420ac67e23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2194b2d6ba44a6a6a85ac0ffca19339c"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename ... Tp&gt; </td></tr>
<tr class="memitem:a2194b2d6ba44a6a6a85ac0ffca19339c"><td class="memTemplItemLeft" align="right" valign="top">hydra_thrust::detail::enable_if&lt;(I&lt; sizeof...(Tp)), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a2194b2d6ba44a6a6a85ac0ffca19339c">hydra::detail::add_parameters_in_tuple</a> (std::vector&lt; <a class="el" href="group__fit.html#structhydra_1_1Parameter">hydra::Parameter</a> *&gt; &amp;user_parameters, hydra_thrust::tuple&lt; Tp... &gt; &amp;t)</td></tr>
<tr class="separator:a2194b2d6ba44a6a6a85ac0ffca19339c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2df93ef3f457f1eb6f203758033350df"><td class="memTemplParams" colspan="2">template&lt;size_t I, typename ... T&gt; </td></tr>
<tr class="memitem:a2df93ef3f457f1eb6f203758033350df"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::detail::enable_if&lt;(I==sizeof...(T)), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a2df93ef3f457f1eb6f203758033350df">hydra::detail::add_tuple_values</a> (GReal_t &amp;, hydra_thrust::tuple&lt; T... &gt; const &amp;)</td></tr>
<tr class="separator:a2df93ef3f457f1eb6f203758033350df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a438dc9b0660d0be705cd74a24bb75055"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename ... T&gt; </td></tr>
<tr class="memitem:a438dc9b0660d0be705cd74a24bb75055"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::detail::enable_if&lt;(I&lt; sizeof...(T)), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a438dc9b0660d0be705cd74a24bb75055">hydra::detail::add_tuple_values</a> (GReal_t &amp;result, hydra_thrust::tuple&lt; T... &gt; const &amp;tpl)</td></tr>
<tr class="separator:a438dc9b0660d0be705cd74a24bb75055"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fb09f08e05c59f9cb8f7810677b0a35"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N&gt; </td></tr>
<tr class="memitem:a2fb09f08e05c59f9cb8f7810677b0a35"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a2fb09f08e05c59f9cb8f7810677b0a35">hydra::detail::arrayToTuple</a> (std::array&lt; T, N &gt;const &amp;Array) -&gt; decltype(arrayToTupleHelper(Array, make_index_sequence&lt; N &gt;</td></tr>
<tr class="separator:a2fb09f08e05c59f9cb8f7810677b0a35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d0da29f0be34c5fe0f79e47b6963340"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N&gt; </td></tr>
<tr class="memitem:a9d0da29f0be34c5fe0f79e47b6963340"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a9d0da29f0be34c5fe0f79e47b6963340">hydra::detail::arrayToTuple</a> (T *Array) -&gt; decltype(arrayToTupleHelper(Array, make_index_sequence&lt; N &gt;</td></tr>
<tr class="separator:a9d0da29f0be34c5fe0f79e47b6963340"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45da45c4361e4fa7183b32d72d5441af"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t... Is&gt; </td></tr>
<tr class="memitem:a45da45c4361e4fa7183b32d72d5441af"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a45da45c4361e4fa7183b32d72d5441af">hydra::detail::arrayToTupleHelper</a> (std::array&lt; T, sizeof...(Is)&gt;const &amp;Array, index_sequence&lt; Is... &gt;) -&gt; decltype(hydra_thrust::make_tuple(Array[Is]...))</td></tr>
<tr class="separator:a45da45c4361e4fa7183b32d72d5441af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0f469856dbd0bb5e87f5c012efae2b0"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t... Indices&gt; </td></tr>
<tr class="memitem:aa0f469856dbd0bb5e87f5c012efae2b0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#aa0f469856dbd0bb5e87f5c012efae2b0">hydra::detail::arrayToTupleHelper</a> (T *Array, index_sequence&lt; Indices... &gt;) -&gt; decltype(hydra_thrust::make_tuple(Array[Indices]...))</td></tr>
<tr class="separator:aa0f469856dbd0bb5e87f5c012efae2b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d10110b86c5d6e45099e126e5c54fb7"><td class="memTemplParams" colspan="2">template&lt;size_t I, typename ArrayType , typename FistType , typename ... OtherTypes&gt; </td></tr>
<tr class="memitem:a2d10110b86c5d6e45099e126e5c54fb7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::detail::enable_if&lt; I==(sizeof...(OtherTypes)+1) &amp;&amp;std::is_convertible&lt; FistType, ArrayType &gt;::value &amp;&amp;all_true&lt; std::is_convertible&lt; OtherTypes, ArrayType &gt;::value... &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a2d10110b86c5d6e45099e126e5c54fb7">hydra::detail::assignArrayToTuple</a> (hydra_thrust::tuple&lt; FistType, OtherTypes... &gt; &amp;, ArrayType const *)</td></tr>
<tr class="separator:a2d10110b86c5d6e45099e126e5c54fb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08b60bbd48640f46836c018a4e685b70"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename ArrayType , typename FistType , typename ... OtherTypes&gt; </td></tr>
<tr class="memitem:a08b60bbd48640f46836c018a4e685b70"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::detail::enable_if&lt;(I&lt; sizeof...(OtherTypes)+1) &amp;&amp;std::is_convertible&lt; FistType, ArrayType &gt;::value &amp;&amp;all_true&lt; std::is_convertible&lt; OtherTypes, ArrayType &gt;::value... &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a08b60bbd48640f46836c018a4e685b70">hydra::detail::assignArrayToTuple</a> (hydra_thrust::tuple&lt; FistType, OtherTypes... &gt; &amp;t, ArrayType const *Array)</td></tr>
<tr class="separator:a08b60bbd48640f46836c018a4e685b70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09d65a22cd08900bb301cfa560cab50f"><td class="memTemplParams" colspan="2">template&lt;size_t I, typename ArrayType , typename FistType , typename ... OtherTypes&gt; </td></tr>
<tr class="memitem:a09d65a22cd08900bb301cfa560cab50f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::detail::enable_if&lt; I==(sizeof...(OtherTypes)+1) &amp;&amp;std::is_convertible&lt; FistType, ArrayType &gt;::value &amp;&amp;all_true&lt; std::is_convertible&lt; OtherTypes, ArrayType &gt;::value... &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a09d65a22cd08900bb301cfa560cab50f">hydra::detail::assignArrayToTuple</a> (hydra_thrust::detail::tuple_of_iterator_references&lt; FistType, OtherTypes... &gt; &amp;, ArrayType const *)</td></tr>
<tr class="separator:a09d65a22cd08900bb301cfa560cab50f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a94b4c8a4f17b2014c79be1a2f05f6a"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename ArrayType , typename FistType , typename ... OtherTypes&gt; </td></tr>
<tr class="memitem:a7a94b4c8a4f17b2014c79be1a2f05f6a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::detail::enable_if&lt;(I&lt; sizeof...(OtherTypes)+1) &amp;&amp;std::is_convertible&lt; FistType, ArrayType &gt;::value &amp;&amp;all_true&lt; std::is_convertible&lt; OtherTypes, ArrayType &gt;::value... &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a7a94b4c8a4f17b2014c79be1a2f05f6a">hydra::detail::assignArrayToTuple</a> (hydra_thrust::detail::tuple_of_iterator_references&lt; FistType, OtherTypes... &gt; &amp;t, ArrayType const *Array)</td></tr>
<tr class="separator:a7a94b4c8a4f17b2014c79be1a2f05f6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8824f1c8bee0a4b09bfc0eff093dd14f"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename ArrayType , typename FistType , typename ... OtherTypes&gt; </td></tr>
<tr class="memitem:a8824f1c8bee0a4b09bfc0eff093dd14f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::detail::enable_if&lt; I==(sizeof...(OtherTypes)+1) &amp;&amp;is_hydra_convertible_to_tuple&lt; ArrayType &gt;::value &amp;&amp;are_all_same&lt; FistType, OtherTypes... &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a8824f1c8bee0a4b09bfc0eff093dd14f">hydra::detail::assignTupleToArray</a> (hydra_thrust::tuple&lt; FistType, OtherTypes... &gt; const &amp;, ArrayType(&amp;)[sizeof...(OtherTypes)+1])</td></tr>
<tr class="separator:a8824f1c8bee0a4b09bfc0eff093dd14f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72efcb430e2aea2171eba70f81cb08b8"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename ArrayType , typename FistType , typename ... OtherTypes&gt; </td></tr>
<tr class="memitem:a72efcb430e2aea2171eba70f81cb08b8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::detail::enable_if&lt;(I&lt; sizeof...(OtherTypes)+1) &amp;&amp;is_hydra_convertible_to_tuple&lt; ArrayType &gt;::value &amp;&amp;are_all_same&lt; FistType, OtherTypes... &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a72efcb430e2aea2171eba70f81cb08b8">hydra::detail::assignTupleToArray</a> (hydra_thrust::tuple&lt; FistType, OtherTypes... &gt; const &amp;t, ArrayType(&amp;Array)[sizeof...(OtherTypes)+1])</td></tr>
<tr class="separator:a72efcb430e2aea2171eba70f81cb08b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85d6c644fd94e7d86174c9da15486ca3"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename ArrayType , typename FistType , typename ... OtherTypes&gt; </td></tr>
<tr class="memitem:a85d6c644fd94e7d86174c9da15486ca3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::detail::enable_if&lt; I==(sizeof...(OtherTypes)+1) &amp;&amp;is_hydra_convertible_to_tuple&lt; ArrayType &gt;::value &amp;&amp;are_all_same&lt; FistType, OtherTypes... &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a85d6c644fd94e7d86174c9da15486ca3">hydra::detail::assignTupleToArray</a> (hydra_thrust::tuple&lt; FistType &amp;, OtherTypes &amp;... &gt; const &amp;, ArrayType(&amp;)[sizeof...(OtherTypes)+1])</td></tr>
<tr class="separator:a85d6c644fd94e7d86174c9da15486ca3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac32dd708dfece676fb655b6600946ebe"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename ArrayType , typename FistType , typename ... OtherTypes&gt; </td></tr>
<tr class="memitem:ac32dd708dfece676fb655b6600946ebe"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::detail::enable_if&lt;(I&lt; sizeof...(OtherTypes)+1) &amp;&amp;is_hydra_convertible_to_tuple&lt; ArrayType &gt;::value &amp;&amp;are_all_same&lt; FistType, OtherTypes... &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#ac32dd708dfece676fb655b6600946ebe">hydra::detail::assignTupleToArray</a> (hydra_thrust::tuple&lt; FistType &amp;, OtherTypes &amp;... &gt; const &amp;t, ArrayType(&amp;Array)[sizeof...(OtherTypes)+1])</td></tr>
<tr class="separator:ac32dd708dfece676fb655b6600946ebe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a370d1378b3bf83ff0976dc85cb97a559"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename ArrayType , typename FistType , typename ... OtherTypes&gt; </td></tr>
<tr class="memitem:a370d1378b3bf83ff0976dc85cb97a559"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::detail::enable_if&lt; I==(sizeof...(OtherTypes)+1) &amp;&amp;is_hydra_convertible_to_tuple&lt; ArrayType &gt;::value &amp;&amp;are_all_same&lt; FistType, OtherTypes... &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a370d1378b3bf83ff0976dc85cb97a559">hydra::detail::assignTupleToArray</a> (hydra_thrust::detail::tuple_of_iterator_references&lt; FistType, OtherTypes... &gt; const &amp;, ArrayType(&amp;)[sizeof...(OtherTypes)+1])</td></tr>
<tr class="separator:a370d1378b3bf83ff0976dc85cb97a559"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7600f26d1540ce89d073e564d97909ab"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename ArrayType , typename FistType , typename ... OtherTypes&gt; </td></tr>
<tr class="memitem:a7600f26d1540ce89d073e564d97909ab"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::detail::enable_if&lt;(I&lt; sizeof...(OtherTypes)+1) &amp;&amp;is_hydra_convertible_to_tuple&lt; ArrayType &gt;::value &amp;&amp;are_all_same&lt; FistType, OtherTypes... &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a7600f26d1540ce89d073e564d97909ab">hydra::detail::assignTupleToArray</a> (hydra_thrust::detail::tuple_of_iterator_references&lt; FistType, OtherTypes... &gt; const &amp;t, ArrayType(&amp;Array)[sizeof...(OtherTypes)+1])</td></tr>
<tr class="separator:a7600f26d1540ce89d073e564d97909ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03b17f9b7b0e39924e0819250d04ea85"><td class="memTemplParams" colspan="2">template&lt;unsigned int I = 0, typename FuncT , typename ... Tp&gt; </td></tr>
<tr class="memitem:a03b17f9b7b0e39924e0819250d04ea85"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::detail::enable_if&lt; I==sizeof...(Tp), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a03b17f9b7b0e39924e0819250d04ea85">hydra::detail::eval_on_tuple_element</a> (<a class="el" href="namespace_3globalScope_4.html#classint">int</a>, hydra_thrust::tuple&lt; Tp... &gt; const &amp;, FuncT const &amp;)</td></tr>
<tr class="separator:a03b17f9b7b0e39924e0819250d04ea85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe7c19041604f8d2835e030454b95d0f"><td class="memTemplParams" colspan="2">template&lt;unsigned int I = 0, typename FuncT , typename ... Tp&gt; </td></tr>
<tr class="memitem:afe7c19041604f8d2835e030454b95d0f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::detail::enable_if&lt;(I&lt; sizeof...(Tp)), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#afe7c19041604f8d2835e030454b95d0f">hydra::detail::eval_on_tuple_element</a> (<a class="el" href="namespace_3globalScope_4.html#classint">int</a> index, hydra_thrust::tuple&lt; Tp... &gt; const &amp;t, FuncT const &amp;f)</td></tr>
<tr class="separator:afe7c19041604f8d2835e030454b95d0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45910f4522df506c9e510219a2327e96"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename Return_Type , typename ArgType , typename ... Tp&gt; </td></tr>
<tr class="memitem:a45910f4522df506c9e510219a2327e96"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::detail::enable_if&lt; I==sizeof...(Tp), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a45910f4522df506c9e510219a2327e96">hydra::detail::eval_tuple_element</a> (Return_Type &amp;, <a class="el" href="namespace_3globalScope_4.html#classint">int</a>, hydra_thrust::tuple&lt; Tp... &gt; const &amp;, ArgType const &amp;)</td></tr>
<tr class="separator:a45910f4522df506c9e510219a2327e96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5059b569131e6db6c738eb807e743c25"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename Return_Type , typename ArgType , typename ... Tp&gt; </td></tr>
<tr class="memitem:a5059b569131e6db6c738eb807e743c25"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::detail::enable_if&lt;(I&lt; sizeof...(Tp)), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a5059b569131e6db6c738eb807e743c25">hydra::detail::eval_tuple_element</a> (Return_Type &amp;r, <a class="el" href="namespace_3globalScope_4.html#classint">int</a> index, hydra_thrust::tuple&lt; Tp... &gt; const &amp;t, ArgType const &amp;arg)</td></tr>
<tr class="separator:a5059b569131e6db6c738eb807e743c25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96a946dad2a4b9f834836d9b954ad8b6"><td class="memTemplParams" colspan="2">template&lt;typename Type , typename Tuple &gt; </td></tr>
<tr class="memitem:a96a946dad2a4b9f834836d9b954ad8b6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a96a946dad2a4b9f834836d9b954ad8b6">hydra::detail::extract</a> (const <a class="el" href="namespace_3globalScope_4.html#classint">int</a> idx, const Tuple &amp;t)</td></tr>
<tr class="separator:a96a946dad2a4b9f834836d9b954ad8b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add5147a947f0edd769e9fc10f7a65759"><td class="memTemplParams" colspan="2">template&lt;typename R , typename ... T&gt; </td></tr>
<tr class="memitem:add5147a947f0edd769e9fc10f7a65759"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> R &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#add5147a947f0edd769e9fc10f7a65759">hydra::detail::get_element</a> (const size_t index, hydra_thrust::tuple&lt; T... &gt; &amp;t)</td></tr>
<tr class="separator:add5147a947f0edd769e9fc10f7a65759"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6edb844108024e669c32dad4c1246c8"><td class="memTemplParams" colspan="2">template&lt;unsigned int I = 0, typename T , typename ... Tp&gt; </td></tr>
<tr class="memitem:ab6edb844108024e669c32dad4c1246c8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::detail::enable_if&lt; I==sizeof...(Tp), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#ab6edb844108024e669c32dad4c1246c8">hydra::detail::get_tuple_element</a> (const <a class="el" href="namespace_3globalScope_4.html#classint">int</a>, hydra_thrust::tuple&lt; Tp... &gt; const &amp;, T &amp;)</td></tr>
<tr class="separator:ab6edb844108024e669c32dad4c1246c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17fb31790c0652edefd8e9438fa69103"><td class="memTemplParams" colspan="2">template&lt;unsigned int I = 0, typename T , typename ... Tp&gt; </td></tr>
<tr class="memitem:a17fb31790c0652edefd8e9438fa69103"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::detail::enable_if&lt;(I&lt; sizeof...(Tp)), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a17fb31790c0652edefd8e9438fa69103">hydra::detail::get_tuple_element</a> (const <a class="el" href="namespace_3globalScope_4.html#classint">int</a> index, hydra_thrust::tuple&lt; Tp... &gt; const &amp;t, T &amp;x)</td></tr>
<tr class="separator:a17fb31790c0652edefd8e9438fa69103"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a227e0b524804a0ceef56b4a1da1953d4"><td class="memTemplParams" colspan="2">template&lt;typename Iterator , size_t N&gt; </td></tr>
<tr class="memitem:a227e0b524804a0ceef56b4a1da1953d4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a227e0b524804a0ceef56b4a1da1953d4">hydra::detail::get_zip_iterator</a> (std::array&lt; Iterator, N &gt;const &amp;array_of_iterators) -&gt; decltype(get_zip_iterator_helper(array_of_iterators, make_index_sequence&lt; N &gt;</td></tr>
<tr class="separator:a227e0b524804a0ceef56b4a1da1953d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9da0535b5305aaf5cfe698c42ebc8d6"><td class="memTemplParams" colspan="2">template&lt;typename IteratorHead , typename IteratorTail , size_t N&gt; </td></tr>
<tr class="memitem:ae9da0535b5305aaf5cfe698c42ebc8d6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#ae9da0535b5305aaf5cfe698c42ebc8d6">hydra::detail::get_zip_iterator</a> (IteratorHead head, std::array&lt; IteratorTail, N &gt;const &amp;array_of_iterators) -&gt; decltype(get_zip_iterator_helper(head, array_of_iterators, make_index_sequence&lt; N &gt;</td></tr>
<tr class="separator:ae9da0535b5305aaf5cfe698c42ebc8d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e7ac2e75fefa5d9a41daa1d7279c8c5"><td class="memTemplParams" colspan="2">template&lt;typename Iterator , size_t ... Index&gt; </td></tr>
<tr class="memitem:a0e7ac2e75fefa5d9a41daa1d7279c8c5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a0e7ac2e75fefa5d9a41daa1d7279c8c5">hydra::detail::get_zip_iterator_helper</a> (std::array&lt; Iterator, sizeof ...(Index)&gt;const &amp;array_of_iterators, index_sequence&lt; Index... &gt;) -&gt; decltype(hydra_thrust::make_zip_iterator(hydra_thrust::make_tuple(array_of_iterators[Index]...)))</td></tr>
<tr class="separator:a0e7ac2e75fefa5d9a41daa1d7279c8c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8087253280ceed0580f29a1688f385e9"><td class="memTemplParams" colspan="2">template&lt;typename IteratorHead , typename IteratorTail , size_t ... Index&gt; </td></tr>
<tr class="memitem:a8087253280ceed0580f29a1688f385e9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a8087253280ceed0580f29a1688f385e9">hydra::detail::get_zip_iterator_helper</a> (IteratorHead head, std::array&lt; IteratorTail, sizeof ...(Index)&gt;const &amp;array_of_iterators, index_sequence&lt; Index... &gt;) -&gt; decltype(hydra_thrust::make_zip_iterator(hydra_thrust::make_tuple(head, array_of_iterators[Index]...)))</td></tr>
<tr class="separator:a8087253280ceed0580f29a1688f385e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b30f3961b7f4ed7c28a4e1373281c1c"><td class="memTemplParams" colspan="2">template&lt;typename Tup , typename ArgType , size_t N = hydra_thrust::tuple_size&lt;typename hydra_thrust::detail::remove_reference&lt;Tup&gt;::type&gt;::value&gt; </td></tr>
<tr class="memitem:a0b30f3961b7f4ed7c28a4e1373281c1c"><td class="memTemplItemLeft" align="right" valign="top">__hydra_thrust_exec_check_disable__ <a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a0b30f3961b7f4ed7c28a4e1373281c1c">hydra::detail::invoke</a> (ArgType &amp;&amp;x, Tup &amp;&amp;tup) -&gt; decltype(invoke_helper(std::forward&lt; ArgType &gt;(x), std::forward&lt; Tup &gt;(tup), make_index_sequence&lt; N &gt;</td></tr>
<tr class="separator:a0b30f3961b7f4ed7c28a4e1373281c1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad31b6d1499b5a6b2d77c015a71385a6e"><td class="memTemplParams" colspan="2">template&lt;typename Tup , typename ArgType , size_t N = hydra_thrust::tuple_size&lt;typename hydra_thrust::detail::remove_reference&lt;Tup&gt;::type&gt;::value&gt; </td></tr>
<tr class="memitem:ad31b6d1499b5a6b2d77c015a71385a6e"><td class="memTemplItemLeft" align="right" valign="top">__hydra_thrust_exec_check_disable__ <a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#ad31b6d1499b5a6b2d77c015a71385a6e">hydra::detail::invoke</a> (ArgType const &amp;x, Tup const &amp;tup) -&gt; decltype(invoke_helper(x, tup, make_index_sequence&lt; N &gt;</td></tr>
<tr class="separator:ad31b6d1499b5a6b2d77c015a71385a6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c6414446d272ca304b39b9d9b7b0c35"><td class="memTemplParams" colspan="2">template&lt;typename Tup , typename ArgType1 , typename ArgType2 , size_t N = hydra_thrust::tuple_size&lt;typename hydra_thrust::detail::remove_reference&lt;Tup&gt;::type&gt;::value&gt; </td></tr>
<tr class="memitem:a3c6414446d272ca304b39b9d9b7b0c35"><td class="memTemplItemLeft" align="right" valign="top">__hydra_thrust_exec_check_disable__ <a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a3c6414446d272ca304b39b9d9b7b0c35">hydra::detail::invoke</a> (ArgType1 &amp;&amp;x, ArgType2 &amp;&amp;y, Tup &amp;&amp;tup) -&gt; decltype(invoke_helper(std::forward&lt; ArgType1 &gt;(x), std::forward&lt; ArgType2 &gt;(y), std::forward&lt; Tup &gt;(tup), make_index_sequence&lt; hydra_thrust::tuple_size&lt; Tup &gt;::value &gt;</td></tr>
<tr class="separator:a3c6414446d272ca304b39b9d9b7b0c35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af119ddecbbdf7e22bde76370b3b28f0c"><td class="memTemplParams" colspan="2">template&lt;typename Tup , typename ArgType1 , typename ArgType2 &gt; </td></tr>
<tr class="memitem:af119ddecbbdf7e22bde76370b3b28f0c"><td class="memTemplItemLeft" align="right" valign="top">__hydra_thrust_exec_check_disable__ <a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#af119ddecbbdf7e22bde76370b3b28f0c">hydra::detail::invoke</a> (ArgType1 const &amp;x, ArgType2 const &amp;y, Tup const &amp;tup) -&gt; decltype(invoke_helper(x, y, tup, make_index_sequence&lt; hydra_thrust::tuple_size&lt; Tup &gt;::value &gt;</td></tr>
<tr class="separator:af119ddecbbdf7e22bde76370b3b28f0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a70502ee212958c154c2ea97c1047ab"><td class="memTemplParams" colspan="2">template&lt;typename Tup , typename ArgType , size_t ... index&gt; </td></tr>
<tr class="memitem:a4a70502ee212958c154c2ea97c1047ab"><td class="memTemplItemLeft" align="right" valign="top">__hydra_thrust_exec_check_disable__ <a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a4a70502ee212958c154c2ea97c1047ab">hydra::detail::invoke_helper</a> (ArgType &amp;&amp;x, Tup &amp;&amp;tup, index_sequence&lt; index... &gt;) -&gt; decltype(hydra_thrust::make_tuple(hydra_thrust::get&lt; index &gt;(std::forward&lt; Tup &gt;(tup))(std::forward&lt; ArgType &gt;(x))...))</td></tr>
<tr class="separator:a4a70502ee212958c154c2ea97c1047ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeba5bf60f8de619daa3665ab1a5c088d"><td class="memTemplParams" colspan="2">template&lt;typename Tup , typename ArgType , size_t ... index&gt; </td></tr>
<tr class="memitem:aeba5bf60f8de619daa3665ab1a5c088d"><td class="memTemplItemLeft" align="right" valign="top">__hydra_thrust_exec_check_disable__ <a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#aeba5bf60f8de619daa3665ab1a5c088d">hydra::detail::invoke_helper</a> (ArgType const &amp;x, Tup const &amp;tup, index_sequence&lt; index... &gt;) -&gt; decltype(hydra_thrust::make_tuple(hydra_thrust::get&lt; index &gt;(tup)(x)...))</td></tr>
<tr class="separator:aeba5bf60f8de619daa3665ab1a5c088d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90c0d2110813667cce17c16fcf21cdd2"><td class="memTemplParams" colspan="2">template&lt;typename Tup , typename ArgType1 , typename ArgType2 , size_t ... index&gt; </td></tr>
<tr class="memitem:a90c0d2110813667cce17c16fcf21cdd2"><td class="memTemplItemLeft" align="right" valign="top">__hydra_thrust_exec_check_disable__ <a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a90c0d2110813667cce17c16fcf21cdd2">hydra::detail::invoke_helper</a> (ArgType1 &amp;&amp;x, ArgType2 &amp;&amp;y, Tup &amp;&amp;tup, index_sequence&lt; index... &gt;) -&gt; decltype(hydra_thrust::make_tuple(hydra_thrust::get&lt; index &gt;(std::forward&lt; Tup &gt;(tup))(std::forward&lt; ArgType1 &gt;(x), std::forward&lt; ArgType2 &gt;(y))...))</td></tr>
<tr class="separator:a90c0d2110813667cce17c16fcf21cdd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7bfae6e91a367c89f0bd5d905237f16"><td class="memTemplParams" colspan="2">template&lt;typename Tup , typename ArgType1 , typename ArgType2 , size_t ... index&gt; </td></tr>
<tr class="memitem:aa7bfae6e91a367c89f0bd5d905237f16"><td class="memTemplItemLeft" align="right" valign="top">__hydra_thrust_exec_check_disable__ <a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#aa7bfae6e91a367c89f0bd5d905237f16">hydra::detail::invoke_helper</a> (ArgType1 const &amp;x, ArgType2 const &amp;y, Tup const &amp;tup, index_sequence&lt; index... &gt;) -&gt; decltype(hydra_thrust::make_tuple(hydra_thrust::get&lt; index &gt;(tup)(x, y)...))</td></tr>
<tr class="separator:aa7bfae6e91a367c89f0bd5d905237f16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9360a30d9cffc4d39b34187a56f0bb92"><td class="memItemLeft" align="right" valign="top"><a class="el" href="basic__distributions_8inl.html#a9717e7bbecb906637e86cef6da3d83c2">return</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a9360a30d9cffc4d39b34187a56f0bb92">hydra::detail::invoke_helper</a> (x, y, tup, make_index_sequence&lt; Size &gt; { })</td></tr>
<tr class="separator:a9360a30d9cffc4d39b34187a56f0bb92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af991f6032453407f65f584508d2f776d"><td class="memTemplParams" colspan="2">template&lt;typename Tup , typename ArgType &gt; </td></tr>
<tr class="memitem:af991f6032453407f65f584508d2f776d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#af991f6032453407f65f584508d2f776d">hydra::detail::invoke_normalized</a> (ArgType const &amp;x, Tup const &amp;tup) -&gt; decltype(invoke_helper(x, tup, make_index_sequence&lt; hydra_thrust::tuple_size&lt; Tup &gt;::value &gt;</td></tr>
<tr class="separator:af991f6032453407f65f584508d2f776d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4c0051b20d34181994aa5560387054e"><td class="memTemplParams" colspan="2">template&lt;typename Tup , typename ArgType , size_t N = hydra_thrust::tuple_size&lt;typename hydra_thrust::detail::remove_reference&lt;Tup&gt;::type&gt;::value&gt; </td></tr>
<tr class="memitem:af4c0051b20d34181994aa5560387054e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#af4c0051b20d34181994aa5560387054e">hydra::detail::invoke_normalized</a> (ArgType &amp;&amp;x, Tup &amp;&amp;tup) -&gt; decltype(invoke_helper(std::forward&lt; ArgType &gt;(x), std::forward&lt; Tup &gt;(tup), make_index_sequence&lt; N &gt;</td></tr>
<tr class="separator:af4c0051b20d34181994aa5560387054e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51dc6ae31393a420f089ca8fd1207c23"><td class="memTemplParams" colspan="2">template&lt;typename Tup , typename ArgType , size_t ... index&gt; </td></tr>
<tr class="memitem:a51dc6ae31393a420f089ca8fd1207c23"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a51dc6ae31393a420f089ca8fd1207c23">hydra::detail::invoke_normalized_helper</a> (ArgType const &amp;x, Tup const &amp;tup, index_sequence&lt; index... &gt;) -&gt; decltype(hydra_thrust::make_tuple(hydra_thrust::get&lt; index &gt;(tup)(x)...))</td></tr>
<tr class="separator:a51dc6ae31393a420f089ca8fd1207c23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a173eb394103a0e94fbf9abbc1918a894"><td class="memItemLeft" align="right" valign="top"><a class="el" href="basic__distributions_8inl.html#a9717e7bbecb906637e86cef6da3d83c2">return</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a173eb394103a0e94fbf9abbc1918a894">hydra::detail::invoke_normalized_helper</a> (x, tup, make_index_sequence&lt; Size &gt; { })</td></tr>
<tr class="separator:a173eb394103a0e94fbf9abbc1918a894"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a021aed8e1205f3ff6aef35d02065c612"><td class="memTemplParams" colspan="2">template&lt;typename Tup , typename ArgType , size_t ... index&gt; </td></tr>
<tr class="memitem:a021aed8e1205f3ff6aef35d02065c612"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a021aed8e1205f3ff6aef35d02065c612">hydra::detail::invoke_normalized_helper</a> (ArgType &amp;&amp;x, Tup &amp;&amp;tup, index_sequence&lt; index... &gt;) -&gt; decltype(hydra_thrust::make_tuple(hydra_thrust::get&lt; index &gt;(std::forward&lt; Tup &gt;(tup))(std::forward&lt; ArgType &gt;(x))...))</td></tr>
<tr class="separator:a021aed8e1205f3ff6aef35d02065c612"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a806bd1d429f6b821efb5af237fecaa2f"><td class="memTemplParams" colspan="2">template&lt;typename ... T&gt; </td></tr>
<tr class="memitem:a806bd1d429f6b821efb5af237fecaa2f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a806bd1d429f6b821efb5af237fecaa2f">hydra::detail::make_rtuple</a> (hydra_thrust::tuple&lt; T... &gt; &amp;t) -&gt; hydra_thrust::tuple&lt; T &amp;... &gt;</td></tr>
<tr class="separator:a806bd1d429f6b821efb5af237fecaa2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abea7b63acf2a24346dd220c91059e1da"><td class="memTemplParams" colspan="2">template&lt;typename ... T, size_t... I&gt; </td></tr>
<tr class="memitem:abea7b63acf2a24346dd220c91059e1da"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#abea7b63acf2a24346dd220c91059e1da">hydra::detail::make_rtuple_helper</a> (hydra_thrust::tuple&lt; T... &gt; &amp;t, index_sequence&lt; I... &gt;) -&gt; hydra_thrust::tuple&lt; T &amp;... &gt;</td></tr>
<tr class="separator:abea7b63acf2a24346dd220c91059e1da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac16e513053ac8d97923ac166db8e6a98"><td class="memItemLeft" align="right" valign="top">T ::type TupleType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#ac16e513053ac8d97923ac166db8e6a98">hydra::detail::make_tuple</a> (T &amp;&amp;value)</td></tr>
<tr class="separator:ac16e513053ac8d97923ac166db8e6a98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8df2eb3ba9481fec054318974964ec3d"><td class="memTemplParams" colspan="2">template&lt;typename ... T&gt; </td></tr>
<tr class="memitem:a8df2eb3ba9481fec054318974964ec3d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a8df2eb3ba9481fec054318974964ec3d">hydra::detail::max</a> (hydra_thrust::tuple&lt; T... &gt; const &amp;tuple)</td></tr>
<tr class="separator:a8df2eb3ba9481fec054318974964ec3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4140580867ee73e401e1bb1e213548c"><td class="memTemplParams" colspan="2">template&lt;typename T , typename C , size_t N, size_t I&gt; </td></tr>
<tr class="memitem:aa4140580867ee73e401e1bb1e213548c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> std::enable_if&lt; I==N, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#aa4140580867ee73e401e1bb1e213548c">hydra::detail::max_helper</a> (T const &amp;, <a class="el" href="basic__distributions_8inl.html#a4900ef306eb9271438791f1a98b8ccba">C</a> &amp;, size_t &amp;)</td></tr>
<tr class="separator:aa4140580867ee73e401e1bb1e213548c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad23b453b58064598dbd7596ffca55422"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#ad23b453b58064598dbd7596ffca55422">hydra::detail::max_helper&lt; T, C, N, I+1 &gt;</a> (tuple, max_value, max_index)</td></tr>
<tr class="separator:ad23b453b58064598dbd7596ffca55422"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab992b62c0923bb8bd2bfd3a1fcc1a706"><td class="memTemplParams" colspan="2">template&lt;typename ... T&gt; </td></tr>
<tr class="memitem:ab992b62c0923bb8bd2bfd3a1fcc1a706"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#ab992b62c0923bb8bd2bfd3a1fcc1a706">hydra::detail::multiply_array_tuple</a> (GReal_t(&amp;fCoeficients)[sizeof...(T)], hydra_thrust::tuple&lt; T... &gt; const &amp;tpl) -&gt; decltype(multiply_array_tuple_helper(fCoeficients, tpl, make_index_sequence&lt; sizeof...(T)&gt;</td></tr>
<tr class="separator:ab992b62c0923bb8bd2bfd3a1fcc1a706"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a643a9cfc48d39212a6856ce4a6458280"><td class="memTemplParams" colspan="2">template&lt;typename Tuple , size_t ... I&gt; </td></tr>
<tr class="memitem:a643a9cfc48d39212a6856ce4a6458280"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> tuple_type&lt; sizeof...(I), GReal_t &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a643a9cfc48d39212a6856ce4a6458280">hydra::detail::multiply_array_tuple_helper</a> (GReal_t(&amp;fCoeficients)[sizeof...(I)], Tuple const &amp;tpl, index_sequence&lt; I... &gt;)</td></tr>
<tr class="separator:a643a9cfc48d39212a6856ce4a6458280"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66bc1bf60cfc95e34f2ede6986e9af98"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename Return_Type , typename ... Tp&gt; </td></tr>
<tr class="memitem:a66bc1bf60cfc95e34f2ede6986e9af98"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::detail::enable_if&lt; I==sizeof...(Tp), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a66bc1bf60cfc95e34f2ede6986e9af98">hydra::detail::multiply_tuple</a> (Return_Type &amp;, hydra_thrust::tuple&lt; Tp... &gt; const &amp;)</td></tr>
<tr class="separator:a66bc1bf60cfc95e34f2ede6986e9af98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac33cb24201ebd425c3b2f4c91465aea6"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename Return_Type , typename ... Tp&gt; </td></tr>
<tr class="memitem:ac33cb24201ebd425c3b2f4c91465aea6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::detail::enable_if&lt;(I&lt; sizeof...(Tp)), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#ac33cb24201ebd425c3b2f4c91465aea6">hydra::detail::multiply_tuple</a> (Return_Type &amp;r, hydra_thrust::tuple&lt; Tp... &gt;const &amp;t)</td></tr>
<tr class="separator:ac33cb24201ebd425c3b2f4c91465aea6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad363c957681f91b698ac9f5212be47d"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename Return_Type , typename ... Tp&gt; </td></tr>
<tr class="memitem:aad363c957681f91b698ac9f5212be47d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::detail::enable_if&lt; I==sizeof...(Tp), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#aad363c957681f91b698ac9f5212be47d">hydra::detail::multiply_tuple</a> (Return_Type &amp;, hydra_thrust::tuple&lt; Tp... &gt; &amp;&amp;)</td></tr>
<tr class="separator:aad363c957681f91b698ac9f5212be47d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b8b89a3ba444d2c8ef1a6ed26985e6d"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename Return_Type , typename ... Tp&gt; </td></tr>
<tr class="memitem:a4b8b89a3ba444d2c8ef1a6ed26985e6d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::detail::enable_if&lt;(I&lt; sizeof...(Tp)), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a4b8b89a3ba444d2c8ef1a6ed26985e6d">hydra::detail::multiply_tuple</a> (Return_Type &amp;r, hydra_thrust::tuple&lt; Tp... &gt; &amp;&amp;t)</td></tr>
<tr class="separator:a4b8b89a3ba444d2c8ef1a6ed26985e6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28280805ea788b6b7ab8eee526b71acc"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename ... Tp&gt; </td></tr>
<tr class="memitem:a28280805ea788b6b7ab8eee526b71acc"><td class="memTemplItemLeft" align="right" valign="top">hydra_thrust::detail::enable_if&lt; I==sizeof...(Tp), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a28280805ea788b6b7ab8eee526b71acc">hydra::detail::print_parameters_in_tuple</a> (hydra_thrust::tuple&lt; Tp... &gt; &amp;)</td></tr>
<tr class="separator:a28280805ea788b6b7ab8eee526b71acc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91dd9d1ed9eeac4af4b479d3931b4b3f"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename ... Tp&gt; </td></tr>
<tr class="memitem:a91dd9d1ed9eeac4af4b479d3931b4b3f"><td class="memTemplItemLeft" align="right" valign="top">hydra_thrust::detail::enable_if&lt;(I&lt; sizeof...(Tp)), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a91dd9d1ed9eeac4af4b479d3931b4b3f">hydra::detail::print_parameters_in_tuple</a> (hydra_thrust::tuple&lt; Tp... &gt; &amp;t)</td></tr>
<tr class="separator:a91dd9d1ed9eeac4af4b479d3931b4b3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac25504370e97f8483f51b7747a5d062f"><td class="memTemplParams" colspan="2">template&lt;typename Return_Type , typename ArgType , typename ... Tp, typename  = typename hydra_thrust::detail::enable_if&lt;std::is_convertible&lt;Return_Type, double&gt;::value || std::is_constructible&lt;hydra_thrust::complex&lt;double&gt;,Return_Type&gt;::value &gt;::type&gt; </td></tr>
<tr class="memitem:ac25504370e97f8483f51b7747a5d062f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> Return_Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#ac25504370e97f8483f51b7747a5d062f">hydra::detail::product</a> (ArgType const &amp;x, hydra_thrust::tuple&lt; Tp... &gt; const &amp;t)</td></tr>
<tr class="separator:ac25504370e97f8483f51b7747a5d062f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f27e0f9d5a5aeb14274d1775739d650"><td class="memTemplParams" colspan="2">template&lt;typename Return_Type , typename ArgType , typename ... Tp, typename  = typename hydra_thrust::detail::enable_if&lt;std::is_convertible&lt;Return_Type, double&gt;::value || std::is_constructible&lt;hydra_thrust::complex&lt;double&gt;,Return_Type&gt;::value &gt;::type&gt; </td></tr>
<tr class="memitem:a4f27e0f9d5a5aeb14274d1775739d650"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> Return_Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a4f27e0f9d5a5aeb14274d1775739d650">hydra::detail::product</a> (ArgType &amp;x, hydra_thrust::tuple&lt; Tp... &gt; &amp;t)</td></tr>
<tr class="separator:a4f27e0f9d5a5aeb14274d1775739d650"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade2c50d420b21392eae2bf88ef2f1408"><td class="memTemplParams" colspan="2">template&lt;typename Return_Type , typename ArgType1 , typename ArgType2 , typename ... Tp, typename  = typename hydra_thrust::detail::enable_if&lt;std::is_convertible&lt;Return_Type, double&gt;::value || std::is_constructible&lt;hydra_thrust::complex&lt;double&gt;,Return_Type&gt;::value &gt;::type&gt; </td></tr>
<tr class="memitem:ade2c50d420b21392eae2bf88ef2f1408"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> Return_Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#ade2c50d420b21392eae2bf88ef2f1408">hydra::detail::product2</a> (ArgType1 const &amp;x, ArgType2 const &amp;y, hydra_thrust::tuple&lt; Tp... &gt; const &amp;t)</td></tr>
<tr class="separator:ade2c50d420b21392eae2bf88ef2f1408"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a636ac81a76f60f852397b20aa6a5778e"><td class="memTemplParams" colspan="2">template&lt;typename Return_Type , typename ArgType1 , typename ArgType2 , typename ... Tp, typename  = typename hydra_thrust::detail::enable_if&lt;std::is_convertible&lt;Return_Type, double&gt;::value || std::is_constructible&lt;hydra_thrust::complex&lt;double&gt;,Return_Type&gt;::value &gt;::type&gt; </td></tr>
<tr class="memitem:a636ac81a76f60f852397b20aa6a5778e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> Return_Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a636ac81a76f60f852397b20aa6a5778e">hydra::detail::product2</a> (ArgType1 &amp;x, ArgType2 &amp;y, hydra_thrust::tuple&lt; Tp... &gt; &amp;t)</td></tr>
<tr class="separator:a636ac81a76f60f852397b20aa6a5778e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01ce8205f2812d6bc1a8395898455bc6"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename Return_Type , typename ArgType , typename ... Tp&gt; </td></tr>
<tr class="memitem:a01ce8205f2812d6bc1a8395898455bc6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::detail::enable_if&lt; I==sizeof...(Tp), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a01ce8205f2812d6bc1a8395898455bc6">hydra::detail::product_tuple</a> (Return_Type &amp;, hydra_thrust::tuple&lt; Tp... &gt; const &amp;, ArgType const &amp;)</td></tr>
<tr class="separator:a01ce8205f2812d6bc1a8395898455bc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50192c52e8c65a9e261d18f8d7e260ed"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename Return_Type , typename ArgType , typename ... Tp&gt; </td></tr>
<tr class="memitem:a50192c52e8c65a9e261d18f8d7e260ed"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::detail::enable_if&lt;(I&lt; sizeof...(Tp)), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a50192c52e8c65a9e261d18f8d7e260ed">hydra::detail::product_tuple</a> (Return_Type &amp;r, hydra_thrust::tuple&lt; Tp... &gt; const &amp;t, ArgType const &amp;arg)</td></tr>
<tr class="separator:a50192c52e8c65a9e261d18f8d7e260ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fd41b1a175a03273fcc747bf16fa147"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename Return_Type , typename ArgType , typename ... Tp&gt; </td></tr>
<tr class="memitem:a3fd41b1a175a03273fcc747bf16fa147"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::detail::enable_if&lt; I==sizeof...(Tp), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a3fd41b1a175a03273fcc747bf16fa147">hydra::detail::product_tuple</a> (Return_Type &amp;, hydra_thrust::tuple&lt; Tp... &gt; &amp;&amp;, ArgType &amp;&amp;)</td></tr>
<tr class="separator:a3fd41b1a175a03273fcc747bf16fa147"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27b437c78f61e1df0c91737e8f7cd8a8"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename Return_Type , typename ArgType , typename ... Tp&gt; </td></tr>
<tr class="memitem:a27b437c78f61e1df0c91737e8f7cd8a8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::detail::enable_if&lt;(I&lt; sizeof...(Tp)), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a27b437c78f61e1df0c91737e8f7cd8a8">hydra::detail::product_tuple</a> (Return_Type &amp;r, hydra_thrust::tuple&lt; Tp... &gt; &amp;&amp;t, ArgType &amp;&amp;arg)</td></tr>
<tr class="separator:a27b437c78f61e1df0c91737e8f7cd8a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb6c1af7e7483fbc3b22c7ef63788ce7"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename Return_Type , typename ArgType1 , typename ArgType2 , typename ... Tp&gt; </td></tr>
<tr class="memitem:abb6c1af7e7483fbc3b22c7ef63788ce7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::detail::enable_if&lt; I==sizeof...(Tp), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#abb6c1af7e7483fbc3b22c7ef63788ce7">hydra::detail::product_tuple2</a> (Return_Type &amp;, hydra_thrust::tuple&lt; Tp... &gt; const &amp;, ArgType1 const &amp;, ArgType2 const &amp;)</td></tr>
<tr class="separator:abb6c1af7e7483fbc3b22c7ef63788ce7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4517a255a100f22b0f3f962a139426db"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename Return_Type , typename ArgType1 , typename ArgType2 , typename ... Tp&gt; </td></tr>
<tr class="memitem:a4517a255a100f22b0f3f962a139426db"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::detail::enable_if&lt;(I&lt;(sizeof...(Tp))), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a4517a255a100f22b0f3f962a139426db">hydra::detail::product_tuple2</a> (Return_Type &amp;r, hydra_thrust::tuple&lt; Tp... &gt; const &amp;t, ArgType1 const &amp;arg1, ArgType2 const &amp;arg2)</td></tr>
<tr class="separator:a4517a255a100f22b0f3f962a139426db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d1f75d3a1f29b97e2470519273a8819"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename Return_Type , typename ArgType1 , typename ArgType2 , typename ... Tp&gt; </td></tr>
<tr class="memitem:a0d1f75d3a1f29b97e2470519273a8819"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::detail::enable_if&lt; I==sizeof...(Tp), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a0d1f75d3a1f29b97e2470519273a8819">hydra::detail::product_tuple2</a> (Return_Type &amp;, hydra_thrust::tuple&lt; Tp... &gt; &amp;&amp;, ArgType1 &amp;&amp;, ArgType2 &amp;&amp;)</td></tr>
<tr class="separator:a0d1f75d3a1f29b97e2470519273a8819"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d5b5bfede3e07f333b44254f6904008"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename Return_Type , typename ArgType1 , typename ArgType2 , typename ... Tp&gt; </td></tr>
<tr class="memitem:a0d5b5bfede3e07f333b44254f6904008"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::detail::enable_if&lt;(I&lt;(sizeof...(Tp))), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a0d5b5bfede3e07f333b44254f6904008">hydra::detail::product_tuple2</a> (Return_Type &amp;r, hydra_thrust::tuple&lt; Tp... &gt; &amp;&amp;t, ArgType1 &amp;&amp;arg1, ArgType2 &amp;&amp;arg2)</td></tr>
<tr class="separator:a0d5b5bfede3e07f333b44254f6904008"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18996edf882db2f33372691af9cc79d8"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, size_t N, typename Return_Type , typename ArgType1 , typename ArgType2 , typename ... Tp&gt; </td></tr>
<tr class="memitem:a18996edf882db2f33372691af9cc79d8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::detail::enable_if&lt; I==N, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a18996edf882db2f33372691af9cc79d8">hydra::detail::product_tuple3</a> (Return_Type &amp;, hydra_thrust::tuple&lt; Tp... &gt; const &amp;, ArgType1 const &amp;, ArgType2 const &amp;)</td></tr>
<tr class="separator:a18996edf882db2f33372691af9cc79d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcfce57c36263805be3cd8cc9d754498"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, size_t N, typename Return_Type , typename ArgType1 , typename ArgType2 , typename ... Tp&gt; </td></tr>
<tr class="memitem:afcfce57c36263805be3cd8cc9d754498"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::detail::enable_if&lt;(I&lt; N), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#afcfce57c36263805be3cd8cc9d754498">hydra::detail::product_tuple3</a> (Return_Type &amp;r, hydra_thrust::tuple&lt; Tp... &gt; const &amp;t, ArgType1 const &amp;arg1, ArgType2 const &amp;arg2)</td></tr>
<tr class="separator:afcfce57c36263805be3cd8cc9d754498"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14d9160e903a022678a19946e1082fd3"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, size_t N, typename Return_Type , typename ArgType1 , typename ArgType2 , typename ... Tp&gt; </td></tr>
<tr class="memitem:a14d9160e903a022678a19946e1082fd3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::detail::enable_if&lt; I==N, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a14d9160e903a022678a19946e1082fd3">hydra::detail::product_tuple3</a> (Return_Type &amp;, hydra_thrust::tuple&lt; Tp... &gt; &amp;&amp;, ArgType1 &amp;&amp;, ArgType2 &amp;&amp;)</td></tr>
<tr class="separator:a14d9160e903a022678a19946e1082fd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60f6104f2782abaedc08764af74a2513"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, size_t N, typename Return_Type , typename ArgType1 , typename ArgType2 , typename ... Tp&gt; </td></tr>
<tr class="memitem:a60f6104f2782abaedc08764af74a2513"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::detail::enable_if&lt;(I&lt; N), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a60f6104f2782abaedc08764af74a2513">hydra::detail::product_tuple3</a> (Return_Type &amp;r, hydra_thrust::tuple&lt; Tp... &gt; &amp;&amp;t, ArgType1 &amp;&amp;arg1, ArgType2 &amp;&amp;arg2)</td></tr>
<tr class="separator:a60f6104f2782abaedc08764af74a2513"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae12a77e6ee2553c9b830aeaa6e7e75e4"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ae12a77e6ee2553c9b830aeaa6e7e75e4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#ae12a77e6ee2553c9b830aeaa6e7e75e4">hydra::detail::ptr_setter</a> (T1 *&amp;ptr, typename hydra_thrust::detail::enable_if&lt; hydra_thrust::detail::is_same&lt; T1, T2 &gt;::value, T2 &gt;::type *el)</td></tr>
<tr class="separator:ae12a77e6ee2553c9b830aeaa6e7e75e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0c43562d26a5efbbee3de11d58fb6a0"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:af0c43562d26a5efbbee3de11d58fb6a0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#af0c43562d26a5efbbee3de11d58fb6a0">hydra::detail::ptr_setter</a> (T1 *&amp;, typename hydra_thrust::detail::enable_if&lt;!hydra_thrust::detail::is_same&lt; T1, T2 &gt;::value, T2 &gt;::type *)</td></tr>
<tr class="separator:af0c43562d26a5efbbee3de11d58fb6a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93a05294ac78115df3bf8b54fff5174d"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename ... Tp&gt; </td></tr>
<tr class="memitem:a93a05294ac78115df3bf8b54fff5174d"><td class="memTemplItemLeft" align="right" valign="top">hydra_thrust::detail::enable_if&lt; I==sizeof...(Tp), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a93a05294ac78115df3bf8b54fff5174d">hydra::detail::set_functors_in_tuple</a> (hydra_thrust::tuple&lt; Tp... &gt; &amp;, const std::vector&lt; <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt; &amp;)</td></tr>
<tr class="separator:a93a05294ac78115df3bf8b54fff5174d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0efde42488d09f938938e26557b53c05"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename ... Tp&gt; </td></tr>
<tr class="memitem:a0efde42488d09f938938e26557b53c05"><td class="memTemplItemLeft" align="right" valign="top">hydra_thrust::detail::enable_if&lt;(I&lt; sizeof...(Tp)), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a0efde42488d09f938938e26557b53c05">hydra::detail::set_functors_in_tuple</a> (hydra_thrust::tuple&lt; Tp... &gt; &amp;t, const std::vector&lt; <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt; &amp;parameters)</td></tr>
<tr class="separator:a0efde42488d09f938938e26557b53c05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa78862e977fa8cce9259242deb36570b"><td class="memTemplParams" colspan="2">template&lt;unsigned int I, typename Ptr , typename ... Tp&gt; </td></tr>
<tr class="memitem:aa78862e977fa8cce9259242deb36570b"><td class="memTemplItemLeft" align="right" valign="top">hydra_thrust::detail::enable_if&lt; I==sizeof...(Tp), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#aa78862e977fa8cce9259242deb36570b">hydra::detail::set_ptr_to_tuple_element</a> (const <a class="el" href="namespace_3globalScope_4.html#classint">int</a>, std::tuple&lt; Tp... &gt; &amp;, Ptr *&amp;)</td></tr>
<tr class="separator:aa78862e977fa8cce9259242deb36570b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8e4701c4056cff52653b75e79b6c1b1"><td class="memTemplParams" colspan="2">template&lt;unsigned int I = 0, typename Ptr , typename ... Tp&gt; </td></tr>
<tr class="memitem:ad8e4701c4056cff52653b75e79b6c1b1"><td class="memTemplItemLeft" align="right" valign="top">hydra_thrust::detail::enable_if&lt;(I&lt; sizeof...(Tp)), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#ad8e4701c4056cff52653b75e79b6c1b1">hydra::detail::set_ptr_to_tuple_element</a> (const <a class="el" href="namespace_3globalScope_4.html#classint">int</a> index, std::tuple&lt; Tp... &gt; &amp;t, Ptr *&amp;ptr)</td></tr>
<tr class="separator:ad8e4701c4056cff52653b75e79b6c1b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fbd7741e643726fd8ee8295b234586e"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename Array_Type , typename T &gt; </td></tr>
<tr class="memitem:a1fbd7741e643726fd8ee8295b234586e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::detail::enable_if&lt;(I==hydra_thrust::tuple_size&lt; T &gt;::value) &amp;&amp;is_homogeneous&lt; Array_Type, T &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a1fbd7741e643726fd8ee8295b234586e">hydra::detail::set_ptrs_to_tuple</a> (T &amp;, Array_Type **)</td></tr>
<tr class="separator:a1fbd7741e643726fd8ee8295b234586e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64a1e4a7a30b6daa7e4eaabbfd9aa4a2"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename Array_Type , typename T &gt; </td></tr>
<tr class="memitem:a64a1e4a7a30b6daa7e4eaabbfd9aa4a2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::detail::enable_if&lt;(I&lt; hydra_thrust::tuple_size&lt; T &gt;::value) &amp;&amp;is_homogeneous&lt; Array_Type, T &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a64a1e4a7a30b6daa7e4eaabbfd9aa4a2">hydra::detail::set_ptrs_to_tuple</a> (T &amp;t, Array_Type **Array)</td></tr>
<tr class="separator:a64a1e4a7a30b6daa7e4eaabbfd9aa4a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90b2bcec3f72d547652f4db3b581e755"><td class="memTemplParams" colspan="2">template&lt;unsigned int I = 0, typename T , typename ... Tp&gt; </td></tr>
<tr class="memitem:a90b2bcec3f72d547652f4db3b581e755"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::detail::enable_if&lt; I==sizeof...(Tp), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a90b2bcec3f72d547652f4db3b581e755">hydra::detail::set_tuple_element</a> (const <a class="el" href="namespace_3globalScope_4.html#classint">int</a>, hydra_thrust::tuple&lt; Tp... &gt; const &amp;, T &amp;)</td></tr>
<tr class="separator:a90b2bcec3f72d547652f4db3b581e755"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07d2736316e67ca5010eb45eec285fa2"><td class="memTemplParams" colspan="2">template&lt;unsigned int I = 0, typename T , typename ... Tp&gt; </td></tr>
<tr class="memitem:a07d2736316e67ca5010eb45eec285fa2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::detail::enable_if&lt;(I&lt; sizeof...(Tp)), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a07d2736316e67ca5010eb45eec285fa2">hydra::detail::set_tuple_element</a> (const <a class="el" href="namespace_3globalScope_4.html#classint">int</a> index, hydra_thrust::tuple&lt; Tp... &gt; &amp;t, const T &amp;x)</td></tr>
<tr class="separator:a07d2736316e67ca5010eb45eec285fa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d766efc8b57b8ea0808be1a69aec7fc"><td class="memTemplParams" colspan="2">template&lt;typename ... T1, typename ... T2&gt; </td></tr>
<tr class="memitem:a9d766efc8b57b8ea0808be1a69aec7fc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a9d766efc8b57b8ea0808be1a69aec7fc">hydra::detail::split_tuple</a> (hydra_thrust::tuple&lt; T1... &gt; &amp;t1, hydra_thrust::tuple&lt; T2... &gt; &amp;t2, hydra_thrust::tuple&lt; T1..., T2... &gt; const &amp;t)</td></tr>
<tr class="separator:a9d766efc8b57b8ea0808be1a69aec7fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f1aa7425652bdb11f578dea52cac883"><td class="memTemplParams" colspan="2">template&lt;size_t N, typename ... T&gt; </td></tr>
<tr class="memitem:a5f1aa7425652bdb11f578dea52cac883"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a5f1aa7425652bdb11f578dea52cac883">hydra::detail::split_tuple</a> (hydra_thrust::tuple&lt; T... &gt; &amp;t) -&gt; decltype(split_tuple_helper(t, make_index_sequence&lt; N &gt;</td></tr>
<tr class="separator:a5f1aa7425652bdb11f578dea52cac883"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b1b36c840b16da1dc97c8b3729e4c8b"><td class="memTemplParams" colspan="2">template&lt;typename ... T1, typename ... T2, size_t... I1, size_t... I2&gt; </td></tr>
<tr class="memitem:a7b1b36c840b16da1dc97c8b3729e4c8b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a7b1b36c840b16da1dc97c8b3729e4c8b">hydra::detail::split_tuple_helper</a> (hydra_thrust::tuple&lt; T1... &gt; &amp;t1, hydra_thrust::tuple&lt; T2... &gt; &amp;t2, hydra_thrust::tuple&lt; T1..., T2... &gt; const &amp;t, index_sequence&lt; I1... &gt;, index_sequence&lt; I2... &gt;)</td></tr>
<tr class="separator:a7b1b36c840b16da1dc97c8b3729e4c8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac32e9090f5cf5008d6a7abbcd6c6535f"><td class="memTemplParams" colspan="2">template&lt;typename ... T, size_t... I1, size_t... I2&gt; </td></tr>
<tr class="memitem:ac32e9090f5cf5008d6a7abbcd6c6535f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#ac32e9090f5cf5008d6a7abbcd6c6535f">hydra::detail::split_tuple_helper</a> (hydra_thrust::tuple&lt; T... &gt; &amp;t, index_sequence&lt; I1... &gt;, index_sequence&lt; I2... &gt;) -&gt; decltype(hydra_thrust::make_pair(hydra_thrust::tie(hydra_thrust::get&lt; I1 &gt;(t)...), hydra_thrust::tie(hydra_thrust::get&lt; I2++sizeof...(I1)&gt;(t)...)))</td></tr>
<tr class="separator:ac32e9090f5cf5008d6a7abbcd6c6535f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3827659803f37e62c150df7e7fabd817"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename Return_Type , typename ArgType , typename ... Tp&gt; </td></tr>
<tr class="memitem:a3827659803f37e62c150df7e7fabd817"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::detail::enable_if&lt; I==sizeof...(Tp), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a3827659803f37e62c150df7e7fabd817">hydra::detail::sum_tuple</a> (Return_Type &amp;, hydra_thrust::tuple&lt; Tp... &gt; &amp;&amp;, ArgType &amp;&amp;)</td></tr>
<tr class="separator:a3827659803f37e62c150df7e7fabd817"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f54c7821b0c7c33b7cac8e58c467600"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename Return_Type , typename ArgType , typename ... Tp&gt; </td></tr>
<tr class="memitem:a3f54c7821b0c7c33b7cac8e58c467600"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::detail::enable_if&lt;(I&lt; sizeof...(Tp)), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a3f54c7821b0c7c33b7cac8e58c467600">hydra::detail::sum_tuple</a> (Return_Type &amp;r, hydra_thrust::tuple&lt; Tp... &gt; &amp;&amp;t, ArgType &amp;&amp;arg)</td></tr>
<tr class="separator:a3f54c7821b0c7c33b7cac8e58c467600"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84b0195e8b158fb484274604b4add551"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename Return_Type , typename ArgType , typename ... Tp&gt; </td></tr>
<tr class="memitem:a84b0195e8b158fb484274604b4add551"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::detail::enable_if&lt; I==sizeof...(Tp), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a84b0195e8b158fb484274604b4add551">hydra::detail::sum_tuple</a> (Return_Type &amp;, hydra_thrust::tuple&lt; Tp... &gt; const &amp;, ArgType const &amp;)</td></tr>
<tr class="separator:a84b0195e8b158fb484274604b4add551"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac201d9fb427d4a329383f1aa86ba9326"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename Return_Type , typename ArgType , typename ... Tp&gt; </td></tr>
<tr class="memitem:ac201d9fb427d4a329383f1aa86ba9326"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::detail::enable_if&lt;(I&lt; sizeof...(Tp)), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#ac201d9fb427d4a329383f1aa86ba9326">hydra::detail::sum_tuple</a> (Return_Type &amp;r, hydra_thrust::tuple&lt; Tp... &gt;const &amp;t, ArgType const &amp;arg)</td></tr>
<tr class="separator:ac201d9fb427d4a329383f1aa86ba9326"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60433e0129833261ec019f6d7f907da7"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename Return_Type , typename ArgType1 , typename ArgType2 , typename ... Tp&gt; </td></tr>
<tr class="memitem:a60433e0129833261ec019f6d7f907da7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::detail::enable_if&lt; I==sizeof...(Tp), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a60433e0129833261ec019f6d7f907da7">hydra::detail::sum_tuple2</a> (Return_Type &amp;, hydra_thrust::tuple&lt; Tp... &gt; &amp;&amp;, ArgType1 &amp;&amp;, ArgType2 &amp;&amp;)</td></tr>
<tr class="separator:a60433e0129833261ec019f6d7f907da7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefacde8919a6658132ffc081ac40eab8"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename Return_Type , typename ArgType1 , typename ArgType2 , typename ... Tp&gt; </td></tr>
<tr class="memitem:aefacde8919a6658132ffc081ac40eab8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::detail::enable_if&lt;(I&lt; sizeof...(Tp)), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#aefacde8919a6658132ffc081ac40eab8">hydra::detail::sum_tuple2</a> (Return_Type &amp;r, hydra_thrust::tuple&lt; Tp... &gt; &amp;&amp;t, ArgType1 &amp;&amp;arg1, ArgType2 &amp;&amp;arg2)</td></tr>
<tr class="separator:aefacde8919a6658132ffc081ac40eab8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71473533019ee4297e16843bbcd5c168"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename Return_Type , typename ArgType1 , typename ArgType2 , typename ... Tp&gt; </td></tr>
<tr class="memitem:a71473533019ee4297e16843bbcd5c168"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::detail::enable_if&lt; I==sizeof...(Tp), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a71473533019ee4297e16843bbcd5c168">hydra::detail::sum_tuple2</a> (Return_Type &amp;, hydra_thrust::tuple&lt; Tp... &gt;const &amp;, ArgType1 const &amp;, ArgType2 const &amp;)</td></tr>
<tr class="separator:a71473533019ee4297e16843bbcd5c168"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca4351a6da0a103bc7a12f02e8abb675"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename Return_Type , typename ArgType1 , typename ArgType2 , typename ... Tp&gt; </td></tr>
<tr class="memitem:aca4351a6da0a103bc7a12f02e8abb675"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::detail::enable_if&lt;(I&lt; sizeof...(Tp)), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#aca4351a6da0a103bc7a12f02e8abb675">hydra::detail::sum_tuple2</a> (Return_Type &amp;r, hydra_thrust::tuple&lt; Tp... &gt; const &amp;t, ArgType1 const &amp;arg1, ArgType2 const &amp;arg2)</td></tr>
<tr class="separator:aca4351a6da0a103bc7a12f02e8abb675"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61180588ee1d71e4718adf6f8051fd7c"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename FistType , typename ... OtherTypes&gt; </td></tr>
<tr class="memitem:a61180588ee1d71e4718adf6f8051fd7c"><td class="memTemplItemLeft" align="right" valign="top">hydra_thrust::detail::enable_if&lt; I==(sizeof...(OtherTypes)+1) &amp;&amp;are_all_same&lt; FistType, OtherTypes... &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a61180588ee1d71e4718adf6f8051fd7c">hydra::detail::tupleToArray</a> (hydra_thrust::tuple&lt; FistType, OtherTypes... &gt; const &amp;, std::array&lt; FistType, sizeof...(OtherTypes)+1 &gt; &amp;)</td></tr>
<tr class="separator:a61180588ee1d71e4718adf6f8051fd7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08a1c8dabb7a10c7019eae15b9b57396"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename FistType , typename ... OtherTypes&gt; </td></tr>
<tr class="memitem:a08a1c8dabb7a10c7019eae15b9b57396"><td class="memTemplItemLeft" align="right" valign="top">hydra_thrust::detail::enable_if&lt;(I&lt; sizeof...(OtherTypes)+1) &amp;&amp;are_all_same&lt; FistType, OtherTypes... &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a08a1c8dabb7a10c7019eae15b9b57396">hydra::detail::tupleToArray</a> (hydra_thrust::tuple&lt; FistType, OtherTypes... &gt; const &amp;t, std::array&lt; FistType, sizeof...(OtherTypes)+1 &gt; &amp;Array)</td></tr>
<tr class="separator:a08a1c8dabb7a10c7019eae15b9b57396"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d28a90668aa47a0ef0184472165a6eb"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename FistType , typename ... OtherTypes&gt; </td></tr>
<tr class="memitem:a0d28a90668aa47a0ef0184472165a6eb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::detail::enable_if&lt; I==(sizeof...(OtherTypes)+1) &amp;&amp;are_all_same&lt; FistType, OtherTypes... &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a0d28a90668aa47a0ef0184472165a6eb">hydra::detail::tupleToArray</a> (hydra_thrust::tuple&lt; FistType, OtherTypes... &gt; const &amp;, typename std::remove_reference&lt; FistType &gt;::type *)</td></tr>
<tr class="separator:a0d28a90668aa47a0ef0184472165a6eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48b258ba5737f48014fbb26eaba70dc7"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename FistType , typename ... OtherTypes&gt; </td></tr>
<tr class="memitem:a48b258ba5737f48014fbb26eaba70dc7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::detail::enable_if&lt;(I&lt; sizeof...(OtherTypes)+1) &amp;&amp;are_all_same&lt; FistType, OtherTypes... &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a48b258ba5737f48014fbb26eaba70dc7">hydra::detail::tupleToArray</a> (hydra_thrust::tuple&lt; FistType, OtherTypes... &gt; const &amp;t, typename std::remove_reference&lt; FistType &gt;::type *Array)</td></tr>
<tr class="separator:a48b258ba5737f48014fbb26eaba70dc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0241d1e6dda57e0866e3cb2de22199dc"><td class="memTemplParams" colspan="2">template&lt;typename TupleType , typename ArrayType &gt; </td></tr>
<tr class="memitem:a0241d1e6dda57e0866e3cb2de22199dc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::detail::enable_if&lt;(detail::is_instantiation_of&lt; hydra_thrust::tuple, TupleType &gt;::value||detail::is_instantiation_of&lt; hydra_thrust::detail::tuple_of_iterator_references, TupleType &gt;::value), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a0241d1e6dda57e0866e3cb2de22199dc">hydra::detail::tupleToArray</a> (TupleType const &amp;_tuple, ArrayType *_array)</td></tr>
<tr class="separator:a0241d1e6dda57e0866e3cb2de22199dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a6e5ce23b23364c64166f4c390f0f5f03"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a6e5ce23b23364c64166f4c390f0f5f03">hydra::detail::make_index_sequence&lt; sizeof...(T) -N &gt;</a></td></tr>
<tr class="separator:a6e5ce23b23364c64166f4c390f0f5f03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6272aac6b63b0ff4f44d2ff9b24716cf"><td class="memTemplParams" colspan="2">template&lt;typename T , typename C , size_t N, size_t I = 1&gt; </td></tr>
<tr class="memitem:a6272aac6b63b0ff4f44d2ff9b24716cf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> std::enable_if&lt; I&lt; N, void &gt;::type max_helper(T const  &amp;tuple, <a class="el" href="basic__distributions_8inl.html#a4900ef306eb9271438791f1a98b8ccba">C</a> &amp;max_value, size_t &amp;max_index){ max_index=max_value &gt; hydra_thrust::get&lt; I &gt;(tuple) ? max_index&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a6272aac6b63b0ff4f44d2ff9b24716cf">hydra::detail::max_value</a> = max_value &gt; hydra_thrust::get&lt;I&gt;(tuple) ? max_value : hydra_thrust::get&lt;I&gt;(tuple)</td></tr>
<tr class="separator:a6272aac6b63b0ff4f44d2ff9b24716cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<hr/><h2 class="groupheader">Data Structure Documentation</h2>
<a name="structhydra_1_1detail_1_1references__tuple__type" id="structhydra_1_1detail_1_1references__tuple__type"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1detail_1_1references__tuple__type">&#9670;&nbsp;</a></span>hydra::detail::references_tuple_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::detail::references_tuple_type</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;size_t N, typename T&gt;<br />
struct hydra::detail::references_tuple_type&lt; N, T &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::detail::references_tuple_type&lt; N, T &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1references__tuple__type__coll__graph.svg" width="174" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a8c899abc24c3172b67847bc3adba0bd6"></a>typedef <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1repeat">repeat</a>&lt; T, N, tuple_of_iterator_references &gt;::<a class="el" href="namespacehydra_1_1detail.html#a8c899abc24c3172b67847bc3adba0bd6">type</a></td>
<td class="fieldname">
type</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structhydra_1_1detail_1_1tuple__cat__type" id="structhydra_1_1detail_1_1tuple__cat__type"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1detail_1_1tuple__cat__type">&#9670;&nbsp;</a></span>hydra::detail::tuple_cat_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::detail::tuple_cat_type</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename Tuple1, typename Tuple2&gt;<br />
struct hydra::detail::tuple_cat_type&lt; Tuple1, Tuple2 &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::detail::tuple_cat_type&lt; Tuple1, Tuple2 &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1tuple__cat__type__coll__graph.svg" width="200" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a name="structhydra_1_1detail_1_1tuple__cat__type_3_01hydra__thrust_1_1detail_1_1tuple__of__iterator__re5bb9ebd0e2b48fed7e7ce237c7799785" id="structhydra_1_1detail_1_1tuple__cat__type_3_01hydra__thrust_1_1detail_1_1tuple__of__iterator__re5bb9ebd0e2b48fed7e7ce237c7799785"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1detail_1_1tuple__cat__type_3_01hydra__thrust_1_1detail_1_1tuple__of__iterator__re5bb9ebd0e2b48fed7e7ce237c7799785">&#9670;&nbsp;</a></span>hydra::detail::tuple_cat_type&lt; hydra_thrust::detail::tuple_of_iterator_references&lt; T1... &gt;, hydra_thrust::detail::tuple_of_iterator_references&lt; T2... &gt; &gt;</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::detail::tuple_cat_type&lt; hydra_thrust::detail::tuple_of_iterator_references&lt; T1... &gt;, hydra_thrust::detail::tuple_of_iterator_references&lt; T2... &gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename ... T1, typename ... T2&gt;<br />
struct hydra::detail::tuple_cat_type&lt; hydra_thrust::detail::tuple_of_iterator_references&lt; T1... &gt;, hydra_thrust::detail::tuple_of_iterator_references&lt; T2... &gt; &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::detail::tuple_cat_type&lt; hydra_thrust::detail::tuple_of_iterator_references&lt; T1... &gt;, hydra_thrust::detail::tuple_of_iterator_references&lt; T2... &gt; &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1tuple__cat__type_3_01hydra__thrust_1_1detail_1_1tuple__of__iterator__re2741fd8e8c86ddfd555d0733f8d5b654.svg" width="214" height="162"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a729b1dea3e61359b87ebf9395e4e06b9"></a></td>
<td class="fieldname">
type</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structhydra_1_1detail_1_1tuple__cat__type_3_01hydra__thrust_1_1tuple_3_01T1_8_8_8_01_4_00_01hydrfed0294bfa8beb4efb8ca45fc614f789" id="structhydra_1_1detail_1_1tuple__cat__type_3_01hydra__thrust_1_1tuple_3_01T1_8_8_8_01_4_00_01hydrfed0294bfa8beb4efb8ca45fc614f789"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1detail_1_1tuple__cat__type_3_01hydra__thrust_1_1tuple_3_01T1_8_8_8_01_4_00_01hydrfed0294bfa8beb4efb8ca45fc614f789">&#9670;&nbsp;</a></span>hydra::detail::tuple_cat_type&lt; hydra_thrust::tuple&lt; T1... &gt;, hydra_thrust::tuple&lt; T2... &gt; &gt;</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::detail::tuple_cat_type&lt; hydra_thrust::tuple&lt; T1... &gt;, hydra_thrust::tuple&lt; T2... &gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename ... T1, typename ... T2&gt;<br />
struct hydra::detail::tuple_cat_type&lt; hydra_thrust::tuple&lt; T1... &gt;, hydra_thrust::tuple&lt; T2... &gt; &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::detail::tuple_cat_type&lt; hydra_thrust::tuple&lt; T1... &gt;, hydra_thrust::tuple&lt; T2... &gt; &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1tuple__cat__type_3_01hydra__thrust_1_1tuple_3_01T1_8_8_8_01_4_00_01hydr3f2b365811d881a839bc249fef69b76b.svg" width="174" height="132"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="adf0c360dd1cf05db7e5aa1568276c182"></a></td>
<td class="fieldname">
type</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structhydra_1_1detail_1_1tuple__type" id="structhydra_1_1detail_1_1tuple__type"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1detail_1_1tuple__type">&#9670;&nbsp;</a></span>hydra::detail::tuple_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::detail::tuple_type</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;size_t N, typename T&gt;<br />
struct hydra::detail::tuple_type&lt; N, T &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::detail::tuple_type&lt; N, T &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1tuple__type__coll__graph.svg" width="140" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a22e38393ea5d639e178949f9e3093076"></a>typedef <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1repeat">repeat</a>&lt; T, N, <a class="el" href="namespacehydra.html#a717fc4e6b10453164099beade13d0226">tuple</a> &gt;::<a class="el" href="namespacehydra_1_1detail.html#a22e38393ea5d639e178949f9e3093076">type</a></td>
<td class="fieldname">
type</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_92a1ff494355b06c14c0e1fe7b982d29.html">Hydra</a></li><li class="navelem"><a class="el" href="dir_108162cc96056bf8ace3602d16680a1c.html">hydra</a></li><li class="navelem"><a class="el" href="dir_3834ae61da54c887219d23c23fa56bea.html">detail</a></li><li class="navelem"><a class="el" href="dir_50b81e2dbdc2d397ec548125a86506fb.html">utility</a></li><li class="navelem"><a class="el" href="Utility__Tuple_8h.html">Utility_Tuple.h</a></li>
    <li class="footer">Generated on Sun Jun 28 2020 00:00:02 for Hydra by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.14 </li>
  </ul>
</div>
</body>
</html>
