<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Hydra: hydra::detail Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo_Hydra2.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Hydra
   &#160;<span id="projectnumber">4.0.1</span>
   </div>
   <div id="projectbrief">A header-only templated C++ framework to perform data analysis on massively parallel platforms.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('namespacehydra_1_1detail.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">hydra::detail Namespace Reference<div class="ingroups"><a class="el" href="group__policy.html">Policy</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacehydra_1_1detail_1_1convolution"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail_1_1convolution.html">convolution</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacehydra_1_1detail_1_1cpp"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail_1_1cpp.html">cpp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacehydra_1_1detail_1_1cuda"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail_1_1cuda.html">cuda</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacehydra_1_1detail_1_1cufft"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail_1_1cufft.html">cufft</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacehydra_1_1detail_1_1device"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail_1_1device.html">device</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacehydra_1_1detail_1_1fa__impl"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail_1_1fa__impl.html">fa_impl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacehydra_1_1detail_1_1fftw"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail_1_1fftw.html">fftw</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacehydra_1_1detail_1_1host"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail_1_1host.html">host</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacehydra_1_1detail_1_1impl"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail_1_1impl.html">impl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacehydra_1_1detail_1_1jacobi"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail_1_1jacobi.html">jacobi</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacehydra_1_1detail_1_1meld__iterators__ns"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail_1_1meld__iterators__ns.html">meld_iterators_ns</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacehydra_1_1detail_1_1omp"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail_1_1omp.html">omp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacehydra_1_1detail_1_1random"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail_1_1random.html">random</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacehydra_1_1detail_1_1range"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail_1_1range.html">range</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacehydra_1_1detail_1_1spline"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail_1_1spline.html">spline</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacehydra_1_1detail_1_1stuple__impl"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail_1_1stuple__impl.html">stuple_impl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacehydra_1_1detail_1_1tbb"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail_1_1tbb.html">tbb</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacehydra_1_1detail_1_1tuple"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail_1_1tuple.html">tuple</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacehydra_1_1detail_1_1tuple__utility"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail_1_1tuple__utility.html">tuple_utility</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacehydra_1_1detail_1_1utils"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail_1_1utils.html">utils</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:structhydra_1_1detail_1_1__merge__and__renumber"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1__merge__and__renumber">_merge_and_renumber</a></td></tr>
<tr class="separator:structhydra_1_1detail_1_1__merge__and__renumber"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1__merge__and__renumber_3_01index__sequence_3_01I1_8_8_8_01_4_00_01index73e1de0a5394a3c55b32c0d1818a4cc9.html">_merge_and_renumber&lt; index_sequence&lt; I1... &gt;, index_sequence&lt; I2... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1detail_1_1AddPdfBase.html">AddPdfBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1detail_1_1AddPdfChecker.html">AddPdfChecker</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1AddPdfFunctor.html">AddPdfFunctor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1AddResultGenzMalikBoxes.html">AddResultGenzMalikBoxes</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1AddStatsPHSP.html">AddStatsPHSP</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1all__true.html">all_true</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1all__true_3_4.html">all_true&lt;&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1detail_1_1append__to__type__seq"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1append__to__type__seq">append_to_type_seq</a></td></tr>
<tr class="separator:structhydra_1_1detail_1_1append__to__type__seq"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1detail_1_1append__to__type__seq_3_01T_00_01TT_3_01Ts_8_8_8_01_4_01_4"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1append__to__type__seq_3_01T_00_01TT_3_01Ts_8_8_8_01_4_01_4">append_to_type_seq&lt; T, TT&lt; Ts... &gt; &gt;</a></td></tr>
<tr class="separator:structhydra_1_1detail_1_1append__to__type__seq_3_01T_00_01TT_3_01Ts_8_8_8_01_4_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1are__base__of.html">are_base_of</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1are__base__of_3_01Base_00_01T_01_4.html">are_base_of&lt; Base, T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1are__iterables.html">are_iterables</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1are__iterators.html">are_iterators</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1AverageMother.html">AverageMother</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1AverageMothers.html">AverageMothers</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1detail_1_1BackendPolicy"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">BackendPolicy</a></td></tr>
<tr class="separator:structhydra_1_1detail_1_1BackendPolicy"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1BackendPolicy_3_01Backend_1_1Cpp_01_4.html">BackendPolicy&lt; Backend::Cpp &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1BackendPolicy_3_01Backend_1_1Cuda_01_4.html">BackendPolicy&lt; Backend::Cuda &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1BackendPolicy_3_01Backend_1_1Device_01_4.html">BackendPolicy&lt; Backend::Device &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1BackendPolicy_3_01Backend_1_1Host_01_4.html">BackendPolicy&lt; Backend::Host &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1BackendPolicy_3_01Backend_1_1Omp_01_4.html">BackendPolicy&lt; Backend::Omp &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1BackendPolicy_3_01Backend_1_1Tbb_01_4.html">BackendPolicy&lt; Backend::Tbb &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1detail_1_1bool__pack"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1bool__pack">bool_pack</a></td></tr>
<tr class="separator:structhydra_1_1detail_1_1bool__pack"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1detail_1_1CanConvert"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1CanConvert">CanConvert</a></td></tr>
<tr class="separator:structhydra_1_1detail_1_1CanConvert"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1Caster.html">Caster</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1CheckEnergy.html">CheckEnergy</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1CompareGenzMalikBoxes.html">CompareGenzMalikBoxes</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1CompareTuples.html">CompareTuples</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1detail_1_1CompositeBase.html">CompositeBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1conditions__and.html">conditions_and</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1conditions__and_3_01Cond_00_01Conds_8_8_8_01_4.html">conditions_and&lt; Cond, Conds... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1CovMatrixBinary.html">CovMatrixBinary</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1CovMatrixUnary.html">CovMatrixUnary</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1DecayMother.html">DecayMother</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1DecayMothers.html">DecayMothers</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1dimensionality.html">dimensionality</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1detail_1_1divide__result"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1divide__result">divide_result</a></td></tr>
<tr class="separator:structhydra_1_1detail_1_1divide__result"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1EvalMother.html">EvalMother</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1EvalMothers.html">EvalMothers</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1EvalOnDaughters.html">EvalOnDaughters</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1EvalOnDaughtersBinary.html">EvalOnDaughtersBinary</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1FCNWeightsReducerUnary.html">FCNWeightsReducerUnary</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1detail_1_1FFTPolicy"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1FFTPolicy">FFTPolicy</a></td></tr>
<tr class="separator:structhydra_1_1detail_1_1FFTPolicy"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1detail_1_1FFTPolicy_3_01T_00_01detail_1_1CuFFT_01_4"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1FFTPolicy_3_01T_00_01detail_1_1CuFFT_01_4">FFTPolicy&lt; T, detail::CuFFT &gt;</a></td></tr>
<tr class="separator:structhydra_1_1detail_1_1FFTPolicy_3_01T_00_01detail_1_1CuFFT_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1detail_1_1FFTPolicy_3_01T_00_01detail_1_1FFTW_01_4"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1FFTPolicy_3_01T_00_01detail_1_1FFTW_01_4">FFTPolicy&lt; T, detail::FFTW &gt;</a></td></tr>
<tr class="separator:structhydra_1_1detail_1_1FFTPolicy_3_01T_00_01detail_1_1FFTW_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1find__unique__type.html">find_unique_type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1detail_1_1find__unique__type__impl"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1find__unique__type__impl">find_unique_type_impl</a></td></tr>
<tr class="separator:structhydra_1_1detail_1_1find__unique__type__impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1find__unique__type__impl_3_01I_00_01T_01_4.html">find_unique_type_impl&lt; I, T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1find__unique__type__impl_3_01I_00_01T_00_01T_00_01Types_8_8_8_01_4.html">find_unique_type_impl&lt; I, T, T, Types... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1find__unique__type__impl_3_01I_00_01T_00_01U_00_01Types_8_8_8_01_4.html">find_unique_type_impl&lt; I, T, U, Types... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1FlagAcceptReject.html">FlagAcceptReject</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flags generated events as accepted (1) or rejected (0).  <a href="structhydra_1_1detail_1_1FlagAcceptReject.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1detail_1_1FlagDaugthers.html">FlagDaugthers</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1detail_1_1function__traits"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1function__traits">function_traits</a></td></tr>
<tr class="separator:structhydra_1_1detail_1_1function__traits"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1function__traits_3_01ReturnType_07ClassType_1_1_5_08_07Args_01_6_8_8_8_08_4.html">function_traits&lt; ReturnType(ClassType::*)(Args &amp;...)&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1function__traits_3_01ReturnType_07ClassType_1_1_5_08_07Args_8_8_8_08_01const_01_4.html">function_traits&lt; ReturnType(ClassType::*)(Args...) const &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1FunctionArgument.html">FunctionArgument</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1detail_1_1functor__traits"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1functor__traits">functor_traits</a></td></tr>
<tr class="separator:structhydra_1_1detail_1_1functor__traits"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1detail_1_1functor__traits_3_01ReturnType_07ClassType_1_1_5_08_07Args_8_8_8_08_01_4"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1functor__traits_3_01ReturnType_07ClassType_1_1_5_08_07Args_8_8_8_08_01_4">functor_traits&lt; ReturnType(ClassType::*)(Args...) &gt;</a></td></tr>
<tr class="separator:structhydra_1_1detail_1_1functor__traits_3_01ReturnType_07ClassType_1_1_5_08_07Args_8_8_8_08_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1functor__traits_3_01ReturnType_07ClassType_1_1_5_08_07Args_8_8_8_08_01const_01_4.html">functor_traits&lt; ReturnType(ClassType::*)(Args...) const &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1GenerateDecay.html">GenerateDecay</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1detail_1_1GenzMalikBox.html">GenzMalikBox</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1detail_1_1GenzMalikBoxResult.html">GenzMalikBoxResult</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1GetAxisBinCenter.html">GetAxisBinCenter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1GetBinCenter.html">GetBinCenter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1GetBinCenter_3_01T_00_011_01_4.html">GetBinCenter&lt; T, 1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1GetGlobalBin.html">GetGlobalBin</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1GetGlobalBin_3_011_00_01T_01_4.html">GetGlobalBin&lt; 1, T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1GetSWeight.html">GetSWeight</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1detail_1_1gray__code.html">gray_code</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1has__rng__formula.html">has_rng_formula</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1has__rng__formula_3_01Functor_00_01hydra_1_1thrust_1_1void__t_3_01typen11e96fbe001229ffe2bf7fca4b5ff043.html">has_rng_formula&lt; Functor, hydra::thrust::void_t&lt; typename hydra::RngFormula&lt; Functor &gt;::value_type &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1high__bit__mask__t.html">high_bit_mask_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1detail_1_1if__then__else"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#classhydra_1_1detail_1_1if__then__else">if_then_else</a></td></tr>
<tr class="separator:classhydra_1_1detail_1_1if__then__else"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1detail_1_1if__then__else_3_01false_00_01T1_00_01T2_01_4"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#classhydra_1_1detail_1_1if__then__else_3_01false_00_01T1_00_01T2_01_4">if_then_else&lt; false, T1, T2 &gt;</a></td></tr>
<tr class="separator:classhydra_1_1detail_1_1if__then__else_3_01false_00_01T1_00_01T2_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1detail_1_1if__then__else_3_01true_00_01T1_00_01T2_01_4"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#classhydra_1_1detail_1_1if__then__else_3_01true_00_01T1_00_01T2_01_4">if_then_else&lt; true, T1, T2 &gt;</a></td></tr>
<tr class="separator:classhydra_1_1detail_1_1if__then__else_3_01true_00_01T1_00_01T2_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1detail_1_1if__then__else__tt"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1if__then__else__tt">if_then_else_tt</a></td></tr>
<tr class="separator:structhydra_1_1detail_1_1if__then__else__tt"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1detail_1_1if__then__else__tt_3_01false_00_01T1_00_01T2_01_4"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1if__then__else__tt_3_01false_00_01T1_00_01T2_01_4">if_then_else_tt&lt; false, T1, T2 &gt;</a></td></tr>
<tr class="separator:structhydra_1_1detail_1_1if__then__else__tt_3_01false_00_01T1_00_01T2_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1detail_1_1if__then__else__tt_3_01true_00_01T1_00_01T2_01_4"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1if__then__else__tt_3_01true_00_01T1_00_01T2_01_4">if_then_else_tt&lt; true, T1, T2 &gt;</a></td></tr>
<tr class="separator:structhydra_1_1detail_1_1if__then__else__tt_3_01true_00_01T1_00_01T2_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1detail_1_1index__in__tuple"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1index__in__tuple">index_in_tuple</a></td></tr>
<tr class="separator:structhydra_1_1detail_1_1index__in__tuple"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1index__in__tuple_3_01Type_00_01hydra_1_1thrust_1_1tuple_3_01Head_00_01Tail_8_8_8_01_4_01_4.html">index_in_tuple&lt; Type, hydra::thrust::tuple&lt; Head, Tail... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1index__sequence.html">index_sequence</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1detail_1_1int__fast__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1int__fast__t">int_fast_t</a></td></tr>
<tr class="separator:structhydra_1_1detail_1_1int__fast__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1int__t.html">int_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1is__device__reference.html">is_device_reference</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1is__device__reference_3_01hydra_1_1thrust_1_1device__reference_3_01T_01_4_01_4.html">is_device_reference&lt; hydra::thrust::device_reference&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1detail_1_1is__function__argument"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1is__function__argument">is_function_argument</a></td></tr>
<tr class="separator:structhydra_1_1detail_1_1is__function__argument"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1is__function__argument_3_01Arg_00_01false_01_4.html">is_function_argument&lt; Arg, false &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1is__function__argument_3_01Arg_00_01true_01_4.html">is_function_argument&lt; Arg, true &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1is__function__argument_3_01hydra_1_1thrust_1_1device__reference_3_01Arg_01_4_00_01true_01_4.html">is_function_argument&lt; hydra::thrust::device_reference&lt; Arg &gt;, true &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1is__function__argument__pack.html">is_function_argument_pack</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1is__homogeneous.html">is_homogeneous</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1is__homogeneous__base.html">is_homogeneous_base</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1is__homogeneous__base_3_01A_00_01Tp_00_010_01_4.html">is_homogeneous_base&lt; A, Tp, 0 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1is__hydra__composite__functor.html">is_hydra_composite_functor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1is__hydra__composite__functor_3_01T_00_01hydra_1_1thrust_1_1void__t_3_07a7c504705ac984b9df04007922a16e8.html">is_hydra_composite_functor&lt; T, hydra::thrust::void_t&lt; typename T::hydra_composed_functor_type &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1is__hydra__convertible__to__tuple.html">is_hydra_convertible_to_tuple</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1is__hydra__convertible__to__tuple_3_01T_00_01typename_01tag__type_3_01ta964df32a5ab9b829e612ce2772ce8f5.html">is_hydra_convertible_to_tuple&lt; T, typename tag_type&lt; typename T::hydra_convertible_to_tuple_tag &gt;::type &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1is__hydra__dense__histogram.html">is_hydra_dense_histogram</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1is__hydra__dense__histogram_3_01hydra_1_1DenseHistogram_3_01T_00_01N_00fc4864555721ec45e62403c36aadd8e3.html">is_hydra_dense_histogram&lt; hydra::DenseHistogram&lt; T, N, detail::BackendPolicy&lt; BACKEND &gt;, D &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1is__hydra__estimator.html">is_hydra_estimator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1is__hydra__estimator_3_01T_00_01hydra_1_1thrust_1_1void__t_3_01typenamecb4483ffe765542d4f4939dcfe6ec466.html">is_hydra_estimator&lt; T, hydra::thrust::void_t&lt; typename T::likelihood_estimator_type &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">is_hydra_functor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1is__hydra__functor_3_01Functor_00_01hydra_1_1thrust_1_1void__t_3_01type914d0af41236f52c4aee2eb4ddd78cce.html">is_hydra_functor&lt; Functor, hydra::thrust::void_t&lt; typename Functor::hydra_functor_type, typename Functor::argument_type, typename Functor::return_type &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1is__hydra__integrator.html">is_hydra_integrator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1is__hydra__integrator_3_01T_00_01hydra_1_1thrust_1_1void__t_3_01typenamf69de912045d73badd9e2375be6090e3.html">is_hydra_integrator&lt; T, hydra::thrust::void_t&lt; typename T::hydra_integrator_type &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1is__hydra__lambda.html">is_hydra_lambda</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1is__hydra__lambda_3_01Functor_00_01hydra_1_1thrust_1_1void__t_3_01typenc04c26fff383d848b1216ac910da722a.html">is_hydra_lambda&lt; Functor, hydra::thrust::void_t&lt; typename Functor::hydra_lambda_type, typename Functor::argument_type, typename Functor::return_type &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1is__hydra__pdf.html">is_hydra_pdf</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1is__hydra__pdf_3_01T_00_01hydra_1_1thrust_1_1void__t_3_01typename_01T_1_1hydra__pdf__type_01_4_01_4.html">is_hydra_pdf&lt; T, hydra::thrust::void_t&lt; typename T::hydra_pdf_type &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1is__hydra__sparse__histogram.html">is_hydra_sparse_histogram</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1is__hydra__sparse__histogram_3_01hydra_1_1SparseHistogram_3_01T_00_01N_f0e8aca59eda1633a4e7f9f8573f0524.html">is_hydra_sparse_histogram&lt; hydra::SparseHistogram&lt; T, N, detail::BackendPolicy&lt; BACKEND &gt;, D &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1is__hydra__sum__pdf.html">is_hydra_sum_pdf</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1is__hydra__sum__pdf_3_01T_00_01typename_01tag__type_3_01typename_01T_1_cd81614c45a8283de0a328bd93194fef.html">is_hydra_sum_pdf&lt; T, typename tag_type&lt; typename T::hydra_sum_pdf_tag &gt;::type &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1is__instantiation__of.html">is_instantiation_of</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1is__instantiation__of_3_01Template_00_01Template_3_01Args_8_8_8_01_4_01_4.html">is_instantiation_of&lt; Template, Template&lt; Args... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1is__intuple.html">is_intuple</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1is__intuple_3_01T_00_01hydra_1_1tuple_3_01Head_00_01Tail_8_8_8_01_4_01_4.html">is_intuple&lt; T, hydra::tuple&lt; Head, Tail... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1is__intuple_3_01T_00_01hydra_1_1tuple_3_4_01_4.html">is_intuple&lt; T, hydra::tuple&lt;&gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1is__iterable.html">is_iterable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1is__iterable_3_01T_00_01hydra_1_1thrust_1_1void__t_3_01decltype_07std_18bff5f1d503b579eb5fa9fc9531097f9.html">is_iterable&lt; T, hydra::thrust::void_t&lt; decltype(std::declval&lt; T &gt;().begin()), decltype(std::declval&lt; T &gt;().end()), decltype(++std::declval&lt; decltype(hydra::begin(std::declval&lt; T &gt;()))&amp; &gt;()), decltype(*hydra::begin(std::declval&lt; T &gt;())) &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1is__iterator.html">is_iterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1is__iterator_3_01T_00_01hydra_1_1thrust_1_1void__t_3_01typename_01std_1960e516d34ba640b63ee17922e53dd7c.html">is_iterator&lt; T, hydra::thrust::void_t&lt; typename std::enable_if&lt; std::is_default_constructible&lt; T &gt;::value, void &gt;::type, typename std::enable_if&lt; std::is_copy_constructible&lt; T &gt;::value, void &gt;::type, typename std::enable_if&lt; std::is_destructible&lt; T &gt;::value, void &gt;::type, decltype(std::declval&lt; T &amp; &gt;()[0]), decltype(std::declval&lt; T &amp; &gt;() -std::declval&lt; T &amp; &gt;()), decltype(++std::declval&lt; T &amp; &gt;()), decltype(*std::declval&lt; T &amp; &gt;()), decltype(std::declval&lt; T &amp; &gt;()==std::declval&lt; T &amp; &gt;()), decltype(std::declval&lt; T &amp; &gt;() !=std::declval&lt; T &amp; &gt;())&gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1is__reverse__iterable.html">is_reverse_iterable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1is__reverse__iterable_3_01T_00_01hydra_1_1thrust_1_1void__t_3_01decltyp8612da4bba4251de50f6b68aefa5ac09.html">is_reverse_iterable&lt; T, hydra::thrust::void_t&lt; decltype(std::declval&lt; T &gt;().rbegin()), decltype(std::declval&lt; T &gt;().rend()), decltype(++std::declval&lt; decltype(hydra::rbegin(std::declval&lt; T &gt;()))&amp; &gt;()), decltype(*hydra::rbegin(std::declval&lt; T &gt;())) &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1is__rng__formula.html">is_rng_formula</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1is__rng__formula_3_01hydra_1_1RngFormula_3_01Formula_01_4_01_4.html">is_rng_formula&lt; hydra::RngFormula&lt; Formula &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1is__specialization.html">is_specialization</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1is__specialization_3_01REF_3_01Args_8_8_8_01_4_00_01REF_01_4.html">is_specialization&lt; REF&lt; Args... &gt;, REF &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1is__tuple.html">is_tuple</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1is__tuple_3_01hydra_1_1tuple_3_01T_8_8_8_01_4_01_4.html">is_tuple&lt; hydra::tuple&lt; T... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1is__tuple__of__function__arguments.html">is_tuple_of_function_arguments</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1is__tuple__of__function__arguments_3_01hydra_1_1thrust_1_1detail_1_1tupb8d5df9f37f5c6735a3d0165e8041ed9.html">is_tuple_of_function_arguments&lt; hydra::thrust::detail::tuple_of_iterator_references&lt; ArgTypes &amp;... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1is__tuple__of__function__arguments_3_01hydra_1_1thrust_1_1detail_1_1tup9c3ba752e8de42a534da063330119dc7.html">is_tuple_of_function_arguments&lt; hydra::thrust::detail::tuple_of_iterator_references&lt; hydra::thrust::device_reference&lt; ArgTypes &gt;... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1is__tuple__of__function__arguments_3_01hydra_1_1thrust_1_1tuple_3_01ArgTypes_8_8_8_01_4_01_4.html">is_tuple_of_function_arguments&lt; hydra::thrust::tuple&lt; ArgTypes... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1is__tuple__type.html">is_tuple_type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1is__tuple__type_3_01hydra_1_1thrust_1_1detail_1_1tuple__of__iterator__r7a2f4cfa59d78b39be4f2d7139f8e494.html">is_tuple_type&lt; hydra::thrust::detail::tuple_of_iterator_references&lt; ArgTypes... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1is__tuple__type_3_01hydra_1_1thrust_1_1tuple_3_01ArgTypes_8_8_8_01_4_01_4.html">is_tuple_type&lt; hydra::thrust::tuple&lt; ArgTypes... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1detail_1_1is__valid__type__pack"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1is__valid__type__pack">is_valid_type_pack</a></td></tr>
<tr class="separator:structhydra_1_1detail_1_1is__valid__type__pack"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1is__valid__type__pack_3_01hydra_1_1thrust_1_1tuple_3_01RefT_8_8_8_01_4_00_01T_8_8_8_01_4.html">is_valid_type_pack&lt; hydra::thrust::tuple&lt; RefT... &gt;, T... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1is__zip__iterator.html">is_zip_iterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1is__zip__iterator_3_01hydra_1_1thrust_1_1zip__iterator_3_01T_8_8_8_01_4_01_4.html">is_zip_iterator&lt; hydra::thrust::zip_iterator&lt; T... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1isAccepted.html">isAccepted</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1IteratorTraits.html">IteratorTraits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1lambda__traits.html">lambda_traits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1LogLikelihood1.html">LogLikelihood1</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1LogLikelihood2.html">LogLikelihood2</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1low__bits__mask__t.html">low_bits_mask_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1low__bits__mask__t_3_01std_1_1numeric__limits_3_01unsigned_01char_01_4_1_1digits_01_4.html">low_bits_mask_t&lt; std::numeric_limits&lt; unsigned char &gt;::digits &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1make__index__sequence.html">make_index_sequence</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1make__index__sequence_3_010_01_4.html">make_index_sequence&lt; 0 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1make__index__sequence_3_011_01_4.html">make_index_sequence&lt; 1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1detail_1_1merged__tuple"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1merged__tuple">merged_tuple</a></td></tr>
<tr class="separator:structhydra_1_1detail_1_1merged__tuple"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1detail_1_1merged__tuple_3_01hydra_1_1tuple_3_01T_8_8_8_01_4_01_4"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1merged__tuple_3_01hydra_1_1tuple_3_01T_8_8_8_01_4_01_4">merged_tuple&lt; hydra::tuple&lt; T... &gt; &gt;</a></td></tr>
<tr class="separator:structhydra_1_1detail_1_1merged__tuple_3_01hydra_1_1tuple_3_01T_8_8_8_01_4_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1merged__tuple_3_01hydra_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1tuple_3_01U_8_8_8_01_4_01_4.html">merged_tuple&lt; hydra::tuple&lt; T... &gt;, hydra::tuple&lt; U... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1merged__tuple_3_01hydra_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1tuple_3a2087d7aa1d7d8255c2c776843f52d86.html">merged_tuple&lt; hydra::tuple&lt; T... &gt;, hydra::tuple&lt; U... &gt;, Z... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1detail_1_1merged__zip__iterator"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1merged__zip__iterator">merged_zip_iterator</a></td></tr>
<tr class="separator:structhydra_1_1detail_1_1merged__zip__iterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1detail_1_1merged__zip__iterator_3_01hydra_1_1thrust_1_1zip__iterator_3_01T_8_8_8_01_4_01_4"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1merged__zip__iterator_3_01hydra_1_1thrust_1_1zip__iterator_3_01T_8_8_8_01_4_01_4">merged_zip_iterator&lt; hydra::thrust::zip_iterator&lt; T... &gt; &gt;</a></td></tr>
<tr class="separator:structhydra_1_1detail_1_1merged__zip__iterator_3_01hydra_1_1thrust_1_1zip__iterator_3_01T_8_8_8_01_4_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1merged__zip__iterator_3_01hydra_1_1thrust_1_1zip__iterator_3_01T_8_8_8_af9cd510b733c41ec440a164543802c4.html">merged_zip_iterator&lt; hydra::thrust::zip_iterator&lt; T... &gt;, hydra::thrust::zip_iterator&lt; U... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1merged__zip__iterator_3_01hydra_1_1thrust_1_1zip__iterator_3_01T_8_8_8_4a33d48df6e8a588b91d1374d96582ca.html">merged_zip_iterator&lt; hydra::thrust::zip_iterator&lt; T... &gt;, hydra::thrust::zip_iterator&lt; U... &gt;, Z... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1detail_1_1minus__result"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1minus__result">minus_result</a></td></tr>
<tr class="separator:structhydra_1_1detail_1_1minus__result"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1detail_1_1multidimensional"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1multidimensional">multidimensional</a></td></tr>
<tr class="separator:structhydra_1_1detail_1_1multidimensional"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1detail_1_1multiply__result"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1multiply__result">multiply_result</a></td></tr>
<tr class="separator:structhydra_1_1detail_1_1multiply__result"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1nearest__int.html">nearest_int</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Round to nearest integer at compile time.  <a href="structhydra_1_1detail_1_1nearest__int.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1detail_1_1ObjSelector"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1ObjSelector">ObjSelector</a></td></tr>
<tr class="separator:structhydra_1_1detail_1_1ObjSelector"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1ObjSelector_3_01false_01_4.html">ObjSelector&lt; false &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1ObjSelector_3_01true_01_4.html">ObjSelector&lt; true &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1detail_1_1Parameters.html">Parameters</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1detail_1_1Parameters_3_010_01_4.html">Parameters&lt; 0 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">specialization for no-parametrized functor  <a href="classhydra_1_1detail_1_1Parameters_3_010_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1detail_1_1ParametersCompositeFunctor.html">ParametersCompositeFunctor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1power.html">power</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1power_3_01B_00_010_01_4.html">power&lt; B, 0 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1ProcessBoxesVegas.html">ProcessBoxesVegas</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1ProcessCallsPlainBinary.html">ProcessCallsPlainBinary</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1ProcessCallsPlainUnary.html">ProcessCallsPlainUnary</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1ProcessCallsVegas.html">ProcessCallsVegas</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1ProcessCallsVegas_3_01FUNCTOR_00_01NDimensions_00_01hydra_1_1detail_1_1d02dd45e61a2dbf17b7be7b9bd27e346.html">ProcessCallsVegas&lt; FUNCTOR, NDimensions, hydra::detail::BackendPolicy&lt; BACKEND &gt;, IteratorBackendReal, IteratorBackendUInt, GRND &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1ProcessGenzMalikBinaryCall.html">ProcessGenzMalikBinaryCall</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1ProcessGenzMalikBox.html">ProcessGenzMalikBox</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1ProcessGenzMalikUnaryCall.html">ProcessGenzMalikUnaryCall</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1detail_1_1quasi__random__base.html">quasi_random_base</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1detail_1_1random__traits"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1random__traits">random_traits</a></td></tr>
<tr class="separator:structhydra_1_1detail_1_1random__traits"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1random__traits_3_01hydra__r123_1_1Philox2x64_01_4.html">random_traits&lt; hydra_r123::Philox2x64 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1random__traits_3_01hydra__r123_1_1Philox4x64_01_4.html">random_traits&lt; hydra_r123::Philox4x64 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1random__traits_3_01hydra__r123_1_1Threefry2x64_01_4.html">random_traits&lt; hydra_r123::Threefry2x64 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1random__traits_3_01hydra__r123_1_1Threefry4x64_01_4.html">random_traits&lt; hydra_r123::Threefry4x64 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1detail_1_1references__tuple__type"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1references__tuple__type">references_tuple_type</a></td></tr>
<tr class="separator:structhydra_1_1detail_1_1references__tuple__type"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1detail_1_1remove__device__reference"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1remove__device__reference">remove_device_reference</a></td></tr>
<tr class="separator:structhydra_1_1detail_1_1remove__device__reference"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1detail_1_1remove__device__reference_3_01hydra_1_1thrust_1_1device__reference_3_01T_01_4_01_4"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1remove__device__reference_3_01hydra_1_1thrust_1_1device__reference_3_01T_01_4_01_4">remove_device_reference&lt; hydra::thrust::device_reference&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:structhydra_1_1detail_1_1remove__device__reference_3_01hydra_1_1thrust_1_1device__reference_3_01T_01_4_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1detail_1_1remove__device__reference_3_01T_01_6_01_4"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1remove__device__reference_3_01T_01_6_01_4">remove_device_reference&lt; T &amp; &gt;</a></td></tr>
<tr class="separator:structhydra_1_1detail_1_1remove__device__reference_3_01T_01_6_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1detail_1_1repeat"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1repeat">repeat</a></td></tr>
<tr class="separator:structhydra_1_1detail_1_1repeat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1detail_1_1repeat_3_01T_00_010_00_01TT_01_4"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1repeat_3_01T_00_010_00_01TT_01_4">repeat&lt; T, 0, TT &gt;</a></td></tr>
<tr class="separator:structhydra_1_1detail_1_1repeat_3_01T_00_010_00_01TT_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1detail_1_1ResultPHSP"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1ResultPHSP">ResultPHSP</a></td></tr>
<tr class="separator:structhydra_1_1detail_1_1ResultPHSP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1detail_1_1ResultVegas"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1ResultVegas">ResultVegas</a></td></tr>
<tr class="separator:structhydra_1_1detail_1_1ResultVegas"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1RndBreitWigner.html">RndBreitWigner</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1RndCDF.html">RndCDF</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1RndExp.html">RndExp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1RndFlag.html">RndFlag</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1RndGauss.html">RndGauss</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1RndTrial.html">RndTrial</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1RndTrial_3_01T_00_01GRND_00_01FUNCTOR_00_011_01_4.html">RndTrial&lt; T, GRND, FUNCTOR, 1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1RndUniform.html">RndUniform</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1Sampler.html">Sampler</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1detail_1_1selected__tuple"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1selected__tuple">selected_tuple</a></td></tr>
<tr class="separator:structhydra_1_1detail_1_1selected__tuple"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1detail_1_1selected__tuple_3_01Selector_00_01hydra_1_1tuple_3_01Head_00_01Tail_8_8_8_01_4_01_4"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1selected__tuple_3_01Selector_00_01hydra_1_1tuple_3_01Head_00_01Tail_8_8_8_01_4_01_4">selected_tuple&lt; Selector, hydra::tuple&lt; Head, Tail... &gt; &gt;</a></td></tr>
<tr class="separator:structhydra_1_1detail_1_1selected__tuple_3_01Selector_00_01hydra_1_1tuple_3_01Head_00_01Tail_8_8_8_01_4_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1detail_1_1selected__tuple_3_01Selector_00_01hydra_1_1tuple_3_01Type_01_4_01_4"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1selected__tuple_3_01Selector_00_01hydra_1_1tuple_3_01Type_01_4_01_4">selected_tuple&lt; Selector, hydra::tuple&lt; Type &gt; &gt;</a></td></tr>
<tr class="separator:structhydra_1_1detail_1_1selected__tuple_3_01Selector_00_01hydra_1_1tuple_3_01Type_01_4_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1detail_1_1signature__traits"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1signature__traits">signature_traits</a></td></tr>
<tr class="separator:structhydra_1_1detail_1_1signature__traits"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1signature__traits_3_01hydra_1_1thrust_1_1tuple_3_01R_00_01Args_8_8_8_01_4_01_4.html">signature_traits&lt; hydra::thrust::tuple&lt; R, Args... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1signature__traits_3_01R_07Args_8_8_8_08_4.html">signature_traits&lt; R(Args...)&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1detail_1_1signature__type"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1signature__type">signature_type</a></td></tr>
<tr class="separator:structhydra_1_1detail_1_1signature__type"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1detail_1_1signature__type__impl"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1signature__type__impl">signature_type_impl</a></td></tr>
<tr class="separator:structhydra_1_1detail_1_1signature__type__impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1sobol__lattice.html">sobol_lattice</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1SobolTable.html">SobolTable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1StatsPHSP.html">StatsPHSP</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1detail_1_1stripped__tuple"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1stripped__tuple">stripped_tuple</a></td></tr>
<tr class="separator:structhydra_1_1detail_1_1stripped__tuple"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1stripped__tuple_3_01hydra_1_1tuple_3_01T_8_8_8_01_4_01_4.html">stripped_tuple&lt; hydra::tuple&lt; T... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1detail_1_1stripped__type"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1stripped__type">stripped_type</a></td></tr>
<tr class="separator:structhydra_1_1detail_1_1stripped__type"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1detail_1_1stripped__type_3_01Arg_00_01false_01_4"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1stripped__type_3_01Arg_00_01false_01_4">stripped_type&lt; Arg, false &gt;</a></td></tr>
<tr class="separator:structhydra_1_1detail_1_1stripped__type_3_01Arg_00_01false_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1detail_1_1stripped__type_3_01Arg_00_01true_01_4"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1stripped__type_3_01Arg_00_01true_01_4">stripped_type&lt; Arg, true &gt;</a></td></tr>
<tr class="separator:structhydra_1_1detail_1_1stripped__type_3_01Arg_00_01true_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1detail_1_1sum__result"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1sum__result">sum_result</a></td></tr>
<tr class="separator:structhydra_1_1detail_1_1sum__result"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1SWeights.html">SWeights</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1detail_1_1tag__type"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1tag__type">tag_type</a></td></tr>
<tr class="separator:structhydra_1_1detail_1_1tag__type"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1detail_1_1trimmed__lambda__signature"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1trimmed__lambda__signature">trimmed_lambda_signature</a></td></tr>
<tr class="separator:structhydra_1_1detail_1_1trimmed__lambda__signature"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1detail_1_1trimmed__lambda__signature_3_01hydra_1_1thrust_1_1tuple_3_01Head_00_01Neck_00_01Tail_8_8_8_01_4_01_4"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1trimmed__lambda__signature_3_01hydra_1_1thrust_1_1tuple_3_01Head_00_01Neck_00_01Tail_8_8_8_01_4_01_4">trimmed_lambda_signature&lt; hydra::thrust::tuple&lt; Head, Neck, Tail... &gt; &gt;</a></td></tr>
<tr class="separator:structhydra_1_1detail_1_1trimmed__lambda__signature_3_01hydra_1_1thrust_1_1tuple_3_01Head_00_01Neck_00_01Tail_8_8_8_01_4_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1detail_1_1tuple__cat__type"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1tuple__cat__type">tuple_cat_type</a></td></tr>
<tr class="separator:structhydra_1_1detail_1_1tuple__cat__type"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1detail_1_1tuple__cat__type_3_01hydra_1_1thrust_1_1detail_1_1tuple__of__iterator__e875b1e0f0d98602461f9d0c3462aad3"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1tuple__cat__type_3_01hydra_1_1thrust_1_1detail_1_1tuple__of__iterator__e875b1e0f0d98602461f9d0c3462aad3">tuple_cat_type&lt; hydra::thrust::detail::tuple_of_iterator_references&lt; T1... &gt;, hydra::thrust::detail::tuple_of_iterator_references&lt; T2... &gt; &gt;</a></td></tr>
<tr class="separator:structhydra_1_1detail_1_1tuple__cat__type_3_01hydra_1_1thrust_1_1detail_1_1tuple__of__iterator__e875b1e0f0d98602461f9d0c3462aad3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1detail_1_1tuple__cat__type_3_01hydra_1_1thrust_1_1tuple_3_01T1_8_8_8_01_4_00_01hy02a3f5f695c9d282a0a9beeb429a18a4"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1tuple__cat__type_3_01hydra_1_1thrust_1_1tuple_3_01T1_8_8_8_01_4_00_01hy02a3f5f695c9d282a0a9beeb429a18a4">tuple_cat_type&lt; hydra::thrust::tuple&lt; T1... &gt;, hydra::thrust::tuple&lt; T2... &gt; &gt;</a></td></tr>
<tr class="separator:structhydra_1_1detail_1_1tuple__cat__type_3_01hydra_1_1thrust_1_1tuple_3_01T1_8_8_8_01_4_00_01hy02a3f5f695c9d282a0a9beeb429a18a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1detail_1_1tuple__type"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1tuple__type">tuple_type</a></td></tr>
<tr class="separator:structhydra_1_1detail_1_1tuple__type"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1TypeTraits.html">TypeTraits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1TypeTraits_3_01hydra_1_1thrust_1_1complex_3_01T_01_4_01_4.html">TypeTraits&lt; hydra::thrust::complex&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1uint__t.html">uint_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1detail_1_1unidimensional"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1unidimensional">unidimensional</a></td></tr>
<tr class="separator:structhydra_1_1detail_1_1unidimensional"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a3c72e1aed3a4538dac06a7e816543c23"><td class="memTemplParams" colspan="2">template&lt;class R , class... Ts&gt; </td></tr>
<tr class="memitem:a3c72e1aed3a4538dac06a7e816543c23"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a3c72e1aed3a4538dac06a7e816543c23">are_all_same</a> = <a class="el" href="structhydra_1_1detail_1_1all__true.html">all_true</a>&lt; std::is_same&lt; Ts, R &gt;::value... &gt;</td></tr>
<tr class="separator:a3c72e1aed3a4538dac06a7e816543c23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee93c31c37a22c22c49c73483cfd0f91"><td class="memTemplParams" colspan="2">template&lt;class... T&gt; </td></tr>
<tr class="memitem:aee93c31c37a22c22c49c73483cfd0f91"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#aee93c31c37a22c22c49c73483cfd0f91">common_type_t</a> = typename std::common_type&lt; T... &gt;::type</td></tr>
<tr class="separator:aee93c31c37a22c22c49c73483cfd0f91"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a759ad336f50b88396a0bef211afe698e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="namespacehydra_1_1detail.html#a759ad336f50b88396a0bef211afe698eaea9c72bdee6f384d88af4eab49530ea8">kInvalidNumber</a> = -111
 }</td></tr>
<tr class="separator:a759ad336f50b88396a0bef211afe698e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1461b18b118ced9f91233acbe90fd897"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a1461b18b118ced9f91233acbe90fd897">Backend</a> { <br />
&#160;&#160;<a class="el" href="namespacehydra_1_1detail.html#a1461b18b118ced9f91233acbe90fd897a394a4eccb0e1634ec1294f902f5439e2">Host</a>, 
<a class="el" href="namespacehydra_1_1detail.html#a1461b18b118ced9f91233acbe90fd897ad7a51d196c98a1057d741a6ebd3d84db">Device</a>, 
<a class="el" href="namespacehydra_1_1detail.html#a1461b18b118ced9f91233acbe90fd897a0fb8e6fb3bd5e20cae92bc309106fae4">Cpp</a>, 
<a class="el" href="namespacehydra_1_1detail.html#a1461b18b118ced9f91233acbe90fd897a1b83f5e80dc60afdb33987f3d9ce20bf">Omp</a>, 
<br />
&#160;&#160;<a class="el" href="namespacehydra_1_1detail.html#a1461b18b118ced9f91233acbe90fd897a0346e63703cdc5752878c4e0623ace64">Tbb</a>, 
<a class="el" href="namespacehydra_1_1detail.html#a1461b18b118ced9f91233acbe90fd897a3ef47f45ff0de8694163bcfe498e4a89">Cuda</a>
<br />
 }</td></tr>
<tr class="separator:a1461b18b118ced9f91233acbe90fd897"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa817d51dec8ff2c9ad9eeaf1f91bc6e4"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#aa817d51dec8ff2c9ad9eeaf1f91bc6e4">FFTCalculator</a> { <a class="el" href="namespacehydra_1_1detail.html#aa817d51dec8ff2c9ad9eeaf1f91bc6e4a2dcac3babe9917463a1823b4fc97d989">CuFFT</a>, 
<a class="el" href="namespacehydra_1_1detail.html#aa817d51dec8ff2c9ad9eeaf1f91bc6e4ac7647480fd178ef276ec77e4830704b3">FFTW</a>
 }</td></tr>
<tr class="separator:aa817d51dec8ff2c9ad9eeaf1f91bc6e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a52a71a770e750c0031cdad447a7d31fd"><td class="memTemplParams" colspan="2">template&lt;typename R , typename T , size_t I&gt; </td></tr>
<tr class="memitem:a52a71a770e750c0031cdad447a7d31fd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::detail::enable_if&lt;(I==hydra::thrust::tuple_size&lt; T &gt;::value), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a52a71a770e750c0031cdad447a7d31fd">_get_element</a> (const size_t, T &amp;, R *&amp;)</td></tr>
<tr class="separator:a52a71a770e750c0031cdad447a7d31fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a515bd52a87e3b90c746742adae859ab7"><td class="memTemplParams" colspan="2">template&lt;typename R , typename T , size_t I = 0&gt; </td></tr>
<tr class="memitem:a515bd52a87e3b90c746742adae859ab7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::detail::enable_if&lt;(I&lt; hydra::thrust::tuple_size&lt; T &gt;::value), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a515bd52a87e3b90c746742adae859ab7">_get_element</a> (const size_t index, T &amp;t, R *&amp;ptr)</td></tr>
<tr class="separator:a515bd52a87e3b90c746742adae859ab7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31bfd6894ad39b66da15df4dc436d35e"><td class="memTemplParams" colspan="2">template&lt;typename Return_Type , typename ArgType , typename ... Tp, typename  = typename hydra::thrust::detail::enable_if&lt;std::is_convertible&lt;Return_Type, double&gt;::value || std::is_constructible&lt;hydra::thrust::complex&lt;double&gt;,Return_Type&gt;::value &gt;::type&gt; </td></tr>
<tr class="memitem:a31bfd6894ad39b66da15df4dc436d35e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> Return_Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a31bfd6894ad39b66da15df4dc436d35e">accumulate</a> (ArgType &amp;x, hydra::thrust::tuple&lt; Tp... &gt; &amp;t)</td></tr>
<tr class="separator:a31bfd6894ad39b66da15df4dc436d35e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06d87d0383479101350ee8934d7fcdf2"><td class="memTemplParams" colspan="2">template&lt;typename Return_Type , typename ArgType , typename ... Tp, typename  = typename hydra::thrust::detail::enable_if&lt;std::is_convertible&lt;Return_Type, double&gt;::value || std::is_constructible&lt;hydra::thrust::complex&lt;double&gt;,Return_Type&gt;::value &gt;::type&gt; </td></tr>
<tr class="memitem:a06d87d0383479101350ee8934d7fcdf2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> Return_Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a06d87d0383479101350ee8934d7fcdf2">accumulate</a> (ArgType const &amp;x, hydra::thrust::tuple&lt; Tp... &gt; const &amp;t)</td></tr>
<tr class="separator:a06d87d0383479101350ee8934d7fcdf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b42783cc9a200f4083295d1e2cfd374"><td class="memTemplParams" colspan="2">template&lt;typename Return_Type , typename ArgType1 , typename ArgType2 , typename ... Tp, typename  = typename hydra::thrust::detail::enable_if&lt;std::is_convertible&lt;Return_Type, double&gt;::value || std::is_constructible&lt;hydra::thrust::complex&lt;double&gt;,Return_Type&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a9b42783cc9a200f4083295d1e2cfd374"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> Return_Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a9b42783cc9a200f4083295d1e2cfd374">accumulate2</a> (ArgType1 &amp;x, ArgType2 &amp;y, hydra::thrust::tuple&lt; Tp... &gt; &amp;t)</td></tr>
<tr class="separator:a9b42783cc9a200f4083295d1e2cfd374"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a966cab74d28014bd9c6c90524a933f53"><td class="memTemplParams" colspan="2">template&lt;typename Return_Type , typename ArgType1 , typename ArgType2 , typename ... Tp, typename  = typename hydra::thrust::detail::enable_if&lt;std::is_convertible&lt;Return_Type, double&gt;::value || std::is_constructible&lt;hydra::thrust::complex&lt;double&gt;,Return_Type&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a966cab74d28014bd9c6c90524a933f53"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> Return_Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a966cab74d28014bd9c6c90524a933f53">accumulate2</a> (ArgType1 const &amp;x, ArgType2 const &amp;y, hydra::thrust::tuple&lt; Tp... &gt; const &amp;t)</td></tr>
<tr class="separator:a966cab74d28014bd9c6c90524a933f53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5e05e95babbc9b3610158ca245e9ea9"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename ... Tp&gt; </td></tr>
<tr class="memitem:ad5e05e95babbc9b3610158ca245e9ea9"><td class="memTemplItemLeft" align="right" valign="top">hydra::thrust::detail::enable_if&lt; I==sizeof...(Tp), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#ad5e05e95babbc9b3610158ca245e9ea9">add_parameters_in_tuple</a> (std::vector&lt; <a class="el" href="group__fit.html#structhydra_1_1Parameter">hydra::Parameter</a> *&gt; &amp;, hydra::thrust::tuple&lt; Tp... &gt; &amp;)</td></tr>
<tr class="separator:ad5e05e95babbc9b3610158ca245e9ea9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ec0b20f1c76a09e6f8c20bff1b1606f"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename ... Tp&gt; </td></tr>
<tr class="memitem:a7ec0b20f1c76a09e6f8c20bff1b1606f"><td class="memTemplItemLeft" align="right" valign="top">hydra::thrust::detail::enable_if&lt;(I&lt; sizeof...(Tp)), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a7ec0b20f1c76a09e6f8c20bff1b1606f">add_parameters_in_tuple</a> (std::vector&lt; <a class="el" href="group__fit.html#structhydra_1_1Parameter">hydra::Parameter</a> *&gt; &amp;user_parameters, hydra::thrust::tuple&lt; Tp... &gt; &amp;t)</td></tr>
<tr class="separator:a7ec0b20f1c76a09e6f8c20bff1b1606f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47ca3e1e60cf87925082ffecc2ffc189"><td class="memTemplParams" colspan="2">template&lt;size_t I, typename ... T&gt; </td></tr>
<tr class="memitem:a47ca3e1e60cf87925082ffecc2ffc189"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::detail::enable_if&lt;(I==sizeof...(T)), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a47ca3e1e60cf87925082ffecc2ffc189">add_tuple_values</a> (<a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> &amp;, hydra::thrust::tuple&lt; T... &gt; const &amp;)</td></tr>
<tr class="separator:a47ca3e1e60cf87925082ffecc2ffc189"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af386c271b963d41d9cfc54fe76a0d581"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename ... T&gt; </td></tr>
<tr class="memitem:af386c271b963d41d9cfc54fe76a0d581"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::detail::enable_if&lt;(I&lt; sizeof...(T)), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#af386c271b963d41d9cfc54fe76a0d581">add_tuple_values</a> (<a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> &amp;result, hydra::thrust::tuple&lt; T... &gt; const &amp;tpl)</td></tr>
<tr class="separator:af386c271b963d41d9cfc54fe76a0d581"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac651383169b82d9cf2a231475addf465"><td class="memTemplParams" colspan="2">template&lt;typename ... T, size_t ... I&gt; </td></tr>
<tr class="memitem:ac651383169b82d9cf2a231475addf465"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::tuple&lt; T... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#ac651383169b82d9cf2a231475addf465">addTuples</a> (const hydra::thrust::tuple&lt; T... &gt; &amp;a, const hydra::thrust::tuple&lt; T... &gt; &amp;b, <a class="el" href="structhydra_1_1detail_1_1index__sequence.html">index_sequence</a>&lt; I... &gt;)</td></tr>
<tr class="separator:ac651383169b82d9cf2a231475addf465"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cfd0003bddb737423532a8fc9246fcb"><td class="memTemplParams" colspan="2">template&lt;typename ... T&gt; </td></tr>
<tr class="memitem:a6cfd0003bddb737423532a8fc9246fcb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::tuple&lt; T... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a6cfd0003bddb737423532a8fc9246fcb">addTuples</a> (const hydra::thrust::tuple&lt; T... &gt; &amp;a, const hydra::thrust::tuple&lt; T... &gt; &amp;b)</td></tr>
<tr class="separator:a6cfd0003bddb737423532a8fc9246fcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ab373fce03602fa7e4ab99b8ec00232"><td class="memTemplParams" colspan="2">template&lt;size_t I, typename ... T&gt; </td></tr>
<tr class="memitem:a1ab373fce03602fa7e4ab99b8ec00232"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::tuple_element&lt; I, hydra::thrust::tuple&lt; T... &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a1ab373fce03602fa7e4ab99b8ec00232">addTuplesHelper</a> (const hydra::thrust::tuple&lt; T... &gt; &amp;a, const hydra::thrust::tuple&lt; T... &gt; &amp;b)</td></tr>
<tr class="separator:a1ab373fce03602fa7e4ab99b8ec00232"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3be119e15f0b9be4173ba8268a66b71"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa3be119e15f0b9be4173ba8268a66b71"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#aa3be119e15f0b9be4173ba8268a66b71">ApproximatelyEqual</a> (T a, T b, T tolerance=<a class="el" href="namespacehydra_1_1detail.html#af60fc3e60cc10bd79092ca02c8e8b84c">machine_eps_f64</a>())</td></tr>
<tr class="separator:aa3be119e15f0b9be4173ba8268a66b71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc4a7a3b4f3c2827fd0eaff57e0b300c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:acc4a7a3b4f3c2827fd0eaff57e0b300c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#acc4a7a3b4f3c2827fd0eaff57e0b300c">ApproximatelyZero</a> (T a, T tolerance=<a class="el" href="namespacehydra_1_1detail.html#af60fc3e60cc10bd79092ca02c8e8b84c">machine_eps_f64</a>())</td></tr>
<tr class="separator:acc4a7a3b4f3c2827fd0eaff57e0b300c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fb09f08e05c59f9cb8f7810677b0a35"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N&gt; </td></tr>
<tr class="memitem:a2fb09f08e05c59f9cb8f7810677b0a35"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a2fb09f08e05c59f9cb8f7810677b0a35">arrayToTuple</a> (std::array&lt; T, N &gt;const &amp;Array) -&gt; decltype(<a class="el" href="namespacehydra_1_1detail.html#aad94bd46c688eb458dde424609df5dae">arrayToTupleHelper</a>(Array, <a class="el" href="structhydra_1_1detail_1_1make__index__sequence.html">make_index_sequence</a>&lt; N &gt;</td></tr>
<tr class="separator:a2fb09f08e05c59f9cb8f7810677b0a35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d0da29f0be34c5fe0f79e47b6963340"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N&gt; </td></tr>
<tr class="memitem:a9d0da29f0be34c5fe0f79e47b6963340"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a9d0da29f0be34c5fe0f79e47b6963340">arrayToTuple</a> (T *Array) -&gt; decltype(<a class="el" href="namespacehydra_1_1detail.html#aad94bd46c688eb458dde424609df5dae">arrayToTupleHelper</a>(Array, <a class="el" href="structhydra_1_1detail_1_1make__index__sequence.html">make_index_sequence</a>&lt; N &gt;</td></tr>
<tr class="separator:a9d0da29f0be34c5fe0f79e47b6963340"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad94bd46c688eb458dde424609df5dae"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t... Is&gt; </td></tr>
<tr class="memitem:aad94bd46c688eb458dde424609df5dae"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#aad94bd46c688eb458dde424609df5dae">arrayToTupleHelper</a> (std::array&lt; T, sizeof...(Is)&gt;const &amp;Array, <a class="el" href="structhydra_1_1detail_1_1index__sequence.html">index_sequence</a>&lt; Is... &gt;) -&gt; decltype(hydra::thrust::make_tuple(Array[Is]...))</td></tr>
<tr class="separator:aad94bd46c688eb458dde424609df5dae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6551302bfdad575a3f6a01b57d14f0d"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t... Indices&gt; </td></tr>
<tr class="memitem:ab6551302bfdad575a3f6a01b57d14f0d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#ab6551302bfdad575a3f6a01b57d14f0d">arrayToTupleHelper</a> (T *Array, <a class="el" href="structhydra_1_1detail_1_1index__sequence.html">index_sequence</a>&lt; Indices... &gt;) -&gt; decltype(hydra::thrust::make_tuple(Array[Indices]...))</td></tr>
<tr class="separator:ab6551302bfdad575a3f6a01b57d14f0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81d062e40531f7b09a8926d642ba2032"><td class="memTemplParams" colspan="2">template&lt;size_t I, typename ArrayType , typename FistType , typename ... OtherTypes&gt; </td></tr>
<tr class="memitem:a81d062e40531f7b09a8926d642ba2032"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::detail::enable_if&lt; I==(sizeof...(OtherTypes)+1) &amp;&amp;std::is_convertible&lt; FistType, ArrayType &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1all__true.html">all_true</a>&lt; std::is_convertible&lt; OtherTypes, ArrayType &gt;::value... &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a81d062e40531f7b09a8926d642ba2032">assignArrayToTuple</a> (hydra::thrust::tuple&lt; FistType, OtherTypes... &gt; &amp;, ArrayType const *)</td></tr>
<tr class="separator:a81d062e40531f7b09a8926d642ba2032"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a688c325b220c8fa30f5790d636183eca"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename ArrayType , typename FistType , typename ... OtherTypes&gt; </td></tr>
<tr class="memitem:a688c325b220c8fa30f5790d636183eca"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::detail::enable_if&lt;(I&lt; sizeof...(OtherTypes)+1) &amp;&amp;std::is_convertible&lt; FistType, ArrayType &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1all__true.html">all_true</a>&lt; std::is_convertible&lt; OtherTypes, ArrayType &gt;::value... &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a688c325b220c8fa30f5790d636183eca">assignArrayToTuple</a> (hydra::thrust::tuple&lt; FistType, OtherTypes... &gt; &amp;t, ArrayType const *Array)</td></tr>
<tr class="separator:a688c325b220c8fa30f5790d636183eca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a240c9e228115543008d63b6e21f300ea"><td class="memTemplParams" colspan="2">template&lt;size_t I, typename ArrayType , typename FistType , typename ... OtherTypes&gt; </td></tr>
<tr class="memitem:a240c9e228115543008d63b6e21f300ea"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::detail::enable_if&lt; I==(sizeof...(OtherTypes)+1) &amp;&amp;std::is_convertible&lt; FistType, ArrayType &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1all__true.html">all_true</a>&lt; std::is_convertible&lt; OtherTypes, ArrayType &gt;::value... &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a240c9e228115543008d63b6e21f300ea">assignArrayToTuple</a> (hydra::thrust::detail::tuple_of_iterator_references&lt; FistType, OtherTypes... &gt; &amp;, ArrayType const *)</td></tr>
<tr class="separator:a240c9e228115543008d63b6e21f300ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed9ce2a67e87b89e2bacaeac434fc5a8"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename ArrayType , typename FistType , typename ... OtherTypes&gt; </td></tr>
<tr class="memitem:aed9ce2a67e87b89e2bacaeac434fc5a8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::detail::enable_if&lt;(I&lt; sizeof...(OtherTypes)+1) &amp;&amp;std::is_convertible&lt; FistType, ArrayType &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1all__true.html">all_true</a>&lt; std::is_convertible&lt; OtherTypes, ArrayType &gt;::value... &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#aed9ce2a67e87b89e2bacaeac434fc5a8">assignArrayToTuple</a> (hydra::thrust::detail::tuple_of_iterator_references&lt; FistType, OtherTypes... &gt; &amp;t, ArrayType const *Array)</td></tr>
<tr class="separator:aed9ce2a67e87b89e2bacaeac434fc5a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d6f9257e6380f1890e0b7adc0190747"><td class="memTemplParams" colspan="2">template&lt;size_t I, typename Type , typename Head , typename ... Tail&gt; </td></tr>
<tr class="memitem:a3d6f9257e6380f1890e0b7adc0190747"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> std::enable_if&lt;(I==sizeof...(Tail)+1) &amp;&amp;std::is_convertible&lt; Head, Type &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1all__true.html">all_true</a>&lt; std::is_convertible&lt; Tail, Type &gt;::value ... &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a3d6f9257e6380f1890e0b7adc0190747">assignTupleToArray</a> (hydra::thrust::tuple&lt; Head, Tail... &gt; const &amp;, Type(&amp;)[sizeof...(Tail)+1])</td></tr>
<tr class="separator:a3d6f9257e6380f1890e0b7adc0190747"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3b86512e9cd5ea9ed988e099f5c54b4"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename Type , typename Head , typename ... Tail&gt; </td></tr>
<tr class="memitem:ac3b86512e9cd5ea9ed988e099f5c54b4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> std::enable_if&lt;(I&lt; sizeof...(Tail)+1) &amp;&amp;std::is_convertible&lt; Head, Type &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1all__true.html">all_true</a>&lt; std::is_convertible&lt; Tail, Type &gt;::value ... &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#ac3b86512e9cd5ea9ed988e099f5c54b4">assignTupleToArray</a> (hydra::thrust::tuple&lt; Head, Tail... &gt; const &amp;Tuple, Type(&amp;Array)[sizeof...(Tail)+1])</td></tr>
<tr class="separator:ac3b86512e9cd5ea9ed988e099f5c54b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a713732dd6592045a450b169e34ef956c"><td class="memTemplParams" colspan="2">template&lt;size_t I, typename Type , typename Head , typename ... Tail&gt; </td></tr>
<tr class="memitem:a713732dd6592045a450b169e34ef956c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> std::enable_if&lt;(I==sizeof...(Tail)+1) &amp;&amp;std::is_convertible&lt; Head, Type &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1all__true.html">all_true</a>&lt; std::is_convertible&lt; Tail, Type &gt;::value ... &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a713732dd6592045a450b169e34ef956c">assignTupleToArray</a> (hydra::thrust::tuple&lt; Head, Tail... &gt; const &amp;, std::array&lt; Type, sizeof...(Tail)+1 &gt; &amp;)</td></tr>
<tr class="separator:a713732dd6592045a450b169e34ef956c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31af39400225fa9e9ff79a3b802e73d0"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename Type , typename Head , typename ... Tail&gt; </td></tr>
<tr class="memitem:a31af39400225fa9e9ff79a3b802e73d0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> std::enable_if&lt;(I&lt; sizeof...(Tail)+1) &amp;&amp;std::is_convertible&lt; Head, Type &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1all__true.html">all_true</a>&lt; std::is_convertible&lt; Tail, Type &gt;::value ... &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a31af39400225fa9e9ff79a3b802e73d0">assignTupleToArray</a> (hydra::thrust::tuple&lt; Head, Tail... &gt; const &amp;Tuple, std::array&lt; Type, sizeof...(Tail)+1 &gt; &amp;Array)</td></tr>
<tr class="separator:a31af39400225fa9e9ff79a3b802e73d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a857673d7a6d3e5e5da3891670a276c6e"><td class="memTemplParams" colspan="2">template&lt;size_t I, typename Type , typename Head , typename ... Tail&gt; </td></tr>
<tr class="memitem:a857673d7a6d3e5e5da3891670a276c6e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> std::enable_if&lt;(I==sizeof...(Tail)+1) &amp;&amp;std::is_convertible&lt; typename <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1remove__device__reference">remove_device_reference</a>&lt; Head &gt;::type, Type &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1all__true.html">all_true</a>&lt; std::is_convertible&lt; typename <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1remove__device__reference">remove_device_reference</a>&lt; Tail &gt;::type, Type &gt;::value ... &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a857673d7a6d3e5e5da3891670a276c6e">assignTupleToArray</a> (hydra::thrust::detail::tuple_of_iterator_references&lt; Head, Tail... &gt; const &amp;, Type(&amp;)[sizeof...(Tail)+1])</td></tr>
<tr class="separator:a857673d7a6d3e5e5da3891670a276c6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23efaec2eb9afcba167ec112900bd809"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename Type , typename Head , typename ... Tail&gt; </td></tr>
<tr class="memitem:a23efaec2eb9afcba167ec112900bd809"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> std::enable_if&lt;(I&lt; sizeof...(Tail)+1) &amp;&amp;std::is_convertible&lt; typename <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1remove__device__reference">remove_device_reference</a>&lt; Head &gt;::type, Type &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1all__true.html">all_true</a>&lt; std::is_convertible&lt; typename <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1remove__device__reference">remove_device_reference</a>&lt; Tail &gt;::type, Type &gt;::value ... &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a23efaec2eb9afcba167ec112900bd809">assignTupleToArray</a> (hydra::thrust::detail::tuple_of_iterator_references&lt; Head, Tail... &gt; const &amp;Tuple, Type(&amp;Array)[sizeof...(Tail)+1])</td></tr>
<tr class="separator:a23efaec2eb9afcba167ec112900bd809"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9eba02ade1dc8fad3c8a812861d1f51"><td class="memTemplParams" colspan="2">template&lt;size_t I, typename Type , typename Head , typename ... Tail&gt; </td></tr>
<tr class="memitem:ab9eba02ade1dc8fad3c8a812861d1f51"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> std::enable_if&lt;(I==sizeof...(Tail)+1) &amp;&amp;std::is_convertible&lt; typename <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1remove__device__reference">remove_device_reference</a>&lt; Head &gt;::type, Type &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1all__true.html">all_true</a>&lt; std::is_convertible&lt; typename <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1remove__device__reference">remove_device_reference</a>&lt; Tail &gt;::type, Type &gt;::value ... &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#ab9eba02ade1dc8fad3c8a812861d1f51">assignTupleToArray</a> (hydra::thrust::detail::tuple_of_iterator_references&lt; Head, Tail... &gt; const &amp;, std::array&lt; Type, sizeof...(Tail)+1 &gt; &amp;)</td></tr>
<tr class="separator:ab9eba02ade1dc8fad3c8a812861d1f51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b8e2c32f19fd47e9ca64e2cc2352c55"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename Type , typename Head , typename ... Tail&gt; </td></tr>
<tr class="memitem:a9b8e2c32f19fd47e9ca64e2cc2352c55"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> std::enable_if&lt;(I&lt; sizeof...(Tail)+1) &amp;&amp;std::is_convertible&lt; typename <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1remove__device__reference">remove_device_reference</a>&lt; Head &gt;::type, Type &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1all__true.html">all_true</a>&lt; std::is_convertible&lt; typename <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1remove__device__reference">remove_device_reference</a>&lt; Tail &gt;::type, Type &gt;::value ... &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a9b8e2c32f19fd47e9ca64e2cc2352c55">assignTupleToArray</a> (hydra::thrust::detail::tuple_of_iterator_references&lt; Head, Tail... &gt; const &amp;Tuple, std::array&lt; Type, sizeof...(Tail)+1 &gt; &amp;Array)</td></tr>
<tr class="separator:a9b8e2c32f19fd47e9ca64e2cc2352c55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a109730297fac46a2426c6059b9784beb"><td class="memTemplParams" colspan="2">template&lt;typename F , typename ... T&gt; </td></tr>
<tr class="memitem:a109730297fac46a2426c6059b9784beb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::tuple&lt; T... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a109730297fac46a2426c6059b9784beb">callOnTuple</a> (F const &amp;f, const hydra::thrust::tuple&lt; T... &gt; &amp;<a class="el" href="namespacehydra.html#ac3486502b2db72187626125cea971683">tuple</a>)</td></tr>
<tr class="separator:a109730297fac46a2426c6059b9784beb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a0b98375d08af50ce905a6111ea28d6"><td class="memTemplParams" colspan="2">template&lt;typename F , typename ... T, size_t ... I&gt; </td></tr>
<tr class="memitem:a6a0b98375d08af50ce905a6111ea28d6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::tuple&lt; T... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a6a0b98375d08af50ce905a6111ea28d6">callOnTupleHelper</a> (F const &amp;f, const hydra::thrust::tuple&lt; T... &gt; &amp;<a class="el" href="namespacehydra.html#ac3486502b2db72187626125cea971683">tuple</a>, <a class="el" href="structhydra_1_1detail_1_1index__sequence.html">index_sequence</a>&lt; I... &gt;)</td></tr>
<tr class="separator:a6a0b98375d08af50ce905a6111ea28d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeccac2b5a421cca43286e9717d251c69"><td class="memTemplParams" colspan="2">template&lt;typename T , typename ... Ts&gt; </td></tr>
<tr class="memitem:aeccac2b5a421cca43286e9717d251c69"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#aeccac2b5a421cca43286e9717d251c69">CheckValue</a> (T &amp;&amp;x, char const *fmt, char const *file, char const *function, <a class="el" href="namespace_3globalScope_4.html#classunsigned">unsigned</a> <a class="el" href="namespace_3globalScope_4.html#classint">int</a> line, Ts &amp;&amp;...par)</td></tr>
<tr class="separator:aeccac2b5a421cca43286e9717d251c69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a533680a227b0bdd9daec32b216c92945"><td class="memTemplParams" colspan="2">template&lt;typename ... T, size_t ... I&gt; </td></tr>
<tr class="memitem:a533680a227b0bdd9daec32b216c92945"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::tuple&lt; T... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a533680a227b0bdd9daec32b216c92945">divideTuples</a> (const hydra::thrust::tuple&lt; T... &gt; &amp;a, const hydra::thrust::tuple&lt; T... &gt; &amp;b, <a class="el" href="structhydra_1_1detail_1_1index__sequence.html">index_sequence</a>&lt; I... &gt;)</td></tr>
<tr class="separator:a533680a227b0bdd9daec32b216c92945"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a439c4bd1b41623ef36429392b1c29c46"><td class="memTemplParams" colspan="2">template&lt;typename ... T&gt; </td></tr>
<tr class="memitem:a439c4bd1b41623ef36429392b1c29c46"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::tuple&lt; T... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a439c4bd1b41623ef36429392b1c29c46">divideTuples</a> (const hydra::thrust::tuple&lt; T... &gt; &amp;a, const hydra::thrust::tuple&lt; T... &gt; &amp;b)</td></tr>
<tr class="separator:a439c4bd1b41623ef36429392b1c29c46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0123bf736172613baa970113bd1a21c8"><td class="memTemplParams" colspan="2">template&lt;size_t I, typename ... T&gt; </td></tr>
<tr class="memitem:a0123bf736172613baa970113bd1a21c8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::tuple_element&lt; I, hydra::thrust::tuple&lt; T... &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a0123bf736172613baa970113bd1a21c8">divideTuplesHelper</a> (const hydra::thrust::tuple&lt; T... &gt; &amp;a, const hydra::thrust::tuple&lt; T... &gt; &amp;b)</td></tr>
<tr class="separator:a0123bf736172613baa970113bd1a21c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa48b8114dfe40b2ad9f15962fca73873"><td class="memTemplParams" colspan="2">template&lt;unsigned int I = 0, typename FuncT , typename ... Tp&gt; </td></tr>
<tr class="memitem:aa48b8114dfe40b2ad9f15962fca73873"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::detail::enable_if&lt; I==sizeof...(Tp), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#aa48b8114dfe40b2ad9f15962fca73873">eval_on_tuple_element</a> (<a class="el" href="namespace_3globalScope_4.html#classint">int</a>, hydra::thrust::tuple&lt; Tp... &gt; const &amp;, FuncT const &amp;)</td></tr>
<tr class="separator:aa48b8114dfe40b2ad9f15962fca73873"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa22e275cf1dc4aa0553815e5a403afe9"><td class="memTemplParams" colspan="2">template&lt;unsigned int I = 0, typename FuncT , typename ... Tp&gt; </td></tr>
<tr class="memitem:aa22e275cf1dc4aa0553815e5a403afe9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::detail::enable_if&lt;(I&lt; sizeof...(Tp)), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#aa22e275cf1dc4aa0553815e5a403afe9">eval_on_tuple_element</a> (<a class="el" href="namespace_3globalScope_4.html#classint">int</a> index, hydra::thrust::tuple&lt; Tp... &gt; const &amp;t, FuncT const &amp;f)</td></tr>
<tr class="separator:aa22e275cf1dc4aa0553815e5a403afe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c36121fc4ff640d4bb5e46df8fab18a"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename Return_Type , typename ArgType , typename ... Tp&gt; </td></tr>
<tr class="memitem:a5c36121fc4ff640d4bb5e46df8fab18a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::detail::enable_if&lt; I==sizeof...(Tp), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a5c36121fc4ff640d4bb5e46df8fab18a">eval_tuple_element</a> (Return_Type &amp;, <a class="el" href="namespace_3globalScope_4.html#classint">int</a>, hydra::thrust::tuple&lt; Tp... &gt; const &amp;, ArgType const &amp;)</td></tr>
<tr class="separator:a5c36121fc4ff640d4bb5e46df8fab18a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a822da880b13448285790c6d029454a4f"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename Return_Type , typename ArgType , typename ... Tp&gt; </td></tr>
<tr class="memitem:a822da880b13448285790c6d029454a4f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::detail::enable_if&lt;(I&lt; sizeof...(Tp)), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a822da880b13448285790c6d029454a4f">eval_tuple_element</a> (Return_Type &amp;r, <a class="el" href="namespace_3globalScope_4.html#classint">int</a> index, hydra::thrust::tuple&lt; Tp... &gt; const &amp;t, ArgType const &amp;<a class="el" href="namespacehydra.html#ae96191cbaa62c58f63b7e58924362c24">arg</a>)</td></tr>
<tr class="separator:a822da880b13448285790c6d029454a4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96a946dad2a4b9f834836d9b954ad8b6"><td class="memTemplParams" colspan="2">template&lt;typename Type , typename Tuple &gt; </td></tr>
<tr class="memitem:a96a946dad2a4b9f834836d9b954ad8b6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a96a946dad2a4b9f834836d9b954ad8b6">extract</a> (const <a class="el" href="namespace_3globalScope_4.html#classint">int</a> idx, const Tuple &amp;t)</td></tr>
<tr class="separator:a96a946dad2a4b9f834836d9b954ad8b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3128d1411d3b961132470fbad5761721"><td class="memTemplParams" colspan="2">template&lt;typename R , typename ... T&gt; </td></tr>
<tr class="memitem:a3128d1411d3b961132470fbad5761721"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> R &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a3128d1411d3b961132470fbad5761721">get_element</a> (const size_t index, hydra::thrust::tuple&lt; T... &gt; &amp;t)</td></tr>
<tr class="separator:a3128d1411d3b961132470fbad5761721"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f5a0cb9111ec6aee52c31a221dfd6d3"><td class="memTemplParams" colspan="2">template&lt;typename Tup &gt; </td></tr>
<tr class="memitem:a4f5a0cb9111ec6aee52c31a221dfd6d3"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a4f5a0cb9111ec6aee52c31a221dfd6d3">get_functor_tuple</a> (Tup &amp;pdfs) -&gt; decltype(<a class="el" href="namespacehydra_1_1detail.html#aa7ba7bea072d6c3b6de86086bb49436d">get_functor_tuple_helper</a>(pdfs, <a class="el" href="structhydra_1_1detail_1_1make__index__sequence.html">make_index_sequence</a>&lt; hydra::thrust::tuple_size&lt; Tup &gt;::value &gt;</td></tr>
<tr class="separator:a4f5a0cb9111ec6aee52c31a221dfd6d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7ba7bea072d6c3b6de86086bb49436d"><td class="memTemplParams" colspan="2">template&lt;typename Tup , size_t ... index&gt; </td></tr>
<tr class="memitem:aa7ba7bea072d6c3b6de86086bb49436d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#aa7ba7bea072d6c3b6de86086bb49436d">get_functor_tuple_helper</a> (Tup &amp;pdfs, <a class="el" href="structhydra_1_1detail_1_1index__sequence.html">index_sequence</a>&lt; index... &gt;) -&gt; decltype(hydra::thrust::make_tuple(hydra::thrust::get&lt; index &gt;(pdfs).GetFunctor()...))</td></tr>
<tr class="separator:aa7ba7bea072d6c3b6de86086bb49436d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c688d5b722922805a5837cac93a6411"><td class="memItemLeft" align="right" valign="top"><a class="el" href="basic__distributions_8inl.html#a9717e7bbecb906637e86cef6da3d83c2">return</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a7c688d5b722922805a5837cac93a6411">get_functor_tuple_helper</a> (pdfs, <a class="el" href="structhydra_1_1detail_1_1make__index__sequence.html">make_index_sequence</a>&lt; Size &gt; { })</td></tr>
<tr class="separator:a7c688d5b722922805a5837cac93a6411"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a325f4c7bd791f8e4c8e7777fd1004e6a"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t DIM, size_t I&gt; </td></tr>
<tr class="memitem:a325f4c7bd791f8e4c8e7777fd1004e6a"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;(I==DIM) &amp;&amp;(std::is_integral&lt; T &gt;::value), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a325f4c7bd791f8e4c8e7777fd1004e6a">get_indexes</a> (size_t, std::array&lt; T, DIM &gt; const &amp;, std::array&lt; T, DIM &gt; &amp;)</td></tr>
<tr class="separator:a325f4c7bd791f8e4c8e7777fd1004e6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ba59a3eeef51673f8abf850370c9d55"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t DIM, size_t I = 0&gt; </td></tr>
<tr class="memitem:a7ba59a3eeef51673f8abf850370c9d55"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;(I&lt; DIM) &amp;&amp;(std::is_integral&lt; T &gt;::value), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a7ba59a3eeef51673f8abf850370c9d55">get_indexes</a> (size_t index, std::array&lt; T, DIM &gt; const &amp;depths, std::array&lt; T, DIM &gt; &amp;indexes)</td></tr>
<tr class="separator:a7ba59a3eeef51673f8abf850370c9d55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25ee93686d2834f2c81bbc9ca75340b3"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t DIM, size_t I&gt; </td></tr>
<tr class="memitem:a25ee93686d2834f2c81bbc9ca75340b3"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;(I==DIM) &amp;&amp;(std::is_integral&lt; T &gt;::value), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a25ee93686d2834f2c81bbc9ca75340b3">get_indexes</a> (size_t, const T(&amp;)[DIM], T(&amp;)[DIM])</td></tr>
<tr class="separator:a25ee93686d2834f2c81bbc9ca75340b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab08843425e05190a4baeb424c9da09a9"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t DIM, size_t I = 0&gt; </td></tr>
<tr class="memitem:ab08843425e05190a4baeb424c9da09a9"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;(I&lt; DIM) &amp;&amp;(std::is_integral&lt; T &gt;::value), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#ab08843425e05190a4baeb424c9da09a9">get_indexes</a> (size_t index, const T(&amp;depths)[DIM], T(&amp;indexes)[DIM])</td></tr>
<tr class="separator:ab08843425e05190a4baeb424c9da09a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae31448e32eaed1ff5ff50aa5e38f07c2"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Types&gt; </td></tr>
<tr class="memitem:ae31448e32eaed1ff5ff50aa5e38f07c2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#ae31448e32eaed1ff5ff50aa5e38f07c2">get_tuple_element</a> (hydra::thrust::tuple&lt; Types... &gt; &amp;t)</td></tr>
<tr class="separator:ae31448e32eaed1ff5ff50aa5e38f07c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87618b06102d42ac34d558bf61c62348"><td class="memTemplParams" colspan="2">template&lt;class T , class... Types&gt; </td></tr>
<tr class="memitem:a87618b06102d42ac34d558bf61c62348"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a87618b06102d42ac34d558bf61c62348">get_tuple_element</a> (const hydra::thrust::tuple&lt; Types... &gt; &amp;t)</td></tr>
<tr class="separator:a87618b06102d42ac34d558bf61c62348"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad44ec203de64b9badd86e5346a10844d"><td class="memTemplParams" colspan="2">template&lt;class T , class... Types&gt; </td></tr>
<tr class="memitem:ad44ec203de64b9badd86e5346a10844d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> T &amp;&amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#ad44ec203de64b9badd86e5346a10844d">get_tuple_element</a> (hydra::thrust::tuple&lt; Types... &gt; &amp;&amp;t)</td></tr>
<tr class="separator:ad44ec203de64b9badd86e5346a10844d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5b190f448bfde92779de08ba20bd1cf"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Types&gt; </td></tr>
<tr class="memitem:af5b190f448bfde92779de08ba20bd1cf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::device_reference&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#af5b190f448bfde92779de08ba20bd1cf">get_tuple_element</a> (hydra::thrust::tuple&lt; hydra::thrust::device_reference&lt; Types &gt;... &gt; &amp;t)</td></tr>
<tr class="separator:af5b190f448bfde92779de08ba20bd1cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5e56dc110894f474283544cd1d10cf4"><td class="memTemplParams" colspan="2">template&lt;class T , class... Types&gt; </td></tr>
<tr class="memitem:aa5e56dc110894f474283544cd1d10cf4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> const hydra::thrust::device_reference&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#aa5e56dc110894f474283544cd1d10cf4">get_tuple_element</a> (const hydra::thrust::tuple&lt; hydra::thrust::device_reference&lt; Types &gt;... &gt; &amp;t)</td></tr>
<tr class="separator:aa5e56dc110894f474283544cd1d10cf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6fe4e915198df9be331a66afab71487"><td class="memTemplParams" colspan="2">template&lt;class T , class... Types&gt; </td></tr>
<tr class="memitem:ad6fe4e915198df9be331a66afab71487"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::device_reference&lt; T &gt; &amp;&amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#ad6fe4e915198df9be331a66afab71487">get_tuple_element</a> (hydra::thrust::tuple&lt; hydra::thrust::device_reference&lt; Types &gt;... &gt; &amp;&amp;t)</td></tr>
<tr class="separator:ad6fe4e915198df9be331a66afab71487"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94f259d5cf34fae4d59075522fa0e8e0"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Types&gt; </td></tr>
<tr class="memitem:a94f259d5cf34fae4d59075522fa0e8e0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::device_reference&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a94f259d5cf34fae4d59075522fa0e8e0">get_tuple_element</a> (hydra::thrust::detail::tuple_of_iterator_references&lt; hydra::thrust::device_reference&lt; Types &gt;... &gt; &amp;t)</td></tr>
<tr class="separator:a94f259d5cf34fae4d59075522fa0e8e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30daeef337658b187d8a47db529b4e75"><td class="memTemplParams" colspan="2">template&lt;class T , class... Types&gt; </td></tr>
<tr class="memitem:a30daeef337658b187d8a47db529b4e75"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> const hydra::thrust::device_reference&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a30daeef337658b187d8a47db529b4e75">get_tuple_element</a> (const hydra::thrust::detail::tuple_of_iterator_references&lt; hydra::thrust::device_reference&lt; Types &gt;... &gt; &amp;t)</td></tr>
<tr class="separator:a30daeef337658b187d8a47db529b4e75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0728be8212954b5f0756e47ec00981cf"><td class="memTemplParams" colspan="2">template&lt;class T , class... Types&gt; </td></tr>
<tr class="memitem:a0728be8212954b5f0756e47ec00981cf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::device_reference&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a0728be8212954b5f0756e47ec00981cf">get_tuple_element</a> (hydra::thrust::detail::tuple_of_iterator_references&lt; hydra::thrust::device_reference&lt; Types &gt;... &gt; &amp;&amp;t)</td></tr>
<tr class="separator:a0728be8212954b5f0756e47ec00981cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a602cafd73a2e5770fad6ee90d555e0e0"><td class="memTemplParams" colspan="2">template&lt;unsigned int I = 0, typename T , typename ... Tp&gt; </td></tr>
<tr class="memitem:a602cafd73a2e5770fad6ee90d555e0e0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::detail::enable_if&lt; I==sizeof...(Tp), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a602cafd73a2e5770fad6ee90d555e0e0">get_tuple_element</a> (const <a class="el" href="namespace_3globalScope_4.html#classint">int</a>, hydra::thrust::tuple&lt; Tp... &gt; const &amp;, T &amp;)</td></tr>
<tr class="separator:a602cafd73a2e5770fad6ee90d555e0e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18ad8af35017817d42f421ba36a832b9"><td class="memTemplParams" colspan="2">template&lt;unsigned int I = 0, typename T , typename ... Tp&gt; </td></tr>
<tr class="memitem:a18ad8af35017817d42f421ba36a832b9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::detail::enable_if&lt;(I&lt; sizeof...(Tp)), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a18ad8af35017817d42f421ba36a832b9">get_tuple_element</a> (const <a class="el" href="namespace_3globalScope_4.html#classint">int</a> index, hydra::thrust::tuple&lt; Tp... &gt; const &amp;t, T &amp;x)</td></tr>
<tr class="separator:a18ad8af35017817d42f421ba36a832b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a227e0b524804a0ceef56b4a1da1953d4"><td class="memTemplParams" colspan="2">template&lt;typename Iterator , size_t N&gt; </td></tr>
<tr class="memitem:a227e0b524804a0ceef56b4a1da1953d4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a227e0b524804a0ceef56b4a1da1953d4">get_zip_iterator</a> (std::array&lt; Iterator, N &gt;const &amp;array_of_iterators) -&gt; decltype(<a class="el" href="namespacehydra_1_1detail.html#a70f2fe29b87457d99a58eb0025bf88dd">get_zip_iterator_helper</a>(array_of_iterators, <a class="el" href="structhydra_1_1detail_1_1make__index__sequence.html">make_index_sequence</a>&lt; N &gt;</td></tr>
<tr class="separator:a227e0b524804a0ceef56b4a1da1953d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9da0535b5305aaf5cfe698c42ebc8d6"><td class="memTemplParams" colspan="2">template&lt;typename IteratorHead , typename IteratorTail , size_t N&gt; </td></tr>
<tr class="memitem:ae9da0535b5305aaf5cfe698c42ebc8d6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#ae9da0535b5305aaf5cfe698c42ebc8d6">get_zip_iterator</a> (IteratorHead head, std::array&lt; IteratorTail, N &gt;const &amp;array_of_iterators) -&gt; decltype(<a class="el" href="namespacehydra_1_1detail.html#a70f2fe29b87457d99a58eb0025bf88dd">get_zip_iterator_helper</a>(head, array_of_iterators, <a class="el" href="structhydra_1_1detail_1_1make__index__sequence.html">make_index_sequence</a>&lt; N &gt;</td></tr>
<tr class="separator:ae9da0535b5305aaf5cfe698c42ebc8d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70f2fe29b87457d99a58eb0025bf88dd"><td class="memTemplParams" colspan="2">template&lt;typename Iterator , size_t ... Index&gt; </td></tr>
<tr class="memitem:a70f2fe29b87457d99a58eb0025bf88dd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a70f2fe29b87457d99a58eb0025bf88dd">get_zip_iterator_helper</a> (std::array&lt; Iterator, sizeof ...(Index)&gt;const &amp;array_of_iterators, <a class="el" href="structhydra_1_1detail_1_1index__sequence.html">index_sequence</a>&lt; Index... &gt;) -&gt; decltype(hydra::thrust::make_zip_iterator(hydra::thrust::make_tuple(array_of_iterators[Index]...)))</td></tr>
<tr class="separator:a70f2fe29b87457d99a58eb0025bf88dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a935492c6993543ddd346a1ce0bb1e2"><td class="memTemplParams" colspan="2">template&lt;typename IteratorHead , typename IteratorTail , size_t ... Index&gt; </td></tr>
<tr class="memitem:a8a935492c6993543ddd346a1ce0bb1e2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a8a935492c6993543ddd346a1ce0bb1e2">get_zip_iterator_helper</a> (IteratorHead head, std::array&lt; IteratorTail, sizeof ...(Index)&gt;const &amp;array_of_iterators, <a class="el" href="structhydra_1_1detail_1_1index__sequence.html">index_sequence</a>&lt; Index... &gt;) -&gt; decltype(hydra::thrust::make_zip_iterator(hydra::thrust::make_tuple(head, array_of_iterators[Index]...)))</td></tr>
<tr class="separator:a8a935492c6993543ddd346a1ce0bb1e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a618d244958e2ded8465ae85756a011cd"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a618d244958e2ded8465ae85756a011cd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a618d244958e2ded8465ae85756a011cd">hash_combine</a> (std::size_t &amp;seed, T const &amp;v)</td></tr>
<tr class="separator:a618d244958e2ded8465ae85756a011cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0be774a301b3817c97d58c61aa08ba85"><td class="memTemplParams" colspan="2">template&lt;class It &gt; </td></tr>
<tr class="memitem:a0be774a301b3817c97d58c61aa08ba85"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a0be774a301b3817c97d58c61aa08ba85">hash_range</a> (It first, It last)</td></tr>
<tr class="separator:a0be774a301b3817c97d58c61aa08ba85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abda9a4b4ec271e3f6c5adf9bc93a3173"><td class="memTemplParams" colspan="2">template&lt;class It &gt; </td></tr>
<tr class="memitem:abda9a4b4ec271e3f6c5adf9bc93a3173"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#abda9a4b4ec271e3f6c5adf9bc93a3173">hash_range</a> (std::size_t &amp;seed, It first, It last)</td></tr>
<tr class="separator:abda9a4b4ec271e3f6c5adf9bc93a3173"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a256df6594bc88c80701d99622515c875"><td class="memTemplParams" colspan="2">template&lt;typename ... T&gt; </td></tr>
<tr class="memitem:a256df6594bc88c80701d99622515c875"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a256df6594bc88c80701d99622515c875">hash_tuple</a> (std::size_t &amp;seed, <a class="el" href="namespacehydra.html#ac3486502b2db72187626125cea971683">hydra::tuple</a>&lt; T... &gt; const &amp;_tuple)</td></tr>
<tr class="separator:a256df6594bc88c80701d99622515c875"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a425bb4f65a43d822ba80ebdbca5b8b74"><td class="memTemplParams" colspan="2">template&lt;typename ... T&gt; </td></tr>
<tr class="memitem:a425bb4f65a43d822ba80ebdbca5b8b74"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a425bb4f65a43d822ba80ebdbca5b8b74">hash_tuple</a> (<a class="el" href="namespacehydra.html#ac3486502b2db72187626125cea971683">hydra::tuple</a>&lt; T... &gt; const &amp;_tuple)</td></tr>
<tr class="separator:a425bb4f65a43d822ba80ebdbca5b8b74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b30f3961b7f4ed7c28a4e1373281c1c"><td class="memTemplParams" colspan="2">template&lt;typename Tup , typename ArgType , size_t N = hydra::thrust::tuple_size&lt;typename hydra::thrust::detail::remove_reference&lt;Tup&gt;::type&gt;::value&gt; </td></tr>
<tr class="memitem:a0b30f3961b7f4ed7c28a4e1373281c1c"><td class="memTemplItemLeft" align="right" valign="top">__hydra_thrust_exec_check_disable__ <a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a0b30f3961b7f4ed7c28a4e1373281c1c">invoke</a> (ArgType &amp;&amp;x, Tup &amp;&amp;tup) -&gt; decltype(<a class="el" href="namespacehydra_1_1detail.html#a15800958694e9465ff44c60dae36d25b">invoke_helper</a>(std::forward&lt; ArgType &gt;(x), std::forward&lt; Tup &gt;(tup), <a class="el" href="structhydra_1_1detail_1_1make__index__sequence.html">make_index_sequence</a>&lt; N &gt;</td></tr>
<tr class="separator:a0b30f3961b7f4ed7c28a4e1373281c1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad31b6d1499b5a6b2d77c015a71385a6e"><td class="memTemplParams" colspan="2">template&lt;typename Tup , typename ArgType , size_t N = hydra::thrust::tuple_size&lt;typename hydra::thrust::detail::remove_reference&lt;Tup&gt;::type&gt;::value&gt; </td></tr>
<tr class="memitem:ad31b6d1499b5a6b2d77c015a71385a6e"><td class="memTemplItemLeft" align="right" valign="top">__hydra_thrust_exec_check_disable__ <a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#ad31b6d1499b5a6b2d77c015a71385a6e">invoke</a> (ArgType const &amp;x, Tup const &amp;tup) -&gt; decltype(<a class="el" href="namespacehydra_1_1detail.html#a15800958694e9465ff44c60dae36d25b">invoke_helper</a>(x, tup, <a class="el" href="structhydra_1_1detail_1_1make__index__sequence.html">make_index_sequence</a>&lt; N &gt;</td></tr>
<tr class="separator:ad31b6d1499b5a6b2d77c015a71385a6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7367f21b0df25c033551a4f2a88b9f7"><td class="memTemplParams" colspan="2">template&lt;typename Tup , typename ArgType1 , typename ArgType2 , size_t N = hydra::thrust::tuple_size&lt;typename hydra::thrust::detail::remove_reference&lt;Tup&gt;::type&gt;::value&gt; </td></tr>
<tr class="memitem:ab7367f21b0df25c033551a4f2a88b9f7"><td class="memTemplItemLeft" align="right" valign="top">__hydra_thrust_exec_check_disable__ <a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#ab7367f21b0df25c033551a4f2a88b9f7">invoke</a> (ArgType1 &amp;&amp;x, ArgType2 &amp;&amp;y, Tup &amp;&amp;tup) -&gt; decltype(<a class="el" href="namespacehydra_1_1detail.html#a15800958694e9465ff44c60dae36d25b">invoke_helper</a>(std::forward&lt; ArgType1 &gt;(x), std::forward&lt; ArgType2 &gt;(y), std::forward&lt; Tup &gt;(tup), <a class="el" href="structhydra_1_1detail_1_1make__index__sequence.html">make_index_sequence</a>&lt; hydra::thrust::tuple_size&lt; Tup &gt;::value &gt;</td></tr>
<tr class="separator:ab7367f21b0df25c033551a4f2a88b9f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12930cc3363cf266694e4e13077758de"><td class="memTemplParams" colspan="2">template&lt;typename Tup , typename ArgType1 , typename ArgType2 &gt; </td></tr>
<tr class="memitem:a12930cc3363cf266694e4e13077758de"><td class="memTemplItemLeft" align="right" valign="top">__hydra_thrust_exec_check_disable__ <a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a12930cc3363cf266694e4e13077758de">invoke</a> (ArgType1 const &amp;x, ArgType2 const &amp;y, Tup const &amp;tup) -&gt; decltype(<a class="el" href="namespacehydra_1_1detail.html#a15800958694e9465ff44c60dae36d25b">invoke_helper</a>(x, y, tup, <a class="el" href="structhydra_1_1detail_1_1make__index__sequence.html">make_index_sequence</a>&lt; hydra::thrust::tuple_size&lt; Tup &gt;::value &gt;</td></tr>
<tr class="separator:a12930cc3363cf266694e4e13077758de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15800958694e9465ff44c60dae36d25b"><td class="memTemplParams" colspan="2">template&lt;typename Tup , typename ArgType , size_t ... index&gt; </td></tr>
<tr class="memitem:a15800958694e9465ff44c60dae36d25b"><td class="memTemplItemLeft" align="right" valign="top">__hydra_thrust_exec_check_disable__ <a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a15800958694e9465ff44c60dae36d25b">invoke_helper</a> (ArgType &amp;&amp;x, Tup &amp;&amp;tup, <a class="el" href="structhydra_1_1detail_1_1index__sequence.html">index_sequence</a>&lt; index... &gt;) -&gt; decltype(hydra::thrust::make_tuple(hydra::thrust::get&lt; index &gt;(std::forward&lt; Tup &gt;(tup))(std::forward&lt; ArgType &gt;(x))...))</td></tr>
<tr class="separator:a15800958694e9465ff44c60dae36d25b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78cc12c7ba49afe6f1ad39c31d705758"><td class="memTemplParams" colspan="2">template&lt;typename Tup , typename ArgType , size_t ... index&gt; </td></tr>
<tr class="memitem:a78cc12c7ba49afe6f1ad39c31d705758"><td class="memTemplItemLeft" align="right" valign="top">__hydra_thrust_exec_check_disable__ <a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a78cc12c7ba49afe6f1ad39c31d705758">invoke_helper</a> (ArgType const &amp;x, Tup const &amp;tup, <a class="el" href="structhydra_1_1detail_1_1index__sequence.html">index_sequence</a>&lt; index... &gt;) -&gt; decltype(hydra::thrust::make_tuple(hydra::thrust::get&lt; index &gt;(tup)(x)...))</td></tr>
<tr class="separator:a78cc12c7ba49afe6f1ad39c31d705758"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38971d6835214e8b68e4d05ec01a8360"><td class="memTemplParams" colspan="2">template&lt;typename Tup , typename ArgType1 , typename ArgType2 , size_t ... index&gt; </td></tr>
<tr class="memitem:a38971d6835214e8b68e4d05ec01a8360"><td class="memTemplItemLeft" align="right" valign="top">__hydra_thrust_exec_check_disable__ <a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a38971d6835214e8b68e4d05ec01a8360">invoke_helper</a> (ArgType1 &amp;&amp;x, ArgType2 &amp;&amp;y, Tup &amp;&amp;tup, <a class="el" href="structhydra_1_1detail_1_1index__sequence.html">index_sequence</a>&lt; index... &gt;) -&gt; decltype(hydra::thrust::make_tuple(hydra::thrust::get&lt; index &gt;(std::forward&lt; Tup &gt;(tup))(std::forward&lt; ArgType1 &gt;(x), std::forward&lt; ArgType2 &gt;(y))...))</td></tr>
<tr class="separator:a38971d6835214e8b68e4d05ec01a8360"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12be32d2ba8df4c278c368d8df150084"><td class="memTemplParams" colspan="2">template&lt;typename Tup , typename ArgType1 , typename ArgType2 , size_t ... index&gt; </td></tr>
<tr class="memitem:a12be32d2ba8df4c278c368d8df150084"><td class="memTemplItemLeft" align="right" valign="top">__hydra_thrust_exec_check_disable__ <a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a12be32d2ba8df4c278c368d8df150084">invoke_helper</a> (ArgType1 const &amp;x, ArgType2 const &amp;y, Tup const &amp;tup, <a class="el" href="structhydra_1_1detail_1_1index__sequence.html">index_sequence</a>&lt; index... &gt;) -&gt; decltype(hydra::thrust::make_tuple(hydra::thrust::get&lt; index &gt;(tup)(x, y)...))</td></tr>
<tr class="separator:a12be32d2ba8df4c278c368d8df150084"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9360a30d9cffc4d39b34187a56f0bb92"><td class="memItemLeft" align="right" valign="top"><a class="el" href="basic__distributions_8inl.html#a9717e7bbecb906637e86cef6da3d83c2">return</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a9360a30d9cffc4d39b34187a56f0bb92">invoke_helper</a> (x, y, tup, <a class="el" href="structhydra_1_1detail_1_1make__index__sequence.html">make_index_sequence</a>&lt; Size &gt; { })</td></tr>
<tr class="separator:a9360a30d9cffc4d39b34187a56f0bb92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cf84b4edaeb303174a32a9d9ee44e39"><td class="memTemplParams" colspan="2">template&lt;typename Tup , typename ArgType &gt; </td></tr>
<tr class="memitem:a9cf84b4edaeb303174a32a9d9ee44e39"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a9cf84b4edaeb303174a32a9d9ee44e39">invoke_normalized</a> (ArgType const &amp;x, Tup const &amp;tup) -&gt; decltype(<a class="el" href="namespacehydra_1_1detail.html#a15800958694e9465ff44c60dae36d25b">invoke_helper</a>(x, tup, <a class="el" href="structhydra_1_1detail_1_1make__index__sequence.html">make_index_sequence</a>&lt; hydra::thrust::tuple_size&lt; Tup &gt;::value &gt;</td></tr>
<tr class="separator:a9cf84b4edaeb303174a32a9d9ee44e39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4c0051b20d34181994aa5560387054e"><td class="memTemplParams" colspan="2">template&lt;typename Tup , typename ArgType , size_t N = hydra::thrust::tuple_size&lt;typename hydra::thrust::detail::remove_reference&lt;Tup&gt;::type&gt;::value&gt; </td></tr>
<tr class="memitem:af4c0051b20d34181994aa5560387054e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#af4c0051b20d34181994aa5560387054e">invoke_normalized</a> (ArgType &amp;&amp;x, Tup &amp;&amp;tup) -&gt; decltype(<a class="el" href="namespacehydra_1_1detail.html#a15800958694e9465ff44c60dae36d25b">invoke_helper</a>(std::forward&lt; ArgType &gt;(x), std::forward&lt; Tup &gt;(tup), <a class="el" href="structhydra_1_1detail_1_1make__index__sequence.html">make_index_sequence</a>&lt; N &gt;</td></tr>
<tr class="separator:af4c0051b20d34181994aa5560387054e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00f219e8545b9dcff63940bf1bc4d63e"><td class="memTemplParams" colspan="2">template&lt;typename Tup , typename ArgType , size_t ... index&gt; </td></tr>
<tr class="memitem:a00f219e8545b9dcff63940bf1bc4d63e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a00f219e8545b9dcff63940bf1bc4d63e">invoke_normalized_helper</a> (ArgType const &amp;x, Tup const &amp;tup, <a class="el" href="structhydra_1_1detail_1_1index__sequence.html">index_sequence</a>&lt; index... &gt;) -&gt; decltype(hydra::thrust::make_tuple(hydra::thrust::get&lt; index &gt;(tup)(x)...))</td></tr>
<tr class="separator:a00f219e8545b9dcff63940bf1bc4d63e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a173eb394103a0e94fbf9abbc1918a894"><td class="memItemLeft" align="right" valign="top"><a class="el" href="basic__distributions_8inl.html#a9717e7bbecb906637e86cef6da3d83c2">return</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a173eb394103a0e94fbf9abbc1918a894">invoke_normalized_helper</a> (x, tup, <a class="el" href="structhydra_1_1detail_1_1make__index__sequence.html">make_index_sequence</a>&lt; Size &gt; { })</td></tr>
<tr class="separator:a173eb394103a0e94fbf9abbc1918a894"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3253bf4c374c43071735c8ca91a1598"><td class="memTemplParams" colspan="2">template&lt;typename Tup , typename ArgType , size_t ... index&gt; </td></tr>
<tr class="memitem:af3253bf4c374c43071735c8ca91a1598"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#af3253bf4c374c43071735c8ca91a1598">invoke_normalized_helper</a> (ArgType &amp;&amp;x, Tup &amp;&amp;tup, <a class="el" href="structhydra_1_1detail_1_1index__sequence.html">index_sequence</a>&lt; index... &gt;) -&gt; decltype(hydra::thrust::make_tuple(hydra::thrust::get&lt; index &gt;(std::forward&lt; Tup &gt;(tup))(std::forward&lt; ArgType &gt;(x))...))</td></tr>
<tr class="separator:af3253bf4c374c43071735c8ca91a1598"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad9d0de301331608aa91ce3589f9c5c1"><td class="memTemplParams" colspan="2">template&lt;class Iterator &gt; </td></tr>
<tr class="memitem:aad9d0de301331608aa91ce3589f9c5c1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#aad9d0de301331608aa91ce3589f9c5c1">iter_swap</a> (Iterator first, Iterator second)</td></tr>
<tr class="separator:aad9d0de301331608aa91ce3589f9c5c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0a8ff71493e18493d9df6b9cfa1a745"><td class="memTemplParams" colspan="2">template&lt;typename T , typename ... Ts&gt; </td></tr>
<tr class="memitem:ad0a8ff71493e18493d9df6b9cfa1a745"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#ad0a8ff71493e18493d9df6b9cfa1a745">kill</a> (T &amp;&amp;x)</td></tr>
<tr class="separator:ad0a8ff71493e18493d9df6b9cfa1a745"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5050bf77c477bccc5db77c507cca743"><td class="memTemplParams" colspan="2">template&lt;size_t N, typename GRND , typename Iterator &gt; </td></tr>
<tr class="memitem:ab5050bf77c477bccc5db77c507cca743"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#ab5050bf77c477bccc5db77c507cca743">launch_decayer</a> (Iterator <a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>, Iterator <a class="el" href="namespacehydra.html#a4274268d147e9a988f379326b73682b0">end</a>, <a class="el" href="structhydra_1_1detail_1_1DecayMother.html">DecayMother</a>&lt; N, GRND &gt; const &amp;decayer)</td></tr>
<tr class="separator:ab5050bf77c477bccc5db77c507cca743"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4695a02794382f4f997052b425413987"><td class="memTemplParams" colspan="2">template&lt;size_t N, typename GRND , typename Iterator , hydra::detail::Backend BACKEND&gt; </td></tr>
<tr class="memitem:a4695a02794382f4f997052b425413987"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a4695a02794382f4f997052b425413987">launch_decayer</a> (<a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; const &amp;exec_policy, Iterator <a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>, Iterator <a class="el" href="namespacehydra.html#a4274268d147e9a988f379326b73682b0">end</a>, <a class="el" href="structhydra_1_1detail_1_1DecayMother.html">DecayMother</a>&lt; N, GRND &gt; const &amp;decayer)</td></tr>
<tr class="separator:a4695a02794382f4f997052b425413987"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a35cdb4fa592a33bba8d836aed248df"><td class="memTemplParams" colspan="2">template&lt;size_t N, typename GRND , typename IteratorMother , typename IteratorDaughter &gt; </td></tr>
<tr class="memitem:a9a35cdb4fa592a33bba8d836aed248df"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a9a35cdb4fa592a33bba8d836aed248df">launch_decayer</a> (IteratorMother begin_mothers, IteratorMother end_mothers, IteratorDaughter begin_daugters, <a class="el" href="structhydra_1_1detail_1_1DecayMothers.html">DecayMothers</a>&lt; N, GRND &gt; const &amp;decayer)</td></tr>
<tr class="separator:a9a35cdb4fa592a33bba8d836aed248df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3482cd2a135b31d8bb68fcd11dcdac8d"><td class="memTemplParams" colspan="2">template&lt;size_t N, typename GRND , typename IteratorMother , typename IteratorDaughter , hydra::detail::Backend BACKEND&gt; </td></tr>
<tr class="memitem:a3482cd2a135b31d8bb68fcd11dcdac8d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a3482cd2a135b31d8bb68fcd11dcdac8d">launch_decayer</a> (<a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; const &amp;exec_policy, IteratorMother begin_mothers, IteratorMother end_mothers, IteratorDaughter begin_daugters, <a class="el" href="structhydra_1_1detail_1_1DecayMothers.html">DecayMothers</a>&lt; N, GRND &gt; const &amp;decayer)</td></tr>
<tr class="separator:a3482cd2a135b31d8bb68fcd11dcdac8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a2cc34389ca89449738a46e209133a8"><td class="memTemplParams" colspan="2">template&lt;size_t N, typename FUNCTOR , typename ... FUNCTORS, typename GRND , typename Iterator &gt; </td></tr>
<tr class="memitem:a9a2cc34389ca89449738a46e209133a8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a9a2cc34389ca89449738a46e209133a8">launch_evaluator</a> (Iterator <a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>, Iterator <a class="el" href="namespacehydra.html#a4274268d147e9a988f379326b73682b0">end</a>, <a class="el" href="structhydra_1_1detail_1_1EvalMother.html">detail::EvalMother</a>&lt; N, GRND, FUNCTOR, FUNCTORS... &gt; const &amp;evaluator)</td></tr>
<tr class="separator:a9a2cc34389ca89449738a46e209133a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a272aed700c4b40bbd2639a84507da00d"><td class="memTemplParams" colspan="2">template&lt;size_t N, typename FUNCTOR , typename ... FUNCTORS, typename GRND , typename IteratorMother , typename Iterator &gt; </td></tr>
<tr class="memitem:a272aed700c4b40bbd2639a84507da00d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a272aed700c4b40bbd2639a84507da00d">launch_evaluator</a> (IteratorMother mbegin, IteratorMother mend, Iterator <a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>, <a class="el" href="structhydra_1_1detail_1_1EvalMothers.html">detail::EvalMothers</a>&lt; N, GRND, FUNCTOR, FUNCTORS... &gt; const &amp;evaluator)</td></tr>
<tr class="separator:a272aed700c4b40bbd2639a84507da00d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dce458532ae6b3d821a91604dad7895"><td class="memTemplParams" colspan="2">template&lt;size_t N, hydra::detail::Backend BACKEND, typename FUNCTOR , typename GRND , typename Iterator &gt; </td></tr>
<tr class="memitem:a8dce458532ae6b3d821a91604dad7895"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structhydra_1_1detail_1_1StatsPHSP.html">StatsPHSP</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a8dce458532ae6b3d821a91604dad7895">launch_reducer</a> (<a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt;const &amp;policy, Iterator <a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>, Iterator <a class="el" href="namespacehydra.html#a4274268d147e9a988f379326b73682b0">end</a>, <a class="el" href="structhydra_1_1detail_1_1AverageMother.html">detail::AverageMother</a>&lt; N, GRND, FUNCTOR &gt; const &amp;evaluator)</td></tr>
<tr class="separator:a8dce458532ae6b3d821a91604dad7895"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8b536e68d5a5831e546272b56c031ee"><td class="memTemplParams" colspan="2">template&lt;size_t N, typename FUNCTOR , typename GRND , typename Iterator &gt; </td></tr>
<tr class="memitem:aa8b536e68d5a5831e546272b56c031ee"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structhydra_1_1detail_1_1StatsPHSP.html">StatsPHSP</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#aa8b536e68d5a5831e546272b56c031ee">launch_reducer</a> (Iterator <a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>, Iterator <a class="el" href="namespacehydra.html#a4274268d147e9a988f379326b73682b0">end</a>, <a class="el" href="structhydra_1_1detail_1_1AverageMothers.html">detail::AverageMothers</a>&lt; N, GRND, FUNCTOR &gt; const &amp;evaluator)</td></tr>
<tr class="separator:aa8b536e68d5a5831e546272b56c031ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a024a15ab3a2da15dc78f090437220dde"><td class="memTemplParams" colspan="2">template&lt;typename Integer &gt; </td></tr>
<tr class="memitem:a024a15ab3a2da15dc78f090437220dde"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> std::enable_if&lt; std::is_integral&lt; Integer &gt;::value &amp;&amp;!(std::is_signed&lt; Integer &gt;::value) &amp;&amp;(sizeof(Integer)==8), <a class="el" href="namespace_3globalScope_4.html#classunsigned">unsigned</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a024a15ab3a2da15dc78f090437220dde">lsb</a> (Integer x)</td></tr>
<tr class="separator:a024a15ab3a2da15dc78f090437220dde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5ba85f2308d53e41bfbd714a2850b3e"><td class="memTemplParams" colspan="2">template&lt;typename Integer &gt; </td></tr>
<tr class="memitem:af5ba85f2308d53e41bfbd714a2850b3e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> std::enable_if&lt; std::is_integral&lt; Integer &gt;::value &amp;&amp;!(std::is_signed&lt; Integer &gt;::value) &amp;&amp;(sizeof(Integer)==4), <a class="el" href="namespace_3globalScope_4.html#classunsigned">unsigned</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#af5ba85f2308d53e41bfbd714a2850b3e">lsb</a> (Integer x)</td></tr>
<tr class="separator:af5ba85f2308d53e41bfbd714a2850b3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afef4bbc17cf6421b0da41b1872dc7781"><td class="memItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#afef4bbc17cf6421b0da41b1872dc7781">machine_eps_f32</a> (float value=1.0)</td></tr>
<tr class="separator:afef4bbc17cf6421b0da41b1872dc7781"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af60fc3e60cc10bd79092ca02c8e8b84c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#af60fc3e60cc10bd79092ca02c8e8b84c">machine_eps_f64</a> (<a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> value=1.0)</td></tr>
<tr class="separator:af60fc3e60cc10bd79092ca02c8e8b84c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecd9fdc1ef691978c73582a7f81ca59b"><td class="memTemplParams" colspan="2">template&lt;typename ... T&gt; </td></tr>
<tr class="memitem:aecd9fdc1ef691978c73582a7f81ca59b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#aecd9fdc1ef691978c73582a7f81ca59b">make_rtuple</a> (hydra::thrust::tuple&lt; T... &gt; &amp;t) -&gt; hydra::thrust::tuple&lt; T &amp;... &gt;</td></tr>
<tr class="separator:aecd9fdc1ef691978c73582a7f81ca59b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dbc5fcecd172e18c2ecb75b89560ac2"><td class="memTemplParams" colspan="2">template&lt;typename ... T, size_t... I&gt; </td></tr>
<tr class="memitem:a6dbc5fcecd172e18c2ecb75b89560ac2"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a6dbc5fcecd172e18c2ecb75b89560ac2">make_rtuple_helper</a> (hydra::thrust::tuple&lt; T... &gt; &amp;t, <a class="el" href="structhydra_1_1detail_1_1index__sequence.html">index_sequence</a>&lt; I... &gt;) -&gt; hydra::thrust::tuple&lt; T &amp;... &gt;</td></tr>
<tr class="separator:a6dbc5fcecd172e18c2ecb75b89560ac2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac16e513053ac8d97923ac166db8e6a98"><td class="memItemLeft" align="right" valign="top">T ::type TupleType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#ac16e513053ac8d97923ac166db8e6a98">make_tuple</a> (T &amp;&amp;value)</td></tr>
<tr class="separator:ac16e513053ac8d97923ac166db8e6a98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad720a19d349e53d36757cfe71338ca64"><td class="memTemplParams" colspan="2">template&lt;typename ... T&gt; </td></tr>
<tr class="memitem:ad720a19d349e53d36757cfe71338ca64"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#ad720a19d349e53d36757cfe71338ca64">max</a> (hydra::thrust::tuple&lt; T... &gt; const &amp;<a class="el" href="namespacehydra.html#ac3486502b2db72187626125cea971683">tuple</a>)</td></tr>
<tr class="separator:ad720a19d349e53d36757cfe71338ca64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4140580867ee73e401e1bb1e213548c"><td class="memTemplParams" colspan="2">template&lt;typename T , typename C , size_t N, size_t I&gt; </td></tr>
<tr class="memitem:aa4140580867ee73e401e1bb1e213548c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> std::enable_if&lt; I==N, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#aa4140580867ee73e401e1bb1e213548c">max_helper</a> (T const &amp;, <a class="el" href="basic__distributions_8inl.html#a4900ef306eb9271438791f1a98b8ccba">C</a> &amp;, size_t &amp;)</td></tr>
<tr class="separator:aa4140580867ee73e401e1bb1e213548c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad23b453b58064598dbd7596ffca55422"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#ad23b453b58064598dbd7596ffca55422">max_helper&lt; T, C, N, I+1 &gt;</a> (<a class="el" href="namespacehydra.html#ac3486502b2db72187626125cea971683">tuple</a>, <a class="el" href="namespacehydra_1_1detail.html#a50b277339704a9d22de5802abfd3ff22">max_value</a>, max_index)</td></tr>
<tr class="separator:ad23b453b58064598dbd7596ffca55422"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d9f6a5b4844a887d53284f38f00f89a"><td class="memTemplParams" colspan="2">template&lt;typename ... Iterators&gt; </td></tr>
<tr class="memitem:a3d9f6a5b4844a887d53284f38f00f89a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a3d9f6a5b4844a887d53284f38f00f89a">meld_iterators</a> (Iterators &amp;&amp;... iterators) -&gt; decltype(hydra::thrust::make_zip_iterator(hydra::thrust::tuple_cat(<a class="el" href="namespacehydra_1_1detail_1_1meld__iterators__ns.html#a6256486a1fd69c4d2df51f9fff3ef3d5">meld_iterators_ns::convert_to_tuple</a>(std::forward&lt; Iterators &gt;(iterators))...)))</td></tr>
<tr class="separator:a3d9f6a5b4844a887d53284f38f00f89a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bd83f3f59f6d4881d766809e6172a48"><td class="memTemplParams" colspan="2">template&lt;typename Integer &gt; </td></tr>
<tr class="memitem:a4bd83f3f59f6d4881d766809e6172a48"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> std::enable_if&lt; std::is_integral&lt; Integer &gt;::value &amp;&amp;!(std::is_signed&lt; Integer &gt;::value) &amp;&amp;(std::numeric_limits&lt; Integer &gt;::digits==64), <a class="el" href="namespace_3globalScope_4.html#classunsigned">unsigned</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a4bd83f3f59f6d4881d766809e6172a48">msb</a> (Integer x)</td></tr>
<tr class="separator:a4bd83f3f59f6d4881d766809e6172a48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88d8ecbd10f4e4bbb6c161c69392287d"><td class="memTemplParams" colspan="2">template&lt;typename Integer &gt; </td></tr>
<tr class="memitem:a88d8ecbd10f4e4bbb6c161c69392287d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> std::enable_if&lt; std::is_integral&lt; Integer &gt;::value &amp;&amp;!(std::is_signed&lt; Integer &gt;::value) &amp;&amp;(std::numeric_limits&lt; Integer &gt;::digits&lt;=32), <a class="el" href="namespace_3globalScope_4.html#classunsigned">unsigned</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a88d8ecbd10f4e4bbb6c161c69392287d">msb</a> (Integer x)</td></tr>
<tr class="separator:a88d8ecbd10f4e4bbb6c161c69392287d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2b12c58b82f3d39caa4dffc5ce0faf9"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N, size_t I&gt; </td></tr>
<tr class="memitem:ad2b12c58b82f3d39caa4dffc5ce0faf9"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;(I==N), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#ad2b12c58b82f3d39caa4dffc5ce0faf9">multiply</a> (std::array&lt; T, N &gt; const &amp;, T &amp;)</td></tr>
<tr class="separator:ad2b12c58b82f3d39caa4dffc5ce0faf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52459ef87933d78d5ce88feb998bd8bd"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N, size_t I = 0&gt; </td></tr>
<tr class="memitem:a52459ef87933d78d5ce88feb998bd8bd"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;(I&lt; N), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a52459ef87933d78d5ce88feb998bd8bd">multiply</a> (std::array&lt; T, N &gt; const &amp;obj, T &amp;result)</td></tr>
<tr class="separator:a52459ef87933d78d5ce88feb998bd8bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af73aa95bb4dce5810569f682bb39de27"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N, size_t I&gt; </td></tr>
<tr class="memitem:af73aa95bb4dce5810569f682bb39de27"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;(I==N), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#af73aa95bb4dce5810569f682bb39de27">multiply</a> (const T(&amp;)[N], T &amp;)</td></tr>
<tr class="separator:af73aa95bb4dce5810569f682bb39de27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f767f0131f9a4910ece6f10d1b5a0f2"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N, size_t I = 0&gt; </td></tr>
<tr class="memitem:a4f767f0131f9a4910ece6f10d1b5a0f2"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;(I&lt; N), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a4f767f0131f9a4910ece6f10d1b5a0f2">multiply</a> (const T(&amp;obj)[N], T &amp;result)</td></tr>
<tr class="separator:a4f767f0131f9a4910ece6f10d1b5a0f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b1dbe6a0f5f757d371526da98ae8402"><td class="memTemplParams" colspan="2">template&lt;typename ... T&gt; </td></tr>
<tr class="memitem:a2b1dbe6a0f5f757d371526da98ae8402"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a2b1dbe6a0f5f757d371526da98ae8402">multiply_array_tuple</a> (<a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>(&amp;fCoefficients)[sizeof...(T)], hydra::thrust::tuple&lt; T... &gt; const &amp;tpl) -&gt; decltype(<a class="el" href="namespacehydra_1_1detail.html#a9dedb058563f9d7f616d862fd25b9e3b">multiply_array_tuple_helper</a>(fCoefficients, tpl, <a class="el" href="structhydra_1_1detail_1_1make__index__sequence.html">make_index_sequence</a>&lt; sizeof...(T)&gt;</td></tr>
<tr class="separator:a2b1dbe6a0f5f757d371526da98ae8402"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dedb058563f9d7f616d862fd25b9e3b"><td class="memTemplParams" colspan="2">template&lt;typename Tuple , size_t ... I&gt; </td></tr>
<tr class="memitem:a9dedb058563f9d7f616d862fd25b9e3b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1tuple__type">tuple_type</a>&lt; sizeof...(I), <a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a9dedb058563f9d7f616d862fd25b9e3b">multiply_array_tuple_helper</a> (<a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>(&amp;fCoefficients)[sizeof...(I)], Tuple const &amp;tpl, <a class="el" href="structhydra_1_1detail_1_1index__sequence.html">index_sequence</a>&lt; I... &gt;)</td></tr>
<tr class="separator:a9dedb058563f9d7f616d862fd25b9e3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a983d20b80673f7930cb06751ddfe2685"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename Return_Type , typename ... Tp&gt; </td></tr>
<tr class="memitem:a983d20b80673f7930cb06751ddfe2685"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::detail::enable_if&lt; I==sizeof...(Tp), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a983d20b80673f7930cb06751ddfe2685">multiply_tuple</a> (Return_Type &amp;, hydra::thrust::tuple&lt; Tp... &gt; const &amp;)</td></tr>
<tr class="separator:a983d20b80673f7930cb06751ddfe2685"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac68db34ed817ab2a9dd8dca991576c4f"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename Return_Type , typename ... Tp&gt; </td></tr>
<tr class="memitem:ac68db34ed817ab2a9dd8dca991576c4f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::detail::enable_if&lt;(I&lt; sizeof...(Tp)), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#ac68db34ed817ab2a9dd8dca991576c4f">multiply_tuple</a> (Return_Type &amp;r, hydra::thrust::tuple&lt; Tp... &gt;const &amp;t)</td></tr>
<tr class="separator:ac68db34ed817ab2a9dd8dca991576c4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5306b782f3856dcd6fe0deb087d3d547"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename Return_Type , typename ... Tp&gt; </td></tr>
<tr class="memitem:a5306b782f3856dcd6fe0deb087d3d547"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::detail::enable_if&lt; I==sizeof...(Tp), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a5306b782f3856dcd6fe0deb087d3d547">multiply_tuple</a> (Return_Type &amp;, hydra::thrust::tuple&lt; Tp... &gt; &amp;&amp;)</td></tr>
<tr class="separator:a5306b782f3856dcd6fe0deb087d3d547"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d606d63c86ccd96e65d66a120fa9738"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename Return_Type , typename ... Tp&gt; </td></tr>
<tr class="memitem:a9d606d63c86ccd96e65d66a120fa9738"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::detail::enable_if&lt;(I&lt; sizeof...(Tp)), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a9d606d63c86ccd96e65d66a120fa9738">multiply_tuple</a> (Return_Type &amp;r, hydra::thrust::tuple&lt; Tp... &gt; &amp;&amp;t)</td></tr>
<tr class="separator:a9d606d63c86ccd96e65d66a120fa9738"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae41869730161a24873d2aa958fc6f4cd"><td class="memTemplParams" colspan="2">template&lt;typename ... T, size_t ... I&gt; </td></tr>
<tr class="memitem:ae41869730161a24873d2aa958fc6f4cd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::tuple&lt; T... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#ae41869730161a24873d2aa958fc6f4cd">multiplyTuples</a> (const hydra::thrust::tuple&lt; T... &gt; &amp;a, const hydra::thrust::tuple&lt; T... &gt; &amp;b, <a class="el" href="structhydra_1_1detail_1_1index__sequence.html">index_sequence</a>&lt; I... &gt;)</td></tr>
<tr class="separator:ae41869730161a24873d2aa958fc6f4cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f2f3c283253a975ac058aebfb640535"><td class="memTemplParams" colspan="2">template&lt;typename ... T&gt; </td></tr>
<tr class="memitem:a4f2f3c283253a975ac058aebfb640535"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::tuple&lt; T... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a4f2f3c283253a975ac058aebfb640535">multiplyTuples</a> (const hydra::thrust::tuple&lt; T... &gt; &amp;a, const hydra::thrust::tuple&lt; T... &gt; &amp;b)</td></tr>
<tr class="separator:a4f2f3c283253a975ac058aebfb640535"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a5041517e4c16f7eacb46898f6f029e"><td class="memTemplParams" colspan="2">template&lt;size_t I, typename ... T&gt; </td></tr>
<tr class="memitem:a2a5041517e4c16f7eacb46898f6f029e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::tuple_element&lt; I, hydra::thrust::tuple&lt; T... &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a2a5041517e4c16f7eacb46898f6f029e">multiplyTuplesHelper</a> (const hydra::thrust::tuple&lt; T... &gt; &amp;a, const hydra::thrust::tuple&lt; T... &gt; &amp;b)</td></tr>
<tr class="separator:a2a5041517e4c16f7eacb46898f6f029e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63701869476f9138ea31be4ef303e7c1"><td class="memTemplParams" colspan="2">template&lt;class BidirIt &gt; </td></tr>
<tr class="memitem:a63701869476f9138ea31be4ef303e7c1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a63701869476f9138ea31be4ef303e7c1">next_permutation</a> (BidirIt first, BidirIt last)</td></tr>
<tr class="separator:a63701869476f9138ea31be4ef303e7c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b2e7c87a80dcd5015c2a95ca88f67f1"><td class="memTemplParams" colspan="2">template&lt;typename Iterator , typename Integer , typename Comparator &gt; </td></tr>
<tr class="memitem:a0b2e7c87a80dcd5015c2a95ca88f67f1"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_integral&lt; Integer &gt;::value, void &gt;::type <a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a0b2e7c87a80dcd5015c2a95ca88f67f1">nth_permutation</a> (Iterator <a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>, Iterator <a class="el" href="namespacehydra.html#a4274268d147e9a988f379326b73682b0">end</a>, Integer <a class="el" href="crystal__ball__plus__exponential_8inl.html#a21f77208d6bc667560ff8aaf8f943b6a">n</a>, Comparator comp)</td></tr>
<tr class="separator:a0b2e7c87a80dcd5015c2a95ca88f67f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e34df05c3fc32da9e8fe01dddc9fd7e"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:a6e34df05c3fc32da9e8fe01dddc9fd7e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="classhydra_1_1detail_1_1GenzMalikBoxResult.html">GenzMalikBoxResult</a>&lt; Type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a6e34df05c3fc32da9e8fe01dddc9fd7e">operator+</a> (<a class="el" href="classhydra_1_1detail_1_1GenzMalikBoxResult.html">GenzMalikBoxResult</a>&lt; Type &gt; left, <a class="el" href="classhydra_1_1detail_1_1GenzMalikBoxResult.html">GenzMalikBoxResult</a>&lt; Type &gt; const &amp;right)</td></tr>
<tr class="separator:a6e34df05c3fc32da9e8fe01dddc9fd7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25dfa2f5f8cfb6485dba5d2a4611b217"><td class="memTemplParams" colspan="2">template&lt;typename Type , size_t N&gt; </td></tr>
<tr class="memitem:a25dfa2f5f8cfb6485dba5d2a4611b217"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="classhydra_1_1detail_1_1GenzMalikBoxResult.html">GenzMalikBoxResult</a>&lt; Type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a25dfa2f5f8cfb6485dba5d2a4611b217">operator+</a> (<a class="el" href="classhydra_1_1detail_1_1GenzMalikBoxResult.html">GenzMalikBoxResult</a>&lt; Type &gt; left, <a class="el" href="classhydra_1_1detail_1_1GenzMalikBox.html">GenzMalikBox</a>&lt; N &gt; const &amp;right)</td></tr>
<tr class="separator:a25dfa2f5f8cfb6485dba5d2a4611b217"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c794172447148190ddb210dd1db8a83"><td class="memTemplParams" colspan="2">template&lt;typename T , unsigned int N, unsigned int I&gt; </td></tr>
<tr class="memitem:a1c794172447148190ddb210dd1db8a83"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> std::enable_if&lt; I==N, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a1c794172447148190ddb210dd1db8a83">pow_helper</a> (T const, T &amp;)</td></tr>
<tr class="separator:a1c794172447148190ddb210dd1db8a83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f6c0d8fba43367d54ac4e2ce70f8718"><td class="memTemplParams" colspan="2">template&lt;typename T , unsigned int N, unsigned int I&gt; </td></tr>
<tr class="memitem:a8f6c0d8fba43367d54ac4e2ce70f8718"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> std::enable_if&lt;(I&lt; N), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a8f6c0d8fba43367d54ac4e2ce70f8718">pow_helper</a> (T const x, T &amp;r)</td></tr>
<tr class="separator:a8f6c0d8fba43367d54ac4e2ce70f8718"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3571c0ce97f1472331216a675bb7857"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename ... Tp&gt; </td></tr>
<tr class="memitem:ae3571c0ce97f1472331216a675bb7857"><td class="memTemplItemLeft" align="right" valign="top">hydra::thrust::detail::enable_if&lt; I==sizeof...(Tp), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#ae3571c0ce97f1472331216a675bb7857">print_parameters_in_tuple</a> (hydra::thrust::tuple&lt; Tp... &gt; &amp;)</td></tr>
<tr class="separator:ae3571c0ce97f1472331216a675bb7857"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1df72ec6bac610a8f6d2be642ca1d3a"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename ... Tp&gt; </td></tr>
<tr class="memitem:ae1df72ec6bac610a8f6d2be642ca1d3a"><td class="memTemplItemLeft" align="right" valign="top">hydra::thrust::detail::enable_if&lt;(I&lt; sizeof...(Tp)), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#ae1df72ec6bac610a8f6d2be642ca1d3a">print_parameters_in_tuple</a> (hydra::thrust::tuple&lt; Tp... &gt; &amp;t)</td></tr>
<tr class="separator:ae1df72ec6bac610a8f6d2be642ca1d3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9df96670ef4114c14fa30390b3dca5e"><td class="memTemplParams" colspan="2">template&lt;typename Return_Type , typename ArgType , typename ... Tp, typename  = typename hydra::thrust::detail::enable_if&lt;std::is_convertible&lt;Return_Type, double&gt;::value || std::is_constructible&lt;hydra::thrust::complex&lt;double&gt;,Return_Type&gt;::value &gt;::type&gt; </td></tr>
<tr class="memitem:aa9df96670ef4114c14fa30390b3dca5e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> Return_Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#aa9df96670ef4114c14fa30390b3dca5e">product</a> (ArgType const &amp;x, hydra::thrust::tuple&lt; Tp... &gt; const &amp;t)</td></tr>
<tr class="separator:aa9df96670ef4114c14fa30390b3dca5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad71212520aeba6bfdd5f2f08b1e57949"><td class="memTemplParams" colspan="2">template&lt;typename Return_Type , typename ArgType , typename ... Tp, typename  = typename hydra::thrust::detail::enable_if&lt;std::is_convertible&lt;Return_Type, double&gt;::value || std::is_constructible&lt;hydra::thrust::complex&lt;double&gt;,Return_Type&gt;::value &gt;::type&gt; </td></tr>
<tr class="memitem:ad71212520aeba6bfdd5f2f08b1e57949"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> Return_Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#ad71212520aeba6bfdd5f2f08b1e57949">product</a> (ArgType &amp;x, hydra::thrust::tuple&lt; Tp... &gt; &amp;t)</td></tr>
<tr class="separator:ad71212520aeba6bfdd5f2f08b1e57949"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06f0f7278adec0e18aa797ff500aeec5"><td class="memTemplParams" colspan="2">template&lt;typename Return_Type , typename ArgType1 , typename ArgType2 , typename ... Tp, typename  = typename hydra::thrust::detail::enable_if&lt;std::is_convertible&lt;Return_Type, double&gt;::value || std::is_constructible&lt;hydra::thrust::complex&lt;double&gt;,Return_Type&gt;::value &gt;::type&gt; </td></tr>
<tr class="memitem:a06f0f7278adec0e18aa797ff500aeec5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> Return_Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a06f0f7278adec0e18aa797ff500aeec5">product2</a> (ArgType1 const &amp;x, ArgType2 const &amp;y, hydra::thrust::tuple&lt; Tp... &gt; const &amp;t)</td></tr>
<tr class="separator:a06f0f7278adec0e18aa797ff500aeec5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c82b9ba250e8b4c956796040a58e828"><td class="memTemplParams" colspan="2">template&lt;typename Return_Type , typename ArgType1 , typename ArgType2 , typename ... Tp, typename  = typename hydra::thrust::detail::enable_if&lt;std::is_convertible&lt;Return_Type, double&gt;::value || std::is_constructible&lt;hydra::thrust::complex&lt;double&gt;,Return_Type&gt;::value &gt;::type&gt; </td></tr>
<tr class="memitem:a5c82b9ba250e8b4c956796040a58e828"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> Return_Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a5c82b9ba250e8b4c956796040a58e828">product2</a> (ArgType1 &amp;x, ArgType2 &amp;y, hydra::thrust::tuple&lt; Tp... &gt; &amp;t)</td></tr>
<tr class="separator:a5c82b9ba250e8b4c956796040a58e828"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adabaf23bc5b2f9f9c80cbd757274ce52"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename Return_Type , typename ArgType , typename ... Tp&gt; </td></tr>
<tr class="memitem:adabaf23bc5b2f9f9c80cbd757274ce52"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::detail::enable_if&lt; I==sizeof...(Tp), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#adabaf23bc5b2f9f9c80cbd757274ce52">product_tuple</a> (Return_Type &amp;, hydra::thrust::tuple&lt; Tp... &gt; const &amp;, ArgType const &amp;)</td></tr>
<tr class="separator:adabaf23bc5b2f9f9c80cbd757274ce52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09a64a12d8e0efe71a16254afed3ce51"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename Return_Type , typename ArgType , typename ... Tp&gt; </td></tr>
<tr class="memitem:a09a64a12d8e0efe71a16254afed3ce51"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::detail::enable_if&lt;(I&lt; sizeof...(Tp)), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a09a64a12d8e0efe71a16254afed3ce51">product_tuple</a> (Return_Type &amp;r, hydra::thrust::tuple&lt; Tp... &gt; const &amp;t, ArgType const &amp;<a class="el" href="namespacehydra.html#ae96191cbaa62c58f63b7e58924362c24">arg</a>)</td></tr>
<tr class="separator:a09a64a12d8e0efe71a16254afed3ce51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7ce3d4782e6cc3741d7c22a0a1e6ff4"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename Return_Type , typename ArgType , typename ... Tp&gt; </td></tr>
<tr class="memitem:ab7ce3d4782e6cc3741d7c22a0a1e6ff4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::detail::enable_if&lt; I==sizeof...(Tp), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#ab7ce3d4782e6cc3741d7c22a0a1e6ff4">product_tuple</a> (Return_Type &amp;, hydra::thrust::tuple&lt; Tp... &gt; &amp;&amp;, ArgType &amp;&amp;)</td></tr>
<tr class="separator:ab7ce3d4782e6cc3741d7c22a0a1e6ff4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ddfad88876786c74e596db9c81b2850"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename Return_Type , typename ArgType , typename ... Tp&gt; </td></tr>
<tr class="memitem:a4ddfad88876786c74e596db9c81b2850"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::detail::enable_if&lt;(I&lt; sizeof...(Tp)), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a4ddfad88876786c74e596db9c81b2850">product_tuple</a> (Return_Type &amp;r, hydra::thrust::tuple&lt; Tp... &gt; &amp;&amp;t, ArgType &amp;&amp;<a class="el" href="namespacehydra.html#ae96191cbaa62c58f63b7e58924362c24">arg</a>)</td></tr>
<tr class="separator:a4ddfad88876786c74e596db9c81b2850"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dd180e5db52df8b603f54eccec23540"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename Return_Type , typename ArgType1 , typename ArgType2 , typename ... Tp&gt; </td></tr>
<tr class="memitem:a9dd180e5db52df8b603f54eccec23540"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::detail::enable_if&lt; I==sizeof...(Tp), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a9dd180e5db52df8b603f54eccec23540">product_tuple2</a> (Return_Type &amp;, hydra::thrust::tuple&lt; Tp... &gt; const &amp;, ArgType1 const &amp;, ArgType2 const &amp;)</td></tr>
<tr class="separator:a9dd180e5db52df8b603f54eccec23540"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab889266aba923c3d948f60ed385743f5"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename Return_Type , typename ArgType1 , typename ArgType2 , typename ... Tp&gt; </td></tr>
<tr class="memitem:ab889266aba923c3d948f60ed385743f5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::detail::enable_if&lt;(I&lt;(sizeof...(Tp))), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#ab889266aba923c3d948f60ed385743f5">product_tuple2</a> (Return_Type &amp;r, hydra::thrust::tuple&lt; Tp... &gt; const &amp;t, ArgType1 const &amp;arg1, ArgType2 const &amp;arg2)</td></tr>
<tr class="separator:ab889266aba923c3d948f60ed385743f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a439342ca452238b86683172c616af275"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename Return_Type , typename ArgType1 , typename ArgType2 , typename ... Tp&gt; </td></tr>
<tr class="memitem:a439342ca452238b86683172c616af275"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::detail::enable_if&lt; I==sizeof...(Tp), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a439342ca452238b86683172c616af275">product_tuple2</a> (Return_Type &amp;, hydra::thrust::tuple&lt; Tp... &gt; &amp;&amp;, ArgType1 &amp;&amp;, ArgType2 &amp;&amp;)</td></tr>
<tr class="separator:a439342ca452238b86683172c616af275"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae57819631ed091712bbf07475ead232"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename Return_Type , typename ArgType1 , typename ArgType2 , typename ... Tp&gt; </td></tr>
<tr class="memitem:aae57819631ed091712bbf07475ead232"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::detail::enable_if&lt;(I&lt;(sizeof...(Tp))), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#aae57819631ed091712bbf07475ead232">product_tuple2</a> (Return_Type &amp;r, hydra::thrust::tuple&lt; Tp... &gt; &amp;&amp;t, ArgType1 &amp;&amp;arg1, ArgType2 &amp;&amp;arg2)</td></tr>
<tr class="separator:aae57819631ed091712bbf07475ead232"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a3a2145b19503fed123dff2196155c3"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, size_t N, typename Return_Type , typename ArgType1 , typename ArgType2 , typename ... Tp&gt; </td></tr>
<tr class="memitem:a5a3a2145b19503fed123dff2196155c3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::detail::enable_if&lt; I==N, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a5a3a2145b19503fed123dff2196155c3">product_tuple3</a> (Return_Type &amp;, hydra::thrust::tuple&lt; Tp... &gt; const &amp;, ArgType1 const &amp;, ArgType2 const &amp;)</td></tr>
<tr class="separator:a5a3a2145b19503fed123dff2196155c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6561fc8b52118b1c2139a976128cb4e"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, size_t N, typename Return_Type , typename ArgType1 , typename ArgType2 , typename ... Tp&gt; </td></tr>
<tr class="memitem:af6561fc8b52118b1c2139a976128cb4e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::detail::enable_if&lt;(I&lt; N), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#af6561fc8b52118b1c2139a976128cb4e">product_tuple3</a> (Return_Type &amp;r, hydra::thrust::tuple&lt; Tp... &gt; const &amp;t, ArgType1 const &amp;arg1, ArgType2 const &amp;arg2)</td></tr>
<tr class="separator:af6561fc8b52118b1c2139a976128cb4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf3f3a459fd81baba8d17ad3db69aae9"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, size_t N, typename Return_Type , typename ArgType1 , typename ArgType2 , typename ... Tp&gt; </td></tr>
<tr class="memitem:aaf3f3a459fd81baba8d17ad3db69aae9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::detail::enable_if&lt; I==N, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#aaf3f3a459fd81baba8d17ad3db69aae9">product_tuple3</a> (Return_Type &amp;, hydra::thrust::tuple&lt; Tp... &gt; &amp;&amp;, ArgType1 &amp;&amp;, ArgType2 &amp;&amp;)</td></tr>
<tr class="separator:aaf3f3a459fd81baba8d17ad3db69aae9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b12b4c186d19a36238c7e82cd8d4348"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, size_t N, typename Return_Type , typename ArgType1 , typename ArgType2 , typename ... Tp&gt; </td></tr>
<tr class="memitem:a6b12b4c186d19a36238c7e82cd8d4348"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::detail::enable_if&lt;(I&lt; N), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a6b12b4c186d19a36238c7e82cd8d4348">product_tuple3</a> (Return_Type &amp;r, hydra::thrust::tuple&lt; Tp... &gt; &amp;&amp;t, ArgType1 &amp;&amp;arg1, ArgType2 &amp;&amp;arg2)</td></tr>
<tr class="separator:a6b12b4c186d19a36238c7e82cd8d4348"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9108ba6cbf5144a048fa7c2ed068d5ba"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a9108ba6cbf5144a048fa7c2ed068d5ba"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a9108ba6cbf5144a048fa7c2ed068d5ba">ptr_setter</a> (T1 *&amp;ptr, typename hydra::thrust::detail::enable_if&lt; hydra::thrust::detail::is_same&lt; T1, T2 &gt;::value, T2 &gt;::type *el)</td></tr>
<tr class="separator:a9108ba6cbf5144a048fa7c2ed068d5ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a607a6a529236b69164e1a4a446a6e8c7"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a607a6a529236b69164e1a4a446a6e8c7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a607a6a529236b69164e1a4a446a6e8c7">ptr_setter</a> (T1 *&amp;, typename hydra::thrust::detail::enable_if&lt;!hydra::thrust::detail::is_same&lt; T1, T2 &gt;::value, T2 &gt;::type *)</td></tr>
<tr class="separator:a607a6a529236b69164e1a4a446a6e8c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab46acd298d2f60edf21c334fa8823d65"><td class="memTemplParams" colspan="2">template&lt;class Iterator &gt; </td></tr>
<tr class="memitem:ab46acd298d2f60edf21c334fa8823d65"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> Iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#ab46acd298d2f60edf21c334fa8823d65">rotate</a> (Iterator first, Iterator n_first, Iterator last)</td></tr>
<tr class="separator:ab46acd298d2f60edf21c334fa8823d65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02aa7a21cd5aca1e6cba7419e0009a9f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a02aa7a21cd5aca1e6cba7419e0009a9f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a02aa7a21cd5aca1e6cba7419e0009a9f">SafeGreaterThan</a> (T a, T b, T tolerance=<a class="el" href="namespacehydra_1_1detail.html#af60fc3e60cc10bd79092ca02c8e8b84c">machine_eps_f64</a>())</td></tr>
<tr class="separator:a02aa7a21cd5aca1e6cba7419e0009a9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b57eb5fbdba90142d2127ab29514de7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8b57eb5fbdba90142d2127ab29514de7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a8b57eb5fbdba90142d2127ab29514de7">SafeLessThan</a> (T a, T b, T tolerance=<a class="el" href="namespacehydra_1_1detail.html#af60fc3e60cc10bd79092ca02c8e8b84c">machine_eps_f64</a>())</td></tr>
<tr class="separator:a8b57eb5fbdba90142d2127ab29514de7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa21b24762fe6b3793d99a9c02bd523c1"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename ... Tp&gt; </td></tr>
<tr class="memitem:aa21b24762fe6b3793d99a9c02bd523c1"><td class="memTemplItemLeft" align="right" valign="top">hydra::thrust::detail::enable_if&lt; I==sizeof...(Tp), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#aa21b24762fe6b3793d99a9c02bd523c1">set_functors_in_tuple</a> (hydra::thrust::tuple&lt; Tp... &gt; &amp;, const std::vector&lt; <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt; &amp;)</td></tr>
<tr class="separator:aa21b24762fe6b3793d99a9c02bd523c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc2e3e251a1ba97b903c37dcf6b7614d"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename ... Tp&gt; </td></tr>
<tr class="memitem:afc2e3e251a1ba97b903c37dcf6b7614d"><td class="memTemplItemLeft" align="right" valign="top">hydra::thrust::detail::enable_if&lt;(I&lt; sizeof...(Tp)), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#afc2e3e251a1ba97b903c37dcf6b7614d">set_functors_in_tuple</a> (hydra::thrust::tuple&lt; Tp... &gt; &amp;t, const std::vector&lt; <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt; &amp;parameters)</td></tr>
<tr class="separator:afc2e3e251a1ba97b903c37dcf6b7614d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57a43797825f305b178079f80fc79d11"><td class="memTemplParams" colspan="2">template&lt;unsigned int I, typename Ptr , typename ... Tp&gt; </td></tr>
<tr class="memitem:a57a43797825f305b178079f80fc79d11"><td class="memTemplItemLeft" align="right" valign="top">hydra::thrust::detail::enable_if&lt; I==sizeof...(Tp), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a57a43797825f305b178079f80fc79d11">set_ptr_to_tuple_element</a> (const <a class="el" href="namespace_3globalScope_4.html#classint">int</a>, std::tuple&lt; Tp... &gt; &amp;, Ptr *&amp;)</td></tr>
<tr class="separator:a57a43797825f305b178079f80fc79d11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed57cabad1c9b745eafc489910884b2c"><td class="memTemplParams" colspan="2">template&lt;unsigned int I = 0, typename Ptr , typename ... Tp&gt; </td></tr>
<tr class="memitem:aed57cabad1c9b745eafc489910884b2c"><td class="memTemplItemLeft" align="right" valign="top">hydra::thrust::detail::enable_if&lt;(I&lt; sizeof...(Tp)), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#aed57cabad1c9b745eafc489910884b2c">set_ptr_to_tuple_element</a> (const <a class="el" href="namespace_3globalScope_4.html#classint">int</a> index, std::tuple&lt; Tp... &gt; &amp;t, Ptr *&amp;ptr)</td></tr>
<tr class="separator:aed57cabad1c9b745eafc489910884b2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fc1f520b1120b2292937669d6c66505"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename Array_Type , typename T &gt; </td></tr>
<tr class="memitem:a2fc1f520b1120b2292937669d6c66505"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::detail::enable_if&lt;(I==hydra::thrust::tuple_size&lt; T &gt;::value) &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1is__homogeneous.html">is_homogeneous</a>&lt; Array_Type, T &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a2fc1f520b1120b2292937669d6c66505">set_ptrs_to_tuple</a> (T &amp;, Array_Type **)</td></tr>
<tr class="separator:a2fc1f520b1120b2292937669d6c66505"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abced9457fd3703a8bf8b1a5d762ffb4b"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename Array_Type , typename T &gt; </td></tr>
<tr class="memitem:abced9457fd3703a8bf8b1a5d762ffb4b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::detail::enable_if&lt;(I&lt; hydra::thrust::tuple_size&lt; T &gt;::value) &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1is__homogeneous.html">is_homogeneous</a>&lt; Array_Type, T &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#abced9457fd3703a8bf8b1a5d762ffb4b">set_ptrs_to_tuple</a> (T &amp;t, Array_Type **Array)</td></tr>
<tr class="separator:abced9457fd3703a8bf8b1a5d762ffb4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54539a1b1cee55ab70dc738bc89a5180"><td class="memTemplParams" colspan="2">template&lt;unsigned int I = 0, typename T , typename ... Tp&gt; </td></tr>
<tr class="memitem:a54539a1b1cee55ab70dc738bc89a5180"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::detail::enable_if&lt; I==sizeof...(Tp), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a54539a1b1cee55ab70dc738bc89a5180">set_tuple_element</a> (const <a class="el" href="namespace_3globalScope_4.html#classint">int</a>, hydra::thrust::tuple&lt; Tp... &gt; const &amp;, T &amp;)</td></tr>
<tr class="separator:a54539a1b1cee55ab70dc738bc89a5180"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8d27d3aecd240e4d7d3300bfc2ee63b"><td class="memTemplParams" colspan="2">template&lt;unsigned int I = 0, typename T , typename ... Tp&gt; </td></tr>
<tr class="memitem:ad8d27d3aecd240e4d7d3300bfc2ee63b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::detail::enable_if&lt;(I&lt; sizeof...(Tp)), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#ad8d27d3aecd240e4d7d3300bfc2ee63b">set_tuple_element</a> (const <a class="el" href="namespace_3globalScope_4.html#classint">int</a> index, hydra::thrust::tuple&lt; Tp... &gt; &amp;t, const T &amp;x)</td></tr>
<tr class="separator:ad8d27d3aecd240e4d7d3300bfc2ee63b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0125c53a3b2aac1cab9e83d65b6494f6"><td class="memTemplParams" colspan="2">template&lt;typename ... T1, typename ... T2&gt; </td></tr>
<tr class="memitem:a0125c53a3b2aac1cab9e83d65b6494f6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a0125c53a3b2aac1cab9e83d65b6494f6">split_tuple</a> (hydra::thrust::tuple&lt; T1... &gt; &amp;t1, hydra::thrust::tuple&lt; T2... &gt; &amp;t2, hydra::thrust::tuple&lt; T1..., T2... &gt; const &amp;t)</td></tr>
<tr class="separator:a0125c53a3b2aac1cab9e83d65b6494f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ab8d8856893dad2e11b1293005e5d35"><td class="memTemplParams" colspan="2">template&lt;size_t N, typename ... T&gt; </td></tr>
<tr class="memitem:a1ab8d8856893dad2e11b1293005e5d35"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a1ab8d8856893dad2e11b1293005e5d35">split_tuple</a> (hydra::thrust::tuple&lt; T... &gt; &amp;t) -&gt; decltype(<a class="el" href="namespacehydra_1_1detail.html#aaa93f2fd80191b1999092757e023a29c">split_tuple_helper</a>(t, <a class="el" href="structhydra_1_1detail_1_1make__index__sequence.html">make_index_sequence</a>&lt; N &gt;</td></tr>
<tr class="separator:a1ab8d8856893dad2e11b1293005e5d35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa93f2fd80191b1999092757e023a29c"><td class="memTemplParams" colspan="2">template&lt;typename ... T1, typename ... T2, size_t... I1, size_t... I2&gt; </td></tr>
<tr class="memitem:aaa93f2fd80191b1999092757e023a29c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#aaa93f2fd80191b1999092757e023a29c">split_tuple_helper</a> (hydra::thrust::tuple&lt; T1... &gt; &amp;t1, hydra::thrust::tuple&lt; T2... &gt; &amp;t2, hydra::thrust::tuple&lt; T1..., T2... &gt; const &amp;t, <a class="el" href="structhydra_1_1detail_1_1index__sequence.html">index_sequence</a>&lt; I1... &gt;, <a class="el" href="structhydra_1_1detail_1_1index__sequence.html">index_sequence</a>&lt; I2... &gt;)</td></tr>
<tr class="separator:aaa93f2fd80191b1999092757e023a29c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93552a3e6c3a7d409faf3ad676479465"><td class="memTemplParams" colspan="2">template&lt;typename ... T, size_t... I1, size_t... I2&gt; </td></tr>
<tr class="memitem:a93552a3e6c3a7d409faf3ad676479465"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a93552a3e6c3a7d409faf3ad676479465">split_tuple_helper</a> (hydra::thrust::tuple&lt; T... &gt; &amp;t, <a class="el" href="structhydra_1_1detail_1_1index__sequence.html">index_sequence</a>&lt; I1... &gt;, <a class="el" href="structhydra_1_1detail_1_1index__sequence.html">index_sequence</a>&lt; I2... &gt;) -&gt; decltype(hydra::thrust::make_pair(hydra::thrust::tie(hydra::thrust::get&lt; I1 &gt;(t)...), hydra::thrust::tie(hydra::thrust::get&lt; I2++sizeof...(I1)&gt;(t)...)))</td></tr>
<tr class="separator:a93552a3e6c3a7d409faf3ad676479465"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d99f4894a305719c52f70093f870fc9"><td class="memTemplParams" colspan="2">template&lt;typename ... T, size_t ... I&gt; </td></tr>
<tr class="memitem:a7d99f4894a305719c52f70093f870fc9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::tuple&lt; T... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a7d99f4894a305719c52f70093f870fc9">subtractTuples</a> (const hydra::thrust::tuple&lt; T... &gt; &amp;a, const hydra::thrust::tuple&lt; T... &gt; &amp;b, <a class="el" href="structhydra_1_1detail_1_1index__sequence.html">index_sequence</a>&lt; I... &gt;)</td></tr>
<tr class="separator:a7d99f4894a305719c52f70093f870fc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee7e4bcbfcf9c3c4d4c9c0ac8e48925e"><td class="memTemplParams" colspan="2">template&lt;typename ... T&gt; </td></tr>
<tr class="memitem:aee7e4bcbfcf9c3c4d4c9c0ac8e48925e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::tuple&lt; T... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#aee7e4bcbfcf9c3c4d4c9c0ac8e48925e">subtractTuples</a> (const hydra::thrust::tuple&lt; T... &gt; &amp;a, const hydra::thrust::tuple&lt; T... &gt; &amp;b)</td></tr>
<tr class="separator:aee7e4bcbfcf9c3c4d4c9c0ac8e48925e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5657e7fa1567c800bafeca39c0aa09c8"><td class="memTemplParams" colspan="2">template&lt;size_t I, typename ... T&gt; </td></tr>
<tr class="memitem:a5657e7fa1567c800bafeca39c0aa09c8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::tuple_element&lt; I, hydra::thrust::tuple&lt; T... &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a5657e7fa1567c800bafeca39c0aa09c8">subtractTuplesHelper</a> (const hydra::thrust::tuple&lt; T... &gt; &amp;a, const hydra::thrust::tuple&lt; T... &gt; &amp;b)</td></tr>
<tr class="separator:a5657e7fa1567c800bafeca39c0aa09c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a0afb276fe05c1beafcecc2e0f2b9e6"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename Return_Type , typename ArgType , typename ... Tp&gt; </td></tr>
<tr class="memitem:a1a0afb276fe05c1beafcecc2e0f2b9e6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::detail::enable_if&lt; I==sizeof...(Tp), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a1a0afb276fe05c1beafcecc2e0f2b9e6">sum_tuple</a> (Return_Type &amp;, hydra::thrust::tuple&lt; Tp... &gt; &amp;&amp;, ArgType &amp;&amp;)</td></tr>
<tr class="separator:a1a0afb276fe05c1beafcecc2e0f2b9e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a88f79d07aa17ce1978e5685ab4e6a1"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename Return_Type , typename ArgType , typename ... Tp&gt; </td></tr>
<tr class="memitem:a6a88f79d07aa17ce1978e5685ab4e6a1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::detail::enable_if&lt;(I&lt; sizeof...(Tp)), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a6a88f79d07aa17ce1978e5685ab4e6a1">sum_tuple</a> (Return_Type &amp;r, hydra::thrust::tuple&lt; Tp... &gt; &amp;&amp;t, ArgType &amp;&amp;<a class="el" href="namespacehydra.html#ae96191cbaa62c58f63b7e58924362c24">arg</a>)</td></tr>
<tr class="separator:a6a88f79d07aa17ce1978e5685ab4e6a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aceecb8b30f5203c57207c892d3ceb4c3"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename Return_Type , typename ArgType , typename ... Tp&gt; </td></tr>
<tr class="memitem:aceecb8b30f5203c57207c892d3ceb4c3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::detail::enable_if&lt; I==sizeof...(Tp), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#aceecb8b30f5203c57207c892d3ceb4c3">sum_tuple</a> (Return_Type &amp;, hydra::thrust::tuple&lt; Tp... &gt; const &amp;, ArgType const &amp;)</td></tr>
<tr class="separator:aceecb8b30f5203c57207c892d3ceb4c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecd4cf8b1f9353041de1f411389ab66d"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename Return_Type , typename ArgType , typename ... Tp&gt; </td></tr>
<tr class="memitem:aecd4cf8b1f9353041de1f411389ab66d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::detail::enable_if&lt;(I&lt; sizeof...(Tp)), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#aecd4cf8b1f9353041de1f411389ab66d">sum_tuple</a> (Return_Type &amp;r, hydra::thrust::tuple&lt; Tp... &gt;const &amp;t, ArgType const &amp;<a class="el" href="namespacehydra.html#ae96191cbaa62c58f63b7e58924362c24">arg</a>)</td></tr>
<tr class="separator:aecd4cf8b1f9353041de1f411389ab66d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ad8cca28a9c44ae90b5db186e5cd7ea"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename Return_Type , typename ArgType1 , typename ArgType2 , typename ... Tp&gt; </td></tr>
<tr class="memitem:a6ad8cca28a9c44ae90b5db186e5cd7ea"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::detail::enable_if&lt; I==sizeof...(Tp), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a6ad8cca28a9c44ae90b5db186e5cd7ea">sum_tuple2</a> (Return_Type &amp;, hydra::thrust::tuple&lt; Tp... &gt; &amp;&amp;, ArgType1 &amp;&amp;, ArgType2 &amp;&amp;)</td></tr>
<tr class="separator:a6ad8cca28a9c44ae90b5db186e5cd7ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7177c6a22b6fa4af64a6b0a27d80b984"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename Return_Type , typename ArgType1 , typename ArgType2 , typename ... Tp&gt; </td></tr>
<tr class="memitem:a7177c6a22b6fa4af64a6b0a27d80b984"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::detail::enable_if&lt;(I&lt; sizeof...(Tp)), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a7177c6a22b6fa4af64a6b0a27d80b984">sum_tuple2</a> (Return_Type &amp;r, hydra::thrust::tuple&lt; Tp... &gt; &amp;&amp;t, ArgType1 &amp;&amp;arg1, ArgType2 &amp;&amp;arg2)</td></tr>
<tr class="separator:a7177c6a22b6fa4af64a6b0a27d80b984"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cb4a9045ea6dd505cf04d74c52e61f4"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename Return_Type , typename ArgType1 , typename ArgType2 , typename ... Tp&gt; </td></tr>
<tr class="memitem:a9cb4a9045ea6dd505cf04d74c52e61f4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::detail::enable_if&lt; I==sizeof...(Tp), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a9cb4a9045ea6dd505cf04d74c52e61f4">sum_tuple2</a> (Return_Type &amp;, hydra::thrust::tuple&lt; Tp... &gt;const &amp;, ArgType1 const &amp;, ArgType2 const &amp;)</td></tr>
<tr class="separator:a9cb4a9045ea6dd505cf04d74c52e61f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e41539382f482a4d344b87c7f7a46e5"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename Return_Type , typename ArgType1 , typename ArgType2 , typename ... Tp&gt; </td></tr>
<tr class="memitem:a4e41539382f482a4d344b87c7f7a46e5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::detail::enable_if&lt;(I&lt; sizeof...(Tp)), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a4e41539382f482a4d344b87c7f7a46e5">sum_tuple2</a> (Return_Type &amp;r, hydra::thrust::tuple&lt; Tp... &gt; const &amp;t, ArgType1 const &amp;arg1, ArgType2 const &amp;arg2)</td></tr>
<tr class="separator:a4e41539382f482a4d344b87c7f7a46e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a238d20dfda2677074a1e3d48b29be54a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a238d20dfda2677074a1e3d48b29be54a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__tuple.html">detail::is_tuple</a>&lt; T &gt;::value, T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a238d20dfda2677074a1e3d48b29be54a">tupler</a> (T const &amp;<a class="el" href="basic__distributions_8inl.html#a248ea98483ce90baaf65a7682438d72d">data</a>)</td></tr>
<tr class="separator:a238d20dfda2677074a1e3d48b29be54a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19f0ad5cca44b69a03162009efcb2092"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a19f0ad5cca44b69a03162009efcb2092"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> std::enable_if&lt;!<a class="el" href="structhydra_1_1detail_1_1is__tuple.html">detail::is_tuple</a>&lt; T &gt;::value, <a class="el" href="namespacehydra.html#ac3486502b2db72187626125cea971683">hydra::tuple</a>&lt; T &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a19f0ad5cca44b69a03162009efcb2092">tupler</a> (T const &amp;<a class="el" href="basic__distributions_8inl.html#a248ea98483ce90baaf65a7682438d72d">data</a>)</td></tr>
<tr class="separator:a19f0ad5cca44b69a03162009efcb2092"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c77a410602498524dfb5844857c84dc"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename FistType , typename ... OtherTypes&gt; </td></tr>
<tr class="memitem:a3c77a410602498524dfb5844857c84dc"><td class="memTemplItemLeft" align="right" valign="top">hydra::thrust::detail::enable_if&lt; I==(sizeof...(OtherTypes)+1) &amp;&amp;<a class="el" href="namespacehydra_1_1detail.html#a3c72e1aed3a4538dac06a7e816543c23">are_all_same</a>&lt; FistType, OtherTypes... &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a3c77a410602498524dfb5844857c84dc">tupleToArray</a> (hydra::thrust::tuple&lt; FistType, OtherTypes... &gt; const &amp;, std::array&lt; FistType, sizeof...(OtherTypes)+1 &gt; &amp;)</td></tr>
<tr class="separator:a3c77a410602498524dfb5844857c84dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0af1f330ae7d29bf0b1e33eb3f655af"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename FistType , typename ... OtherTypes&gt; </td></tr>
<tr class="memitem:ae0af1f330ae7d29bf0b1e33eb3f655af"><td class="memTemplItemLeft" align="right" valign="top">hydra::thrust::detail::enable_if&lt;(I&lt; sizeof...(OtherTypes)+1) &amp;&amp;<a class="el" href="namespacehydra_1_1detail.html#a3c72e1aed3a4538dac06a7e816543c23">are_all_same</a>&lt; FistType, OtherTypes... &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#ae0af1f330ae7d29bf0b1e33eb3f655af">tupleToArray</a> (hydra::thrust::tuple&lt; FistType, OtherTypes... &gt; const &amp;t, std::array&lt; FistType, sizeof...(OtherTypes)+1 &gt; &amp;Array)</td></tr>
<tr class="separator:ae0af1f330ae7d29bf0b1e33eb3f655af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a811265beb04612913fec71efc6c97af4"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename FistType , typename ... OtherTypes&gt; </td></tr>
<tr class="memitem:a811265beb04612913fec71efc6c97af4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::detail::enable_if&lt; I==(sizeof...(OtherTypes)+1) &amp;&amp;<a class="el" href="namespacehydra_1_1detail.html#a3c72e1aed3a4538dac06a7e816543c23">are_all_same</a>&lt; FistType, OtherTypes... &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a811265beb04612913fec71efc6c97af4">tupleToArray</a> (hydra::thrust::tuple&lt; FistType, OtherTypes... &gt; const &amp;, typename std::remove_reference&lt; FistType &gt;::type *)</td></tr>
<tr class="separator:a811265beb04612913fec71efc6c97af4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89c1bed6272c8b2efecbe3032ab769a4"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename FistType , typename ... OtherTypes&gt; </td></tr>
<tr class="memitem:a89c1bed6272c8b2efecbe3032ab769a4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::detail::enable_if&lt;(I&lt; sizeof...(OtherTypes)+1) &amp;&amp;<a class="el" href="namespacehydra_1_1detail.html#a3c72e1aed3a4538dac06a7e816543c23">are_all_same</a>&lt; FistType, OtherTypes... &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a89c1bed6272c8b2efecbe3032ab769a4">tupleToArray</a> (hydra::thrust::tuple&lt; FistType, OtherTypes... &gt; const &amp;t, typename std::remove_reference&lt; FistType &gt;::type *Array)</td></tr>
<tr class="separator:a89c1bed6272c8b2efecbe3032ab769a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01f6c991c9345e0ef585f5c1e85773a3"><td class="memTemplParams" colspan="2">template&lt;typename TupleType , typename ArrayType &gt; </td></tr>
<tr class="memitem:a01f6c991c9345e0ef585f5c1e85773a3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::detail::enable_if&lt;(<a class="el" href="structhydra_1_1detail_1_1is__instantiation__of.html">detail::is_instantiation_of</a>&lt; hydra::thrust::tuple, TupleType &gt;::value||<a class="el" href="structhydra_1_1detail_1_1is__instantiation__of.html">detail::is_instantiation_of</a>&lt; hydra::thrust::detail::tuple_of_iterator_references, TupleType &gt;::value), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a01f6c991c9345e0ef585f5c1e85773a3">tupleToArray</a> (TupleType const &amp;_tuple, ArrayType *_array)</td></tr>
<tr class="separator:a01f6c991c9345e0ef585f5c1e85773a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2864aeaf911297306efcc70d9ed617d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab2864aeaf911297306efcc70d9ed617d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#ab2864aeaf911297306efcc70d9ed617d">WithinPrecisionInterval</a> (T b, T a, <a class="el" href="namespace_3globalScope_4.html#classunsigned">unsigned</a> <a class="el" href="namespace_3globalScope_4.html#classint">int</a> interval_size=1)</td></tr>
<tr class="separator:ab2864aeaf911297306efcc70d9ed617d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d803c1c594f979fb4a8f4beae580766"><td class="memTemplParams" colspan="2">template&lt;typename ... T&gt; </td></tr>
<tr class="memitem:a6d803c1c594f979fb4a8f4beae580766"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1all__true.html">all_true</a>&lt; <a class="el" href="structhydra_1_1detail_1_1is__zip__iterator.html">is_zip_iterator</a>&lt; T &gt;::value... &gt;::value, typename <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1merged__zip__iterator">detail::merged_zip_iterator</a>&lt; T... &gt;::type &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a6d803c1c594f979fb4a8f4beae580766">zip_iterator_cat</a> (T const &amp;... zip_iterators)</td></tr>
<tr class="separator:a6d803c1c594f979fb4a8f4beae580766"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a6e5ce23b23364c64166f4c390f0f5f03"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a6e5ce23b23364c64166f4c390f0f5f03">make_index_sequence&lt; sizeof...(T) -N &gt;</a></td></tr>
<tr class="separator:a6e5ce23b23364c64166f4c390f0f5f03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50b277339704a9d22de5802abfd3ff22"><td class="memTemplParams" colspan="2">template&lt;typename T , typename C , size_t N, size_t I = 1&gt; </td></tr>
<tr class="memitem:a50b277339704a9d22de5802abfd3ff22"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> std::enable_if&lt; I&lt; N, void &gt;::type <a class="el" href="namespacehydra_1_1detail.html#aa4140580867ee73e401e1bb1e213548c">max_helper</a>(T const  &amp;<a class="el" href="namespacehydra.html#ac3486502b2db72187626125cea971683">tuple</a>, <a class="el" href="basic__distributions_8inl.html#a4900ef306eb9271438791f1a98b8ccba">C</a> &amp;max_value, size_t &amp;max_index){ max_index=max_value &gt; hydra::thrust::get&lt; I &gt;(<a class="el" href="namespacehydra.html#ac3486502b2db72187626125cea971683">tuple</a>) ? max_index&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a50b277339704a9d22de5802abfd3ff22">max_value</a> = max_value &gt; hydra::thrust::get&lt;I&gt;(<a class="el" href="namespacehydra.html#ac3486502b2db72187626125cea971683">tuple</a>) ? max_value : hydra::thrust::get&lt;I&gt;(<a class="el" href="namespacehydra.html#ac3486502b2db72187626125cea971683">tuple</a>)</td></tr>
<tr class="separator:a50b277339704a9d22de5802abfd3ff22"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<hr/><h2 class="groupheader">Data Structure Documentation</h2>
<a name="structhydra_1_1detail_1_1__merge__and__renumber" id="structhydra_1_1detail_1_1__merge__and__renumber"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1detail_1_1__merge__and__renumber">&#9670;&nbsp;</a></span>hydra::detail::_merge_and_renumber</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::detail::_merge_and_renumber</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;class Sequence1, class Sequence2&gt;<br />
struct hydra::detail::_merge_and_renumber&lt; Sequence1, Sequence2 &gt;</h3>

</div><div class="dynheader">
Inheritance diagram for hydra::detail::_merge_and_renumber&lt; Sequence1, Sequence2 &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1__merge__and__renumber__inherit__graph.svg" width="284" height="487"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Collaboration diagram for hydra::detail::_merge_and_renumber&lt; Sequence1, Sequence2 &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1__merge__and__renumber__coll__graph.svg" width="203" height="118"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a name="structhydra_1_1detail_1_1append__to__type__seq" id="structhydra_1_1detail_1_1append__to__type__seq"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1detail_1_1append__to__type__seq">&#9670;&nbsp;</a></span>hydra::detail::append_to_type_seq</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::detail::append_to_type_seq</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename, typename&gt;<br />
struct hydra::detail::append_to_type_seq&lt; typename, typename &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::detail::append_to_type_seq&lt; typename, typename &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1append__to__type__seq__coll__graph.svg" width="184" height="118"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a name="structhydra_1_1detail_1_1append__to__type__seq_3_01T_00_01TT_3_01Ts_8_8_8_01_4_01_4" id="structhydra_1_1detail_1_1append__to__type__seq_3_01T_00_01TT_3_01Ts_8_8_8_01_4_01_4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1detail_1_1append__to__type__seq_3_01T_00_01TT_3_01Ts_8_8_8_01_4_01_4">&#9670;&nbsp;</a></span>hydra::detail::append_to_type_seq&lt; T, TT&lt; Ts... &gt; &gt;</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::detail::append_to_type_seq&lt; T, TT&lt; Ts... &gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename T, typename... Ts, template&lt; typename... &gt; class TT&gt;<br />
struct hydra::detail::append_to_type_seq&lt; T, TT&lt; Ts... &gt; &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::detail::append_to_type_seq&lt; T, TT&lt; Ts... &gt; &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1append__to__type__seq_3_01T_00_01TT_3_01Ts_8_8_8_01_4_01_4__coll__graph.svg" width="162" height="118"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a96007bd667e99ae9126cb0378e0ea3d9"></a></td>
<td class="fieldname">
type</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structhydra_1_1detail_1_1BackendPolicy" id="structhydra_1_1detail_1_1BackendPolicy"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1detail_1_1BackendPolicy">&#9670;&nbsp;</a></span>hydra::detail::BackendPolicy</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::detail::BackendPolicy</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;Backend BACKEND&gt;<br />
struct hydra::detail::BackendPolicy&lt; BACKEND &gt;</h3>

<dl><dt><b>Examples: </b></dt><dd><a class="el" href="dalitz_plot_8C-example.html#_a45">dalitz_plot.C</a>, <a class="el" href="dalitz_plot_8inl-example.html#_a48">dalitz_plot.inl</a>, <a class="el" href="dense_histogram_8inl-example.html#_a13">dense_histogram.inl</a>, <a class="el" href="multidimensional_fit_8inl-example.html#_a39">multidimensional_fit.inl</a>, <a class="el" href="multivector_container_8inl-example.html#_a7">multivector_container.inl</a>, <a class="el" href="phsp_basic_8inl-example.html#_a22">phsp_basic.inl</a>, <a class="el" href="phsp_chain_8inl-example.html#_a19">phsp_chain.inl</a>, <a class="el" href="phsp_reweighting_8inl-example.html#_a27">phsp_reweighting.inl</a>, <a class="el" href="phsp_unweighting_8inl-example.html#_a22">phsp_unweighting.inl</a>, <a class="el" href="phsp_unweighting_functor_8inl-example.html#_a27">phsp_unweighting_functor.inl</a>, <a class="el" href="pseudo_experiment_8inl-example.html#_a25">pseudo_experiment.inl</a>, <a class="el" href="range_semantics_8inl-example.html#_a9">range_semantics.inl</a>, and <a class="el" href="splot_8inl-example.html#_a27">splot.inl</a>.</dd>
</dl></div><div class="dynheader">
Collaboration diagram for hydra::detail::BackendPolicy&lt; BACKEND &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1BackendPolicy__coll__graph.svg" width="199" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a name="structhydra_1_1detail_1_1bool__pack" id="structhydra_1_1detail_1_1bool__pack"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1detail_1_1bool__pack">&#9670;&nbsp;</a></span>hydra::detail::bool_pack</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::detail::bool_pack</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;bool...&gt;<br />
struct hydra::detail::bool_pack&lt;... &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::detail::bool_pack&lt;... &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1bool__pack__coll__graph.svg" width="136" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a name="structhydra_1_1detail_1_1CanConvert" id="structhydra_1_1detail_1_1CanConvert"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1detail_1_1CanConvert">&#9670;&nbsp;</a></span>hydra::detail::CanConvert</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::detail::CanConvert</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;class ... A&gt;<br />
struct hydra::detail::CanConvert&lt; A &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::detail::CanConvert&lt; A &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1CanConvert__coll__graph.svg" width="212" height="88"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a name="structhydra_1_1detail_1_1divide__result" id="structhydra_1_1detail_1_1divide__result"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1detail_1_1divide__result">&#9670;&nbsp;</a></span>hydra::detail::divide_result</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::detail::divide_result</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename F1, typename F2, typename ... Fs&gt;<br />
struct hydra::detail::divide_result&lt; F1, F2, Fs &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::detail::divide_result&lt; F1, F2, Fs &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1divide__result__coll__graph.svg" width="158" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a11d97c4c8a678e80149749e40e905142"></a></td>
<td class="fieldname">
type</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structhydra_1_1detail_1_1FFTPolicy" id="structhydra_1_1detail_1_1FFTPolicy"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1detail_1_1FFTPolicy">&#9670;&nbsp;</a></span>hydra::detail::FFTPolicy</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::detail::FFTPolicy</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename Precision, FFTCalculator FFTBackend&gt;<br />
struct hydra::detail::FFTPolicy&lt; Precision, FFTBackend &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::detail::FFTPolicy&lt; Precision, FFTBackend &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1FFTPolicy__coll__graph.svg" width="194" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a name="structhydra_1_1detail_1_1FFTPolicy_3_01T_00_01detail_1_1CuFFT_01_4" id="structhydra_1_1detail_1_1FFTPolicy_3_01T_00_01detail_1_1CuFFT_01_4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1detail_1_1FFTPolicy_3_01T_00_01detail_1_1CuFFT_01_4">&#9670;&nbsp;</a></span>hydra::detail::FFTPolicy&lt; T, detail::CuFFT &gt;</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::detail::FFTPolicy&lt; T, detail::CuFFT &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename T&gt;<br />
struct hydra::detail::FFTPolicy&lt; T, detail::CuFFT &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::detail::FFTPolicy&lt; T, detail::CuFFT &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1FFTPolicy_3_01T_00_01detail_1_1CuFFT_01_4__coll__graph.svg" width="172" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a0f3b7a3f7c4406803731416f6d91e306"></a>typedef <a class="el" href="classhydra_1_1ComplexToComplexCuFFT.html">ComplexToComplexCuFFT</a>&lt; T &gt;</td>
<td class="fieldname">
C2C</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="afde9e24c64e161c60811e4f2e3dde32f"></a>typedef <a class="el" href="classhydra_1_1ComplexToRealCuFFT.html">ComplexToRealCuFFT</a>&lt; T &gt;</td>
<td class="fieldname">
C2R</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a0622ac8a1e2f071aae1de916907a33a9"></a>typedef sys_t</td>
<td class="fieldname">
device_backend_type</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a104b4351044b9f8f7d224c9a7e318031"></a>typedef sys_t</td>
<td class="fieldname">
host_backend_type</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a481beb0295a5622b5bb1a34943826894"></a>typedef <a class="el" href="classhydra_1_1RealToComplexCuFFT.html">RealToComplexCuFFT</a>&lt; T &gt;</td>
<td class="fieldname">
R2C</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structhydra_1_1detail_1_1FFTPolicy_3_01T_00_01detail_1_1FFTW_01_4" id="structhydra_1_1detail_1_1FFTPolicy_3_01T_00_01detail_1_1FFTW_01_4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1detail_1_1FFTPolicy_3_01T_00_01detail_1_1FFTW_01_4">&#9670;&nbsp;</a></span>hydra::detail::FFTPolicy&lt; T, detail::FFTW &gt;</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::detail::FFTPolicy&lt; T, detail::FFTW &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename T&gt;<br />
struct hydra::detail::FFTPolicy&lt; T, detail::FFTW &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::detail::FFTPolicy&lt; T, detail::FFTW &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1FFTPolicy_3_01T_00_01detail_1_1FFTW_01_4__coll__graph.svg" width="172" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="ade556a186e98035468da80cc53abdb63"></a>typedef <a class="el" href="classhydra_1_1ComplexToComplexFFTW.html">ComplexToComplexFFTW</a>&lt; T &gt;</td>
<td class="fieldname">
C2C</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="aa4257c468ef1ecd0ddcdbb3887b2fc51"></a>typedef <a class="el" href="classhydra_1_1ComplexToRealFFTW.html">ComplexToRealFFTW</a>&lt; T &gt;</td>
<td class="fieldname">
C2R</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a07f86869d771bddd0f2d0a9772cb370b"></a>typedef sys_t</td>
<td class="fieldname">
device_backend_type</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a59e397b257e2684bc9e1d77a250b55bc"></a>typedef sys_t</td>
<td class="fieldname">
host_backend_type</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a8518989b6fcc217a7cd34406f7ce6ad1"></a>typedef <a class="el" href="classhydra_1_1RealToComplexFFTW.html">RealToComplexFFTW</a>&lt; T &gt;</td>
<td class="fieldname">
R2C</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structhydra_1_1detail_1_1find__unique__type__impl" id="structhydra_1_1detail_1_1find__unique__type__impl"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1detail_1_1find__unique__type__impl">&#9670;&nbsp;</a></span>hydra::detail::find_unique_type_impl</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::detail::find_unique_type_impl</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;size_t I, class T, class... Types&gt;<br />
struct hydra::detail::find_unique_type_impl&lt; I, T, Types &gt;</h3>

</div><div class="dynheader">
Inheritance diagram for hydra::detail::find_unique_type_impl&lt; I, T, Types &gt;:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1find__unique__type__impl__inherit__graph.svg" width="100%" height="600"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</div>
<div class="dynheader">
Collaboration diagram for hydra::detail::find_unique_type_impl&lt; I, T, Types &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1find__unique__type__impl__coll__graph.svg" width="162" height="118"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a name="structhydra_1_1detail_1_1function__traits" id="structhydra_1_1detail_1_1function__traits"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1detail_1_1function__traits">&#9670;&nbsp;</a></span>hydra::detail::function_traits</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::detail::function_traits</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename T&gt;<br />
struct hydra::detail::function_traits&lt; T &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::detail::function_traits&lt; T &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1function__traits__coll__graph.svg" width="158" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a name="structhydra_1_1detail_1_1functor__traits" id="structhydra_1_1detail_1_1functor__traits"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1detail_1_1functor__traits">&#9670;&nbsp;</a></span>hydra::detail::functor_traits</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::detail::functor_traits</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename T&gt;<br />
struct hydra::detail::functor_traits&lt; T &gt;</h3>

</div><div class="dynheader">
Inheritance diagram for hydra::detail::functor_traits&lt; T &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1functor__traits__inherit__graph.svg" width="244" height="414"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Collaboration diagram for hydra::detail::functor_traits&lt; T &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1functor__traits__coll__graph.svg" width="152" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a name="structhydra_1_1detail_1_1functor__traits_3_01ReturnType_07ClassType_1_1_5_08_07Args_8_8_8_08_01_4" id="structhydra_1_1detail_1_1functor__traits_3_01ReturnType_07ClassType_1_1_5_08_07Args_8_8_8_08_01_4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1detail_1_1functor__traits_3_01ReturnType_07ClassType_1_1_5_08_07Args_8_8_8_08_01_4">&#9670;&nbsp;</a></span>hydra::detail::functor_traits&lt; ReturnType(ClassType::*)(Args...) &gt;</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::detail::functor_traits&lt; ReturnType(ClassType::*)(Args...) &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename ClassType, typename ReturnType, typename... Args&gt;<br />
struct hydra::detail::functor_traits&lt; ReturnType(ClassType::*)(Args...) &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::detail::functor_traits&lt; ReturnType(ClassType::*)(Args...) &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1functor__traits_3_01ReturnType_07ClassType_1_1_5_08_07Args_8_8_8_08_01_4__coll__graph.svg" width="214" height="118"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a name="classhydra_1_1detail_1_1if__then__else" id="classhydra_1_1detail_1_1if__then__else"></a>
<h2 class="memtitle"><span class="permalink"><a href="#classhydra_1_1detail_1_1if__then__else">&#9670;&nbsp;</a></span>hydra::detail::if_then_else</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class hydra::detail::if_then_else</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;bool C, typename T1, typename T2&gt;<br />
class hydra::detail::if_then_else&lt; C, T1, T2 &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::detail::if_then_else&lt; C, T1, T2 &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classhydra_1_1detail_1_1if__then__else__coll__graph.svg" width="151" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a name="classhydra_1_1detail_1_1if__then__else_3_01false_00_01T1_00_01T2_01_4" id="classhydra_1_1detail_1_1if__then__else_3_01false_00_01T1_00_01T2_01_4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#classhydra_1_1detail_1_1if__then__else_3_01false_00_01T1_00_01T2_01_4">&#9670;&nbsp;</a></span>hydra::detail::if_then_else&lt; false, T1, T2 &gt;</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class hydra::detail::if_then_else&lt; false, T1, T2 &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename T1, typename T2&gt;<br />
class hydra::detail::if_then_else&lt; false, T1, T2 &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::detail::if_then_else&lt; false, T1, T2 &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classhydra_1_1detail_1_1if__then__else_3_01false_00_01T1_00_01T2_01_4__coll__graph.svg" width="162" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a9ccbe22c7f1cb3f5c1a2d408bed944a8"></a>typedef T2</td>
<td class="fieldname">
type</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="classhydra_1_1detail_1_1if__then__else_3_01true_00_01T1_00_01T2_01_4" id="classhydra_1_1detail_1_1if__then__else_3_01true_00_01T1_00_01T2_01_4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#classhydra_1_1detail_1_1if__then__else_3_01true_00_01T1_00_01T2_01_4">&#9670;&nbsp;</a></span>hydra::detail::if_then_else&lt; true, T1, T2 &gt;</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class hydra::detail::if_then_else&lt; true, T1, T2 &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename T1, typename T2&gt;<br />
class hydra::detail::if_then_else&lt; true, T1, T2 &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::detail::if_then_else&lt; true, T1, T2 &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classhydra_1_1detail_1_1if__then__else_3_01true_00_01T1_00_01T2_01_4__coll__graph.svg" width="156" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a34c5da7d250feff5bad076f085abf67b"></a>typedef T1</td>
<td class="fieldname">
type</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structhydra_1_1detail_1_1if__then__else__tt" id="structhydra_1_1detail_1_1if__then__else__tt"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1detail_1_1if__then__else__tt">&#9670;&nbsp;</a></span>hydra::detail::if_then_else_tt</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::detail::if_then_else_tt</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;bool Condition, template&lt; typename ... &gt; class T1, template&lt; typename ... &gt; class T2&gt;<br />
struct hydra::detail::if_then_else_tt&lt; Condition, T1, T2 &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::detail::if_then_else_tt&lt; Condition, T1, T2 &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1if__then__else__tt__coll__graph.svg" width="204" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a name="structhydra_1_1detail_1_1if__then__else__tt_3_01false_00_01T1_00_01T2_01_4" id="structhydra_1_1detail_1_1if__then__else__tt_3_01false_00_01T1_00_01T2_01_4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1detail_1_1if__then__else__tt_3_01false_00_01T1_00_01T2_01_4">&#9670;&nbsp;</a></span>hydra::detail::if_then_else_tt&lt; false, T1, T2 &gt;</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::detail::if_then_else_tt&lt; false, T1, T2 &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;template&lt; typename ... &gt; class T1, template&lt; typename ... &gt; class T2&gt;<br />
struct hydra::detail::if_then_else_tt&lt; false, T1, T2 &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::detail::if_then_else_tt&lt; false, T1, T2 &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1if__then__else__tt_3_01false_00_01T1_00_01T2_01_4__coll__graph.svg" width="178" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="ad720270512c28116871b746b1e11686e"></a></td>
<td class="fieldname">
type</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structhydra_1_1detail_1_1if__then__else__tt_3_01true_00_01T1_00_01T2_01_4" id="structhydra_1_1detail_1_1if__then__else__tt_3_01true_00_01T1_00_01T2_01_4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1detail_1_1if__then__else__tt_3_01true_00_01T1_00_01T2_01_4">&#9670;&nbsp;</a></span>hydra::detail::if_then_else_tt&lt; true, T1, T2 &gt;</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::detail::if_then_else_tt&lt; true, T1, T2 &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;template&lt; typename ... &gt; class T1, template&lt; typename ... &gt; class T2&gt;<br />
struct hydra::detail::if_then_else_tt&lt; true, T1, T2 &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::detail::if_then_else_tt&lt; true, T1, T2 &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1if__then__else__tt_3_01true_00_01T1_00_01T2_01_4__coll__graph.svg" width="171" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a6a09c2f0ef798cfca4abdfb2ab115c25"></a></td>
<td class="fieldname">
type</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structhydra_1_1detail_1_1index__in__tuple" id="structhydra_1_1detail_1_1index__in__tuple"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1detail_1_1index__in__tuple">&#9670;&nbsp;</a></span>hydra::detail::index_in_tuple</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::detail::index_in_tuple</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename Type, typename Tuple&gt;<br />
struct hydra::detail::index_in_tuple&lt; Type, Tuple &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::detail::index_in_tuple&lt; Type, Tuple &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1index__in__tuple__coll__graph.svg" width="178" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a name="structhydra_1_1detail_1_1int__fast__t" id="structhydra_1_1detail_1_1int__fast__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1detail_1_1int__fast__t">&#9670;&nbsp;</a></span>hydra::detail::int_fast_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::detail::int_fast_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename LeastInt&gt;<br />
struct hydra::detail::int_fast_t&lt; LeastInt &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::detail::int_fast_t&lt; LeastInt &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1int__fast__t__coll__graph.svg" width="144" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="af2ec5c2bfd6190ea9c89130bdccc8bf5"></a>typedef LeastInt</td>
<td class="fieldname">
fast</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="acde5af648678420102bf2fb887859be8"></a>typedef <a class="el" href="namespacehydra_1_1detail.html#af2ec5c2bfd6190ea9c89130bdccc8bf5">fast</a></td>
<td class="fieldname">
type</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structhydra_1_1detail_1_1is__function__argument" id="structhydra_1_1detail_1_1is__function__argument"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1detail_1_1is__function__argument">&#9670;&nbsp;</a></span>hydra::detail::is_function_argument</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::detail::is_function_argument</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename Arg, bool B = fa_impl::_is_function_argument&lt;Arg&gt;::value&gt;<br />
struct hydra::detail::is_function_argument&lt; Arg, B &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::detail::is_function_argument&lt; Arg, B &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1is__function__argument__coll__graph.svg" width="175" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a name="structhydra_1_1detail_1_1is__valid__type__pack" id="structhydra_1_1detail_1_1is__valid__type__pack"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1detail_1_1is__valid__type__pack">&#9670;&nbsp;</a></span>hydra::detail::is_valid_type_pack</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::detail::is_valid_type_pack</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename RefT, typename ... T&gt;<br />
struct hydra::detail::is_valid_type_pack&lt; RefT, T &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::detail::is_valid_type_pack&lt; RefT, T &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1is__valid__type__pack__coll__graph.svg" width="167" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a name="structhydra_1_1detail_1_1merged__tuple" id="structhydra_1_1detail_1_1merged__tuple"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1detail_1_1merged__tuple">&#9670;&nbsp;</a></span>hydra::detail::merged_tuple</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::detail::merged_tuple</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename ... T&gt;<br />
struct hydra::detail::merged_tuple&lt; T &gt;</h3>

</div><div class="dynheader">
Inheritance diagram for hydra::detail::merged_tuple&lt; T &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1merged__tuple__inherit__graph.svg" width="542" height="458"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Collaboration diagram for hydra::detail::merged_tuple&lt; T &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1merged__tuple__coll__graph.svg" width="155" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a name="structhydra_1_1detail_1_1merged__tuple_3_01hydra_1_1tuple_3_01T_8_8_8_01_4_01_4" id="structhydra_1_1detail_1_1merged__tuple_3_01hydra_1_1tuple_3_01T_8_8_8_01_4_01_4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1detail_1_1merged__tuple_3_01hydra_1_1tuple_3_01T_8_8_8_01_4_01_4">&#9670;&nbsp;</a></span>hydra::detail::merged_tuple&lt; hydra::tuple&lt; T... &gt; &gt;</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::detail::merged_tuple&lt; hydra::tuple&lt; T... &gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename ... T&gt;<br />
struct hydra::detail::merged_tuple&lt; hydra::tuple&lt; T... &gt; &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::detail::merged_tuple&lt; hydra::tuple&lt; T... &gt; &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1merged__tuple_3_01hydra_1_1tuple_3_01T_8_8_8_01_4_01_4__coll__graph.svg" width="155" height="118"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a15786b8d6c6a219b01b74cf9fdb3f92d"></a></td>
<td class="fieldname">
type</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structhydra_1_1detail_1_1merged__zip__iterator" id="structhydra_1_1detail_1_1merged__zip__iterator"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1detail_1_1merged__zip__iterator">&#9670;&nbsp;</a></span>hydra::detail::merged_zip_iterator</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::detail::merged_zip_iterator</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename ... T&gt;<br />
struct hydra::detail::merged_zip_iterator&lt; T &gt;</h3>

</div><div class="dynheader">
Inheritance diagram for hydra::detail::merged_zip_iterator&lt; T &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1merged__zip__iterator__inherit__graph.svg" width="368" height="502"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Collaboration diagram for hydra::detail::merged_zip_iterator&lt; T &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1merged__zip__iterator__coll__graph.svg" width="155" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a name="structhydra_1_1detail_1_1merged__zip__iterator_3_01hydra_1_1thrust_1_1zip__iterator_3_01T_8_8_8_01_4_01_4" id="structhydra_1_1detail_1_1merged__zip__iterator_3_01hydra_1_1thrust_1_1zip__iterator_3_01T_8_8_8_01_4_01_4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1detail_1_1merged__zip__iterator_3_01hydra_1_1thrust_1_1zip__iterator_3_01T_8_8_8_01_4_01_4">&#9670;&nbsp;</a></span>hydra::detail::merged_zip_iterator&lt; hydra::thrust::zip_iterator&lt; T... &gt; &gt;</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::detail::merged_zip_iterator&lt; hydra::thrust::zip_iterator&lt; T... &gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename ... T&gt;<br />
struct hydra::detail::merged_zip_iterator&lt; hydra::thrust::zip_iterator&lt; T... &gt; &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::detail::merged_zip_iterator&lt; hydra::thrust::zip_iterator&lt; T... &gt; &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1merged__zip__iterator_3_01hydra_1_1thrust_1_1zip__iterator_3_01T_8_8_8_01_4_01_4__coll__graph.svg" width="155" height="132"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a89ce6c41d8902d3e3b7232d4ec8724bd"></a></td>
<td class="fieldname">
type</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structhydra_1_1detail_1_1minus__result" id="structhydra_1_1detail_1_1minus__result"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1detail_1_1minus__result">&#9670;&nbsp;</a></span>hydra::detail::minus_result</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::detail::minus_result</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename F1, typename F2, typename ... Fs&gt;<br />
struct hydra::detail::minus_result&lt; F1, F2, Fs &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::detail::minus_result&lt; F1, F2, Fs &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1minus__result__coll__graph.svg" width="158" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="add29ddc4b8fac81ed38f877959086d79"></a></td>
<td class="fieldname">
type</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structhydra_1_1detail_1_1multidimensional" id="structhydra_1_1detail_1_1multidimensional"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1detail_1_1multidimensional">&#9670;&nbsp;</a></span>hydra::detail::multidimensional</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::detail::multidimensional</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"></div><div class="dynheader">
Collaboration diagram for hydra::detail::multidimensional:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1multidimensional__coll__graph.svg" width="210" height="88"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a name="structhydra_1_1detail_1_1multiply__result" id="structhydra_1_1detail_1_1multiply__result"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1detail_1_1multiply__result">&#9670;&nbsp;</a></span>hydra::detail::multiply_result</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::detail::multiply_result</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename F1, typename F2, typename ... Fs&gt;<br />
struct hydra::detail::multiply_result&lt; F1, F2, Fs &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::detail::multiply_result&lt; F1, F2, Fs &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1multiply__result__coll__graph.svg" width="158" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a9f322e4e5accd44a6a804994aca86b7b"></a></td>
<td class="fieldname">
type</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structhydra_1_1detail_1_1ObjSelector" id="structhydra_1_1detail_1_1ObjSelector"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1detail_1_1ObjSelector">&#9670;&nbsp;</a></span>hydra::detail::ObjSelector</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::detail::ObjSelector</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;bool FLAG&gt;<br />
struct hydra::detail::ObjSelector&lt; FLAG &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::detail::ObjSelector&lt; FLAG &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1ObjSelector__coll__graph.svg" width="180" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a name="structhydra_1_1detail_1_1random__traits" id="structhydra_1_1detail_1_1random__traits"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1detail_1_1random__traits">&#9670;&nbsp;</a></span>hydra::detail::random_traits</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::detail::random_traits</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename Engine&gt;<br />
struct hydra::detail::random_traits&lt; Engine &gt;</h3>

</div><div class="dynheader">
Inheritance diagram for hydra::detail::random_traits&lt; Engine &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1random__traits__inherit__graph.svg" width="186" height="258"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Collaboration diagram for hydra::detail::random_traits&lt; Engine &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1random__traits__coll__graph.svg" width="155" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a name="structhydra_1_1detail_1_1references__tuple__type" id="structhydra_1_1detail_1_1references__tuple__type"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1detail_1_1references__tuple__type">&#9670;&nbsp;</a></span>hydra::detail::references_tuple_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::detail::references_tuple_type</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;size_t N, typename T&gt;<br />
struct hydra::detail::references_tuple_type&lt; N, T &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::detail::references_tuple_type&lt; N, T &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1references__tuple__type__coll__graph.svg" width="174" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a5b7b28f3038efea5e16af361c761c1b4"></a>typedef <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1repeat">repeat</a>&lt; T, N, tuple_of_iterator_references &gt;::<a class="el" href="namespacehydra_1_1detail.html#a5b7b28f3038efea5e16af361c761c1b4">type</a></td>
<td class="fieldname">
type</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structhydra_1_1detail_1_1remove__device__reference" id="structhydra_1_1detail_1_1remove__device__reference"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1detail_1_1remove__device__reference">&#9670;&nbsp;</a></span>hydra::detail::remove_device_reference</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::detail::remove_device_reference</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename T&gt;<br />
struct hydra::detail::remove_device_reference&lt; T &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::detail::remove_device_reference&lt; T &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1remove__device__reference__coll__graph.svg" width="171" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a3369bac6ca9a2ac5bfac3d6641551ecb"></a>typedef T</td>
<td class="fieldname">
type</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structhydra_1_1detail_1_1remove__device__reference_3_01hydra_1_1thrust_1_1device__reference_3_01T_01_4_01_4" id="structhydra_1_1detail_1_1remove__device__reference_3_01hydra_1_1thrust_1_1device__reference_3_01T_01_4_01_4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1detail_1_1remove__device__reference_3_01hydra_1_1thrust_1_1device__reference_3_01T_01_4_01_4">&#9670;&nbsp;</a></span>hydra::detail::remove_device_reference&lt; hydra::thrust::device_reference&lt; T &gt; &gt;</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::detail::remove_device_reference&lt; hydra::thrust::device_reference&lt; T &gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename T&gt;<br />
struct hydra::detail::remove_device_reference&lt; hydra::thrust::device_reference&lt; T &gt; &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::detail::remove_device_reference&lt; hydra::thrust::device_reference&lt; T &gt; &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1remove__device__reference_3_01hydra_1_1thrust_1_1device__reference_3_01T_01_4_01_4__coll__graph.svg" width="226" height="118"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="af623fdb8de60ab15609af42e08b317f5"></a>typedef T</td>
<td class="fieldname">
type</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structhydra_1_1detail_1_1remove__device__reference_3_01T_01_6_01_4" id="structhydra_1_1detail_1_1remove__device__reference_3_01T_01_6_01_4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1detail_1_1remove__device__reference_3_01T_01_6_01_4">&#9670;&nbsp;</a></span>hydra::detail::remove_device_reference&lt; T &amp; &gt;</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::detail::remove_device_reference&lt; T &amp; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename T&gt;<br />
struct hydra::detail::remove_device_reference&lt; T &amp; &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::detail::remove_device_reference&lt; T &amp; &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1remove__device__reference_3_01T_01_6_01_4__coll__graph.svg" width="184" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a7fd24291b19127ab66c7b8f9512e00ce"></a>typedef T</td>
<td class="fieldname">
type</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structhydra_1_1detail_1_1repeat" id="structhydra_1_1detail_1_1repeat"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1detail_1_1repeat">&#9670;&nbsp;</a></span>hydra::detail::repeat</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::detail::repeat</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename T, unsigned int N, template&lt; typename... &gt; class TT&gt;<br />
struct hydra::detail::repeat&lt; T, N, TT &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::detail::repeat&lt; T, N, TT &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1repeat__coll__graph.svg" width="148" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a3c8492545a2a08149cff4a2b065d2b6f"></a>typedef typename <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1append__to__type__seq">append_to_type_seq</a>&lt; T, typename <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1repeat">repeat</a>&lt; T, N-1, TT &gt;::<a class="el" href="namespacehydra_1_1detail.html#a3c8492545a2a08149cff4a2b065d2b6f">type</a> &gt;::<a class="el" href="namespacehydra_1_1detail.html#a3c8492545a2a08149cff4a2b065d2b6f">type</a></td>
<td class="fieldname">
type</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structhydra_1_1detail_1_1repeat_3_01T_00_010_00_01TT_01_4" id="structhydra_1_1detail_1_1repeat_3_01T_00_010_00_01TT_01_4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1detail_1_1repeat_3_01T_00_010_00_01TT_01_4">&#9670;&nbsp;</a></span>hydra::detail::repeat&lt; T, 0, TT &gt;</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::detail::repeat&lt; T, 0, TT &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename T, template&lt; typename... &gt; class TT&gt;<br />
struct hydra::detail::repeat&lt; T, 0, TT &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::detail::repeat&lt; T, 0, TT &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1repeat_3_01T_00_010_00_01TT_01_4__coll__graph.svg" width="148" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a7e12a8d9a98e19982fedf2fc1b7f207a"></a>typedef TT&lt;&gt;</td>
<td class="fieldname">
type</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structhydra_1_1detail_1_1ResultPHSP" id="structhydra_1_1detail_1_1ResultPHSP"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1detail_1_1ResultPHSP">&#9670;&nbsp;</a></span>hydra::detail::ResultPHSP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::detail::ResultPHSP</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"></div><div class="dynheader">
Collaboration diagram for hydra::detail::ResultPHSP:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1ResultPHSP__coll__graph.svg" width="187" height="258"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a8d19e0d65eaa393fe0d5f2d578675900"></a><a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a></td>
<td class="fieldname">
fM2</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a9c02ae737d47a9ae27842532c81c07bf"></a><a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a></td>
<td class="fieldname">
fMean</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a99c4af82a39dec887b1718c445d47ecd"></a><a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a></td>
<td class="fieldname">
fW</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structhydra_1_1detail_1_1ResultVegas" id="structhydra_1_1detail_1_1ResultVegas"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1detail_1_1ResultVegas">&#9670;&nbsp;</a></span>hydra::detail::ResultVegas</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::detail::ResultVegas</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"></div><div class="dynheader">
Collaboration diagram for hydra::detail::ResultVegas:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1ResultVegas__coll__graph.svg" width="187" height="258"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="addf467fb4f6b03675952501e353748e7"></a><a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a></td>
<td class="fieldname">
fM2</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a4d239d7f5d0d7b5335cec859fbb263c8"></a><a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a></td>
<td class="fieldname">
fMean</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="aeac7d6d40e06471c8713e6f589e3d15b"></a><a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a></td>
<td class="fieldname">
fN</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structhydra_1_1detail_1_1selected__tuple" id="structhydra_1_1detail_1_1selected__tuple"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1detail_1_1selected__tuple">&#9670;&nbsp;</a></span>hydra::detail::selected_tuple</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::detail::selected_tuple</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;template&lt; typename Type &gt; class Selector, typename TypeList&gt;<br />
struct hydra::detail::selected_tuple&lt; Selector, TypeList &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::detail::selected_tuple&lt; Selector, TypeList &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1selected__tuple__coll__graph.svg" width="196" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a name="structhydra_1_1detail_1_1selected__tuple_3_01Selector_00_01hydra_1_1tuple_3_01Head_00_01Tail_8_8_8_01_4_01_4" id="structhydra_1_1detail_1_1selected__tuple_3_01Selector_00_01hydra_1_1tuple_3_01Head_00_01Tail_8_8_8_01_4_01_4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1detail_1_1selected__tuple_3_01Selector_00_01hydra_1_1tuple_3_01Head_00_01Tail_8_8_8_01_4_01_4">&#9670;&nbsp;</a></span>hydra::detail::selected_tuple&lt; Selector, hydra::tuple&lt; Head, Tail... &gt; &gt;</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::detail::selected_tuple&lt; Selector, hydra::tuple&lt; Head, Tail... &gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;template&lt; typename T &gt; class Selector, typename Head, typename ... Tail&gt;<br />
struct hydra::detail::selected_tuple&lt; Selector, hydra::tuple&lt; Head, Tail... &gt; &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::detail::selected_tuple&lt; Selector, hydra::tuple&lt; Head, Tail... &gt; &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1selected__tuple_3_01Selector_00_01hydra_1_1tuple_3_01Head_00_01Tail_8_8_8_01_4_01_4__coll__graph.svg" width="176" height="118"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a3634476cb5c5bbc96e3b9f4325781f4c"></a></td>
<td class="fieldname">
type</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structhydra_1_1detail_1_1selected__tuple_3_01Selector_00_01hydra_1_1tuple_3_01Type_01_4_01_4" id="structhydra_1_1detail_1_1selected__tuple_3_01Selector_00_01hydra_1_1tuple_3_01Type_01_4_01_4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1detail_1_1selected__tuple_3_01Selector_00_01hydra_1_1tuple_3_01Type_01_4_01_4">&#9670;&nbsp;</a></span>hydra::detail::selected_tuple&lt; Selector, hydra::tuple&lt; Type &gt; &gt;</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::detail::selected_tuple&lt; Selector, hydra::tuple&lt; Type &gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;template&lt; typename T &gt; class Selector, typename Type&gt;<br />
struct hydra::detail::selected_tuple&lt; Selector, hydra::tuple&lt; Type &gt; &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::detail::selected_tuple&lt; Selector, hydra::tuple&lt; Type &gt; &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1selected__tuple_3_01Selector_00_01hydra_1_1tuple_3_01Type_01_4_01_4__coll__graph.svg" width="167" height="118"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a67fca6b4069494d78deca8280a754cf8"></a>typedef conditional&lt; Selector&lt; Type &gt;::value, <a class="el" href="namespacehydra.html#ac3486502b2db72187626125cea971683">tuple</a>&lt; Type &gt;, <a class="el" href="namespacehydra.html#ac3486502b2db72187626125cea971683">tuple</a>&lt;&gt; &gt;::<a class="el" href="namespacehydra_1_1detail.html#a67fca6b4069494d78deca8280a754cf8">type</a></td>
<td class="fieldname">
type</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structhydra_1_1detail_1_1signature__traits" id="structhydra_1_1detail_1_1signature__traits"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1detail_1_1signature__traits">&#9670;&nbsp;</a></span>hydra::detail::signature_traits</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::detail::signature_traits</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename S&gt;<br />
struct hydra::detail::signature_traits&lt; S &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::detail::signature_traits&lt; S &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1signature__traits__coll__graph.svg" width="166" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a name="structhydra_1_1detail_1_1signature__type" id="structhydra_1_1detail_1_1signature__type"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1detail_1_1signature__type">&#9670;&nbsp;</a></span>hydra::detail::signature_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::detail::signature_type</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename R, typename ... A&gt;<br />
struct hydra::detail::signature_type&lt; R, A &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::detail::signature_type&lt; R, A &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1signature__type__coll__graph.svg" width="166" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="ac3018bd6f66064373ef1765d808e847c"></a></td>
<td class="fieldname">
type</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structhydra_1_1detail_1_1signature__type__impl" id="structhydra_1_1detail_1_1signature__type__impl"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1detail_1_1signature__type__impl">&#9670;&nbsp;</a></span>hydra::detail::signature_type_impl</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::detail::signature_type_impl</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename T&gt;<br />
struct hydra::detail::signature_type_impl&lt; T &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::detail::signature_type_impl&lt; T &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1signature__type__impl__coll__graph.svg" width="166" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a5f6aacb86130478ef997463d0aeb58c3"></a>typedef T</td>
<td class="fieldname">
type</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structhydra_1_1detail_1_1stripped__tuple" id="structhydra_1_1detail_1_1stripped__tuple"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1detail_1_1stripped__tuple">&#9670;&nbsp;</a></span>hydra::detail::stripped_tuple</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::detail::stripped_tuple</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename T&gt;<br />
struct hydra::detail::stripped_tuple&lt; T &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::detail::stripped_tuple&lt; T &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1stripped__tuple__coll__graph.svg" width="158" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a name="structhydra_1_1detail_1_1stripped__type" id="structhydra_1_1detail_1_1stripped__type"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1detail_1_1stripped__type">&#9670;&nbsp;</a></span>hydra::detail::stripped_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::detail::stripped_type</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename Arg, bool T = is_function_argument&lt;Arg&gt;::value&gt;<br />
struct hydra::detail::stripped_type&lt; Arg, T &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::detail::stripped_type&lt; Arg, T &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1stripped__type__coll__graph.svg" width="158" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a name="structhydra_1_1detail_1_1stripped__type_3_01Arg_00_01false_01_4" id="structhydra_1_1detail_1_1stripped__type_3_01Arg_00_01false_01_4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1detail_1_1stripped__type_3_01Arg_00_01false_01_4">&#9670;&nbsp;</a></span>hydra::detail::stripped_type&lt; Arg, false &gt;</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::detail::stripped_type&lt; Arg, false &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename Arg&gt;<br />
struct hydra::detail::stripped_type&lt; Arg, false &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::detail::stripped_type&lt; Arg, false &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1stripped__type_3_01Arg_00_01false_01_4__coll__graph.svg" width="158" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a978c54faaef382347c9dd413a45ebd83"></a>typedef Arg</td>
<td class="fieldname">
type</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structhydra_1_1detail_1_1stripped__type_3_01Arg_00_01true_01_4" id="structhydra_1_1detail_1_1stripped__type_3_01Arg_00_01true_01_4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1detail_1_1stripped__type_3_01Arg_00_01true_01_4">&#9670;&nbsp;</a></span>hydra::detail::stripped_type&lt; Arg, true &gt;</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::detail::stripped_type&lt; Arg, true &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename Arg&gt;<br />
struct hydra::detail::stripped_type&lt; Arg, true &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::detail::stripped_type&lt; Arg, true &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1stripped__type_3_01Arg_00_01true_01_4__coll__graph.svg" width="158" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="ac3d1aeb85f09983419859baacc8d801d"></a>typedef value_type</td>
<td class="fieldname">
type</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structhydra_1_1detail_1_1sum__result" id="structhydra_1_1detail_1_1sum__result"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1detail_1_1sum__result">&#9670;&nbsp;</a></span>hydra::detail::sum_result</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::detail::sum_result</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename F1, typename F2, typename ... Fs&gt;<br />
struct hydra::detail::sum_result&lt; F1, F2, Fs &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::detail::sum_result&lt; F1, F2, Fs &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1sum__result__coll__graph.svg" width="158" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a574a0cf3739a23e067ea7e3b1acc7592"></a></td>
<td class="fieldname">
type</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structhydra_1_1detail_1_1tag__type" id="structhydra_1_1detail_1_1tag__type"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1detail_1_1tag__type">&#9670;&nbsp;</a></span>hydra::detail::tag_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::detail::tag_type</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;class T, class R = void&gt;<br />
struct hydra::detail::tag_type&lt; T, R &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::detail::tag_type&lt; T, R &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1tag__type__coll__graph.svg" width="130" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a559de10d2ff5e2db2754adf86b3840ec"></a>typedef R</td>
<td class="fieldname">
type</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structhydra_1_1detail_1_1trimmed__lambda__signature" id="structhydra_1_1detail_1_1trimmed__lambda__signature"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1detail_1_1trimmed__lambda__signature">&#9670;&nbsp;</a></span>hydra::detail::trimmed_lambda_signature</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::detail::trimmed_lambda_signature</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename T&gt;<br />
struct hydra::detail::trimmed_lambda_signature&lt; T &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::detail::trimmed_lambda_signature&lt; T &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1trimmed__lambda__signature__coll__graph.svg" width="174" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a name="structhydra_1_1detail_1_1trimmed__lambda__signature_3_01hydra_1_1thrust_1_1tuple_3_01Head_00_01Neck_00_01Tail_8_8_8_01_4_01_4" id="structhydra_1_1detail_1_1trimmed__lambda__signature_3_01hydra_1_1thrust_1_1tuple_3_01Head_00_01Neck_00_01Tail_8_8_8_01_4_01_4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1detail_1_1trimmed__lambda__signature_3_01hydra_1_1thrust_1_1tuple_3_01Head_00_01Neck_00_01Tail_8_8_8_01_4_01_4">&#9670;&nbsp;</a></span>hydra::detail::trimmed_lambda_signature&lt; hydra::thrust::tuple&lt; Head, Neck, Tail... &gt; &gt;</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::detail::trimmed_lambda_signature&lt; hydra::thrust::tuple&lt; Head, Neck, Tail... &gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename Head, typename Neck, typename ... Tail&gt;<br />
struct hydra::detail::trimmed_lambda_signature&lt; hydra::thrust::tuple&lt; Head, Neck, Tail... &gt; &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::detail::trimmed_lambda_signature&lt; hydra::thrust::tuple&lt; Head, Neck, Tail... &gt; &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1trimmed__lambda__signature_3_01hydra_1_1thrust_1_1tuple_3_01Head_00_01Nd4f9371f08bbcac17b5c83706208fdf0.svg" width="196" height="132"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="ac1cc582909828aa2dd9c37fd0c94597c"></a></td>
<td class="fieldname">
type</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structhydra_1_1detail_1_1tuple__cat__type" id="structhydra_1_1detail_1_1tuple__cat__type"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1detail_1_1tuple__cat__type">&#9670;&nbsp;</a></span>hydra::detail::tuple_cat_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::detail::tuple_cat_type</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename Tuple1, typename Tuple2&gt;<br />
struct hydra::detail::tuple_cat_type&lt; Tuple1, Tuple2 &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::detail::tuple_cat_type&lt; Tuple1, Tuple2 &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1tuple__cat__type__coll__graph.svg" width="200" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a name="structhydra_1_1detail_1_1tuple__cat__type_3_01hydra_1_1thrust_1_1detail_1_1tuple__of__iterator__e875b1e0f0d98602461f9d0c3462aad3" id="structhydra_1_1detail_1_1tuple__cat__type_3_01hydra_1_1thrust_1_1detail_1_1tuple__of__iterator__e875b1e0f0d98602461f9d0c3462aad3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1detail_1_1tuple__cat__type_3_01hydra_1_1thrust_1_1detail_1_1tuple__of__iterator__e875b1e0f0d98602461f9d0c3462aad3">&#9670;&nbsp;</a></span>hydra::detail::tuple_cat_type&lt; hydra::thrust::detail::tuple_of_iterator_references&lt; T1... &gt;, hydra::thrust::detail::tuple_of_iterator_references&lt; T2... &gt; &gt;</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::detail::tuple_cat_type&lt; hydra::thrust::detail::tuple_of_iterator_references&lt; T1... &gt;, hydra::thrust::detail::tuple_of_iterator_references&lt; T2... &gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename ... T1, typename ... T2&gt;<br />
struct hydra::detail::tuple_cat_type&lt; hydra::thrust::detail::tuple_of_iterator_references&lt; T1... &gt;, hydra::thrust::detail::tuple_of_iterator_references&lt; T2... &gt; &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::detail::tuple_cat_type&lt; hydra::thrust::detail::tuple_of_iterator_references&lt; T1... &gt;, hydra::thrust::detail::tuple_of_iterator_references&lt; T2... &gt; &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1tuple__cat__type_3_01hydra_1_1thrust_1_1detail_1_1tuple__of__iterator__96485e536c385bbaa94572426173ea38.svg" width="214" height="162"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a781c6cbc7da3f23f4d93ffd8186a428f"></a></td>
<td class="fieldname">
type</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structhydra_1_1detail_1_1tuple__cat__type_3_01hydra_1_1thrust_1_1tuple_3_01T1_8_8_8_01_4_00_01hy02a3f5f695c9d282a0a9beeb429a18a4" id="structhydra_1_1detail_1_1tuple__cat__type_3_01hydra_1_1thrust_1_1tuple_3_01T1_8_8_8_01_4_00_01hy02a3f5f695c9d282a0a9beeb429a18a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1detail_1_1tuple__cat__type_3_01hydra_1_1thrust_1_1tuple_3_01T1_8_8_8_01_4_00_01hy02a3f5f695c9d282a0a9beeb429a18a4">&#9670;&nbsp;</a></span>hydra::detail::tuple_cat_type&lt; hydra::thrust::tuple&lt; T1... &gt;, hydra::thrust::tuple&lt; T2... &gt; &gt;</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::detail::tuple_cat_type&lt; hydra::thrust::tuple&lt; T1... &gt;, hydra::thrust::tuple&lt; T2... &gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename ... T1, typename ... T2&gt;<br />
struct hydra::detail::tuple_cat_type&lt; hydra::thrust::tuple&lt; T1... &gt;, hydra::thrust::tuple&lt; T2... &gt; &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::detail::tuple_cat_type&lt; hydra::thrust::tuple&lt; T1... &gt;, hydra::thrust::tuple&lt; T2... &gt; &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1tuple__cat__type_3_01hydra_1_1thrust_1_1tuple_3_01T1_8_8_8_01_4_00_01hy6031fe0c723fbad6bf33d4c2f9170f20.svg" width="175" height="132"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="aa4ac0ad3146b152db625579432b36de0"></a></td>
<td class="fieldname">
type</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structhydra_1_1detail_1_1tuple__type" id="structhydra_1_1detail_1_1tuple__type"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1detail_1_1tuple__type">&#9670;&nbsp;</a></span>hydra::detail::tuple_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::detail::tuple_type</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;size_t N, typename T&gt;<br />
struct hydra::detail::tuple_type&lt; N, T &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::detail::tuple_type&lt; N, T &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1tuple__type__coll__graph.svg" width="140" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a9ba5c4622ec78b2832b30043bb95fed5"></a>typedef <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1repeat">repeat</a>&lt; T, N, <a class="el" href="namespacehydra.html#ac3486502b2db72187626125cea971683">tuple</a> &gt;::<a class="el" href="namespacehydra_1_1detail.html#a9ba5c4622ec78b2832b30043bb95fed5">type</a></td>
<td class="fieldname">
type</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structhydra_1_1detail_1_1unidimensional" id="structhydra_1_1detail_1_1unidimensional"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1detail_1_1unidimensional">&#9670;&nbsp;</a></span>hydra::detail::unidimensional</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::detail::unidimensional</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"></div><div class="dynheader">
Collaboration diagram for hydra::detail::unidimensional:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1unidimensional__coll__graph.svg" width="198" height="88"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a3c72e1aed3a4538dac06a7e816543c23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c72e1aed3a4538dac06a7e816543c23">&#9670;&nbsp;</a></span>are_all_same</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R , class... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacehydra_1_1detail.html#a3c72e1aed3a4538dac06a7e816543c23">hydra::detail::are_all_same</a> = typedef <a class="el" href="structhydra_1_1detail_1_1all__true.html">all_true</a>&lt;std::is_same&lt;Ts, R&gt;::value...&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aee93c31c37a22c22c49c73483cfd0f91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee93c31c37a22c22c49c73483cfd0f91">&#9670;&nbsp;</a></span>common_type_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class... T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacehydra_1_1detail.html#aee93c31c37a22c22c49c73483cfd0f91">hydra::detail::common_type_t</a> = typedef typename std::common_type&lt;T...&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a759ad336f50b88396a0bef211afe698e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a759ad336f50b88396a0bef211afe698e">&#9670;&nbsp;</a></span>anonymous enum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a759ad336f50b88396a0bef211afe698eaea9c72bdee6f384d88af4eab49530ea8"></a>kInvalidNumber&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a1461b18b118ced9f91233acbe90fd897"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1461b18b118ced9f91233acbe90fd897">&#9670;&nbsp;</a></span>Backend</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacehydra_1_1detail.html#a1461b18b118ced9f91233acbe90fd897">hydra::detail::Backend</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a1461b18b118ced9f91233acbe90fd897a394a4eccb0e1634ec1294f902f5439e2"></a>Host&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1461b18b118ced9f91233acbe90fd897ad7a51d196c98a1057d741a6ebd3d84db"></a>Device&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1461b18b118ced9f91233acbe90fd897a0fb8e6fb3bd5e20cae92bc309106fae4"></a>Cpp&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1461b18b118ced9f91233acbe90fd897a1b83f5e80dc60afdb33987f3d9ce20bf"></a>Omp&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1461b18b118ced9f91233acbe90fd897a0346e63703cdc5752878c4e0623ace64"></a>Tbb&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1461b18b118ced9f91233acbe90fd897a3ef47f45ff0de8694163bcfe498e4a89"></a>Cuda&#160;</td><td class="fielddoc"></td></tr>
</table>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="dalitz_plot_8C-example.html#a27">dalitz_plot.C</a>, and <a class="el" href="dalitz_plot_8inl-example.html#a28">dalitz_plot.inl</a>.</dd>
</dl>
</div>
</div>
<a id="aa817d51dec8ff2c9ad9eeaf1f91bc6e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa817d51dec8ff2c9ad9eeaf1f91bc6e4">&#9670;&nbsp;</a></span>FFTCalculator</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacehydra_1_1detail.html#aa817d51dec8ff2c9ad9eeaf1f91bc6e4">hydra::detail::FFTCalculator</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aa817d51dec8ff2c9ad9eeaf1f91bc6e4a2dcac3babe9917463a1823b4fc97d989"></a>CuFFT&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa817d51dec8ff2c9ad9eeaf1f91bc6e4ac7647480fd178ef276ec77e4830704b3"></a>FFTW&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a52a71a770e750c0031cdad447a7d31fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52a71a770e750c0031cdad447a7d31fd">&#9670;&nbsp;</a></span>_get_element() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename T , size_t I&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::detail::enable_if&lt;(I == hydra::thrust::tuple_size&lt;T&gt;::value), void&gt;::type hydra::detail::_get_element </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R *&amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a515bd52a87e3b90c746742adae859ab7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a515bd52a87e3b90c746742adae859ab7">&#9670;&nbsp;</a></span>_get_element() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename T , size_t I = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::detail::enable_if&lt;( I &lt; hydra::thrust::tuple_size&lt;T&gt;::value), void&gt;::type hydra::detail::_get_element </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R *&amp;&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a31bfd6894ad39b66da15df4dc436d35e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31bfd6894ad39b66da15df4dc436d35e">&#9670;&nbsp;</a></span>accumulate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Return_Type , typename ArgType , typename ... Tp, typename  = typename hydra::thrust::detail::enable_if&lt;std::is_convertible&lt;Return_Type, double&gt;::value || std::is_constructible&lt;hydra::thrust::complex&lt;double&gt;,Return_Type&gt;::value &gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> Return_Type hydra::detail::accumulate </td>
          <td>(</td>
          <td class="paramtype">ArgType &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hydra::thrust::tuple&lt; Tp... &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a06d87d0383479101350ee8934d7fcdf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06d87d0383479101350ee8934d7fcdf2">&#9670;&nbsp;</a></span>accumulate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Return_Type , typename ArgType , typename ... Tp, typename  = typename hydra::thrust::detail::enable_if&lt;std::is_convertible&lt;Return_Type, double&gt;::value || std::is_constructible&lt;hydra::thrust::complex&lt;double&gt;,Return_Type&gt;::value &gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> Return_Type hydra::detail::accumulate </td>
          <td>(</td>
          <td class="paramtype">ArgType const &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hydra::thrust::tuple&lt; Tp... &gt; const &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9b42783cc9a200f4083295d1e2cfd374"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b42783cc9a200f4083295d1e2cfd374">&#9670;&nbsp;</a></span>accumulate2() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Return_Type , typename ArgType1 , typename ArgType2 , typename ... Tp, typename  = typename hydra::thrust::detail::enable_if&lt;std::is_convertible&lt;Return_Type, double&gt;::value || std::is_constructible&lt;hydra::thrust::complex&lt;double&gt;,Return_Type&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> Return_Type hydra::detail::accumulate2 </td>
          <td>(</td>
          <td class="paramtype">ArgType1 &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArgType2 &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hydra::thrust::tuple&lt; Tp... &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a966cab74d28014bd9c6c90524a933f53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a966cab74d28014bd9c6c90524a933f53">&#9670;&nbsp;</a></span>accumulate2() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Return_Type , typename ArgType1 , typename ArgType2 , typename ... Tp, typename  = typename hydra::thrust::detail::enable_if&lt;std::is_convertible&lt;Return_Type, double&gt;::value || std::is_constructible&lt;hydra::thrust::complex&lt;double&gt;,Return_Type&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> Return_Type hydra::detail::accumulate2 </td>
          <td>(</td>
          <td class="paramtype">ArgType1 const &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArgType2 const &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hydra::thrust::tuple&lt; Tp... &gt; const &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad5e05e95babbc9b3610158ca245e9ea9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5e05e95babbc9b3610158ca245e9ea9">&#9670;&nbsp;</a></span>add_parameters_in_tuple() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I = 0, typename ... Tp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">hydra::thrust::detail::enable_if&lt;I == sizeof...(Tp), void&gt;::type hydra::detail::add_parameters_in_tuple </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="group__fit.html#structhydra_1_1Parameter">hydra::Parameter</a> *&gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hydra::thrust::tuple&lt; Tp... &gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7ec0b20f1c76a09e6f8c20bff1b1606f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ec0b20f1c76a09e6f8c20bff1b1606f">&#9670;&nbsp;</a></span>add_parameters_in_tuple() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I = 0, typename ... Tp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">hydra::thrust::detail::enable_if&lt;(I &lt; sizeof...(Tp)),void &gt;::type hydra::detail::add_parameters_in_tuple </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="group__fit.html#structhydra_1_1Parameter">hydra::Parameter</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>user_parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hydra::thrust::tuple&lt; Tp... &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a47ca3e1e60cf87925082ffecc2ffc189"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47ca3e1e60cf87925082ffecc2ffc189">&#9670;&nbsp;</a></span>add_tuple_values() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I, typename ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::detail::enable_if&lt;(I == sizeof...(T)),void &gt;::type hydra::detail::add_tuple_values </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hydra::thrust::tuple&lt; T... &gt; const &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af386c271b963d41d9cfc54fe76a0d581"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af386c271b963d41d9cfc54fe76a0d581">&#9670;&nbsp;</a></span>add_tuple_values() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I = 0, typename ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::detail::enable_if&lt;(I &lt; sizeof...(T)),void &gt;::type hydra::detail::add_tuple_values </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hydra::thrust::tuple&lt; T... &gt; const &amp;&#160;</td>
          <td class="paramname"><em>tpl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac651383169b82d9cf2a231475addf465"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac651383169b82d9cf2a231475addf465">&#9670;&nbsp;</a></span>addTuples() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, size_t ... I&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::tuple&lt;T...&gt; hydra::detail::addTuples </td>
          <td>(</td>
          <td class="paramtype">const hydra::thrust::tuple&lt; T... &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const hydra::thrust::tuple&lt; T... &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1detail_1_1index__sequence.html">index_sequence</a>&lt; I... &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6cfd0003bddb737423532a8fc9246fcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cfd0003bddb737423532a8fc9246fcb">&#9670;&nbsp;</a></span>addTuples() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::tuple&lt;T...&gt; hydra::detail::addTuples </td>
          <td>(</td>
          <td class="paramtype">const hydra::thrust::tuple&lt; T... &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const hydra::thrust::tuple&lt; T... &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1ab373fce03602fa7e4ab99b8ec00232"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ab373fce03602fa7e4ab99b8ec00232">&#9670;&nbsp;</a></span>addTuplesHelper()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I, typename ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::tuple_element&lt;I, hydra::thrust::tuple&lt;T...&gt; &gt;::type hydra::detail::addTuplesHelper </td>
          <td>(</td>
          <td class="paramtype">const hydra::thrust::tuple&lt; T... &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const hydra::thrust::tuple&lt; T... &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa3be119e15f0b9be4173ba8268a66b71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3be119e15f0b9be4173ba8268a66b71">&#9670;&nbsp;</a></span>ApproximatelyEqual()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> bool hydra::detail::ApproximatelyEqual </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code><a class="el" href="namespacehydra_1_1detail.html#af60fc3e60cc10bd79092ca02c8e8b84c">machine_eps_f64</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="acc4a7a3b4f3c2827fd0eaff57e0b300c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc4a7a3b4f3c2827fd0eaff57e0b300c">&#9670;&nbsp;</a></span>ApproximatelyZero()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> bool hydra::detail::ApproximatelyZero </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code><a class="el" href="namespacehydra_1_1detail.html#af60fc3e60cc10bd79092ca02c8e8b84c">machine_eps_f64</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2fb09f08e05c59f9cb8f7810677b0a35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fb09f08e05c59f9cb8f7810677b0a35">&#9670;&nbsp;</a></span>arrayToTuple() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::detail::arrayToTuple </td>
          <td>(</td>
          <td class="paramtype">std::array&lt; T, N &gt;const &amp;&#160;</td>
          <td class="paramname"><em>Array</em></td><td>)</td>
          <td> -&gt; decltype(<a class="el" href="namespacehydra_1_1detail.html#aad94bd46c688eb458dde424609df5dae">arrayToTupleHelper</a>(Array, <a class="el" href="structhydra_1_1detail_1_1make__index__sequence.html">make_index_sequence</a>&lt;N&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9d0da29f0be34c5fe0f79e47b6963340"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d0da29f0be34c5fe0f79e47b6963340">&#9670;&nbsp;</a></span>arrayToTuple() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> auto hydra::detail::arrayToTuple </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>Array</em></td><td>)</td>
          <td> -&gt; decltype( <a class="el" href="namespacehydra_1_1detail.html#aad94bd46c688eb458dde424609df5dae">arrayToTupleHelper</a>(Array, <a class="el" href="structhydra_1_1detail_1_1make__index__sequence.html">make_index_sequence</a>&lt;N&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aad94bd46c688eb458dde424609df5dae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad94bd46c688eb458dde424609df5dae">&#9670;&nbsp;</a></span>arrayToTupleHelper() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t... Is&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::detail::arrayToTupleHelper </td>
          <td>(</td>
          <td class="paramtype">std::array&lt; T, sizeof...(Is)&gt;const &amp;&#160;</td>
          <td class="paramname"><em>Array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1detail_1_1index__sequence.html">index_sequence</a>&lt; Is... &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(hydra::thrust::make_tuple(Array[Is]...))
	</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab6551302bfdad575a3f6a01b57d14f0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6551302bfdad575a3f6a01b57d14f0d">&#9670;&nbsp;</a></span>arrayToTupleHelper() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t... Indices&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> auto hydra::detail::arrayToTupleHelper </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>Array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1detail_1_1index__sequence.html">index_sequence</a>&lt; Indices... &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(hydra::thrust::make_tuple(Array[Indices]...))
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a81d062e40531f7b09a8926d642ba2032"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81d062e40531f7b09a8926d642ba2032">&#9670;&nbsp;</a></span>assignArrayToTuple() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I, typename ArrayType , typename FistType , typename ... OtherTypes&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::detail::enable_if&lt; I == (sizeof...(OtherTypes) + 1) &amp;&amp; std::is_convertible&lt;FistType, ArrayType&gt;::value &amp;&amp; <a class="el" href="structhydra_1_1detail_1_1all__true.html">all_true</a>&lt; std::is_convertible&lt;OtherTypes,ArrayType&gt;::value...&gt;::value, void &gt;::type hydra::detail::assignArrayToTuple </td>
          <td>(</td>
          <td class="paramtype">hydra::thrust::tuple&lt; FistType, OtherTypes... &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArrayType const *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a688c325b220c8fa30f5790d636183eca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a688c325b220c8fa30f5790d636183eca">&#9670;&nbsp;</a></span>assignArrayToTuple() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I = 0, typename ArrayType , typename FistType , typename ... OtherTypes&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::detail::enable_if&lt; (I &lt; sizeof...(OtherTypes)+1) &amp;&amp; std::is_convertible&lt;FistType, ArrayType&gt;::value &amp;&amp; <a class="el" href="structhydra_1_1detail_1_1all__true.html">all_true</a>&lt; std::is_convertible&lt;OtherTypes,ArrayType&gt;::value...&gt;::value, void &gt;::type hydra::detail::assignArrayToTuple </td>
          <td>(</td>
          <td class="paramtype">hydra::thrust::tuple&lt; FistType, OtherTypes... &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArrayType const *&#160;</td>
          <td class="paramname"><em>Array</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a240c9e228115543008d63b6e21f300ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a240c9e228115543008d63b6e21f300ea">&#9670;&nbsp;</a></span>assignArrayToTuple() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I, typename ArrayType , typename FistType , typename ... OtherTypes&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::detail::enable_if&lt; I == (sizeof...(OtherTypes) + 1) &amp;&amp; std::is_convertible&lt;FistType,ArrayType &gt;::value &amp;&amp; <a class="el" href="structhydra_1_1detail_1_1all__true.html">all_true</a>&lt;std::is_convertible&lt;OtherTypes,ArrayType&gt;::value...&gt;::value, void&gt;::type hydra::detail::assignArrayToTuple </td>
          <td>(</td>
          <td class="paramtype">hydra::thrust::detail::tuple_of_iterator_references&lt; FistType, OtherTypes... &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArrayType const *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aed9ce2a67e87b89e2bacaeac434fc5a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed9ce2a67e87b89e2bacaeac434fc5a8">&#9670;&nbsp;</a></span>assignArrayToTuple() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I = 0, typename ArrayType , typename FistType , typename ... OtherTypes&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::detail::enable_if&lt; (I &lt; sizeof...(OtherTypes)+1) &amp;&amp; std::is_convertible&lt;FistType,ArrayType &gt;::value &amp;&amp; <a class="el" href="structhydra_1_1detail_1_1all__true.html">all_true</a>&lt;std::is_convertible&lt;OtherTypes,ArrayType&gt;::value...&gt;::value, void &gt;::type hydra::detail::assignArrayToTuple </td>
          <td>(</td>
          <td class="paramtype">hydra::thrust::detail::tuple_of_iterator_references&lt; FistType, OtherTypes... &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArrayType const *&#160;</td>
          <td class="paramname"><em>Array</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3d6f9257e6380f1890e0b7adc0190747"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d6f9257e6380f1890e0b7adc0190747">&#9670;&nbsp;</a></span>assignTupleToArray() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I, typename Type , typename Head , typename ... Tail&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> std::enable_if&lt; (I == sizeof...(Tail) + 1) &amp;&amp; std::is_convertible&lt; Head, Type&gt;::value &amp;&amp; <a class="el" href="structhydra_1_1detail_1_1all__true.html">all_true</a>&lt;std::is_convertible&lt;Tail, Type&gt;::value ... &gt;::value, void &gt;::type hydra::detail::assignTupleToArray </td>
          <td>(</td>
          <td class="paramtype">hydra::thrust::tuple&lt; Head, Tail... &gt; const &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type(&amp;)&#160;</td>
          <td class="paramname">[sizeof...(Tail)+1]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac3b86512e9cd5ea9ed988e099f5c54b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3b86512e9cd5ea9ed988e099f5c54b4">&#9670;&nbsp;</a></span>assignTupleToArray() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I = 0, typename Type , typename Head , typename ... Tail&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> std::enable_if&lt; (I &lt; sizeof...(Tail) + 1) &amp;&amp; std::is_convertible&lt; Head, Type&gt;::value &amp;&amp; <a class="el" href="structhydra_1_1detail_1_1all__true.html">all_true</a>&lt;std::is_convertible&lt;Tail, Type&gt;::value ... &gt;::value, void &gt;::type hydra::detail::assignTupleToArray </td>
          <td>(</td>
          <td class="paramtype">hydra::thrust::tuple&lt; Head, Tail... &gt; const &amp;&#160;</td>
          <td class="paramname"><em>Tuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type(&amp;)&#160;</td>
          <td class="paramname"><em>Array</em>[sizeof...(Tail)+1]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a713732dd6592045a450b169e34ef956c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a713732dd6592045a450b169e34ef956c">&#9670;&nbsp;</a></span>assignTupleToArray() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I, typename Type , typename Head , typename ... Tail&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> std::enable_if&lt; (I == sizeof...(Tail) + 1) &amp;&amp; std::is_convertible&lt; Head, Type&gt;::value &amp;&amp; <a class="el" href="structhydra_1_1detail_1_1all__true.html">all_true</a>&lt;std::is_convertible&lt;Tail, Type&gt;::value ... &gt;::value, void &gt;::type hydra::detail::assignTupleToArray </td>
          <td>(</td>
          <td class="paramtype">hydra::thrust::tuple&lt; Head, Tail... &gt; const &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; Type, sizeof...(Tail)+1 &gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a31af39400225fa9e9ff79a3b802e73d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31af39400225fa9e9ff79a3b802e73d0">&#9670;&nbsp;</a></span>assignTupleToArray() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I = 0, typename Type , typename Head , typename ... Tail&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> std::enable_if&lt; (I &lt; sizeof...(Tail) + 1) &amp;&amp; std::is_convertible&lt; Head, Type&gt;::value &amp;&amp; <a class="el" href="structhydra_1_1detail_1_1all__true.html">all_true</a>&lt;std::is_convertible&lt;Tail, Type&gt;::value ... &gt;::value, void &gt;::type hydra::detail::assignTupleToArray </td>
          <td>(</td>
          <td class="paramtype">hydra::thrust::tuple&lt; Head, Tail... &gt; const &amp;&#160;</td>
          <td class="paramname"><em>Tuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; Type, sizeof...(Tail)+1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>Array</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a857673d7a6d3e5e5da3891670a276c6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a857673d7a6d3e5e5da3891670a276c6e">&#9670;&nbsp;</a></span>assignTupleToArray() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I, typename Type , typename Head , typename ... Tail&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> std::enable_if&lt; (I == sizeof...(Tail) + 1) &amp;&amp; std::is_convertible&lt; typename <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1remove__device__reference">remove_device_reference</a>&lt;Head&gt;::type, Type&gt;::value &amp;&amp; <a class="el" href="structhydra_1_1detail_1_1all__true.html">all_true</a>&lt;std::is_convertible&lt; typename <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1remove__device__reference">remove_device_reference</a>&lt;Tail&gt;::type, Type&gt;::value ... &gt;::value, void &gt;::type hydra::detail::assignTupleToArray </td>
          <td>(</td>
          <td class="paramtype">hydra::thrust::detail::tuple_of_iterator_references&lt; Head, Tail... &gt; const &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type(&amp;)&#160;</td>
          <td class="paramname">[sizeof...(Tail)+1]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a23efaec2eb9afcba167ec112900bd809"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23efaec2eb9afcba167ec112900bd809">&#9670;&nbsp;</a></span>assignTupleToArray() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I = 0, typename Type , typename Head , typename ... Tail&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> std::enable_if&lt; (I &lt; sizeof...(Tail) + 1) &amp;&amp; std::is_convertible&lt; typename <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1remove__device__reference">remove_device_reference</a>&lt;Head&gt;::type, Type&gt;::value &amp;&amp; <a class="el" href="structhydra_1_1detail_1_1all__true.html">all_true</a>&lt;std::is_convertible&lt;typename <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1remove__device__reference">remove_device_reference</a>&lt;Tail&gt;::type, Type&gt;::value ... &gt;::value, void &gt;::type hydra::detail::assignTupleToArray </td>
          <td>(</td>
          <td class="paramtype">hydra::thrust::detail::tuple_of_iterator_references&lt; Head, Tail... &gt; const &amp;&#160;</td>
          <td class="paramname"><em>Tuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type(&amp;)&#160;</td>
          <td class="paramname"><em>Array</em>[sizeof...(Tail)+1]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab9eba02ade1dc8fad3c8a812861d1f51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9eba02ade1dc8fad3c8a812861d1f51">&#9670;&nbsp;</a></span>assignTupleToArray() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I, typename Type , typename Head , typename ... Tail&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> std::enable_if&lt; (I == sizeof...(Tail) + 1) &amp;&amp; std::is_convertible&lt; typename <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1remove__device__reference">remove_device_reference</a>&lt;Head&gt;::type, Type&gt;::value &amp;&amp; <a class="el" href="structhydra_1_1detail_1_1all__true.html">all_true</a>&lt;std::is_convertible&lt;typename <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1remove__device__reference">remove_device_reference</a>&lt;Tail&gt;::type, Type&gt;::value ... &gt;::value, void &gt;::type hydra::detail::assignTupleToArray </td>
          <td>(</td>
          <td class="paramtype">hydra::thrust::detail::tuple_of_iterator_references&lt; Head, Tail... &gt; const &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; Type, sizeof...(Tail)+1 &gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9b8e2c32f19fd47e9ca64e2cc2352c55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b8e2c32f19fd47e9ca64e2cc2352c55">&#9670;&nbsp;</a></span>assignTupleToArray() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I = 0, typename Type , typename Head , typename ... Tail&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> std::enable_if&lt; (I &lt; sizeof...(Tail) + 1) &amp;&amp; std::is_convertible&lt; typename <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1remove__device__reference">remove_device_reference</a>&lt;Head&gt;::type, Type&gt;::value &amp;&amp; <a class="el" href="structhydra_1_1detail_1_1all__true.html">all_true</a>&lt;std::is_convertible&lt;typename <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1remove__device__reference">remove_device_reference</a>&lt;Tail&gt;::type, Type&gt;::value ... &gt;::value, void &gt;::type hydra::detail::assignTupleToArray </td>
          <td>(</td>
          <td class="paramtype">hydra::thrust::detail::tuple_of_iterator_references&lt; Head, Tail... &gt; const &amp;&#160;</td>
          <td class="paramname"><em>Tuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; Type, sizeof...(Tail)+1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>Array</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a109730297fac46a2426c6059b9784beb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a109730297fac46a2426c6059b9784beb">&#9670;&nbsp;</a></span>callOnTuple()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F , typename ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::tuple&lt;T...&gt; hydra::detail::callOnTuple </td>
          <td>(</td>
          <td class="paramtype">F const &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const hydra::thrust::tuple&lt; T... &gt; &amp;&#160;</td>
          <td class="paramname"><em>tuple</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6a0b98375d08af50ce905a6111ea28d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a0b98375d08af50ce905a6111ea28d6">&#9670;&nbsp;</a></span>callOnTupleHelper()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F , typename ... T, size_t ... I&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::tuple&lt;T...&gt; hydra::detail::callOnTupleHelper </td>
          <td>(</td>
          <td class="paramtype">F const &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const hydra::thrust::tuple&lt; T... &gt; &amp;&#160;</td>
          <td class="paramname"><em>tuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1detail_1_1index__sequence.html">index_sequence</a>&lt; I... &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aeccac2b5a421cca43286e9717d251c69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeccac2b5a421cca43286e9717d251c69">&#9670;&nbsp;</a></span>CheckValue()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename ... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> T hydra::detail::CheckValue </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_3globalScope_4.html#classunsigned">unsigned</a> <a class="el" href="namespace_3globalScope_4.html#classint">int</a>&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ts &amp;&amp;...&#160;</td>
          <td class="paramname"><em>par</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a533680a227b0bdd9daec32b216c92945"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a533680a227b0bdd9daec32b216c92945">&#9670;&nbsp;</a></span>divideTuples() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, size_t ... I&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::tuple&lt;T...&gt; hydra::detail::divideTuples </td>
          <td>(</td>
          <td class="paramtype">const hydra::thrust::tuple&lt; T... &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const hydra::thrust::tuple&lt; T... &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1detail_1_1index__sequence.html">index_sequence</a>&lt; I... &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a439c4bd1b41623ef36429392b1c29c46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a439c4bd1b41623ef36429392b1c29c46">&#9670;&nbsp;</a></span>divideTuples() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::tuple&lt;T...&gt; hydra::detail::divideTuples </td>
          <td>(</td>
          <td class="paramtype">const hydra::thrust::tuple&lt; T... &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const hydra::thrust::tuple&lt; T... &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0123bf736172613baa970113bd1a21c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0123bf736172613baa970113bd1a21c8">&#9670;&nbsp;</a></span>divideTuplesHelper()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I, typename ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::tuple_element&lt;I, hydra::thrust::tuple&lt;T...&gt; &gt;::type hydra::detail::divideTuplesHelper </td>
          <td>(</td>
          <td class="paramtype">const hydra::thrust::tuple&lt; T... &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const hydra::thrust::tuple&lt; T... &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa48b8114dfe40b2ad9f15962fca73873"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa48b8114dfe40b2ad9f15962fca73873">&#9670;&nbsp;</a></span>eval_on_tuple_element() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int I = 0, typename FuncT , typename ... Tp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::detail::enable_if&lt;I == sizeof...(Tp), void&gt;::type hydra::detail::eval_on_tuple_element </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_3globalScope_4.html#classint">int</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hydra::thrust::tuple&lt; Tp... &gt; const &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FuncT const &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa22e275cf1dc4aa0553815e5a403afe9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa22e275cf1dc4aa0553815e5a403afe9">&#9670;&nbsp;</a></span>eval_on_tuple_element() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int I = 0, typename FuncT , typename ... Tp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::detail::enable_if&lt;(I &lt; sizeof...(Tp)), void &gt;::type hydra::detail::eval_on_tuple_element </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_3globalScope_4.html#classint">int</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hydra::thrust::tuple&lt; Tp... &gt; const &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FuncT const &amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5c36121fc4ff640d4bb5e46df8fab18a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c36121fc4ff640d4bb5e46df8fab18a">&#9670;&nbsp;</a></span>eval_tuple_element() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I = 0, typename Return_Type , typename ArgType , typename ... Tp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::detail::enable_if&lt;I == sizeof...(Tp), void&gt;::type hydra::detail::eval_tuple_element </td>
          <td>(</td>
          <td class="paramtype">Return_Type &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_3globalScope_4.html#classint">int</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hydra::thrust::tuple&lt; Tp... &gt; const &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArgType const &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a822da880b13448285790c6d029454a4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a822da880b13448285790c6d029454a4f">&#9670;&nbsp;</a></span>eval_tuple_element() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I = 0, typename Return_Type , typename ArgType , typename ... Tp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::detail::enable_if&lt;(I &lt; sizeof...(Tp)), void &gt;::type hydra::detail::eval_tuple_element </td>
          <td>(</td>
          <td class="paramtype">Return_Type &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_3globalScope_4.html#classint">int</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hydra::thrust::tuple&lt; Tp... &gt; const &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArgType const &amp;&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a96a946dad2a4b9f834836d9b954ad8b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96a946dad2a4b9f834836d9b954ad8b6">&#9670;&nbsp;</a></span>extract()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , typename Tuple &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> Type hydra::detail::extract </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_3globalScope_4.html#classint">int</a>&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Tuple &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3128d1411d3b961132470fbad5761721"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3128d1411d3b961132470fbad5761721">&#9670;&nbsp;</a></span>get_element()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> R&amp; hydra::detail::get_element </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hydra::thrust::tuple&lt; T... &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4f5a0cb9111ec6aee52c31a221dfd6d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f5a0cb9111ec6aee52c31a221dfd6d3">&#9670;&nbsp;</a></span>get_functor_tuple()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tup &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::detail::get_functor_tuple </td>
          <td>(</td>
          <td class="paramtype">Tup &amp;&#160;</td>
          <td class="paramname"><em>pdfs</em></td><td>)</td>
          <td> -&gt; decltype(<a class="el" href="namespacehydra_1_1detail.html#aa7ba7bea072d6c3b6de86086bb49436d">get_functor_tuple_helper</a>(pdfs, <a class="el" href="structhydra_1_1detail_1_1make__index__sequence.html">make_index_sequence</a>&lt; hydra::thrust::tuple_size&lt;Tup&gt;::value&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa7ba7bea072d6c3b6de86086bb49436d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7ba7bea072d6c3b6de86086bb49436d">&#9670;&nbsp;</a></span>get_functor_tuple_helper() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tup , size_t ... index&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::detail::get_functor_tuple_helper </td>
          <td>(</td>
          <td class="paramtype">Tup &amp;&#160;</td>
          <td class="paramname"><em>pdfs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1detail_1_1index__sequence.html">index_sequence</a>&lt; index... &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(hydra::thrust::make_tuple(hydra::thrust::get&lt;index&gt;(pdfs).GetFunctor()...))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7c688d5b722922805a5837cac93a6411"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c688d5b722922805a5837cac93a6411">&#9670;&nbsp;</a></span>get_functor_tuple_helper() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="basic__distributions_8inl.html#a9717e7bbecb906637e86cef6da3d83c2">return</a> hydra::detail::get_functor_tuple_helper </td>
          <td>(</td>
          <td class="paramtype">pdfs&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1detail_1_1make__index__sequence.html">make_index_sequence</a>&lt; Size &gt; { }&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a325f4c7bd791f8e4c8e7777fd1004e6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a325f4c7bd791f8e4c8e7777fd1004e6a">&#9670;&nbsp;</a></span>get_indexes() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t DIM, size_t I&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; (I==DIM) &amp;&amp; (std::is_integral&lt;T&gt;::value), void &gt;::type hydra::detail::get_indexes </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; T, DIM &gt; const &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; T, DIM &gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7ba59a3eeef51673f8abf850370c9d55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ba59a3eeef51673f8abf850370c9d55">&#9670;&nbsp;</a></span>get_indexes() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t DIM, size_t I = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; (I&lt;DIM) &amp;&amp; (std::is_integral&lt;T&gt;::value), void &gt;::type hydra::detail::get_indexes </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; T, DIM &gt; const &amp;&#160;</td>
          <td class="paramname"><em>depths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; T, DIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>indexes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a25ee93686d2834f2c81bbc9ca75340b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25ee93686d2834f2c81bbc9ca75340b3">&#9670;&nbsp;</a></span>get_indexes() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t DIM, size_t I&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; (I==DIM) &amp;&amp; (std::is_integral&lt;T&gt;::value), void &gt;::type hydra::detail::get_indexes </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const &#160;</td>
          <td class="paramname"><em>T</em>(&amp;)[DIM], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T(&amp;)&#160;</td>
          <td class="paramname">[DIM]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab08843425e05190a4baeb424c9da09a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab08843425e05190a4baeb424c9da09a9">&#9670;&nbsp;</a></span>get_indexes() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t DIM, size_t I = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; (I&lt;DIM) &amp;&amp; (std::is_integral&lt;T&gt;::value), void &gt;::type hydra::detail::get_indexes </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T(&amp;)&#160;</td>
          <td class="paramname"><em>depths</em>[DIM], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T(&amp;)&#160;</td>
          <td class="paramname"><em>indexes</em>[DIM]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae31448e32eaed1ff5ff50aa5e38f07c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae31448e32eaed1ff5ff50aa5e38f07c2">&#9670;&nbsp;</a></span>get_tuple_element() <span class="overload">[1/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Types&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> T&amp; hydra::detail::get_tuple_element </td>
          <td>(</td>
          <td class="paramtype">hydra::thrust::tuple&lt; Types... &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a87618b06102d42ac34d558bf61c62348"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87618b06102d42ac34d558bf61c62348">&#9670;&nbsp;</a></span>get_tuple_element() <span class="overload">[2/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class... Types&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> const T&amp; hydra::detail::get_tuple_element </td>
          <td>(</td>
          <td class="paramtype">const hydra::thrust::tuple&lt; Types... &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad44ec203de64b9badd86e5346a10844d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad44ec203de64b9badd86e5346a10844d">&#9670;&nbsp;</a></span>get_tuple_element() <span class="overload">[3/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class... Types&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> T&amp;&amp; hydra::detail::get_tuple_element </td>
          <td>(</td>
          <td class="paramtype">hydra::thrust::tuple&lt; Types... &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af5b190f448bfde92779de08ba20bd1cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5b190f448bfde92779de08ba20bd1cf">&#9670;&nbsp;</a></span>get_tuple_element() <span class="overload">[4/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Types&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::device_reference&lt;T&gt; hydra::detail::get_tuple_element </td>
          <td>(</td>
          <td class="paramtype">hydra::thrust::tuple&lt; hydra::thrust::device_reference&lt; Types &gt;... &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa5e56dc110894f474283544cd1d10cf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5e56dc110894f474283544cd1d10cf4">&#9670;&nbsp;</a></span>get_tuple_element() <span class="overload">[5/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class... Types&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> const hydra::thrust::device_reference&lt;T&gt; hydra::detail::get_tuple_element </td>
          <td>(</td>
          <td class="paramtype">const hydra::thrust::tuple&lt; hydra::thrust::device_reference&lt; Types &gt;... &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad6fe4e915198df9be331a66afab71487"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6fe4e915198df9be331a66afab71487">&#9670;&nbsp;</a></span>get_tuple_element() <span class="overload">[6/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class... Types&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::device_reference&lt;T&gt;&amp;&amp; hydra::detail::get_tuple_element </td>
          <td>(</td>
          <td class="paramtype">hydra::thrust::tuple&lt; hydra::thrust::device_reference&lt; Types &gt;... &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a94f259d5cf34fae4d59075522fa0e8e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94f259d5cf34fae4d59075522fa0e8e0">&#9670;&nbsp;</a></span>get_tuple_element() <span class="overload">[7/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Types&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::device_reference&lt;T&gt; hydra::detail::get_tuple_element </td>
          <td>(</td>
          <td class="paramtype">hydra::thrust::detail::tuple_of_iterator_references&lt; hydra::thrust::device_reference&lt; Types &gt;... &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a30daeef337658b187d8a47db529b4e75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30daeef337658b187d8a47db529b4e75">&#9670;&nbsp;</a></span>get_tuple_element() <span class="overload">[8/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class... Types&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> const hydra::thrust::device_reference&lt;T&gt; hydra::detail::get_tuple_element </td>
          <td>(</td>
          <td class="paramtype">const hydra::thrust::detail::tuple_of_iterator_references&lt; hydra::thrust::device_reference&lt; Types &gt;... &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0728be8212954b5f0756e47ec00981cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0728be8212954b5f0756e47ec00981cf">&#9670;&nbsp;</a></span>get_tuple_element() <span class="overload">[9/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class... Types&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::device_reference&lt;T&gt; hydra::detail::get_tuple_element </td>
          <td>(</td>
          <td class="paramtype">hydra::thrust::detail::tuple_of_iterator_references&lt; hydra::thrust::device_reference&lt; Types &gt;... &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a602cafd73a2e5770fad6ee90d555e0e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a602cafd73a2e5770fad6ee90d555e0e0">&#9670;&nbsp;</a></span>get_tuple_element() <span class="overload">[10/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int I = 0, typename T , typename ... Tp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::detail::enable_if&lt;I == sizeof...(Tp), void&gt;::type hydra::detail::get_tuple_element </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_3globalScope_4.html#classint">int</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hydra::thrust::tuple&lt; Tp... &gt; const &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a18ad8af35017817d42f421ba36a832b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18ad8af35017817d42f421ba36a832b9">&#9670;&nbsp;</a></span>get_tuple_element() <span class="overload">[11/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int I = 0, typename T , typename ... Tp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::detail::enable_if&lt;(I &lt; sizeof...(Tp)), void &gt;::type hydra::detail::get_tuple_element </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_3globalScope_4.html#classint">int</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hydra::thrust::tuple&lt; Tp... &gt; const &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a227e0b524804a0ceef56b4a1da1953d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a227e0b524804a0ceef56b4a1da1953d4">&#9670;&nbsp;</a></span>get_zip_iterator() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator , size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> auto hydra::detail::get_zip_iterator </td>
          <td>(</td>
          <td class="paramtype">std::array&lt; Iterator, N &gt;const &amp;&#160;</td>
          <td class="paramname"><em>array_of_iterators</em></td><td>)</td>
          <td> -&gt; decltype( <a class="el" href="namespacehydra_1_1detail.html#a70f2fe29b87457d99a58eb0025bf88dd">get_zip_iterator_helper</a>( array_of_iterators , <a class="el" href="structhydra_1_1detail_1_1make__index__sequence.html">make_index_sequence</a>&lt;N&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae9da0535b5305aaf5cfe698c42ebc8d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9da0535b5305aaf5cfe698c42ebc8d6">&#9670;&nbsp;</a></span>get_zip_iterator() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IteratorHead , typename IteratorTail , size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> auto hydra::detail::get_zip_iterator </td>
          <td>(</td>
          <td class="paramtype">IteratorHead&#160;</td>
          <td class="paramname"><em>head</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; IteratorTail, N &gt;const &amp;&#160;</td>
          <td class="paramname"><em>array_of_iterators</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype( <a class="el" href="namespacehydra_1_1detail.html#a70f2fe29b87457d99a58eb0025bf88dd">get_zip_iterator_helper</a>(head, array_of_iterators , <a class="el" href="structhydra_1_1detail_1_1make__index__sequence.html">make_index_sequence</a>&lt;N&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a70f2fe29b87457d99a58eb0025bf88dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70f2fe29b87457d99a58eb0025bf88dd">&#9670;&nbsp;</a></span>get_zip_iterator_helper() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator , size_t ... Index&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> auto hydra::detail::get_zip_iterator_helper </td>
          <td>(</td>
          <td class="paramtype">std::array&lt; Iterator, sizeof ...(Index)&gt;const &amp;&#160;</td>
          <td class="paramname"><em>array_of_iterators</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1detail_1_1index__sequence.html">index_sequence</a>&lt; Index... &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype( hydra::thrust::make_zip_iterator( hydra::thrust::make_tuple( array_of_iterators[Index]...)) )
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8a935492c6993543ddd346a1ce0bb1e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a935492c6993543ddd346a1ce0bb1e2">&#9670;&nbsp;</a></span>get_zip_iterator_helper() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IteratorHead , typename IteratorTail , size_t ... Index&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> auto hydra::detail::get_zip_iterator_helper </td>
          <td>(</td>
          <td class="paramtype">IteratorHead&#160;</td>
          <td class="paramname"><em>head</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; IteratorTail, sizeof ...(Index)&gt;const &amp;&#160;</td>
          <td class="paramname"><em>array_of_iterators</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1detail_1_1index__sequence.html">index_sequence</a>&lt; Index... &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype( hydra::thrust::make_zip_iterator( hydra::thrust::make_tuple(head, array_of_iterators[Index]...)) )
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a618d244958e2ded8465ae85756a011cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a618d244958e2ded8465ae85756a011cd">&#9670;&nbsp;</a></span>hash_combine()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void hydra::detail::hash_combine </td>
          <td>(</td>
          <td class="paramtype">std::size_t &amp;&#160;</td>
          <td class="paramname"><em>seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0be774a301b3817c97d58c61aa08ba85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0be774a301b3817c97d58c61aa08ba85">&#9670;&nbsp;</a></span>hash_range() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class It &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t hydra::detail::hash_range </td>
          <td>(</td>
          <td class="paramtype">It&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">It&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abda9a4b4ec271e3f6c5adf9bc93a3173"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abda9a4b4ec271e3f6c5adf9bc93a3173">&#9670;&nbsp;</a></span>hash_range() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class It &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void hydra::detail::hash_range </td>
          <td>(</td>
          <td class="paramtype">std::size_t &amp;&#160;</td>
          <td class="paramname"><em>seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">It&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">It&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a256df6594bc88c80701d99622515c875"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a256df6594bc88c80701d99622515c875">&#9670;&nbsp;</a></span>hash_tuple() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void hydra::detail::hash_tuple </td>
          <td>(</td>
          <td class="paramtype">std::size_t &amp;&#160;</td>
          <td class="paramname"><em>seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#ac3486502b2db72187626125cea971683">hydra::tuple</a>&lt; T... &gt; const &amp;&#160;</td>
          <td class="paramname"><em>_tuple</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a425bb4f65a43d822ba80ebdbca5b8b74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a425bb4f65a43d822ba80ebdbca5b8b74">&#9670;&nbsp;</a></span>hash_tuple() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t hydra::detail::hash_tuple </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#ac3486502b2db72187626125cea971683">hydra::tuple</a>&lt; T... &gt; const &amp;&#160;</td>
          <td class="paramname"><em>_tuple</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0b30f3961b7f4ed7c28a4e1373281c1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b30f3961b7f4ed7c28a4e1373281c1c">&#9670;&nbsp;</a></span>invoke() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tup , typename ArgType , size_t N = hydra::thrust::tuple_size&lt;typename hydra::thrust::detail::remove_reference&lt;Tup&gt;::type&gt;::value&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_thrust_exec_check_disable__ <a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> auto hydra::detail::invoke </td>
          <td>(</td>
          <td class="paramtype">ArgType &amp;&amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tup &amp;&amp;&#160;</td>
          <td class="paramname"><em>tup</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(<a class="el" href="namespacehydra_1_1detail.html#a15800958694e9465ff44c60dae36d25b">invoke_helper</a>(std::forward&lt;ArgType&gt;(x), std::forward&lt;Tup&gt;(tup), <a class="el" href="structhydra_1_1detail_1_1make__index__sequence.html">make_index_sequence</a>&lt;N&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad31b6d1499b5a6b2d77c015a71385a6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad31b6d1499b5a6b2d77c015a71385a6e">&#9670;&nbsp;</a></span>invoke() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tup , typename ArgType , size_t N = hydra::thrust::tuple_size&lt;typename hydra::thrust::detail::remove_reference&lt;Tup&gt;::type&gt;::value&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_thrust_exec_check_disable__ <a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> auto hydra::detail::invoke </td>
          <td>(</td>
          <td class="paramtype">ArgType const &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tup const &amp;&#160;</td>
          <td class="paramname"><em>tup</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(<a class="el" href="namespacehydra_1_1detail.html#a15800958694e9465ff44c60dae36d25b">invoke_helper</a>(x, tup, <a class="el" href="structhydra_1_1detail_1_1make__index__sequence.html">make_index_sequence</a>&lt;N&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab7367f21b0df25c033551a4f2a88b9f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7367f21b0df25c033551a4f2a88b9f7">&#9670;&nbsp;</a></span>invoke() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tup , typename ArgType1 , typename ArgType2 , size_t N = hydra::thrust::tuple_size&lt;typename hydra::thrust::detail::remove_reference&lt;Tup&gt;::type&gt;::value&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_thrust_exec_check_disable__ <a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> auto hydra::detail::invoke </td>
          <td>(</td>
          <td class="paramtype">ArgType1 &amp;&amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArgType2 &amp;&amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tup &amp;&amp;&#160;</td>
          <td class="paramname"><em>tup</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(<a class="el" href="namespacehydra_1_1detail.html#a15800958694e9465ff44c60dae36d25b">invoke_helper</a>( std::forward&lt;ArgType1&gt;(x), std::forward&lt;ArgType2&gt;(y),  std::forward&lt;Tup&gt;(tup), <a class="el" href="structhydra_1_1detail_1_1make__index__sequence.html">make_index_sequence</a>&lt; hydra::thrust::tuple_size&lt;Tup&gt;::value&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a12930cc3363cf266694e4e13077758de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12930cc3363cf266694e4e13077758de">&#9670;&nbsp;</a></span>invoke() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tup , typename ArgType1 , typename ArgType2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_thrust_exec_check_disable__ <a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> auto hydra::detail::invoke </td>
          <td>(</td>
          <td class="paramtype">ArgType1 const &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArgType2 const &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tup const &amp;&#160;</td>
          <td class="paramname"><em>tup</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(<a class="el" href="namespacehydra_1_1detail.html#a15800958694e9465ff44c60dae36d25b">invoke_helper</a>( x, y, tup, <a class="el" href="structhydra_1_1detail_1_1make__index__sequence.html">make_index_sequence</a>&lt; hydra::thrust::tuple_size&lt;Tup&gt;::value&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a15800958694e9465ff44c60dae36d25b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15800958694e9465ff44c60dae36d25b">&#9670;&nbsp;</a></span>invoke_helper() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tup , typename ArgType , size_t ... index&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_thrust_exec_check_disable__ <a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> auto hydra::detail::invoke_helper </td>
          <td>(</td>
          <td class="paramtype">ArgType &amp;&amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tup &amp;&amp;&#160;</td>
          <td class="paramname"><em>tup</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1detail_1_1index__sequence.html">index_sequence</a>&lt; index... &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(hydra::thrust::make_tuple(hydra::thrust::get&lt;index&gt;(std::forward&lt;Tup&gt;(tup))(std::forward&lt;ArgType&gt;(x))...))
	 </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a78cc12c7ba49afe6f1ad39c31d705758"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78cc12c7ba49afe6f1ad39c31d705758">&#9670;&nbsp;</a></span>invoke_helper() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tup , typename ArgType , size_t ... index&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_thrust_exec_check_disable__ <a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> auto hydra::detail::invoke_helper </td>
          <td>(</td>
          <td class="paramtype">ArgType const &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tup const &amp;&#160;</td>
          <td class="paramname"><em>tup</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1detail_1_1index__sequence.html">index_sequence</a>&lt; index... &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(hydra::thrust::make_tuple(hydra::thrust::get&lt;index&gt;(tup)(x)...))
	 </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a38971d6835214e8b68e4d05ec01a8360"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38971d6835214e8b68e4d05ec01a8360">&#9670;&nbsp;</a></span>invoke_helper() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tup , typename ArgType1 , typename ArgType2 , size_t ... index&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_thrust_exec_check_disable__ <a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> auto hydra::detail::invoke_helper </td>
          <td>(</td>
          <td class="paramtype">ArgType1 &amp;&amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArgType2 &amp;&amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tup &amp;&amp;&#160;</td>
          <td class="paramname"><em>tup</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1detail_1_1index__sequence.html">index_sequence</a>&lt; index... &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype( hydra::thrust::make_tuple(hydra::thrust::get&lt;index&gt;( std::forward&lt;Tup&gt;(tup))(std::forward&lt;ArgType1&gt;(x), std::forward&lt;ArgType2&gt;(y))...) )
	 </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a12be32d2ba8df4c278c368d8df150084"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12be32d2ba8df4c278c368d8df150084">&#9670;&nbsp;</a></span>invoke_helper() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tup , typename ArgType1 , typename ArgType2 , size_t ... index&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_thrust_exec_check_disable__ <a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> auto hydra::detail::invoke_helper </td>
          <td>(</td>
          <td class="paramtype">ArgType1 const &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArgType2 const &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tup const &amp;&#160;</td>
          <td class="paramname"><em>tup</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1detail_1_1index__sequence.html">index_sequence</a>&lt; index... &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype( hydra::thrust::make_tuple(hydra::thrust::get&lt;index&gt;(tup)(x,y)...) )
	 </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9360a30d9cffc4d39b34187a56f0bb92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9360a30d9cffc4d39b34187a56f0bb92">&#9670;&nbsp;</a></span>invoke_helper() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="basic__distributions_8inl.html#a9717e7bbecb906637e86cef6da3d83c2">return</a> hydra::detail::invoke_helper </td>
          <td>(</td>
          <td class="paramtype">x&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">y&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tup&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1detail_1_1make__index__sequence.html">make_index_sequence</a>&lt; Size &gt; { }&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9cf84b4edaeb303174a32a9d9ee44e39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cf84b4edaeb303174a32a9d9ee44e39">&#9670;&nbsp;</a></span>invoke_normalized() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tup , typename ArgType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> auto hydra::detail::invoke_normalized </td>
          <td>(</td>
          <td class="paramtype">ArgType const &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tup const &amp;&#160;</td>
          <td class="paramname"><em>tup</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(<a class="el" href="namespacehydra_1_1detail.html#a15800958694e9465ff44c60dae36d25b">invoke_helper</a>(x, tup, <a class="el" href="structhydra_1_1detail_1_1make__index__sequence.html">make_index_sequence</a>&lt; hydra::thrust::tuple_size&lt;Tup&gt;::value&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af4c0051b20d34181994aa5560387054e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4c0051b20d34181994aa5560387054e">&#9670;&nbsp;</a></span>invoke_normalized() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tup , typename ArgType , size_t N = hydra::thrust::tuple_size&lt;typename hydra::thrust::detail::remove_reference&lt;Tup&gt;::type&gt;::value&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> auto hydra::detail::invoke_normalized </td>
          <td>(</td>
          <td class="paramtype">ArgType &amp;&amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tup &amp;&amp;&#160;</td>
          <td class="paramname"><em>tup</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(<a class="el" href="namespacehydra_1_1detail.html#a15800958694e9465ff44c60dae36d25b">invoke_helper</a>(std::forward&lt;ArgType&gt;(x), std::forward&lt;Tup&gt;(tup), <a class="el" href="structhydra_1_1detail_1_1make__index__sequence.html">make_index_sequence</a>&lt;N&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a00f219e8545b9dcff63940bf1bc4d63e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00f219e8545b9dcff63940bf1bc4d63e">&#9670;&nbsp;</a></span>invoke_normalized_helper() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tup , typename ArgType , size_t ... index&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> auto hydra::detail::invoke_normalized_helper </td>
          <td>(</td>
          <td class="paramtype">ArgType const &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tup const &amp;&#160;</td>
          <td class="paramname"><em>tup</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1detail_1_1index__sequence.html">index_sequence</a>&lt; index... &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(hydra::thrust::make_tuple(hydra::thrust::get&lt;index&gt;(tup)(x)...))
	 </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a173eb394103a0e94fbf9abbc1918a894"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a173eb394103a0e94fbf9abbc1918a894">&#9670;&nbsp;</a></span>invoke_normalized_helper() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="basic__distributions_8inl.html#a9717e7bbecb906637e86cef6da3d83c2">return</a> hydra::detail::invoke_normalized_helper </td>
          <td>(</td>
          <td class="paramtype">x&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tup&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1detail_1_1make__index__sequence.html">make_index_sequence</a>&lt; Size &gt; { }&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af3253bf4c374c43071735c8ca91a1598"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3253bf4c374c43071735c8ca91a1598">&#9670;&nbsp;</a></span>invoke_normalized_helper() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tup , typename ArgType , size_t ... index&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> auto hydra::detail::invoke_normalized_helper </td>
          <td>(</td>
          <td class="paramtype">ArgType &amp;&amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tup &amp;&amp;&#160;</td>
          <td class="paramname"><em>tup</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1detail_1_1index__sequence.html">index_sequence</a>&lt; index... &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(hydra::thrust::make_tuple(hydra::thrust::get&lt;index&gt;(std::forward&lt;Tup&gt;(tup))(std::forward&lt;ArgType&gt;(x))...))
	 </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aad9d0de301331608aa91ce3589f9c5c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad9d0de301331608aa91ce3589f9c5c1">&#9670;&nbsp;</a></span>iter_swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Iterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> void hydra::detail::iter_swap </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>second</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad0a8ff71493e18493d9df6b9cfa1a745"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0a8ff71493e18493d9df6b9cfa1a745">&#9670;&nbsp;</a></span>kill()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename ... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> T hydra::detail::kill </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab5050bf77c477bccc5db77c507cca743"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5050bf77c477bccc5db77c507cca743">&#9670;&nbsp;</a></span>launch_decayer() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t N, typename GRND , typename Iterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void hydra::detail::launch_decayer </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1detail_1_1DecayMother.html">DecayMother</a>&lt; N, GRND &gt; const &amp;&#160;</td>
          <td class="paramname"><em>decayer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4695a02794382f4f997052b425413987"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4695a02794382f4f997052b425413987">&#9670;&nbsp;</a></span>launch_decayer() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t N, typename GRND , typename Iterator , hydra::detail::Backend BACKEND&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void hydra::detail::launch_decayer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; const &amp;&#160;</td>
          <td class="paramname"><em>exec_policy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1detail_1_1DecayMother.html">DecayMother</a>&lt; N, GRND &gt; const &amp;&#160;</td>
          <td class="paramname"><em>decayer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9a35cdb4fa592a33bba8d836aed248df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a35cdb4fa592a33bba8d836aed248df">&#9670;&nbsp;</a></span>launch_decayer() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t N, typename GRND , typename IteratorMother , typename IteratorDaughter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void hydra::detail::launch_decayer </td>
          <td>(</td>
          <td class="paramtype">IteratorMother&#160;</td>
          <td class="paramname"><em>begin_mothers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorMother&#160;</td>
          <td class="paramname"><em>end_mothers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorDaughter&#160;</td>
          <td class="paramname"><em>begin_daugters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1detail_1_1DecayMothers.html">DecayMothers</a>&lt; N, GRND &gt; const &amp;&#160;</td>
          <td class="paramname"><em>decayer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3482cd2a135b31d8bb68fcd11dcdac8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3482cd2a135b31d8bb68fcd11dcdac8d">&#9670;&nbsp;</a></span>launch_decayer() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t N, typename GRND , typename IteratorMother , typename IteratorDaughter , hydra::detail::Backend BACKEND&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void hydra::detail::launch_decayer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; const &amp;&#160;</td>
          <td class="paramname"><em>exec_policy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorMother&#160;</td>
          <td class="paramname"><em>begin_mothers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorMother&#160;</td>
          <td class="paramname"><em>end_mothers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorDaughter&#160;</td>
          <td class="paramname"><em>begin_daugters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1detail_1_1DecayMothers.html">DecayMothers</a>&lt; N, GRND &gt; const &amp;&#160;</td>
          <td class="paramname"><em>decayer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9a2cc34389ca89449738a46e209133a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a2cc34389ca89449738a46e209133a8">&#9670;&nbsp;</a></span>launch_evaluator() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t N, typename FUNCTOR , typename ... FUNCTORS, typename GRND , typename Iterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void hydra::detail::launch_evaluator </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1detail_1_1EvalMother.html">detail::EvalMother</a>&lt; N, GRND, FUNCTOR, FUNCTORS... &gt; const &amp;&#160;</td>
          <td class="paramname"><em>evaluator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a272aed700c4b40bbd2639a84507da00d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a272aed700c4b40bbd2639a84507da00d">&#9670;&nbsp;</a></span>launch_evaluator() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t N, typename FUNCTOR , typename ... FUNCTORS, typename GRND , typename IteratorMother , typename Iterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void hydra::detail::launch_evaluator </td>
          <td>(</td>
          <td class="paramtype">IteratorMother&#160;</td>
          <td class="paramname"><em>mbegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorMother&#160;</td>
          <td class="paramname"><em>mend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1detail_1_1EvalMothers.html">detail::EvalMothers</a>&lt; N, GRND, FUNCTOR, FUNCTORS... &gt; const &amp;&#160;</td>
          <td class="paramname"><em>evaluator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8dce458532ae6b3d821a91604dad7895"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dce458532ae6b3d821a91604dad7895">&#9670;&nbsp;</a></span>launch_reducer() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t N, hydra::detail::Backend BACKEND, typename FUNCTOR , typename GRND , typename Iterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhydra_1_1detail_1_1StatsPHSP.html">StatsPHSP</a> hydra::detail::launch_reducer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt;const &amp;&#160;</td>
          <td class="paramname"><em>policy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1detail_1_1AverageMother.html">detail::AverageMother</a>&lt; N, GRND, FUNCTOR &gt; const &amp;&#160;</td>
          <td class="paramname"><em>evaluator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa8b536e68d5a5831e546272b56c031ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8b536e68d5a5831e546272b56c031ee">&#9670;&nbsp;</a></span>launch_reducer() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t N, typename FUNCTOR , typename GRND , typename Iterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhydra_1_1detail_1_1StatsPHSP.html">StatsPHSP</a> hydra::detail::launch_reducer </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1detail_1_1AverageMothers.html">detail::AverageMothers</a>&lt; N, GRND, FUNCTOR &gt; const &amp;&#160;</td>
          <td class="paramname"><em>evaluator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a024a15ab3a2da15dc78f090437220dde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a024a15ab3a2da15dc78f090437220dde">&#9670;&nbsp;</a></span>lsb() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Integer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> std::enable_if&lt; std::is_integral&lt;Integer&gt;::value &amp;&amp; !(std::is_signed&lt;Integer&gt;::value) &amp;&amp; (sizeof(Integer)==8) , <a class="el" href="namespace_3globalScope_4.html#classunsigned">unsigned</a>&gt;::type hydra::detail::lsb </td>
          <td>(</td>
          <td class="paramtype">Integer&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af5ba85f2308d53e41bfbd714a2850b3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5ba85f2308d53e41bfbd714a2850b3e">&#9670;&nbsp;</a></span>lsb() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Integer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> std::enable_if&lt; std::is_integral&lt;Integer&gt;::value &amp;&amp; !(std::is_signed&lt;Integer&gt;::value) &amp;&amp; (sizeof(Integer)==4) , <a class="el" href="namespace_3globalScope_4.html#classunsigned">unsigned</a>&gt;::type hydra::detail::lsb </td>
          <td>(</td>
          <td class="paramtype">Integer&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afef4bbc17cf6421b0da41b1872dc7781"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afef4bbc17cf6421b0da41b1872dc7781">&#9670;&nbsp;</a></span>machine_eps_f32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> float hydra::detail::machine_eps_f32 </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>value</em> = <code>1.0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af60fc3e60cc10bd79092ca02c8e8b84c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af60fc3e60cc10bd79092ca02c8e8b84c">&#9670;&nbsp;</a></span>machine_eps_f64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> hydra::detail::machine_eps_f64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td>
          <td class="paramname"><em>value</em> = <code>1.0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aecd9fdc1ef691978c73582a7f81ca59b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecd9fdc1ef691978c73582a7f81ca59b">&#9670;&nbsp;</a></span>make_rtuple()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::detail::make_rtuple </td>
          <td>(</td>
          <td class="paramtype">hydra::thrust::tuple&lt; T... &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td> -&gt; hydra::thrust::tuple&lt;T&amp;...&gt;
	</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6dbc5fcecd172e18c2ecb75b89560ac2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dbc5fcecd172e18c2ecb75b89560ac2">&#9670;&nbsp;</a></span>make_rtuple_helper()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, size_t... I&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::detail::make_rtuple_helper </td>
          <td>(</td>
          <td class="paramtype">hydra::thrust::tuple&lt; T... &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1detail_1_1index__sequence.html">index_sequence</a>&lt; I... &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; hydra::thrust::tuple&lt;T&amp;...&gt;
	</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac16e513053ac8d97923ac166db8e6a98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac16e513053ac8d97923ac166db8e6a98">&#9670;&nbsp;</a></span>make_tuple()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">T ::type TupleType hydra::detail::make_tuple </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad720a19d349e53d36757cfe71338ca64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad720a19d349e53d36757cfe71338ca64">&#9670;&nbsp;</a></span>max()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> size_t hydra::detail::max </td>
          <td>(</td>
          <td class="paramtype">hydra::thrust::tuple&lt; T... &gt; const &amp;&#160;</td>
          <td class="paramname"><em>tuple</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa4140580867ee73e401e1bb1e213548c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4140580867ee73e401e1bb1e213548c">&#9670;&nbsp;</a></span>max_helper()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename C , size_t N, size_t I&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> std::enable_if&lt; I==N,void&gt;::type hydra::detail::max_helper </td>
          <td>(</td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="basic__distributions_8inl.html#a4900ef306eb9271438791f1a98b8ccba">C</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad23b453b58064598dbd7596ffca55422"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad23b453b58064598dbd7596ffca55422">&#9670;&nbsp;</a></span>max_helper&lt; T, C, N, I+1 &gt;()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacehydra_1_1detail.html#aa4140580867ee73e401e1bb1e213548c">hydra::detail::max_helper</a>&lt; T, <a class="el" href="basic__distributions_8inl.html#a4900ef306eb9271438791f1a98b8ccba">C</a>, N, I+1 &gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#ac3486502b2db72187626125cea971683">tuple</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehydra_1_1detail.html#a50b277339704a9d22de5802abfd3ff22">max_value</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">max_index&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3d9f6a5b4844a887d53284f38f00f89a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d9f6a5b4844a887d53284f38f00f89a">&#9670;&nbsp;</a></span>meld_iterators()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... Iterators&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::detail::meld_iterators </td>
          <td>(</td>
          <td class="paramtype">Iterators &amp;&amp;...&#160;</td>
          <td class="paramname"><em>iterators</em></td><td>)</td>
          <td> -&gt; decltype( hydra::thrust::make_zip_iterator(
		hydra::thrust::tuple_cat( <a class="el" href="namespacehydra_1_1detail_1_1meld__iterators__ns.html#a6256486a1fd69c4d2df51f9fff3ef3d5">meld_iterators_ns::convert_to_tuple</a>(std::forward&lt;Iterators&gt;(iterators))... )  ))
</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4bd83f3f59f6d4881d766809e6172a48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bd83f3f59f6d4881d766809e6172a48">&#9670;&nbsp;</a></span>msb() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Integer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> std::enable_if&lt; std::is_integral&lt;Integer&gt;::value &amp;&amp; !(std::is_signed&lt;Integer&gt;::value) &amp;&amp; (std::numeric_limits&lt;Integer&gt;::digits==64) , <a class="el" href="namespace_3globalScope_4.html#classunsigned">unsigned</a>&gt;::type hydra::detail::msb </td>
          <td>(</td>
          <td class="paramtype">Integer&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a88d8ecbd10f4e4bbb6c161c69392287d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88d8ecbd10f4e4bbb6c161c69392287d">&#9670;&nbsp;</a></span>msb() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Integer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> std::enable_if&lt; std::is_integral&lt;Integer&gt;::value &amp;&amp; !(std::is_signed&lt;Integer&gt;::value) &amp;&amp; (std::numeric_limits&lt;Integer&gt;::digits&lt;=32) , <a class="el" href="namespace_3globalScope_4.html#classunsigned">unsigned</a>&gt;::type hydra::detail::msb </td>
          <td>(</td>
          <td class="paramtype">Integer&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad2b12c58b82f3d39caa4dffc5ce0faf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2b12c58b82f3d39caa4dffc5ce0faf9">&#9670;&nbsp;</a></span>multiply() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t N, size_t I&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; (I==N), void &gt;::type hydra::detail::multiply </td>
          <td>(</td>
          <td class="paramtype">std::array&lt; T, N &gt; const &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a52459ef87933d78d5ce88feb998bd8bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52459ef87933d78d5ce88feb998bd8bd">&#9670;&nbsp;</a></span>multiply() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t N, size_t I = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; (I&lt;N), void &gt;::type hydra::detail::multiply </td>
          <td>(</td>
          <td class="paramtype">std::array&lt; T, N &gt; const &amp;&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af73aa95bb4dce5810569f682bb39de27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af73aa95bb4dce5810569f682bb39de27">&#9670;&nbsp;</a></span>multiply() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t N, size_t I&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; (I==N), void &gt;::type hydra::detail::multiply </td>
          <td>(</td>
          <td class="paramtype">const &#160;</td>
          <td class="paramname"><em>T</em>(&amp;)[N], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4f767f0131f9a4910ece6f10d1b5a0f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f767f0131f9a4910ece6f10d1b5a0f2">&#9670;&nbsp;</a></span>multiply() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t N, size_t I = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; (I&lt;N), void &gt;::type hydra::detail::multiply </td>
          <td>(</td>
          <td class="paramtype">const T(&amp;)&#160;</td>
          <td class="paramname"><em>obj</em>[N], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2b1dbe6a0f5f757d371526da98ae8402"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b1dbe6a0f5f757d371526da98ae8402">&#9670;&nbsp;</a></span>multiply_array_tuple()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> auto hydra::detail::multiply_array_tuple </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>(&amp;)&#160;</td>
          <td class="paramname"><em>fCoefficients</em>[sizeof...(T)], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hydra::thrust::tuple&lt; T... &gt; const &amp;&#160;</td>
          <td class="paramname"><em>tpl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype( <a class="el" href="namespacehydra_1_1detail.html#a9dedb058563f9d7f616d862fd25b9e3b">multiply_array_tuple_helper</a>(fCoefficients,tpl,<a class="el" href="structhydra_1_1detail_1_1make__index__sequence.html">make_index_sequence</a>&lt;sizeof...(T)&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9dedb058563f9d7f616d862fd25b9e3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dedb058563f9d7f616d862fd25b9e3b">&#9670;&nbsp;</a></span>multiply_array_tuple_helper()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tuple , size_t ... I&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1tuple__type">tuple_type</a>&lt;sizeof...(I), <a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>&gt;::type hydra::detail::multiply_array_tuple_helper </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>(&amp;)&#160;</td>
          <td class="paramname"><em>fCoefficients</em>[sizeof...(I)], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tuple const &amp;&#160;</td>
          <td class="paramname"><em>tpl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1detail_1_1index__sequence.html">index_sequence</a>&lt; I... &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a983d20b80673f7930cb06751ddfe2685"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a983d20b80673f7930cb06751ddfe2685">&#9670;&nbsp;</a></span>multiply_tuple() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I = 0, typename Return_Type , typename ... Tp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::detail::enable_if&lt;I == sizeof...(Tp), void&gt;::type hydra::detail::multiply_tuple </td>
          <td>(</td>
          <td class="paramtype">Return_Type &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hydra::thrust::tuple&lt; Tp... &gt; const &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac68db34ed817ab2a9dd8dca991576c4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac68db34ed817ab2a9dd8dca991576c4f">&#9670;&nbsp;</a></span>multiply_tuple() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I = 0, typename Return_Type , typename ... Tp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::detail::enable_if&lt;(I &lt; sizeof...(Tp)),void &gt;::type hydra::detail::multiply_tuple </td>
          <td>(</td>
          <td class="paramtype">Return_Type &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hydra::thrust::tuple&lt; Tp... &gt;const &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5306b782f3856dcd6fe0deb087d3d547"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5306b782f3856dcd6fe0deb087d3d547">&#9670;&nbsp;</a></span>multiply_tuple() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I = 0, typename Return_Type , typename ... Tp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::detail::enable_if&lt;I == sizeof...(Tp), void&gt;::type hydra::detail::multiply_tuple </td>
          <td>(</td>
          <td class="paramtype">Return_Type &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hydra::thrust::tuple&lt; Tp... &gt; &amp;&amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9d606d63c86ccd96e65d66a120fa9738"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d606d63c86ccd96e65d66a120fa9738">&#9670;&nbsp;</a></span>multiply_tuple() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I = 0, typename Return_Type , typename ... Tp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::detail::enable_if&lt;(I &lt; sizeof...(Tp)),void &gt;::type hydra::detail::multiply_tuple </td>
          <td>(</td>
          <td class="paramtype">Return_Type &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hydra::thrust::tuple&lt; Tp... &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae41869730161a24873d2aa958fc6f4cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae41869730161a24873d2aa958fc6f4cd">&#9670;&nbsp;</a></span>multiplyTuples() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, size_t ... I&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::tuple&lt;T...&gt; hydra::detail::multiplyTuples </td>
          <td>(</td>
          <td class="paramtype">const hydra::thrust::tuple&lt; T... &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const hydra::thrust::tuple&lt; T... &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1detail_1_1index__sequence.html">index_sequence</a>&lt; I... &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4f2f3c283253a975ac058aebfb640535"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f2f3c283253a975ac058aebfb640535">&#9670;&nbsp;</a></span>multiplyTuples() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::tuple&lt;T...&gt; hydra::detail::multiplyTuples </td>
          <td>(</td>
          <td class="paramtype">const hydra::thrust::tuple&lt; T... &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const hydra::thrust::tuple&lt; T... &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2a5041517e4c16f7eacb46898f6f029e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a5041517e4c16f7eacb46898f6f029e">&#9670;&nbsp;</a></span>multiplyTuplesHelper()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I, typename ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::tuple_element&lt;I, hydra::thrust::tuple&lt;T...&gt; &gt;::type hydra::detail::multiplyTuplesHelper </td>
          <td>(</td>
          <td class="paramtype">const hydra::thrust::tuple&lt; T... &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const hydra::thrust::tuple&lt; T... &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a63701869476f9138ea31be4ef303e7c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63701869476f9138ea31be4ef303e7c1">&#9670;&nbsp;</a></span>next_permutation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BidirIt &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> bool hydra::detail::next_permutation </td>
          <td>(</td>
          <td class="paramtype">BidirIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BidirIt&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0b2e7c87a80dcd5015c2a95ca88f67f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b2e7c87a80dcd5015c2a95ca88f67f1">&#9670;&nbsp;</a></span>nth_permutation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator , typename Integer , typename Comparator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_integral&lt; Integer &gt;::value, void &gt;::type <a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::detail::nth_permutation </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Integer&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Comparator&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6e34df05c3fc32da9e8fe01dddc9fd7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e34df05c3fc32da9e8fe01dddc9fd7e">&#9670;&nbsp;</a></span>operator+() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="classhydra_1_1detail_1_1GenzMalikBoxResult.html">GenzMalikBoxResult</a>&lt;Type&gt; hydra::detail::operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhydra_1_1detail_1_1GenzMalikBoxResult.html">GenzMalikBoxResult</a>&lt; Type &gt;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhydra_1_1detail_1_1GenzMalikBoxResult.html">GenzMalikBoxResult</a>&lt; Type &gt; const &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a25dfa2f5f8cfb6485dba5d2a4611b217"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25dfa2f5f8cfb6485dba5d2a4611b217">&#9670;&nbsp;</a></span>operator+() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="classhydra_1_1detail_1_1GenzMalikBoxResult.html">GenzMalikBoxResult</a>&lt;Type&gt; hydra::detail::operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhydra_1_1detail_1_1GenzMalikBoxResult.html">GenzMalikBoxResult</a>&lt; Type &gt;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhydra_1_1detail_1_1GenzMalikBox.html">GenzMalikBox</a>&lt; N &gt; const &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1c794172447148190ddb210dd1db8a83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c794172447148190ddb210dd1db8a83">&#9670;&nbsp;</a></span>pow_helper() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , unsigned int N, unsigned int I&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> std::enable_if&lt;I==N, void &gt;::type hydra::detail::pow_helper </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>const</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8f6c0d8fba43367d54ac4e2ce70f8718"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f6c0d8fba43367d54ac4e2ce70f8718">&#9670;&nbsp;</a></span>pow_helper() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , unsigned int N, unsigned int I&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> std::enable_if&lt; (I&lt; N), void &gt;::type hydra::detail::pow_helper </td>
          <td>(</td>
          <td class="paramtype">T const&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae3571c0ce97f1472331216a675bb7857"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3571c0ce97f1472331216a675bb7857">&#9670;&nbsp;</a></span>print_parameters_in_tuple() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I = 0, typename ... Tp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">hydra::thrust::detail::enable_if&lt;I == sizeof...(Tp), void&gt;::type hydra::detail::print_parameters_in_tuple </td>
          <td>(</td>
          <td class="paramtype">hydra::thrust::tuple&lt; Tp... &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae1df72ec6bac610a8f6d2be642ca1d3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1df72ec6bac610a8f6d2be642ca1d3a">&#9670;&nbsp;</a></span>print_parameters_in_tuple() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I = 0, typename ... Tp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">hydra::thrust::detail::enable_if&lt;(I &lt; sizeof...(Tp)),void &gt;::type hydra::detail::print_parameters_in_tuple </td>
          <td>(</td>
          <td class="paramtype">hydra::thrust::tuple&lt; Tp... &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa9df96670ef4114c14fa30390b3dca5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9df96670ef4114c14fa30390b3dca5e">&#9670;&nbsp;</a></span>product() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Return_Type , typename ArgType , typename ... Tp, typename  = typename hydra::thrust::detail::enable_if&lt;std::is_convertible&lt;Return_Type, double&gt;::value || std::is_constructible&lt;hydra::thrust::complex&lt;double&gt;,Return_Type&gt;::value &gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> Return_Type hydra::detail::product </td>
          <td>(</td>
          <td class="paramtype">ArgType const &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hydra::thrust::tuple&lt; Tp... &gt; const &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad71212520aeba6bfdd5f2f08b1e57949"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad71212520aeba6bfdd5f2f08b1e57949">&#9670;&nbsp;</a></span>product() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Return_Type , typename ArgType , typename ... Tp, typename  = typename hydra::thrust::detail::enable_if&lt;std::is_convertible&lt;Return_Type, double&gt;::value || std::is_constructible&lt;hydra::thrust::complex&lt;double&gt;,Return_Type&gt;::value &gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> Return_Type hydra::detail::product </td>
          <td>(</td>
          <td class="paramtype">ArgType &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hydra::thrust::tuple&lt; Tp... &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a06f0f7278adec0e18aa797ff500aeec5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06f0f7278adec0e18aa797ff500aeec5">&#9670;&nbsp;</a></span>product2() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Return_Type , typename ArgType1 , typename ArgType2 , typename ... Tp, typename  = typename hydra::thrust::detail::enable_if&lt;std::is_convertible&lt;Return_Type, double&gt;::value || std::is_constructible&lt;hydra::thrust::complex&lt;double&gt;,Return_Type&gt;::value &gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> Return_Type hydra::detail::product2 </td>
          <td>(</td>
          <td class="paramtype">ArgType1 const &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArgType2 const &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hydra::thrust::tuple&lt; Tp... &gt; const &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5c82b9ba250e8b4c956796040a58e828"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c82b9ba250e8b4c956796040a58e828">&#9670;&nbsp;</a></span>product2() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Return_Type , typename ArgType1 , typename ArgType2 , typename ... Tp, typename  = typename hydra::thrust::detail::enable_if&lt;std::is_convertible&lt;Return_Type, double&gt;::value || std::is_constructible&lt;hydra::thrust::complex&lt;double&gt;,Return_Type&gt;::value &gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> Return_Type hydra::detail::product2 </td>
          <td>(</td>
          <td class="paramtype">ArgType1 &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArgType2 &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hydra::thrust::tuple&lt; Tp... &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="adabaf23bc5b2f9f9c80cbd757274ce52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adabaf23bc5b2f9f9c80cbd757274ce52">&#9670;&nbsp;</a></span>product_tuple() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I = 0, typename Return_Type , typename ArgType , typename ... Tp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::detail::enable_if&lt;I == sizeof...(Tp), void&gt;::type hydra::detail::product_tuple </td>
          <td>(</td>
          <td class="paramtype">Return_Type &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hydra::thrust::tuple&lt; Tp... &gt; const &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArgType const &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a09a64a12d8e0efe71a16254afed3ce51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09a64a12d8e0efe71a16254afed3ce51">&#9670;&nbsp;</a></span>product_tuple() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I = 0, typename Return_Type , typename ArgType , typename ... Tp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::detail::enable_if&lt;(I &lt; sizeof...(Tp)),void &gt;::type hydra::detail::product_tuple </td>
          <td>(</td>
          <td class="paramtype">Return_Type &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hydra::thrust::tuple&lt; Tp... &gt; const &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArgType const &amp;&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab7ce3d4782e6cc3741d7c22a0a1e6ff4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7ce3d4782e6cc3741d7c22a0a1e6ff4">&#9670;&nbsp;</a></span>product_tuple() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I = 0, typename Return_Type , typename ArgType , typename ... Tp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::detail::enable_if&lt;I == sizeof...(Tp), void&gt;::type hydra::detail::product_tuple </td>
          <td>(</td>
          <td class="paramtype">Return_Type &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hydra::thrust::tuple&lt; Tp... &gt; &amp;&amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArgType &amp;&amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4ddfad88876786c74e596db9c81b2850"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ddfad88876786c74e596db9c81b2850">&#9670;&nbsp;</a></span>product_tuple() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I = 0, typename Return_Type , typename ArgType , typename ... Tp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::detail::enable_if&lt;(I &lt; sizeof...(Tp)),void &gt;::type hydra::detail::product_tuple </td>
          <td>(</td>
          <td class="paramtype">Return_Type &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hydra::thrust::tuple&lt; Tp... &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArgType &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9dd180e5db52df8b603f54eccec23540"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dd180e5db52df8b603f54eccec23540">&#9670;&nbsp;</a></span>product_tuple2() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I = 0, typename Return_Type , typename ArgType1 , typename ArgType2 , typename ... Tp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::detail::enable_if&lt;I == sizeof...(Tp), void&gt;::type hydra::detail::product_tuple2 </td>
          <td>(</td>
          <td class="paramtype">Return_Type &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hydra::thrust::tuple&lt; Tp... &gt; const &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArgType1 const &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArgType2 const &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab889266aba923c3d948f60ed385743f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab889266aba923c3d948f60ed385743f5">&#9670;&nbsp;</a></span>product_tuple2() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I = 0, typename Return_Type , typename ArgType1 , typename ArgType2 , typename ... Tp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::detail::enable_if&lt;(I &lt; (sizeof...(Tp))),void &gt;::type hydra::detail::product_tuple2 </td>
          <td>(</td>
          <td class="paramtype">Return_Type &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hydra::thrust::tuple&lt; Tp... &gt; const &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArgType1 const &amp;&#160;</td>
          <td class="paramname"><em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArgType2 const &amp;&#160;</td>
          <td class="paramname"><em>arg2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a439342ca452238b86683172c616af275"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a439342ca452238b86683172c616af275">&#9670;&nbsp;</a></span>product_tuple2() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I = 0, typename Return_Type , typename ArgType1 , typename ArgType2 , typename ... Tp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::detail::enable_if&lt;I == sizeof...(Tp), void&gt;::type hydra::detail::product_tuple2 </td>
          <td>(</td>
          <td class="paramtype">Return_Type &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hydra::thrust::tuple&lt; Tp... &gt; &amp;&amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArgType1 &amp;&amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArgType2 &amp;&amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aae57819631ed091712bbf07475ead232"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae57819631ed091712bbf07475ead232">&#9670;&nbsp;</a></span>product_tuple2() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I = 0, typename Return_Type , typename ArgType1 , typename ArgType2 , typename ... Tp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::detail::enable_if&lt;(I &lt; (sizeof...(Tp))),void &gt;::type hydra::detail::product_tuple2 </td>
          <td>(</td>
          <td class="paramtype">Return_Type &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hydra::thrust::tuple&lt; Tp... &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArgType1 &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArgType2 &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5a3a2145b19503fed123dff2196155c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a3a2145b19503fed123dff2196155c3">&#9670;&nbsp;</a></span>product_tuple3() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I = 0, size_t N, typename Return_Type , typename ArgType1 , typename ArgType2 , typename ... Tp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::detail::enable_if&lt;I == N, void&gt;::type hydra::detail::product_tuple3 </td>
          <td>(</td>
          <td class="paramtype">Return_Type &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hydra::thrust::tuple&lt; Tp... &gt; const &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArgType1 const &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArgType2 const &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af6561fc8b52118b1c2139a976128cb4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6561fc8b52118b1c2139a976128cb4e">&#9670;&nbsp;</a></span>product_tuple3() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I = 0, size_t N, typename Return_Type , typename ArgType1 , typename ArgType2 , typename ... Tp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::detail::enable_if&lt;(I &lt; N),void &gt;::type hydra::detail::product_tuple3 </td>
          <td>(</td>
          <td class="paramtype">Return_Type &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hydra::thrust::tuple&lt; Tp... &gt; const &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArgType1 const &amp;&#160;</td>
          <td class="paramname"><em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArgType2 const &amp;&#160;</td>
          <td class="paramname"><em>arg2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aaf3f3a459fd81baba8d17ad3db69aae9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf3f3a459fd81baba8d17ad3db69aae9">&#9670;&nbsp;</a></span>product_tuple3() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I = 0, size_t N, typename Return_Type , typename ArgType1 , typename ArgType2 , typename ... Tp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::detail::enable_if&lt;I == N, void&gt;::type hydra::detail::product_tuple3 </td>
          <td>(</td>
          <td class="paramtype">Return_Type &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hydra::thrust::tuple&lt; Tp... &gt; &amp;&amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArgType1 &amp;&amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArgType2 &amp;&amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6b12b4c186d19a36238c7e82cd8d4348"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b12b4c186d19a36238c7e82cd8d4348">&#9670;&nbsp;</a></span>product_tuple3() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I = 0, size_t N, typename Return_Type , typename ArgType1 , typename ArgType2 , typename ... Tp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::detail::enable_if&lt;(I &lt; N),void &gt;::type hydra::detail::product_tuple3 </td>
          <td>(</td>
          <td class="paramtype">Return_Type &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hydra::thrust::tuple&lt; Tp... &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArgType1 &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArgType2 &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9108ba6cbf5144a048fa7c2ed068d5ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9108ba6cbf5144a048fa7c2ed068d5ba">&#9670;&nbsp;</a></span>ptr_setter() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void hydra::detail::ptr_setter </td>
          <td>(</td>
          <td class="paramtype">T1 *&amp;&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename hydra::thrust::detail::enable_if&lt; hydra::thrust::detail::is_same&lt; T1, T2 &gt;::value, T2 &gt;::type *&#160;</td>
          <td class="paramname"><em>el</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a607a6a529236b69164e1a4a446a6e8c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a607a6a529236b69164e1a4a446a6e8c7">&#9670;&nbsp;</a></span>ptr_setter() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void hydra::detail::ptr_setter </td>
          <td>(</td>
          <td class="paramtype">T1 *&amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename hydra::thrust::detail::enable_if&lt;!hydra::thrust::detail::is_same&lt; T1, T2 &gt;::value, T2 &gt;::type *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab46acd298d2f60edf21c334fa8823d65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab46acd298d2f60edf21c334fa8823d65">&#9670;&nbsp;</a></span>rotate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Iterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> Iterator hydra::detail::rotate </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>n_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a02aa7a21cd5aca1e6cba7419e0009a9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02aa7a21cd5aca1e6cba7419e0009a9f">&#9670;&nbsp;</a></span>SafeGreaterThan()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> bool hydra::detail::SafeGreaterThan </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code><a class="el" href="namespacehydra_1_1detail.html#af60fc3e60cc10bd79092ca02c8e8b84c">machine_eps_f64</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8b57eb5fbdba90142d2127ab29514de7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b57eb5fbdba90142d2127ab29514de7">&#9670;&nbsp;</a></span>SafeLessThan()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> bool hydra::detail::SafeLessThan </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code><a class="el" href="namespacehydra_1_1detail.html#af60fc3e60cc10bd79092ca02c8e8b84c">machine_eps_f64</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa21b24762fe6b3793d99a9c02bd523c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa21b24762fe6b3793d99a9c02bd523c1">&#9670;&nbsp;</a></span>set_functors_in_tuple() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I = 0, typename ... Tp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">hydra::thrust::detail::enable_if&lt;I == sizeof...(Tp), void&gt;::type hydra::detail::set_functors_in_tuple </td>
          <td>(</td>
          <td class="paramtype">hydra::thrust::tuple&lt; Tp... &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afc2e3e251a1ba97b903c37dcf6b7614d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc2e3e251a1ba97b903c37dcf6b7614d">&#9670;&nbsp;</a></span>set_functors_in_tuple() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I = 0, typename ... Tp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">hydra::thrust::detail::enable_if&lt;(I &lt; sizeof...(Tp)),void &gt;::type hydra::detail::set_functors_in_tuple </td>
          <td>(</td>
          <td class="paramtype">hydra::thrust::tuple&lt; Tp... &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>parameters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a57a43797825f305b178079f80fc79d11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57a43797825f305b178079f80fc79d11">&#9670;&nbsp;</a></span>set_ptr_to_tuple_element() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int I, typename Ptr , typename ... Tp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">hydra::thrust::detail::enable_if&lt;I == sizeof...(Tp), void&gt;::type hydra::detail::set_ptr_to_tuple_element </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_3globalScope_4.html#classint">int</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::tuple&lt; Tp... &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ptr *&amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aed57cabad1c9b745eafc489910884b2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed57cabad1c9b745eafc489910884b2c">&#9670;&nbsp;</a></span>set_ptr_to_tuple_element() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int I = 0, typename Ptr , typename ... Tp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">hydra::thrust::detail::enable_if&lt;(I &lt; sizeof...(Tp)), void &gt;::type hydra::detail::set_ptr_to_tuple_element </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_3globalScope_4.html#classint">int</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::tuple&lt; Tp... &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ptr *&amp;&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2fc1f520b1120b2292937669d6c66505"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fc1f520b1120b2292937669d6c66505">&#9670;&nbsp;</a></span>set_ptrs_to_tuple() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I = 0, typename Array_Type , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::detail::enable_if&lt;(I == hydra::thrust::tuple_size&lt;T&gt;::value) &amp;&amp; <a class="el" href="structhydra_1_1detail_1_1is__homogeneous.html">is_homogeneous</a>&lt;Array_Type, T&gt;::value, void&gt;::type hydra::detail::set_ptrs_to_tuple </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array_Type **&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abced9457fd3703a8bf8b1a5d762ffb4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abced9457fd3703a8bf8b1a5d762ffb4b">&#9670;&nbsp;</a></span>set_ptrs_to_tuple() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I = 0, typename Array_Type , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::detail::enable_if&lt;(I &lt; hydra::thrust::tuple_size&lt;T&gt;::value) &amp;&amp; <a class="el" href="structhydra_1_1detail_1_1is__homogeneous.html">is_homogeneous</a>&lt;Array_Type, T&gt;::value, void&gt;::type hydra::detail::set_ptrs_to_tuple </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array_Type **&#160;</td>
          <td class="paramname"><em>Array</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a54539a1b1cee55ab70dc738bc89a5180"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54539a1b1cee55ab70dc738bc89a5180">&#9670;&nbsp;</a></span>set_tuple_element() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int I = 0, typename T , typename ... Tp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::detail::enable_if&lt;I == sizeof...(Tp), void&gt;::type hydra::detail::set_tuple_element </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_3globalScope_4.html#classint">int</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hydra::thrust::tuple&lt; Tp... &gt; const &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad8d27d3aecd240e4d7d3300bfc2ee63b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8d27d3aecd240e4d7d3300bfc2ee63b">&#9670;&nbsp;</a></span>set_tuple_element() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int I = 0, typename T , typename ... Tp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::detail::enable_if&lt;(I &lt; sizeof...(Tp)), void &gt;::type hydra::detail::set_tuple_element </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_3globalScope_4.html#classint">int</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hydra::thrust::tuple&lt; Tp... &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0125c53a3b2aac1cab9e83d65b6494f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0125c53a3b2aac1cab9e83d65b6494f6">&#9670;&nbsp;</a></span>split_tuple() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T1, typename ... T2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> void hydra::detail::split_tuple </td>
          <td>(</td>
          <td class="paramtype">hydra::thrust::tuple&lt; T1... &gt; &amp;&#160;</td>
          <td class="paramname"><em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hydra::thrust::tuple&lt; T2... &gt; &amp;&#160;</td>
          <td class="paramname"><em>t2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hydra::thrust::tuple&lt; T1..., T2... &gt; const &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1ab8d8856893dad2e11b1293005e5d35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ab8d8856893dad2e11b1293005e5d35">&#9670;&nbsp;</a></span>split_tuple() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t N, typename ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> auto hydra::detail::split_tuple </td>
          <td>(</td>
          <td class="paramtype">hydra::thrust::tuple&lt; T... &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td> -&gt; decltype( <a class="el" href="namespacehydra_1_1detail.html#aaa93f2fd80191b1999092757e023a29c">split_tuple_helper</a>( t, <a class="el" href="structhydra_1_1detail_1_1make__index__sequence.html">make_index_sequence</a>&lt;N&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aaa93f2fd80191b1999092757e023a29c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa93f2fd80191b1999092757e023a29c">&#9670;&nbsp;</a></span>split_tuple_helper() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T1, typename ... T2, size_t... I1, size_t... I2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> void hydra::detail::split_tuple_helper </td>
          <td>(</td>
          <td class="paramtype">hydra::thrust::tuple&lt; T1... &gt; &amp;&#160;</td>
          <td class="paramname"><em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hydra::thrust::tuple&lt; T2... &gt; &amp;&#160;</td>
          <td class="paramname"><em>t2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hydra::thrust::tuple&lt; T1..., T2... &gt; const &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1detail_1_1index__sequence.html">index_sequence</a>&lt; I1... &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1detail_1_1index__sequence.html">index_sequence</a>&lt; I2... &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a93552a3e6c3a7d409faf3ad676479465"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93552a3e6c3a7d409faf3ad676479465">&#9670;&nbsp;</a></span>split_tuple_helper() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, size_t... I1, size_t... I2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> auto hydra::detail::split_tuple_helper </td>
          <td>(</td>
          <td class="paramtype">hydra::thrust::tuple&lt; T... &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1detail_1_1index__sequence.html">index_sequence</a>&lt; I1... &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1detail_1_1index__sequence.html">index_sequence</a>&lt; I2... &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype( hydra::thrust::make_pair(hydra::thrust::tie( hydra::thrust::get&lt;I1&gt;(t)... ), hydra::thrust::tie( hydra::thrust::get&lt;I2+ + sizeof...(I1)&gt;(t)... ) ) )
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7d99f4894a305719c52f70093f870fc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d99f4894a305719c52f70093f870fc9">&#9670;&nbsp;</a></span>subtractTuples() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, size_t ... I&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::tuple&lt;T...&gt; hydra::detail::subtractTuples </td>
          <td>(</td>
          <td class="paramtype">const hydra::thrust::tuple&lt; T... &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const hydra::thrust::tuple&lt; T... &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1detail_1_1index__sequence.html">index_sequence</a>&lt; I... &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aee7e4bcbfcf9c3c4d4c9c0ac8e48925e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee7e4bcbfcf9c3c4d4c9c0ac8e48925e">&#9670;&nbsp;</a></span>subtractTuples() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::tuple&lt;T...&gt; hydra::detail::subtractTuples </td>
          <td>(</td>
          <td class="paramtype">const hydra::thrust::tuple&lt; T... &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const hydra::thrust::tuple&lt; T... &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5657e7fa1567c800bafeca39c0aa09c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5657e7fa1567c800bafeca39c0aa09c8">&#9670;&nbsp;</a></span>subtractTuplesHelper()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I, typename ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::tuple_element&lt;I, hydra::thrust::tuple&lt;T...&gt; &gt;::type hydra::detail::subtractTuplesHelper </td>
          <td>(</td>
          <td class="paramtype">const hydra::thrust::tuple&lt; T... &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const hydra::thrust::tuple&lt; T... &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1a0afb276fe05c1beafcecc2e0f2b9e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a0afb276fe05c1beafcecc2e0f2b9e6">&#9670;&nbsp;</a></span>sum_tuple() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I = 0, typename Return_Type , typename ArgType , typename ... Tp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::detail::enable_if&lt;I == sizeof...(Tp), void&gt;::type hydra::detail::sum_tuple </td>
          <td>(</td>
          <td class="paramtype">Return_Type &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hydra::thrust::tuple&lt; Tp... &gt; &amp;&amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArgType &amp;&amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6a88f79d07aa17ce1978e5685ab4e6a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a88f79d07aa17ce1978e5685ab4e6a1">&#9670;&nbsp;</a></span>sum_tuple() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I = 0, typename Return_Type , typename ArgType , typename ... Tp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::detail::enable_if&lt;(I &lt; sizeof...(Tp)), void &gt;::type hydra::detail::sum_tuple </td>
          <td>(</td>
          <td class="paramtype">Return_Type &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hydra::thrust::tuple&lt; Tp... &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArgType &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aceecb8b30f5203c57207c892d3ceb4c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aceecb8b30f5203c57207c892d3ceb4c3">&#9670;&nbsp;</a></span>sum_tuple() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I = 0, typename Return_Type , typename ArgType , typename ... Tp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::detail::enable_if&lt;I == sizeof...(Tp), void&gt;::type hydra::detail::sum_tuple </td>
          <td>(</td>
          <td class="paramtype">Return_Type &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hydra::thrust::tuple&lt; Tp... &gt; const &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArgType const &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aecd4cf8b1f9353041de1f411389ab66d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecd4cf8b1f9353041de1f411389ab66d">&#9670;&nbsp;</a></span>sum_tuple() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I = 0, typename Return_Type , typename ArgType , typename ... Tp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::detail::enable_if&lt;(I &lt; sizeof...(Tp)), void &gt;::type hydra::detail::sum_tuple </td>
          <td>(</td>
          <td class="paramtype">Return_Type &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hydra::thrust::tuple&lt; Tp... &gt;const &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArgType const &amp;&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6ad8cca28a9c44ae90b5db186e5cd7ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ad8cca28a9c44ae90b5db186e5cd7ea">&#9670;&nbsp;</a></span>sum_tuple2() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I = 0, typename Return_Type , typename ArgType1 , typename ArgType2 , typename ... Tp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::detail::enable_if&lt;I == sizeof...(Tp), void&gt;::type hydra::detail::sum_tuple2 </td>
          <td>(</td>
          <td class="paramtype">Return_Type &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hydra::thrust::tuple&lt; Tp... &gt; &amp;&amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArgType1 &amp;&amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArgType2 &amp;&amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7177c6a22b6fa4af64a6b0a27d80b984"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7177c6a22b6fa4af64a6b0a27d80b984">&#9670;&nbsp;</a></span>sum_tuple2() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I = 0, typename Return_Type , typename ArgType1 , typename ArgType2 , typename ... Tp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::detail::enable_if&lt;(I &lt; sizeof...(Tp)), void &gt;::type hydra::detail::sum_tuple2 </td>
          <td>(</td>
          <td class="paramtype">Return_Type &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hydra::thrust::tuple&lt; Tp... &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArgType1 &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArgType2 &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9cb4a9045ea6dd505cf04d74c52e61f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cb4a9045ea6dd505cf04d74c52e61f4">&#9670;&nbsp;</a></span>sum_tuple2() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I = 0, typename Return_Type , typename ArgType1 , typename ArgType2 , typename ... Tp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::detail::enable_if&lt;I == sizeof...(Tp), void&gt;::type hydra::detail::sum_tuple2 </td>
          <td>(</td>
          <td class="paramtype">Return_Type &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hydra::thrust::tuple&lt; Tp... &gt;const &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArgType1 const &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArgType2 const &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4e41539382f482a4d344b87c7f7a46e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e41539382f482a4d344b87c7f7a46e5">&#9670;&nbsp;</a></span>sum_tuple2() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I = 0, typename Return_Type , typename ArgType1 , typename ArgType2 , typename ... Tp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::detail::enable_if&lt;(I &lt; sizeof...(Tp)), void &gt;::type hydra::detail::sum_tuple2 </td>
          <td>(</td>
          <td class="paramtype">Return_Type &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hydra::thrust::tuple&lt; Tp... &gt; const &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArgType1 const &amp;&#160;</td>
          <td class="paramname"><em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArgType2 const &amp;&#160;</td>
          <td class="paramname"><em>arg2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a238d20dfda2677074a1e3d48b29be54a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a238d20dfda2677074a1e3d48b29be54a">&#9670;&nbsp;</a></span>tupler() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__tuple.html">detail::is_tuple</a>&lt;T&gt;::value, T&gt;::type hydra::detail::tupler </td>
          <td>(</td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a19f0ad5cca44b69a03162009efcb2092"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19f0ad5cca44b69a03162009efcb2092">&#9670;&nbsp;</a></span>tupler() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> std::enable_if&lt;!<a class="el" href="structhydra_1_1detail_1_1is__tuple.html">detail::is_tuple</a>&lt;T&gt;::value, <a class="el" href="namespacehydra.html#ac3486502b2db72187626125cea971683">hydra::tuple</a>&lt;T&gt; &gt;::type hydra::detail::tupler </td>
          <td>(</td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3c77a410602498524dfb5844857c84dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c77a410602498524dfb5844857c84dc">&#9670;&nbsp;</a></span>tupleToArray() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I = 0, typename FistType , typename ... OtherTypes&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">hydra::thrust::detail::enable_if&lt;I == (sizeof...(OtherTypes) + 1) &amp;&amp; <a class="el" href="namespacehydra_1_1detail.html#a3c72e1aed3a4538dac06a7e816543c23">are_all_same</a>&lt;FistType,OtherTypes...&gt;::value, void&gt;::type hydra::detail::tupleToArray </td>
          <td>(</td>
          <td class="paramtype">hydra::thrust::tuple&lt; FistType, OtherTypes... &gt; const &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; FistType, sizeof...(OtherTypes)+1 &gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae0af1f330ae7d29bf0b1e33eb3f655af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0af1f330ae7d29bf0b1e33eb3f655af">&#9670;&nbsp;</a></span>tupleToArray() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I = 0, typename FistType , typename ... OtherTypes&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">hydra::thrust::detail::enable_if&lt;(I &lt; sizeof...(OtherTypes)+1) &amp;&amp; <a class="el" href="namespacehydra_1_1detail.html#a3c72e1aed3a4538dac06a7e816543c23">are_all_same</a>&lt;FistType,OtherTypes...&gt;::value, void &gt;::type hydra::detail::tupleToArray </td>
          <td>(</td>
          <td class="paramtype">hydra::thrust::tuple&lt; FistType, OtherTypes... &gt; const &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; FistType, sizeof...(OtherTypes)+1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>Array</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a811265beb04612913fec71efc6c97af4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a811265beb04612913fec71efc6c97af4">&#9670;&nbsp;</a></span>tupleToArray() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I = 0, typename FistType , typename ... OtherTypes&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::detail::enable_if&lt;I == (sizeof...(OtherTypes) + 1) &amp;&amp; <a class="el" href="namespacehydra_1_1detail.html#a3c72e1aed3a4538dac06a7e816543c23">are_all_same</a>&lt;FistType,OtherTypes...&gt;::value, void&gt;::type hydra::detail::tupleToArray </td>
          <td>(</td>
          <td class="paramtype">hydra::thrust::tuple&lt; FistType, OtherTypes... &gt; const &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::remove_reference&lt; FistType &gt;::type *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a89c1bed6272c8b2efecbe3032ab769a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89c1bed6272c8b2efecbe3032ab769a4">&#9670;&nbsp;</a></span>tupleToArray() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I = 0, typename FistType , typename ... OtherTypes&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::detail::enable_if&lt;(I &lt; sizeof...(OtherTypes)+1) &amp;&amp; <a class="el" href="namespacehydra_1_1detail.html#a3c72e1aed3a4538dac06a7e816543c23">are_all_same</a>&lt;FistType,OtherTypes...&gt;::value, void &gt;::type hydra::detail::tupleToArray </td>
          <td>(</td>
          <td class="paramtype">hydra::thrust::tuple&lt; FistType, OtherTypes... &gt; const &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::remove_reference&lt; FistType &gt;::type *&#160;</td>
          <td class="paramname"><em>Array</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a01f6c991c9345e0ef585f5c1e85773a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01f6c991c9345e0ef585f5c1e85773a3">&#9670;&nbsp;</a></span>tupleToArray() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TupleType , typename ArrayType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::detail::enable_if&lt; (<a class="el" href="structhydra_1_1detail_1_1is__instantiation__of.html">detail::is_instantiation_of</a>&lt;hydra::thrust::tuple,TupleType&gt;::value || <a class="el" href="structhydra_1_1detail_1_1is__instantiation__of.html">detail::is_instantiation_of</a>&lt;hydra::thrust::detail::tuple_of_iterator_references, TupleType&gt;::value), void&gt;::type hydra::detail::tupleToArray </td>
          <td>(</td>
          <td class="paramtype">TupleType const &amp;&#160;</td>
          <td class="paramname"><em>_tuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArrayType *&#160;</td>
          <td class="paramname"><em>_array</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab2864aeaf911297306efcc70d9ed617d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2864aeaf911297306efcc70d9ed617d">&#9670;&nbsp;</a></span>WithinPrecisionInterval()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> bool hydra::detail::WithinPrecisionInterval </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_3globalScope_4.html#classunsigned">unsigned</a> <a class="el" href="namespace_3globalScope_4.html#classint">int</a>&#160;</td>
          <td class="paramname"><em>interval_size</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6d803c1c594f979fb4a8f4beae580766"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d803c1c594f979fb4a8f4beae580766">&#9670;&nbsp;</a></span>zip_iterator_cat()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1all__true.html">all_true</a>&lt;<a class="el" href="structhydra_1_1detail_1_1is__zip__iterator.html">is_zip_iterator</a>&lt;T&gt;::value...&gt;::value, typename <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1merged__zip__iterator">detail::merged_zip_iterator</a>&lt;T...&gt;::type &gt;::type hydra::detail::zip_iterator_cat </td>
          <td>(</td>
          <td class="paramtype">T const &amp;...&#160;</td>
          <td class="paramname"><em>zip_iterators</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a6e5ce23b23364c64166f4c390f0f5f03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e5ce23b23364c64166f4c390f0f5f03">&#9670;&nbsp;</a></span>make_index_sequence&lt; sizeof...(T) -N &gt;</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhydra_1_1detail_1_1make__index__sequence.html">hydra::detail::make_index_sequence</a>&lt; sizeof...(T) -N &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a50b277339704a9d22de5802abfd3ff22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50b277339704a9d22de5802abfd3ff22">&#9670;&nbsp;</a></span>max_value</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename C , size_t N, size_t I = 1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> std::enable_if&lt; I &lt; N, void&gt;::type <a class="el" href="namespacehydra_1_1detail.html#aa4140580867ee73e401e1bb1e213548c">max_helper</a>( T const&amp; <a class="el" href="namespacehydra.html#ac3486502b2db72187626125cea971683">tuple</a>, <a class="el" href="basic__distributions_8inl.html#a4900ef306eb9271438791f1a98b8ccba">C</a>&amp; max_value, size_t&amp; max_index){ max_index = max_value &gt; hydra::thrust::get&lt;I&gt; (<a class="el" href="namespacehydra.html#ac3486502b2db72187626125cea971683">tuple</a>) ? max_index hydra::detail::max_value = max_value &gt; hydra::thrust::get&lt;I&gt;(<a class="el" href="namespacehydra.html#ac3486502b2db72187626125cea971683">tuple</a>) ? max_value : hydra::thrust::get&lt;I&gt;(<a class="el" href="namespacehydra.html#ac3486502b2db72187626125cea971683">tuple</a>)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacehydra.html">hydra</a></li><li class="navelem"><a class="el" href="namespacehydra_1_1detail.html">detail</a></li>
    <li class="footer">Generated on Sun Dec 3 2023 21:29:48 for Hydra by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.14 </li>
  </ul>
</div>
</body>
</html>
