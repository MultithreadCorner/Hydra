<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Hydra: hydra::multivector&lt; hydra_thrust::tuple&lt; T... &gt;, hydra::detail::BackendPolicy&lt; BACKEND &gt; &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo_Hydra2.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Hydra
   &#160;<span id="projectnumber">3.0.0</span>
   </div>
   <div id="projectbrief">A header-only templated C++ framework to perform data analysis on massively parallel platforms.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">hydra::multivector&lt; hydra_thrust::tuple&lt; T... &gt;, hydra::detail::BackendPolicy&lt; BACKEND &gt; &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This class implements storage in SoA layouts for table where all elements have the same type.  
 <a href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="">multivector.h</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for hydra::multivector&lt; hydra_thrust::tuple&lt; T... &gt;, hydra::detail::BackendPolicy&lt; BACKEND &gt; &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Ba6d0ee5727f19520ea70be12af1ab6f82.svg" width="230" height="279"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a078c8b850c68262e93f4620a3d093780"><td class="memTemplParams" colspan="2">template&lt;typename Functor &gt; </td></tr>
<tr class="memitem:a078c8b850c68262e93f4620a3d093780"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a078c8b850c68262e93f4620a3d093780">caster_iterator</a> = hydra_thrust::transform_iterator&lt; Functor, <a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#acb4a3f31c0da46090cee5305029dbbdd">iterator</a>, typename std::result_of&lt; Functor(tuple_type &amp;)&gt;::type &gt;</td></tr>
<tr class="separator:a078c8b850c68262e93f4620a3d093780"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0988496061e5840b59a01a5db64e74e2"><td class="memTemplParams" colspan="2">template&lt;typename Functor &gt; </td></tr>
<tr class="memitem:a0988496061e5840b59a01a5db64e74e2"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a0988496061e5840b59a01a5db64e74e2">caster_reverse_iterator</a> = hydra_thrust::transform_iterator&lt; Functor, <a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a6423ffbd452a09377a43143229712f47">reverse_iterator</a>, typename std::result_of&lt; Functor(tuple_type &amp;)&gt;::type &gt;</td></tr>
<tr class="separator:a0988496061e5840b59a01a5db64e74e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ec51e41d8e29e5c8c47660b4129792c"><td class="memTemplParams" colspan="2">template&lt;typename Iterators , unsigned int I1, unsigned int I2, unsigned int ... IN&gt; </td></tr>
<tr class="memitem:a9ec51e41d8e29e5c8c47660b4129792c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a9ec51e41d8e29e5c8c47660b4129792c">columns_iterator</a> = hydra_thrust::zip_iterator&lt; hydra_thrust::tuple&lt; typename hydra_thrust::tuple_element&lt; I1, Iterators &gt;::type, typename hydra_thrust::tuple_element&lt; I2, Iterators &gt;::type, typename hydra_thrust::tuple_element&lt; IN, Iterators &gt;::type... &gt; &gt;</td></tr>
<tr class="separator:a9ec51e41d8e29e5c8c47660b4129792c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71a6a4d1056c6a0ec9f8e08f46202b5a"><td class="memItemLeft" align="right" valign="top">typedef hydra_thrust::zip_iterator&lt; <a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a1f4d85a519c1b1070dacefe6e8aa437f">const_iterator_tuple</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a71a6a4d1056c6a0ec9f8e08f46202b5a">const_iterator</a></td></tr>
<tr class="separator:a71a6a4d1056c6a0ec9f8e08f46202b5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f4d85a519c1b1070dacefe6e8aa437f"><td class="memItemLeft" align="right" valign="top">typedef hydra_thrust::tuple&lt; _const_iterator&lt; T &gt;... &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a1f4d85a519c1b1070dacefe6e8aa437f">const_iterator_tuple</a></td></tr>
<tr class="separator:a1f4d85a519c1b1070dacefe6e8aa437f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f91f3a2c0944f43b148ecf1a33e3445"><td class="memItemLeft" align="right" valign="top">typedef hydra_thrust::iterator_traits&lt; <a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a71a6a4d1056c6a0ec9f8e08f46202b5a">const_iterator</a> &gt;::<a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#ad1919b26bba6bbba43c62a450363e35c">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a3f91f3a2c0944f43b148ecf1a33e3445">const_reference</a></td></tr>
<tr class="separator:a3f91f3a2c0944f43b148ecf1a33e3445"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a615a0276cdc32b3c9d897c00f86f4dd1"><td class="memItemLeft" align="right" valign="top">typedef hydra_thrust::tuple&lt; _const_reference&lt; T &gt;... &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a615a0276cdc32b3c9d897c00f86f4dd1">const_reference_tuple</a></td></tr>
<tr class="separator:a615a0276cdc32b3c9d897c00f86f4dd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7f1d7e76570ebd2e3cd11837a83f84e"><td class="memItemLeft" align="right" valign="top">typedef hydra_thrust::zip_iterator&lt; <a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#aae46b9560d4a66e8ff5197d083352b40">const_reverse_iterator_tuple</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#ab7f1d7e76570ebd2e3cd11837a83f84e">const_reverse_iterator</a></td></tr>
<tr class="separator:ab7f1d7e76570ebd2e3cd11837a83f84e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae46b9560d4a66e8ff5197d083352b40"><td class="memItemLeft" align="right" valign="top">typedef hydra_thrust::tuple&lt; _const_reverse_iterator&lt; T &gt;... &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#aae46b9560d4a66e8ff5197d083352b40">const_reverse_iterator_tuple</a></td></tr>
<tr class="separator:aae46b9560d4a66e8ff5197d083352b40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb4a3f31c0da46090cee5305029dbbdd"><td class="memItemLeft" align="right" valign="top">typedef hydra_thrust::zip_iterator&lt; <a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#afb10cbc3fe7918b8a6bf5e38d2130a11">iterator_tuple</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#acb4a3f31c0da46090cee5305029dbbdd">iterator</a></td></tr>
<tr class="separator:acb4a3f31c0da46090cee5305029dbbdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6ea902f339d35704156c26e28334558"><td class="memItemLeft" align="right" valign="top">typedef hydra_thrust::iterator_traits&lt; <a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#acb4a3f31c0da46090cee5305029dbbdd">iterator</a> &gt;::<a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#ad6ea902f339d35704156c26e28334558">iterator_category</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#ad6ea902f339d35704156c26e28334558">iterator_category</a></td></tr>
<tr class="separator:ad6ea902f339d35704156c26e28334558"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb10cbc3fe7918b8a6bf5e38d2130a11"><td class="memItemLeft" align="right" valign="top">typedef hydra_thrust::tuple&lt; _iterator&lt; T &gt;... &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#afb10cbc3fe7918b8a6bf5e38d2130a11">iterator_tuple</a></td></tr>
<tr class="separator:afb10cbc3fe7918b8a6bf5e38d2130a11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace6edbf3d4d3320bd02086edb34c9cf3"><td class="memItemLeft" align="right" valign="top">typedef hydra_thrust::tuple&lt; _pointer&lt; T &gt;... &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#ace6edbf3d4d3320bd02086edb34c9cf3">pointer_tuple</a></td></tr>
<tr class="separator:ace6edbf3d4d3320bd02086edb34c9cf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1919b26bba6bbba43c62a450363e35c"><td class="memItemLeft" align="right" valign="top">typedef hydra_thrust::iterator_traits&lt; <a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#acb4a3f31c0da46090cee5305029dbbdd">iterator</a> &gt;::<a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#ad1919b26bba6bbba43c62a450363e35c">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#ad1919b26bba6bbba43c62a450363e35c">reference</a></td></tr>
<tr class="separator:ad1919b26bba6bbba43c62a450363e35c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acae8445209d326f65a08f5bbeec07877"><td class="memItemLeft" align="right" valign="top">typedef hydra_thrust::tuple&lt; _reference&lt; T &gt;... &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#acae8445209d326f65a08f5bbeec07877">reference_tuple</a></td></tr>
<tr class="separator:acae8445209d326f65a08f5bbeec07877"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6423ffbd452a09377a43143229712f47"><td class="memItemLeft" align="right" valign="top">typedef hydra_thrust::zip_iterator&lt; <a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a9f11226368dc730b94cd85e4c734f3b2">reverse_iterator_tuple</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a6423ffbd452a09377a43143229712f47">reverse_iterator</a></td></tr>
<tr class="separator:a6423ffbd452a09377a43143229712f47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f11226368dc730b94cd85e4c734f3b2"><td class="memItemLeft" align="right" valign="top">typedef hydra_thrust::tuple&lt; _reverse_iterator&lt; T &gt;... &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a9f11226368dc730b94cd85e4c734f3b2">reverse_iterator_tuple</a></td></tr>
<tr class="separator:a9f11226368dc730b94cd85e4c734f3b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b4376d1bae60e70d657ed2b02cd3943"><td class="memItemLeft" align="right" valign="top">typedef size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a1b4376d1bae60e70d657ed2b02cd3943">size_type</a></td></tr>
<tr class="separator:a1b4376d1bae60e70d657ed2b02cd3943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f0d95d51817756d0f5e156d89efb89d"><td class="memItemLeft" align="right" valign="top">typedef hydra_thrust::tuple&lt; _vector&lt; T &gt;... &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a2f0d95d51817756d0f5e156d89efb89d">storage_tuple</a></td></tr>
<tr class="separator:a2f0d95d51817756d0f5e156d89efb89d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbe86be6605b41cd82d238c44afb9531"><td class="memItemLeft" align="right" valign="top">typedef hydra_thrust::iterator_traits&lt; <a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#acb4a3f31c0da46090cee5305029dbbdd">iterator</a> &gt;::<a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#acbe86be6605b41cd82d238c44afb9531">value_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#acbe86be6605b41cd82d238c44afb9531">value_type</a></td></tr>
<tr class="separator:acbe86be6605b41cd82d238c44afb9531"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a360a65cd6defb32398eff7a59306c712"><td class="memItemLeft" align="right" valign="top">typedef hydra_thrust::tuple&lt; _value_type&lt; T &gt;... &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a360a65cd6defb32398eff7a59306c712">value_type_tuple</a></td></tr>
<tr class="separator:a360a65cd6defb32398eff7a59306c712"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ada99de1ba7e827b4d1588c977b1f35fc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#ada99de1ba7e827b4d1588c977b1f35fc">multivector</a> ()=default</td></tr>
<tr class="memdesc:ada99de1ba7e827b4d1588c977b1f35fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="#ada99de1ba7e827b4d1588c977b1f35fc">More...</a><br /></td></tr>
<tr class="separator:ada99de1ba7e827b4d1588c977b1f35fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab951fab73a0295a2a9f0162a33197154"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#ab951fab73a0295a2a9f0162a33197154">multivector</a> (size_t <a class="el" href="crystal__ball__plus__exponential_8inl.html#a21f77208d6bc667560ff8aaf8f943b6a">n</a>)</td></tr>
<tr class="memdesc:ab951fab73a0295a2a9f0162a33197154"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor initializing the <code>multivector</code> with <code>n</code> entries.  <a href="#ab951fab73a0295a2a9f0162a33197154">More...</a><br /></td></tr>
<tr class="separator:ab951fab73a0295a2a9f0162a33197154"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a174e42d2e28905fcb647cf15bd96d74a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a174e42d2e28905fcb647cf15bd96d74a">multivector</a> (size_t <a class="el" href="crystal__ball__plus__exponential_8inl.html#a21f77208d6bc667560ff8aaf8f943b6a">n</a>, <a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#acbe86be6605b41cd82d238c44afb9531">value_type</a> const &amp;value)</td></tr>
<tr class="memdesc:a174e42d2e28905fcb647cf15bd96d74a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor initializing the multivector with <code>n</code> copies of <code>value</code> .  <a href="#a174e42d2e28905fcb647cf15bd96d74a">More...</a><br /></td></tr>
<tr class="separator:a174e42d2e28905fcb647cf15bd96d74a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa3a2c41c7c1a8b4314ed4e3ec34230d"><td class="memTemplParams" colspan="2">template&lt;typename Int , typename  = typename hydra_thrust::detail::enable_if&lt;std::is_integral&lt;Int&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:afa3a2c41c7c1a8b4314ed4e3ec34230d"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#afa3a2c41c7c1a8b4314ed4e3ec34230d">multivector</a> (<a class="el" href="namespacehydra.html#a412c01a2247e7a463fc693a43310d00e">hydra::pair</a>&lt; Int, hydra_thrust::tuple&lt; T... &gt; &gt; const &amp;<a class="el" href="namespacehydra.html#a412c01a2247e7a463fc693a43310d00e">pair</a>)</td></tr>
<tr class="memdesc:afa3a2c41c7c1a8b4314ed4e3ec34230d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor initializing the multivector with <code>n</code> copies of <code>value</code> .  <a href="#afa3a2c41c7c1a8b4314ed4e3ec34230d">More...</a><br /></td></tr>
<tr class="separator:afa3a2c41c7c1a8b4314ed4e3ec34230d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a473d1a18e6ce7afd637fc66236bb75b0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a473d1a18e6ce7afd637fc66236bb75b0">multivector</a> (<a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; hydra_thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; const &amp;other)</td></tr>
<tr class="memdesc:a473d1a18e6ce7afd637fc66236bb75b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="#a473d1a18e6ce7afd637fc66236bb75b0">More...</a><br /></td></tr>
<tr class="separator:a473d1a18e6ce7afd637fc66236bb75b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25f403b6a73a44099396b9aaa0927ba5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a25f403b6a73a44099396b9aaa0927ba5">multivector</a> (<a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; hydra_thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; &amp;&amp;other)</td></tr>
<tr class="memdesc:a25f403b6a73a44099396b9aaa0927ba5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor.  <a href="#a25f403b6a73a44099396b9aaa0927ba5">More...</a><br /></td></tr>
<tr class="separator:a25f403b6a73a44099396b9aaa0927ba5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fd707b3672692f8876a00986ca74a50"><td class="memTemplParams" colspan="2">template&lt;hydra::detail::Backend BACKEND2&gt; </td></tr>
<tr class="memitem:a6fd707b3672692f8876a00986ca74a50"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a6fd707b3672692f8876a00986ca74a50">multivector</a> (<a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; hydra_thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND2 &gt;&gt; const &amp;other)</td></tr>
<tr class="memdesc:a6fd707b3672692f8876a00986ca74a50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor for containers allocated in different backends.  <a href="#a6fd707b3672692f8876a00986ca74a50">More...</a><br /></td></tr>
<tr class="separator:a6fd707b3672692f8876a00986ca74a50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f0070e5e9c98e7cd2f1092e9cac9bcd"><td class="memTemplParams" colspan="2">template&lt;typename Iterator &gt; </td></tr>
<tr class="memitem:a3f0070e5e9c98e7cd2f1092e9cac9bcd"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a3f0070e5e9c98e7cd2f1092e9cac9bcd">multivector</a> (Iterator first, Iterator last)</td></tr>
<tr class="memdesc:a3f0070e5e9c98e7cd2f1092e9cac9bcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This constructor builds a <code>multivector</code> from a range.  <a href="#a3f0070e5e9c98e7cd2f1092e9cac9bcd">More...</a><br /></td></tr>
<tr class="separator:a3f0070e5e9c98e7cd2f1092e9cac9bcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcc3c9a74d82827294f5d129b8da1a33"><td class="memTemplParams" colspan="2">template&lt;typename Iterable , typename  = typename std::enable_if&lt;	           (detail::is_iterable&lt;Iterable&gt;::value) &amp;&amp;	          !(detail::is_iterator&lt;Iterable&gt;::value) &amp;&amp;	           (std::is_convertible&lt;decltype(*std::declval&lt;Iterable&gt;().begin()), value_type&gt;::value)	          &gt;::type&gt; </td></tr>
<tr class="memitem:adcc3c9a74d82827294f5d129b8da1a33"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#adcc3c9a74d82827294f5d129b8da1a33">multivector</a> (Iterable &amp;&amp;other)</td></tr>
<tr class="separator:adcc3c9a74d82827294f5d129b8da1a33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0c0cf51e6b82784ad2209a82717013a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#ad1919b26bba6bbba43c62a450363e35c">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#ac0c0cf51e6b82784ad2209a82717013a">back</a> ()</td></tr>
<tr class="memdesc:ac0c0cf51e6b82784ad2209a82717013a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method returns a reference referring to the last element of this vector_dev.  <a href="#ac0c0cf51e6b82784ad2209a82717013a">More...</a><br /></td></tr>
<tr class="separator:ac0c0cf51e6b82784ad2209a82717013a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33676a22bf835034ccf4caf2dfda70d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a3f91f3a2c0944f43b148ecf1a33e3445">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a33676a22bf835034ccf4caf2dfda70d7">back</a> () const</td></tr>
<tr class="memdesc:a33676a22bf835034ccf4caf2dfda70d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method returns a const reference pointing to the last element of this <code>multivector</code>.  <a href="#a33676a22bf835034ccf4caf2dfda70d7">More...</a><br /></td></tr>
<tr class="separator:a33676a22bf835034ccf4caf2dfda70d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55c4a877dcdedbd34ec35a2715a9c5ab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#acb4a3f31c0da46090cee5305029dbbdd">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a55c4a877dcdedbd34ec35a2715a9c5ab">begin</a> ()</td></tr>
<tr class="memdesc:a55c4a877dcdedbd34ec35a2715a9c5ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method returns an iterator pointing to the beginning of this <code>multivector</code>.  <a href="#a55c4a877dcdedbd34ec35a2715a9c5ab">More...</a><br /></td></tr>
<tr class="separator:a55c4a877dcdedbd34ec35a2715a9c5ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4831d24a646d402ef83648dbf518786"><td class="memTemplParams" colspan="2">template&lt;typename Functor &gt; </td></tr>
<tr class="memitem:af4831d24a646d402ef83648dbf518786"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a078c8b850c68262e93f4620a3d093780">caster_iterator</a>&lt; Functor &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#af4831d24a646d402ef83648dbf518786">begin</a> (Functor const &amp;caster)</td></tr>
<tr class="separator:af4831d24a646d402ef83648dbf518786"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae73d7991ce79b8e5e709a504adf61770"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a71a6a4d1056c6a0ec9f8e08f46202b5a">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#ae73d7991ce79b8e5e709a504adf61770">begin</a> () const</td></tr>
<tr class="separator:ae73d7991ce79b8e5e709a504adf61770"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a404fde770b93b404c30ede4092bb044b"><td class="memTemplParams" colspan="2">template&lt;unsigned int I1, unsigned int I2, unsigned int ... IN&gt; </td></tr>
<tr class="memitem:a404fde770b93b404c30ede4092bb044b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a9ec51e41d8e29e5c8c47660b4129792c">columns_iterator</a>&lt; <a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#afb10cbc3fe7918b8a6bf5e38d2130a11">iterator_tuple</a>, I1, I2, IN... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a404fde770b93b404c30ede4092bb044b">begin</a> (<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I1 &gt; <a class="el" href="breit__wigner__plus__polynomial_8inl.html#a8175ec4e5461dcd38d40ead25fef205c">c1</a>, <a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I2 &gt; <a class="el" href="breit__wigner__plus__polynomial_8inl.html#a024a3031e2ed14c5d1405f6e99df1158">c2</a>, <a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; IN &gt; ...cn)</td></tr>
<tr class="separator:a404fde770b93b404c30ede4092bb044b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4a61268ac538b43eae366768884f033"><td class="memTemplParams" colspan="2">template&lt;unsigned int I&gt; </td></tr>
<tr class="memitem:ad4a61268ac538b43eae366768884f033"><td class="memTemplItemLeft" align="right" valign="top">hydra_thrust::tuple_element&lt; I, <a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#afb10cbc3fe7918b8a6bf5e38d2130a11">iterator_tuple</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#ad4a61268ac538b43eae366768884f033">begin</a> (<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;)</td></tr>
<tr class="separator:ad4a61268ac538b43eae366768884f033"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3408e73d9c80b523cbe3c9fbbfcdcaa5"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:a3408e73d9c80b523cbe3c9fbbfcdcaa5"><td class="memTemplItemLeft" align="right" valign="top">hydra_thrust::tuple_element&lt; <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1index__in__tuple">detail::index_in_tuple</a>&lt; Type, tuple_type &gt;::value, <a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#afb10cbc3fe7918b8a6bf5e38d2130a11">iterator_tuple</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a3408e73d9c80b523cbe3c9fbbfcdcaa5">begin</a> ()</td></tr>
<tr class="separator:a3408e73d9c80b523cbe3c9fbbfcdcaa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add6a3b2454998731b018ea7d837d25b5"><td class="memTemplParams" colspan="2">template&lt;unsigned int I1, unsigned int I2, unsigned int ... IN&gt; </td></tr>
<tr class="memitem:add6a3b2454998731b018ea7d837d25b5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a9ec51e41d8e29e5c8c47660b4129792c">columns_iterator</a>&lt; <a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a1f4d85a519c1b1070dacefe6e8aa437f">const_iterator_tuple</a>, I1, I2, IN... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#add6a3b2454998731b018ea7d837d25b5">begin</a> (<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I1 &gt; <a class="el" href="breit__wigner__plus__polynomial_8inl.html#a8175ec4e5461dcd38d40ead25fef205c">c1</a>, <a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I2 &gt; <a class="el" href="breit__wigner__plus__polynomial_8inl.html#a024a3031e2ed14c5d1405f6e99df1158">c2</a>, <a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; IN &gt; ...cn) const</td></tr>
<tr class="separator:add6a3b2454998731b018ea7d837d25b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab39fa078e2e4d9964b76c09392dac627"><td class="memTemplParams" colspan="2">template&lt;unsigned int I&gt; </td></tr>
<tr class="memitem:ab39fa078e2e4d9964b76c09392dac627"><td class="memTemplItemLeft" align="right" valign="top">hydra_thrust::tuple_element&lt; I, <a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a1f4d85a519c1b1070dacefe6e8aa437f">const_iterator_tuple</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#ab39fa078e2e4d9964b76c09392dac627">begin</a> (<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;) const</td></tr>
<tr class="separator:ab39fa078e2e4d9964b76c09392dac627"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1017073974b6f6753a1f5126f2edfa16"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a1b4376d1bae60e70d657ed2b02cd3943">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a1017073974b6f6753a1f5126f2edfa16">capacity</a> () const</td></tr>
<tr class="memdesc:a1017073974b6f6753a1f5126f2edfa16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements which have been reserved in this <code>multivector</code>.  <a href="#a1017073974b6f6753a1f5126f2edfa16">More...</a><br /></td></tr>
<tr class="separator:a1017073974b6f6753a1f5126f2edfa16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a995ff9749d91510471b7d34fd971ef9f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a71a6a4d1056c6a0ec9f8e08f46202b5a">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a995ff9749d91510471b7d34fd971ef9f">cbegin</a> () const</td></tr>
<tr class="separator:a995ff9749d91510471b7d34fd971ef9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0679d559053d6096dec77eaa2492ab20"><td class="memTemplParams" colspan="2">template&lt;unsigned int I1, unsigned int I2, unsigned int ... IN&gt; </td></tr>
<tr class="memitem:a0679d559053d6096dec77eaa2492ab20"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a9ec51e41d8e29e5c8c47660b4129792c">columns_iterator</a>&lt; <a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a1f4d85a519c1b1070dacefe6e8aa437f">const_iterator_tuple</a>, I1, I2, IN... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a0679d559053d6096dec77eaa2492ab20">cbegin</a> (<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I1 &gt; <a class="el" href="breit__wigner__plus__polynomial_8inl.html#a8175ec4e5461dcd38d40ead25fef205c">c1</a>, <a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I2 &gt; <a class="el" href="breit__wigner__plus__polynomial_8inl.html#a024a3031e2ed14c5d1405f6e99df1158">c2</a>, <a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; IN &gt; ...cn) const</td></tr>
<tr class="separator:a0679d559053d6096dec77eaa2492ab20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93c03a63046c4595a8d660208ddc7aa3"><td class="memTemplParams" colspan="2">template&lt;unsigned int I&gt; </td></tr>
<tr class="memitem:a93c03a63046c4595a8d660208ddc7aa3"><td class="memTemplItemLeft" align="right" valign="top">hydra_thrust::tuple_element&lt; I, <a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a1f4d85a519c1b1070dacefe6e8aa437f">const_iterator_tuple</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a93c03a63046c4595a8d660208ddc7aa3">cbegin</a> (<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;) const</td></tr>
<tr class="separator:a93c03a63046c4595a8d660208ddc7aa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab91684e6e614739af2a950fc8762fa83"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a71a6a4d1056c6a0ec9f8e08f46202b5a">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#ab91684e6e614739af2a950fc8762fa83">cend</a> () const</td></tr>
<tr class="separator:ab91684e6e614739af2a950fc8762fa83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a744666b5687f539f3559f93f462f44f6"><td class="memTemplParams" colspan="2">template&lt;unsigned int I1, unsigned int I2, unsigned int ... IN&gt; </td></tr>
<tr class="memitem:a744666b5687f539f3559f93f462f44f6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a9ec51e41d8e29e5c8c47660b4129792c">columns_iterator</a>&lt; <a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a1f4d85a519c1b1070dacefe6e8aa437f">const_iterator_tuple</a>, I1, I2, IN... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a744666b5687f539f3559f93f462f44f6">cend</a> (<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I1 &gt; <a class="el" href="breit__wigner__plus__polynomial_8inl.html#a8175ec4e5461dcd38d40ead25fef205c">c1</a>, <a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I2 &gt; <a class="el" href="breit__wigner__plus__polynomial_8inl.html#a024a3031e2ed14c5d1405f6e99df1158">c2</a>, <a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; IN &gt; ...cn) const</td></tr>
<tr class="separator:a744666b5687f539f3559f93f462f44f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab183b678996c884cf6cdce9354eaa878"><td class="memTemplParams" colspan="2">template&lt;unsigned int I&gt; </td></tr>
<tr class="memitem:ab183b678996c884cf6cdce9354eaa878"><td class="memTemplItemLeft" align="right" valign="top">hydra_thrust::tuple_element&lt; I, <a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a1f4d85a519c1b1070dacefe6e8aa437f">const_iterator_tuple</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#ab183b678996c884cf6cdce9354eaa878">cend</a> (<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;) const</td></tr>
<tr class="separator:ab183b678996c884cf6cdce9354eaa878"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1551ff4ddc34475c2493ab098cba7a91"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a1551ff4ddc34475c2493ab098cba7a91">clear</a> ()</td></tr>
<tr class="memdesc:a1551ff4ddc34475c2493ab098cba7a91"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method resizes this <code>multivector</code> to 0.  <a href="#a1551ff4ddc34475c2493ab098cba7a91">More...</a><br /></td></tr>
<tr class="separator:a1551ff4ddc34475c2493ab098cba7a91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab2f3363a65fd062a4d437099c72eb9b"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:aab2f3363a65fd062a4d437099c72eb9b"><td class="memTemplItemLeft" align="right" valign="top">hydra_thrust::tuple_element&lt; <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1index__in__tuple">detail::index_in_tuple</a>&lt; Type, tuple_type &gt;::value, <a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a2f0d95d51817756d0f5e156d89efb89d">storage_tuple</a> &gt;::type &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#aab2f3363a65fd062a4d437099c72eb9b">column</a> ()</td></tr>
<tr class="separator:aab2f3363a65fd062a4d437099c72eb9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af863224788e374a43efc4454f91ab3e9"><td class="memTemplParams" colspan="2">template&lt;unsigned int I&gt; </td></tr>
<tr class="memitem:af863224788e374a43efc4454f91ab3e9"><td class="memTemplItemLeft" align="right" valign="top">hydra_thrust::tuple_element&lt; I, <a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a2f0d95d51817756d0f5e156d89efb89d">storage_tuple</a> &gt;::type &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#af863224788e374a43efc4454f91ab3e9">column</a> (<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;)</td></tr>
<tr class="separator:af863224788e374a43efc4454f91ab3e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a747b6715f5f1349737f4df9ed2c75461"><td class="memTemplParams" colspan="2">template&lt;unsigned int I1, unsigned int I2, unsigned int ... IN&gt; </td></tr>
<tr class="memitem:a747b6715f5f1349737f4df9ed2c75461"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacehydra.html#classhydra_1_1Range">hydra::Range</a>&lt; <a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a9ec51e41d8e29e5c8c47660b4129792c">columns_iterator</a>&lt; <a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#afb10cbc3fe7918b8a6bf5e38d2130a11">iterator_tuple</a>, I1, I2, IN... &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a747b6715f5f1349737f4df9ed2c75461">column</a> (<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I1 &gt; <a class="el" href="breit__wigner__plus__polynomial_8inl.html#a8175ec4e5461dcd38d40ead25fef205c">c1</a>, <a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I2 &gt; <a class="el" href="breit__wigner__plus__polynomial_8inl.html#a024a3031e2ed14c5d1405f6e99df1158">c2</a>, <a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; IN &gt; ...cn)</td></tr>
<tr class="separator:a747b6715f5f1349737f4df9ed2c75461"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77a0c0a82d6b42e616d892af2d9a9e7b"><td class="memTemplParams" colspan="2">template&lt;unsigned int I&gt; </td></tr>
<tr class="memitem:a77a0c0a82d6b42e616d892af2d9a9e7b"><td class="memTemplItemLeft" align="right" valign="top">const hydra_thrust::tuple_element&lt; I, <a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a2f0d95d51817756d0f5e156d89efb89d">storage_tuple</a> &gt;::type &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a77a0c0a82d6b42e616d892af2d9a9e7b">column</a> (<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;) const</td></tr>
<tr class="separator:a77a0c0a82d6b42e616d892af2d9a9e7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1828c9c7ba1435e9a2e801edcdb3b778"><td class="memTemplParams" colspan="2">template&lt;unsigned int I1, unsigned int I2, unsigned int ... IN&gt; </td></tr>
<tr class="memitem:a1828c9c7ba1435e9a2e801edcdb3b778"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacehydra.html#classhydra_1_1Range">hydra::Range</a>&lt; <a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a9ec51e41d8e29e5c8c47660b4129792c">columns_iterator</a>&lt; <a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a1f4d85a519c1b1070dacefe6e8aa437f">const_iterator_tuple</a>, I1, I2, IN... &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a1828c9c7ba1435e9a2e801edcdb3b778">column</a> (<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I1 &gt; <a class="el" href="breit__wigner__plus__polynomial_8inl.html#a8175ec4e5461dcd38d40ead25fef205c">c1</a>, <a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I2 &gt; <a class="el" href="breit__wigner__plus__polynomial_8inl.html#a024a3031e2ed14c5d1405f6e99df1158">c2</a>, <a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; IN &gt; ...cn) const</td></tr>
<tr class="separator:a1828c9c7ba1435e9a2e801edcdb3b778"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb82527a728d1a762632a10a6fe9f809"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#ab7f1d7e76570ebd2e3cd11837a83f84e">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#acb82527a728d1a762632a10a6fe9f809">crbegin</a> () const</td></tr>
<tr class="separator:acb82527a728d1a762632a10a6fe9f809"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af40b45a085f6ac290fbc431002eca16d"><td class="memTemplParams" colspan="2">template&lt;unsigned int I1, unsigned int I2, unsigned int ... IN&gt; </td></tr>
<tr class="memitem:af40b45a085f6ac290fbc431002eca16d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a9ec51e41d8e29e5c8c47660b4129792c">columns_iterator</a>&lt; <a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#aae46b9560d4a66e8ff5197d083352b40">const_reverse_iterator_tuple</a>, I1, I2, IN... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#af40b45a085f6ac290fbc431002eca16d">crbegin</a> (<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I1 &gt; <a class="el" href="breit__wigner__plus__polynomial_8inl.html#a8175ec4e5461dcd38d40ead25fef205c">c1</a>, <a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I2 &gt; <a class="el" href="breit__wigner__plus__polynomial_8inl.html#a024a3031e2ed14c5d1405f6e99df1158">c2</a>, <a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; IN &gt; ...cn) const</td></tr>
<tr class="separator:af40b45a085f6ac290fbc431002eca16d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46544d906edb258cb38d0854e4dd8eaa"><td class="memTemplParams" colspan="2">template&lt;unsigned int I&gt; </td></tr>
<tr class="memitem:a46544d906edb258cb38d0854e4dd8eaa"><td class="memTemplItemLeft" align="right" valign="top">hydra_thrust::tuple_element&lt; I, <a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#aae46b9560d4a66e8ff5197d083352b40">const_reverse_iterator_tuple</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a46544d906edb258cb38d0854e4dd8eaa">crbegin</a> (<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;) const</td></tr>
<tr class="separator:a46544d906edb258cb38d0854e4dd8eaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd605b49101f47f6d967132d467e7e76"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#ab7f1d7e76570ebd2e3cd11837a83f84e">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#afd605b49101f47f6d967132d467e7e76">crend</a> () const</td></tr>
<tr class="separator:afd605b49101f47f6d967132d467e7e76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0420b8fc24ca4d9bb7df862ea183f910"><td class="memTemplParams" colspan="2">template&lt;unsigned int I1, unsigned int I2, unsigned int ... IN&gt; </td></tr>
<tr class="memitem:a0420b8fc24ca4d9bb7df862ea183f910"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a9ec51e41d8e29e5c8c47660b4129792c">columns_iterator</a>&lt; <a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#aae46b9560d4a66e8ff5197d083352b40">const_reverse_iterator_tuple</a>, I1, I2, IN... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a0420b8fc24ca4d9bb7df862ea183f910">crend</a> (<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I1 &gt; <a class="el" href="breit__wigner__plus__polynomial_8inl.html#a8175ec4e5461dcd38d40ead25fef205c">c1</a>, <a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I2 &gt; <a class="el" href="breit__wigner__plus__polynomial_8inl.html#a024a3031e2ed14c5d1405f6e99df1158">c2</a>, <a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; IN &gt; ...cn) const</td></tr>
<tr class="separator:a0420b8fc24ca4d9bb7df862ea183f910"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae869686999dbf21de21c83168f1ba14"><td class="memTemplParams" colspan="2">template&lt;unsigned int I&gt; </td></tr>
<tr class="memitem:aae869686999dbf21de21c83168f1ba14"><td class="memTemplItemLeft" align="right" valign="top">hydra_thrust::tuple_element&lt; I, <a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#aae46b9560d4a66e8ff5197d083352b40">const_reverse_iterator_tuple</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#aae869686999dbf21de21c83168f1ba14">crend</a> (<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;) const</td></tr>
<tr class="separator:aae869686999dbf21de21c83168f1ba14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab27484f2f9f68faa27d5602dd819e3d8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#ab27484f2f9f68faa27d5602dd819e3d8">empty</a> () const</td></tr>
<tr class="memdesc:ab27484f2f9f68faa27d5602dd819e3d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method returns true iff <a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a53247dddff1f2a2e7435b88e22f4c25b" title="Returns the number of elements in this multivector. ">size()</a> == 0.  <a href="#ab27484f2f9f68faa27d5602dd819e3d8">More...</a><br /></td></tr>
<tr class="separator:ab27484f2f9f68faa27d5602dd819e3d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa05ff39f52149a6517392257df870278"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#acb4a3f31c0da46090cee5305029dbbdd">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#aa05ff39f52149a6517392257df870278">end</a> ()</td></tr>
<tr class="memdesc:aa05ff39f52149a6517392257df870278"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method returns a const_iterator pointing to one element past the last of this <code>multivector</code>.  <a href="#aa05ff39f52149a6517392257df870278">More...</a><br /></td></tr>
<tr class="separator:aa05ff39f52149a6517392257df870278"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad35d82b4b5c34215dcbb0395c95c06e3"><td class="memTemplParams" colspan="2">template&lt;typename Functor &gt; </td></tr>
<tr class="memitem:ad35d82b4b5c34215dcbb0395c95c06e3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a078c8b850c68262e93f4620a3d093780">caster_iterator</a>&lt; Functor &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#ad35d82b4b5c34215dcbb0395c95c06e3">end</a> (Functor const &amp;caster)</td></tr>
<tr class="separator:ad35d82b4b5c34215dcbb0395c95c06e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1eb49c27e29c137bc0517d824209fb6a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a71a6a4d1056c6a0ec9f8e08f46202b5a">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a1eb49c27e29c137bc0517d824209fb6a">end</a> () const</td></tr>
<tr class="separator:a1eb49c27e29c137bc0517d824209fb6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56e7b095173a1d145981d770a8b4c134"><td class="memTemplParams" colspan="2">template&lt;unsigned int I1, unsigned int I2, unsigned int ... IN&gt; </td></tr>
<tr class="memitem:a56e7b095173a1d145981d770a8b4c134"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a9ec51e41d8e29e5c8c47660b4129792c">columns_iterator</a>&lt; <a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#afb10cbc3fe7918b8a6bf5e38d2130a11">iterator_tuple</a>, I1, I2, IN... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a56e7b095173a1d145981d770a8b4c134">end</a> (<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I1 &gt; <a class="el" href="breit__wigner__plus__polynomial_8inl.html#a8175ec4e5461dcd38d40ead25fef205c">c1</a>, <a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I2 &gt; <a class="el" href="breit__wigner__plus__polynomial_8inl.html#a024a3031e2ed14c5d1405f6e99df1158">c2</a>, <a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; IN &gt; ...cn)</td></tr>
<tr class="separator:a56e7b095173a1d145981d770a8b4c134"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2319a03127b89a84c9a258bca762cc72"><td class="memTemplParams" colspan="2">template&lt;unsigned int I&gt; </td></tr>
<tr class="memitem:a2319a03127b89a84c9a258bca762cc72"><td class="memTemplItemLeft" align="right" valign="top">hydra_thrust::tuple_element&lt; I, <a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#afb10cbc3fe7918b8a6bf5e38d2130a11">iterator_tuple</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a2319a03127b89a84c9a258bca762cc72">end</a> (<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;)</td></tr>
<tr class="separator:a2319a03127b89a84c9a258bca762cc72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39c46ef4a4a9b172cf88e1d968dcf882"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:a39c46ef4a4a9b172cf88e1d968dcf882"><td class="memTemplItemLeft" align="right" valign="top">hydra_thrust::tuple_element&lt; <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1index__in__tuple">detail::index_in_tuple</a>&lt; Type, tuple_type &gt;::value, <a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#afb10cbc3fe7918b8a6bf5e38d2130a11">iterator_tuple</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a39c46ef4a4a9b172cf88e1d968dcf882">end</a> ()</td></tr>
<tr class="separator:a39c46ef4a4a9b172cf88e1d968dcf882"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade0d769bc8e6a5ffc1faaf55cff518f2"><td class="memTemplParams" colspan="2">template&lt;unsigned int I1, unsigned int I2, unsigned int ... IN&gt; </td></tr>
<tr class="memitem:ade0d769bc8e6a5ffc1faaf55cff518f2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a9ec51e41d8e29e5c8c47660b4129792c">columns_iterator</a>&lt; <a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a1f4d85a519c1b1070dacefe6e8aa437f">const_iterator_tuple</a>, I1, I2, IN... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#ade0d769bc8e6a5ffc1faaf55cff518f2">end</a> (<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I1 &gt; <a class="el" href="breit__wigner__plus__polynomial_8inl.html#a8175ec4e5461dcd38d40ead25fef205c">c1</a>, <a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I2 &gt; <a class="el" href="breit__wigner__plus__polynomial_8inl.html#a024a3031e2ed14c5d1405f6e99df1158">c2</a>, <a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; IN &gt; ...cn) const</td></tr>
<tr class="separator:ade0d769bc8e6a5ffc1faaf55cff518f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1933cccc198035386416d4d154edb7f"><td class="memTemplParams" colspan="2">template&lt;unsigned int I&gt; </td></tr>
<tr class="memitem:aa1933cccc198035386416d4d154edb7f"><td class="memTemplItemLeft" align="right" valign="top">hydra_thrust::tuple_element&lt; I, <a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a1f4d85a519c1b1070dacefe6e8aa437f">const_iterator_tuple</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#aa1933cccc198035386416d4d154edb7f">end</a> (<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;) const</td></tr>
<tr class="separator:aa1933cccc198035386416d4d154edb7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca7980e5d4aefb1904439da575e4014b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#acb4a3f31c0da46090cee5305029dbbdd">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#aca7980e5d4aefb1904439da575e4014b">erase</a> (<a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#acb4a3f31c0da46090cee5305029dbbdd">iterator</a> pos)</td></tr>
<tr class="memdesc:aca7980e5d4aefb1904439da575e4014b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method removes the element at position pos.  <a href="#aca7980e5d4aefb1904439da575e4014b">More...</a><br /></td></tr>
<tr class="separator:aca7980e5d4aefb1904439da575e4014b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99a1b96abef00395b4d6addb1aed4577"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#acb4a3f31c0da46090cee5305029dbbdd">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a99a1b96abef00395b4d6addb1aed4577">erase</a> (<a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#acb4a3f31c0da46090cee5305029dbbdd">iterator</a> first, <a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#acb4a3f31c0da46090cee5305029dbbdd">iterator</a> last)</td></tr>
<tr class="memdesc:a99a1b96abef00395b4d6addb1aed4577"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method removes the range of elements [first,last) from this <code>multivector</code>.  <a href="#a99a1b96abef00395b4d6addb1aed4577">More...</a><br /></td></tr>
<tr class="separator:a99a1b96abef00395b4d6addb1aed4577"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a783fe47977740366fed001ce519c906a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#ad1919b26bba6bbba43c62a450363e35c">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a783fe47977740366fed001ce519c906a">front</a> ()</td></tr>
<tr class="memdesc:a783fe47977740366fed001ce519c906a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method returns a const_reference referring to the first element of this <code>multivector</code>.  <a href="#a783fe47977740366fed001ce519c906a">More...</a><br /></td></tr>
<tr class="separator:a783fe47977740366fed001ce519c906a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a926b7063631254f19f36bed0474913"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a3f91f3a2c0944f43b148ecf1a33e3445">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a1a926b7063631254f19f36bed0474913">front</a> () const</td></tr>
<tr class="memdesc:a1a926b7063631254f19f36bed0474913"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method returns a reference pointing to the first element of this <code>multivector</code>.  <a href="#a1a926b7063631254f19f36bed0474913">More...</a><br /></td></tr>
<tr class="separator:a1a926b7063631254f19f36bed0474913"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c345f12f7f58b379830cb9635325e71"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#acb4a3f31c0da46090cee5305029dbbdd">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a8c345f12f7f58b379830cb9635325e71">insert</a> (<a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#acb4a3f31c0da46090cee5305029dbbdd">iterator</a> pos, const <a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#acbe86be6605b41cd82d238c44afb9531">value_type</a> &amp;x)</td></tr>
<tr class="memdesc:a8c345f12f7f58b379830cb9635325e71"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method inserts a single copy of a given exemplar value at the specified position in this <code>multivector</code>.  <a href="#a8c345f12f7f58b379830cb9635325e71">More...</a><br /></td></tr>
<tr class="separator:a8c345f12f7f58b379830cb9635325e71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa485cabe13ab716769592a54c42f96cf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#aa485cabe13ab716769592a54c42f96cf">insert</a> (<a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#acb4a3f31c0da46090cee5305029dbbdd">iterator</a> pos, <a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a1b4376d1bae60e70d657ed2b02cd3943">size_type</a> <a class="el" href="crystal__ball__plus__exponential_8inl.html#a21f77208d6bc667560ff8aaf8f943b6a">n</a>, const <a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#acbe86be6605b41cd82d238c44afb9531">value_type</a> &amp;x)</td></tr>
<tr class="memdesc:aa485cabe13ab716769592a54c42f96cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method inserts a copy of an exemplar value to a range at the specified position in this <code>multivector</code>.  <a href="#aa485cabe13ab716769592a54c42f96cf">More...</a><br /></td></tr>
<tr class="separator:aa485cabe13ab716769592a54c42f96cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afde85df98fe9062b364ffa43f6b857b2"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator &gt; </td></tr>
<tr class="memitem:afde85df98fe9062b364ffa43f6b857b2"><td class="memTemplItemLeft" align="right" valign="top">hydra_thrust::detail::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__zip__iterator.html">detail::is_zip_iterator</a>&lt; InputIterator &gt;::value &amp;&amp;std::is_convertible&lt; typename hydra_thrust::iterator_traits&lt; InputIterator &gt;::<a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#acbe86be6605b41cd82d238c44afb9531">value_type</a>, <a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#acbe86be6605b41cd82d238c44afb9531">value_type</a> &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#afde85df98fe9062b364ffa43f6b857b2">insert</a> (<a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#acb4a3f31c0da46090cee5305029dbbdd">iterator</a> pos, InputIterator first, InputIterator last)</td></tr>
<tr class="memdesc:afde85df98fe9062b364ffa43f6b857b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method inserts a copy of an input range at the specified position in this <code>multivector</code>.  <a href="#afde85df98fe9062b364ffa43f6b857b2">More...</a><br /></td></tr>
<tr class="separator:afde85df98fe9062b364ffa43f6b857b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a0b79e9a500bfe7469deede51586dbd"><td class="memTemplParams" colspan="2">template&lt;typename ... Iterables&gt; </td></tr>
<tr class="memitem:a8a0b79e9a500bfe7469deede51586dbd"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a8a0b79e9a500bfe7469deede51586dbd">meld</a> (Iterables &amp;&amp;...iterables) -&gt; typename std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1all__true.html">detail::all_true</a>&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">detail::is_iterable</a>&lt; Iterables &gt;::value... &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1Range">hydra::Range</a>&lt; decltype(<a class="el" href="namespacehydra_1_1detail.html#ac36de892880609f667e4d5cc9718a5e1">detail::meld_iterators</a>(<a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a55c4a877dcdedbd34ec35a2715a9c5ab">begin</a>(), std::forward&lt; Iterables &gt;(iterables).<a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a55c4a877dcdedbd34ec35a2715a9c5ab">begin</a>()...))&gt;&gt;::type</td></tr>
<tr class="separator:a8a0b79e9a500bfe7469deede51586dbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47cb83cabed52f7215e6d715a2a62515"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; hydra_thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a47cb83cabed52f7215e6d715a2a62515">operator=</a> (<a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; hydra_thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; const &amp;other)</td></tr>
<tr class="memdesc:a47cb83cabed52f7215e6d715a2a62515"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator.  <a href="#a47cb83cabed52f7215e6d715a2a62515">More...</a><br /></td></tr>
<tr class="separator:a47cb83cabed52f7215e6d715a2a62515"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad249df7641011b6873cd0279f00bd6be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; hydra_thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#ad249df7641011b6873cd0279f00bd6be">operator=</a> (<a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; hydra_thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt; &gt; &amp;&amp;other)</td></tr>
<tr class="memdesc:ad249df7641011b6873cd0279f00bd6be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move-assignment operator.  <a href="#ad249df7641011b6873cd0279f00bd6be">More...</a><br /></td></tr>
<tr class="separator:ad249df7641011b6873cd0279f00bd6be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32d1bd50c3927a7e20c8aa0222d57386"><td class="memTemplParams" colspan="2">template&lt;hydra::detail::Backend BACKEND2&gt; </td></tr>
<tr class="memitem:a32d1bd50c3927a7e20c8aa0222d57386"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; hydra_thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt; &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a32d1bd50c3927a7e20c8aa0222d57386">operator=</a> (<a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; hydra_thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND2 &gt; &gt; const &amp;other)</td></tr>
<tr class="memdesc:a32d1bd50c3927a7e20c8aa0222d57386"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator.  <a href="#a32d1bd50c3927a7e20c8aa0222d57386">More...</a><br /></td></tr>
<tr class="separator:a32d1bd50c3927a7e20c8aa0222d57386"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98058ec881b21d5cd75c64338c591637"><td class="memTemplParams" colspan="2">template&lt;typename Functor &gt; </td></tr>
<tr class="memitem:a98058ec881b21d5cd75c64338c591637"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a078c8b850c68262e93f4620a3d093780">caster_iterator</a>&lt; Functor &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a98058ec881b21d5cd75c64338c591637">operator[]</a> (Functor const &amp;caster)</td></tr>
<tr class="separator:a98058ec881b21d5cd75c64338c591637"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc95babea4a3241cc7a9764db47bc307"><td class="memTemplParams" colspan="2">template&lt;unsigned int I&gt; </td></tr>
<tr class="memitem:afc95babea4a3241cc7a9764db47bc307"><td class="memTemplItemLeft" align="right" valign="top">hydra_thrust::tuple_element&lt; I, <a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#afb10cbc3fe7918b8a6bf5e38d2130a11">iterator_tuple</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#afc95babea4a3241cc7a9764db47bc307">operator[]</a> (<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt; index)</td></tr>
<tr class="separator:afc95babea4a3241cc7a9764db47bc307"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e4684917cd63e762fb7c73a310b92fd"><td class="memTemplParams" colspan="2">template&lt;unsigned int I&gt; </td></tr>
<tr class="memitem:a3e4684917cd63e762fb7c73a310b92fd"><td class="memTemplItemLeft" align="right" valign="top">hydra_thrust::tuple_element&lt; I, <a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a1f4d85a519c1b1070dacefe6e8aa437f">const_iterator_tuple</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a3e4684917cd63e762fb7c73a310b92fd">operator[]</a> (<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt; index) const</td></tr>
<tr class="separator:a3e4684917cd63e762fb7c73a310b92fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09f6dbd5d669e5fcc64ff9b98fe3c46c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#ad1919b26bba6bbba43c62a450363e35c">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a09f6dbd5d669e5fcc64ff9b98fe3c46c">operator[]</a> (size_t <a class="el" href="crystal__ball__plus__exponential_8inl.html#a21f77208d6bc667560ff8aaf8f943b6a">n</a>)</td></tr>
<tr class="memdesc:a09f6dbd5d669e5fcc64ff9b98fe3c46c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscript access to the data contained in this vector_dev.  <a href="#a09f6dbd5d669e5fcc64ff9b98fe3c46c">More...</a><br /></td></tr>
<tr class="separator:a09f6dbd5d669e5fcc64ff9b98fe3c46c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85b55185d038c62b51b2413dc2d82dca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a3f91f3a2c0944f43b148ecf1a33e3445">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a85b55185d038c62b51b2413dc2d82dca">operator[]</a> (size_t <a class="el" href="crystal__ball__plus__exponential_8inl.html#a21f77208d6bc667560ff8aaf8f943b6a">n</a>) const</td></tr>
<tr class="memdesc:a85b55185d038c62b51b2413dc2d82dca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscript read access to the data contained in this vector_dev.  <a href="#a85b55185d038c62b51b2413dc2d82dca">More...</a><br /></td></tr>
<tr class="separator:a85b55185d038c62b51b2413dc2d82dca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad507163f768e014ffb6c2ff7f3844de5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#ad507163f768e014ffb6c2ff7f3844de5">pop_back</a> ()</td></tr>
<tr class="memdesc:ad507163f768e014ffb6c2ff7f3844de5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method erases the last element of this <code>multivector</code>, invalidating all iterators and references to it.  <a href="#ad507163f768e014ffb6c2ff7f3844de5">More...</a><br /></td></tr>
<tr class="separator:ad507163f768e014ffb6c2ff7f3844de5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac28b1092da5806d9aaa5c2253fd3518a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#ac28b1092da5806d9aaa5c2253fd3518a">push_back</a> (<a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#acbe86be6605b41cd82d238c44afb9531">value_type</a> const &amp;value)</td></tr>
<tr class="memdesc:ac28b1092da5806d9aaa5c2253fd3518a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method appends the given element to the end of this <code>multivector</code>.  <a href="#ac28b1092da5806d9aaa5c2253fd3518a">More...</a><br /></td></tr>
<tr class="separator:ac28b1092da5806d9aaa5c2253fd3518a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fe81273dd8bb3c88b0ad9fa7e1acd63"><td class="memTemplParams" colspan="2">template&lt;typename Functor , typename Obj &gt; </td></tr>
<tr class="memitem:a7fe81273dd8bb3c88b0ad9fa7e1acd63"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a7fe81273dd8bb3c88b0ad9fa7e1acd63">push_back</a> (Functor const &amp;functor, Obj const &amp;obj)</td></tr>
<tr class="memdesc:a7fe81273dd8bb3c88b0ad9fa7e1acd63"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method appends the given element to the end of this <code>multivector</code>.  <a href="#a7fe81273dd8bb3c88b0ad9fa7e1acd63">More...</a><br /></td></tr>
<tr class="separator:a7fe81273dd8bb3c88b0ad9fa7e1acd63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7edf28e6d6ebab592397df04a7c65c74"><td class="memTemplParams" colspan="2">template&lt;typename Functor &gt; </td></tr>
<tr class="memitem:a7edf28e6d6ebab592397df04a7c65c74"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a0988496061e5840b59a01a5db64e74e2">caster_reverse_iterator</a>&lt; Functor &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a7edf28e6d6ebab592397df04a7c65c74">rbegin</a> (Functor const &amp;caster)</td></tr>
<tr class="separator:a7edf28e6d6ebab592397df04a7c65c74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35ca773245947facfbebee9c19f4d23b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a6423ffbd452a09377a43143229712f47">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a35ca773245947facfbebee9c19f4d23b">rbegin</a> ()</td></tr>
<tr class="separator:a35ca773245947facfbebee9c19f4d23b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93583436f2764d7788acd0c4e82b4a44"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#ab7f1d7e76570ebd2e3cd11837a83f84e">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a93583436f2764d7788acd0c4e82b4a44">rbegin</a> () const</td></tr>
<tr class="separator:a93583436f2764d7788acd0c4e82b4a44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf9eca46149984778c67e7ffd9896ba9"><td class="memTemplParams" colspan="2">template&lt;unsigned int I1, unsigned int I2, unsigned int ... IN&gt; </td></tr>
<tr class="memitem:adf9eca46149984778c67e7ffd9896ba9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a9ec51e41d8e29e5c8c47660b4129792c">columns_iterator</a>&lt; <a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a9f11226368dc730b94cd85e4c734f3b2">reverse_iterator_tuple</a>, I1, I2, IN... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#adf9eca46149984778c67e7ffd9896ba9">rbegin</a> (<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I1 &gt; <a class="el" href="breit__wigner__plus__polynomial_8inl.html#a8175ec4e5461dcd38d40ead25fef205c">c1</a>, <a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I2 &gt; <a class="el" href="breit__wigner__plus__polynomial_8inl.html#a024a3031e2ed14c5d1405f6e99df1158">c2</a>, <a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; IN &gt; ...cn)</td></tr>
<tr class="separator:adf9eca46149984778c67e7ffd9896ba9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff56b6213764b1a64b157992c6a7960e"><td class="memTemplParams" colspan="2">template&lt;unsigned int I&gt; </td></tr>
<tr class="memitem:aff56b6213764b1a64b157992c6a7960e"><td class="memTemplItemLeft" align="right" valign="top">hydra_thrust::tuple_element&lt; I, <a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a9f11226368dc730b94cd85e4c734f3b2">reverse_iterator_tuple</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#aff56b6213764b1a64b157992c6a7960e">rbegin</a> (<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;)</td></tr>
<tr class="separator:aff56b6213764b1a64b157992c6a7960e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29e30e23cc5418d18e9f851de47ae4fb"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:a29e30e23cc5418d18e9f851de47ae4fb"><td class="memTemplItemLeft" align="right" valign="top">hydra_thrust::tuple_element&lt; <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1index__in__tuple">detail::index_in_tuple</a>&lt; Type, tuple_type &gt;::value, <a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a9f11226368dc730b94cd85e4c734f3b2">reverse_iterator_tuple</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a29e30e23cc5418d18e9f851de47ae4fb">rbegin</a> ()</td></tr>
<tr class="separator:a29e30e23cc5418d18e9f851de47ae4fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5302606da9a9aa66096ebcecd08a61f1"><td class="memTemplParams" colspan="2">template&lt;unsigned int I1, unsigned int I2, unsigned int ... IN&gt; </td></tr>
<tr class="memitem:a5302606da9a9aa66096ebcecd08a61f1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a9ec51e41d8e29e5c8c47660b4129792c">columns_iterator</a>&lt; <a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#aae46b9560d4a66e8ff5197d083352b40">const_reverse_iterator_tuple</a>, I1, I2, IN... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a5302606da9a9aa66096ebcecd08a61f1">rbegin</a> (<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I1 &gt; <a class="el" href="breit__wigner__plus__polynomial_8inl.html#a8175ec4e5461dcd38d40ead25fef205c">c1</a>, <a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I2 &gt; <a class="el" href="breit__wigner__plus__polynomial_8inl.html#a024a3031e2ed14c5d1405f6e99df1158">c2</a>, <a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; IN &gt; ...cn) const</td></tr>
<tr class="separator:a5302606da9a9aa66096ebcecd08a61f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36295d17511c24e6afdd152f13b3f0e8"><td class="memTemplParams" colspan="2">template&lt;unsigned int I&gt; </td></tr>
<tr class="memitem:a36295d17511c24e6afdd152f13b3f0e8"><td class="memTemplItemLeft" align="right" valign="top">hydra_thrust::tuple_element&lt; I, <a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#aae46b9560d4a66e8ff5197d083352b40">const_reverse_iterator_tuple</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a36295d17511c24e6afdd152f13b3f0e8">rbegin</a> (<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;) const</td></tr>
<tr class="separator:a36295d17511c24e6afdd152f13b3f0e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dae9cf6be1cc6f2cec300e9aa64668e"><td class="memTemplParams" colspan="2">template&lt;typename Functor &gt; </td></tr>
<tr class="memitem:a1dae9cf6be1cc6f2cec300e9aa64668e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a0988496061e5840b59a01a5db64e74e2">caster_reverse_iterator</a>&lt; Functor &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a1dae9cf6be1cc6f2cec300e9aa64668e">rend</a> (Functor const &amp;caster)</td></tr>
<tr class="separator:a1dae9cf6be1cc6f2cec300e9aa64668e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c39ec2fc8d1b6fdb7029eec793bfbdc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a6423ffbd452a09377a43143229712f47">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a5c39ec2fc8d1b6fdb7029eec793bfbdc">rend</a> ()</td></tr>
<tr class="separator:a5c39ec2fc8d1b6fdb7029eec793bfbdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accb118d4017c7dea4d09a627231fb115"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#ab7f1d7e76570ebd2e3cd11837a83f84e">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#accb118d4017c7dea4d09a627231fb115">rend</a> () const</td></tr>
<tr class="separator:accb118d4017c7dea4d09a627231fb115"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a300dd00f2bdc6452a7a4392918363b07"><td class="memTemplParams" colspan="2">template&lt;unsigned int I1, unsigned int I2, unsigned int ... IN&gt; </td></tr>
<tr class="memitem:a300dd00f2bdc6452a7a4392918363b07"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a9ec51e41d8e29e5c8c47660b4129792c">columns_iterator</a>&lt; <a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a9f11226368dc730b94cd85e4c734f3b2">reverse_iterator_tuple</a>, I1, I2, IN... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a300dd00f2bdc6452a7a4392918363b07">rend</a> (<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I1 &gt; <a class="el" href="breit__wigner__plus__polynomial_8inl.html#a8175ec4e5461dcd38d40ead25fef205c">c1</a>, <a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I2 &gt; <a class="el" href="breit__wigner__plus__polynomial_8inl.html#a024a3031e2ed14c5d1405f6e99df1158">c2</a>, <a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; IN &gt; ...cn)</td></tr>
<tr class="separator:a300dd00f2bdc6452a7a4392918363b07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39652434793d17772d17022d7bd30149"><td class="memTemplParams" colspan="2">template&lt;unsigned int I&gt; </td></tr>
<tr class="memitem:a39652434793d17772d17022d7bd30149"><td class="memTemplItemLeft" align="right" valign="top">hydra_thrust::tuple_element&lt; I, <a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a9f11226368dc730b94cd85e4c734f3b2">reverse_iterator_tuple</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a39652434793d17772d17022d7bd30149">rend</a> (<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;)</td></tr>
<tr class="separator:a39652434793d17772d17022d7bd30149"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02d3f5327cf7d23adef655c84037d1d1"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:a02d3f5327cf7d23adef655c84037d1d1"><td class="memTemplItemLeft" align="right" valign="top">hydra_thrust::tuple_element&lt; <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1index__in__tuple">detail::index_in_tuple</a>&lt; Type, tuple_type &gt;::value, <a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a9f11226368dc730b94cd85e4c734f3b2">reverse_iterator_tuple</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a02d3f5327cf7d23adef655c84037d1d1">rend</a> ()</td></tr>
<tr class="separator:a02d3f5327cf7d23adef655c84037d1d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7e335266c6423a7c94a989072b13b2c"><td class="memTemplParams" colspan="2">template&lt;unsigned int I1, unsigned int I2, unsigned int ... IN&gt; </td></tr>
<tr class="memitem:aa7e335266c6423a7c94a989072b13b2c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a9ec51e41d8e29e5c8c47660b4129792c">columns_iterator</a>&lt; <a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#aae46b9560d4a66e8ff5197d083352b40">const_reverse_iterator_tuple</a>, I1, I2, IN... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#aa7e335266c6423a7c94a989072b13b2c">rend</a> (<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I1 &gt; <a class="el" href="breit__wigner__plus__polynomial_8inl.html#a8175ec4e5461dcd38d40ead25fef205c">c1</a>, <a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I2 &gt; <a class="el" href="breit__wigner__plus__polynomial_8inl.html#a024a3031e2ed14c5d1405f6e99df1158">c2</a>, <a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; IN &gt; ...cn) const</td></tr>
<tr class="separator:aa7e335266c6423a7c94a989072b13b2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a601e20f9b24a8179e550398ff635310e"><td class="memTemplParams" colspan="2">template&lt;unsigned int I&gt; </td></tr>
<tr class="memitem:a601e20f9b24a8179e550398ff635310e"><td class="memTemplItemLeft" align="right" valign="top">hydra_thrust::tuple_element&lt; I, <a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#aae46b9560d4a66e8ff5197d083352b40">const_reverse_iterator_tuple</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a601e20f9b24a8179e550398ff635310e">rend</a> (<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;) const</td></tr>
<tr class="separator:a601e20f9b24a8179e550398ff635310e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c9f90c4bafad536921212e42ef90e86"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a7c9f90c4bafad536921212e42ef90e86">reserve</a> (<a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a1b4376d1bae60e70d657ed2b02cd3943">size_type</a> <a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a53247dddff1f2a2e7435b88e22f4c25b">size</a>)</td></tr>
<tr class="memdesc:a7c9f90c4bafad536921212e42ef90e86"><td class="mdescLeft">&#160;</td><td class="mdescRight">If n is less than or equal to <a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a1017073974b6f6753a1f5126f2edfa16" title="Returns the number of elements which have been reserved in this multivector. ">capacity()</a>, this call has no effect.  <a href="#a7c9f90c4bafad536921212e42ef90e86">More...</a><br /></td></tr>
<tr class="separator:a7c9f90c4bafad536921212e42ef90e86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4588a4a5637cc32329e48ca8146b99af"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a4588a4a5637cc32329e48ca8146b99af">resize</a> (<a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a1b4376d1bae60e70d657ed2b02cd3943">size_type</a> new_size)</td></tr>
<tr class="memdesc:a4588a4a5637cc32329e48ca8146b99af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes this <code>multivector</code> to the specified number of elements.  <a href="#a4588a4a5637cc32329e48ca8146b99af">More...</a><br /></td></tr>
<tr class="separator:a4588a4a5637cc32329e48ca8146b99af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accae8cdc72df3f029595139321b29502"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#accae8cdc72df3f029595139321b29502">shrink_to_fit</a> ()</td></tr>
<tr class="memdesc:accae8cdc72df3f029595139321b29502"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method shrinks the capacity of this <code>multivector</code> to exactly fit its elements.  <a href="#accae8cdc72df3f029595139321b29502">More...</a><br /></td></tr>
<tr class="separator:accae8cdc72df3f029595139321b29502"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53247dddff1f2a2e7435b88e22f4c25b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a1b4376d1bae60e70d657ed2b02cd3943">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a53247dddff1f2a2e7435b88e22f4c25b">size</a> () const</td></tr>
<tr class="memdesc:a53247dddff1f2a2e7435b88e22f4c25b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements in this <code>multivector</code>.  <a href="#a53247dddff1f2a2e7435b88e22f4c25b">More...</a><br /></td></tr>
<tr class="separator:a53247dddff1f2a2e7435b88e22f4c25b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename ... T, hydra::detail::Backend BACKEND&gt;<br />
class hydra::multivector&lt; hydra_thrust::tuple&lt; T... &gt;, hydra::detail::BackendPolicy&lt; BACKEND &gt; &gt;</h3>

<p>This class implements storage in SoA layouts for table where all elements have the same type. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a078c8b850c68262e93f4620a3d093780"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a078c8b850c68262e93f4620a3d093780">&#9670;&nbsp;</a></span>caster_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<div class="memtemplate">
template&lt;typename Functor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra_thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::<a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a078c8b850c68262e93f4620a3d093780">caster_iterator</a> =  hydra_thrust::transform_iterator&lt; Functor, <a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#acb4a3f31c0da46090cee5305029dbbdd">iterator</a>, typename std::result_of&lt;Functor(tuple_type&amp;)&gt;::type &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0988496061e5840b59a01a5db64e74e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0988496061e5840b59a01a5db64e74e2">&#9670;&nbsp;</a></span>caster_reverse_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<div class="memtemplate">
template&lt;typename Functor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra_thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::<a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a0988496061e5840b59a01a5db64e74e2">caster_reverse_iterator</a> =  hydra_thrust::transform_iterator&lt; Functor, <a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a6423ffbd452a09377a43143229712f47">reverse_iterator</a>, typename std::result_of&lt;Functor(tuple_type&amp;)&gt;::type &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9ec51e41d8e29e5c8c47660b4129792c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ec51e41d8e29e5c8c47660b4129792c">&#9670;&nbsp;</a></span>columns_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<div class="memtemplate">
template&lt;typename Iterators , unsigned int I1, unsigned int I2, unsigned int ... IN&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra_thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::<a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a9ec51e41d8e29e5c8c47660b4129792c">columns_iterator</a> =  hydra_thrust::zip_iterator&lt; hydra_thrust::tuple&lt; typename hydra_thrust::tuple_element&lt; I1, Iterators &gt;::type, typename hydra_thrust::tuple_element&lt; I2, Iterators &gt;::type, typename hydra_thrust::tuple_element&lt; IN, Iterators &gt;::type...&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a71a6a4d1056c6a0ec9f8e08f46202b5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71a6a4d1056c6a0ec9f8e08f46202b5a">&#9670;&nbsp;</a></span>const_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef hydra_thrust::zip_iterator&lt;<a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a1f4d85a519c1b1070dacefe6e8aa437f">const_iterator_tuple</a>&gt; <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra_thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::<a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a71a6a4d1056c6a0ec9f8e08f46202b5a">const_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1f4d85a519c1b1070dacefe6e8aa437f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f4d85a519c1b1070dacefe6e8aa437f">&#9670;&nbsp;</a></span>const_iterator_tuple</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef hydra_thrust::tuple&lt; _const_iterator&lt;T&gt;... &gt; <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra_thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::<a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a1f4d85a519c1b1070dacefe6e8aa437f">const_iterator_tuple</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3f91f3a2c0944f43b148ecf1a33e3445"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f91f3a2c0944f43b148ecf1a33e3445">&#9670;&nbsp;</a></span>const_reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef hydra_thrust::iterator_traits&lt;<a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a71a6a4d1056c6a0ec9f8e08f46202b5a">const_iterator</a>&gt;::<a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#ad1919b26bba6bbba43c62a450363e35c">reference</a> <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra_thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::<a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a3f91f3a2c0944f43b148ecf1a33e3445">const_reference</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a615a0276cdc32b3c9d897c00f86f4dd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a615a0276cdc32b3c9d897c00f86f4dd1">&#9670;&nbsp;</a></span>const_reference_tuple</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef hydra_thrust::tuple&lt; _const_reference&lt;T&gt;... &gt; <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra_thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::<a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a615a0276cdc32b3c9d897c00f86f4dd1">const_reference_tuple</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab7f1d7e76570ebd2e3cd11837a83f84e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7f1d7e76570ebd2e3cd11837a83f84e">&#9670;&nbsp;</a></span>const_reverse_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef hydra_thrust::zip_iterator&lt;<a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#aae46b9560d4a66e8ff5197d083352b40">const_reverse_iterator_tuple</a>&gt; <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra_thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::<a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#ab7f1d7e76570ebd2e3cd11837a83f84e">const_reverse_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aae46b9560d4a66e8ff5197d083352b40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae46b9560d4a66e8ff5197d083352b40">&#9670;&nbsp;</a></span>const_reverse_iterator_tuple</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef hydra_thrust::tuple&lt; _const_reverse_iterator&lt;T&gt;...&gt; <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra_thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::<a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#aae46b9560d4a66e8ff5197d083352b40">const_reverse_iterator_tuple</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acb4a3f31c0da46090cee5305029dbbdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb4a3f31c0da46090cee5305029dbbdd">&#9670;&nbsp;</a></span>iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef hydra_thrust::zip_iterator&lt;<a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#afb10cbc3fe7918b8a6bf5e38d2130a11">iterator_tuple</a>&gt; <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra_thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::<a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#acb4a3f31c0da46090cee5305029dbbdd">iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad6ea902f339d35704156c26e28334558"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6ea902f339d35704156c26e28334558">&#9670;&nbsp;</a></span>iterator_category</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef hydra_thrust::iterator_traits&lt;<a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#acb4a3f31c0da46090cee5305029dbbdd">iterator</a>&gt;::<a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#ad6ea902f339d35704156c26e28334558">iterator_category</a> <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra_thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::<a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#ad6ea902f339d35704156c26e28334558">iterator_category</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afb10cbc3fe7918b8a6bf5e38d2130a11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb10cbc3fe7918b8a6bf5e38d2130a11">&#9670;&nbsp;</a></span>iterator_tuple</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef hydra_thrust::tuple&lt; _iterator&lt;T&gt;... &gt; <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra_thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::<a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#afb10cbc3fe7918b8a6bf5e38d2130a11">iterator_tuple</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ace6edbf3d4d3320bd02086edb34c9cf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace6edbf3d4d3320bd02086edb34c9cf3">&#9670;&nbsp;</a></span>pointer_tuple</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef hydra_thrust::tuple&lt; _pointer&lt;T&gt;... &gt; <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra_thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::<a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#ace6edbf3d4d3320bd02086edb34c9cf3">pointer_tuple</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad1919b26bba6bbba43c62a450363e35c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1919b26bba6bbba43c62a450363e35c">&#9670;&nbsp;</a></span>reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef hydra_thrust::iterator_traits&lt;<a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#acb4a3f31c0da46090cee5305029dbbdd">iterator</a>&gt;::<a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#ad1919b26bba6bbba43c62a450363e35c">reference</a> <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra_thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::<a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#ad1919b26bba6bbba43c62a450363e35c">reference</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acae8445209d326f65a08f5bbeec07877"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acae8445209d326f65a08f5bbeec07877">&#9670;&nbsp;</a></span>reference_tuple</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef hydra_thrust::tuple&lt; _reference&lt;T&gt;... &gt; <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra_thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::<a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#acae8445209d326f65a08f5bbeec07877">reference_tuple</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6423ffbd452a09377a43143229712f47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6423ffbd452a09377a43143229712f47">&#9670;&nbsp;</a></span>reverse_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef hydra_thrust::zip_iterator&lt;<a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a9f11226368dc730b94cd85e4c734f3b2">reverse_iterator_tuple</a>&gt; <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra_thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::<a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a6423ffbd452a09377a43143229712f47">reverse_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9f11226368dc730b94cd85e4c734f3b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f11226368dc730b94cd85e4c734f3b2">&#9670;&nbsp;</a></span>reverse_iterator_tuple</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef hydra_thrust::tuple&lt; _reverse_iterator&lt;T&gt;... &gt; <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra_thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::<a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a9f11226368dc730b94cd85e4c734f3b2">reverse_iterator_tuple</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1b4376d1bae60e70d657ed2b02cd3943"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b4376d1bae60e70d657ed2b02cd3943">&#9670;&nbsp;</a></span>size_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef size_t <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra_thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::<a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a1b4376d1bae60e70d657ed2b02cd3943">size_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2f0d95d51817756d0f5e156d89efb89d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f0d95d51817756d0f5e156d89efb89d">&#9670;&nbsp;</a></span>storage_tuple</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef hydra_thrust::tuple&lt; _vector&lt;T&gt;... &gt; <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra_thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::<a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a2f0d95d51817756d0f5e156d89efb89d">storage_tuple</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acbe86be6605b41cd82d238c44afb9531"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbe86be6605b41cd82d238c44afb9531">&#9670;&nbsp;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef hydra_thrust::iterator_traits&lt;<a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#acb4a3f31c0da46090cee5305029dbbdd">iterator</a>&gt;::<a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#acbe86be6605b41cd82d238c44afb9531">value_type</a> <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra_thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::<a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#acbe86be6605b41cd82d238c44afb9531">value_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a360a65cd6defb32398eff7a59306c712"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a360a65cd6defb32398eff7a59306c712">&#9670;&nbsp;</a></span>value_type_tuple</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef hydra_thrust::tuple&lt; _value_type&lt;T&gt;...&gt; <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra_thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::<a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a360a65cd6defb32398eff7a59306c712">value_type_tuple</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ada99de1ba7e827b4d1588c977b1f35fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada99de1ba7e827b4d1588c977b1f35fc">&#9670;&nbsp;</a></span>multivector() <span class="overload">[1/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra_thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::<a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor. </p>
<p>This constructor creates an empty <code>multivector</code>. </p>

</div>
</div>
<a id="ab951fab73a0295a2a9f0162a33197154"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab951fab73a0295a2a9f0162a33197154">&#9670;&nbsp;</a></span>multivector() <span class="overload">[2/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra_thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::<a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor initializing the <code>multivector</code> with <code>n</code> entries. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The number of elements to initially create. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a174e42d2e28905fcb647cf15bd96d74a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a174e42d2e28905fcb647cf15bd96d74a">&#9670;&nbsp;</a></span>multivector() <span class="overload">[3/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra_thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::<a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#acbe86be6605b41cd82d238c44afb9531">value_type</a> const &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor initializing the multivector with <code>n</code> copies of <code>value</code> . </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>number of elements </td></tr>
    <tr><td class="paramname">value</td><td>object to copy from (<a class="el" href="namespacehydra.html#a717fc4e6b10453164099beade13d0226" title="tuple template is an alias to the variadic version of hydra_thrust::tuple and that can be instantiate...">hydra::tuple</a> or convertible to <a class="el" href="namespacehydra.html#a717fc4e6b10453164099beade13d0226" title="tuple template is an alias to the variadic version of hydra_thrust::tuple and that can be instantiate...">hydra::tuple</a>) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afa3a2c41c7c1a8b4314ed4e3ec34230d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa3a2c41c7c1a8b4314ed4e3ec34230d">&#9670;&nbsp;</a></span>multivector() <span class="overload">[4/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<div class="memtemplate">
template&lt;typename Int , typename  = typename hydra_thrust::detail::enable_if&lt;std::is_integral&lt;Int&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra_thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::<a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#a412c01a2247e7a463fc693a43310d00e">hydra::pair</a>&lt; Int, hydra_thrust::tuple&lt; T... &gt; &gt; const &amp;&#160;</td>
          <td class="paramname"><em>pair</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor initializing the multivector with <code>n</code> copies of <code>value</code> . </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pair</td><td><a class="el" href="namespacehydra.html#a412c01a2247e7a463fc693a43310d00e" title="pair template is an alias to the hydra_thrust::pair structure. ">hydra::pair</a>&lt;size_t, <a class="el" href="namespacehydra.html#a717fc4e6b10453164099beade13d0226" title="tuple template is an alias to the variadic version of hydra_thrust::tuple and that can be instantiate...">hydra::tuple&lt;T...&gt;</a> &gt; object to copy from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a473d1a18e6ce7afd637fc66236bb75b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a473d1a18e6ce7afd637fc66236bb75b0">&#9670;&nbsp;</a></span>multivector() <span class="overload">[5/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra_thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::<a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; hydra_thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a25f403b6a73a44099396b9aaa0927ba5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25f403b6a73a44099396b9aaa0927ba5">&#9670;&nbsp;</a></span>multivector() <span class="overload">[6/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra_thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::<a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; hydra_thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6fd707b3672692f8876a00986ca74a50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fd707b3672692f8876a00986ca74a50">&#9670;&nbsp;</a></span>multivector() <span class="overload">[7/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<div class="memtemplate">
template&lt;hydra::detail::Backend BACKEND2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra_thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::<a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; hydra_thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND2 &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor for containers allocated in different backends. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3f0070e5e9c98e7cd2f1092e9cac9bcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f0070e5e9c98e7cd2f1092e9cac9bcd">&#9670;&nbsp;</a></span>multivector() <span class="overload">[8/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<div class="memtemplate">
template&lt;typename Iterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra_thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::<a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a> </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This constructor builds a <code>multivector</code> from a range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The beginning of the range. </td></tr>
    <tr><td class="paramname">last</td><td>The end of the range. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adcc3c9a74d82827294f5d129b8da1a33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcc3c9a74d82827294f5d129b8da1a33">&#9670;&nbsp;</a></span>multivector() <span class="overload">[9/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<div class="memtemplate">
template&lt;typename Iterable , typename  = typename std::enable_if&lt;	           (detail::is_iterable&lt;Iterable&gt;::value) &amp;&amp;	          !(detail::is_iterator&lt;Iterable&gt;::value) &amp;&amp;	           (std::is_convertible&lt;decltype(*std::declval&lt;Iterable&gt;().begin()), value_type&gt;::value)	          &gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra_thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::<a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a> </td>
          <td>(</td>
          <td class="paramtype">Iterable &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ac0c0cf51e6b82784ad2209a82717013a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0c0cf51e6b82784ad2209a82717013a">&#9670;&nbsp;</a></span>back() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#ad1919b26bba6bbba43c62a450363e35c">reference</a> <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra_thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method returns a reference referring to the last element of this vector_dev. </p>
<dl class="section return"><dt>Returns</dt><dd>The last element of this <code>multivector</code>. </dd></dl>

</div>
</div>
<a id="a33676a22bf835034ccf4caf2dfda70d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33676a22bf835034ccf4caf2dfda70d7">&#9670;&nbsp;</a></span>back() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a3f91f3a2c0944f43b148ecf1a33e3445">const_reference</a> <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra_thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method returns a const reference pointing to the last element of this <code>multivector</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>The last element of this <code>multivector</code>. </dd></dl>

</div>
</div>
<a id="a55c4a877dcdedbd34ec35a2715a9c5ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55c4a877dcdedbd34ec35a2715a9c5ab">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#acb4a3f31c0da46090cee5305029dbbdd">iterator</a> <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra_thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method returns an iterator pointing to the beginning of this <code>multivector</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>iterator </dd></dl>

</div>
</div>
<a id="af4831d24a646d402ef83648dbf518786"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4831d24a646d402ef83648dbf518786">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<div class="memtemplate">
template&lt;typename Functor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a078c8b850c68262e93f4620a3d093780">caster_iterator</a>&lt;Functor&gt; <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra_thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::begin </td>
          <td>(</td>
          <td class="paramtype">Functor const &amp;&#160;</td>
          <td class="paramname"><em>caster</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae73d7991ce79b8e5e709a504adf61770"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae73d7991ce79b8e5e709a504adf61770">&#9670;&nbsp;</a></span>begin() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a71a6a4d1056c6a0ec9f8e08f46202b5a">const_iterator</a> <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra_thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a404fde770b93b404c30ede4092bb044b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a404fde770b93b404c30ede4092bb044b">&#9670;&nbsp;</a></span>begin() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<div class="memtemplate">
template&lt;unsigned int I1, unsigned int I2, unsigned int ... IN&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a9ec51e41d8e29e5c8c47660b4129792c">columns_iterator</a>&lt; <a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#afb10cbc3fe7918b8a6bf5e38d2130a11">iterator_tuple</a>, I1, I2,IN...&gt; <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra_thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::begin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I1 &gt;&#160;</td>
          <td class="paramname"><em>c1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I2 &gt;&#160;</td>
          <td class="paramname"><em>c2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; IN &gt; ...&#160;</td>
          <td class="paramname"><em>cn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad4a61268ac538b43eae366768884f033"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4a61268ac538b43eae366768884f033">&#9670;&nbsp;</a></span>begin() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<div class="memtemplate">
template&lt;unsigned int I&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">hydra_thrust::tuple_element&lt;I, <a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#afb10cbc3fe7918b8a6bf5e38d2130a11">iterator_tuple</a>&gt;::type <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra_thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::begin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3408e73d9c80b523cbe3c9fbbfcdcaa5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3408e73d9c80b523cbe3c9fbbfcdcaa5">&#9670;&nbsp;</a></span>begin() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<div class="memtemplate">
template&lt;typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">hydra_thrust::tuple_element&lt; <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1index__in__tuple">detail::index_in_tuple</a>&lt;Type, tuple_type&gt;::value , <a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#afb10cbc3fe7918b8a6bf5e38d2130a11">iterator_tuple</a> &gt;::type <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra_thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="add6a3b2454998731b018ea7d837d25b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add6a3b2454998731b018ea7d837d25b5">&#9670;&nbsp;</a></span>begin() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<div class="memtemplate">
template&lt;unsigned int I1, unsigned int I2, unsigned int ... IN&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a9ec51e41d8e29e5c8c47660b4129792c">columns_iterator</a>&lt; <a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a1f4d85a519c1b1070dacefe6e8aa437f">const_iterator_tuple</a>, I1, I2,IN...&gt; <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra_thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::begin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I1 &gt;&#160;</td>
          <td class="paramname"><em>c1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I2 &gt;&#160;</td>
          <td class="paramname"><em>c2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; IN &gt; ...&#160;</td>
          <td class="paramname"><em>cn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab39fa078e2e4d9964b76c09392dac627"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab39fa078e2e4d9964b76c09392dac627">&#9670;&nbsp;</a></span>begin() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<div class="memtemplate">
template&lt;unsigned int I&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">hydra_thrust::tuple_element&lt;I, <a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a1f4d85a519c1b1070dacefe6e8aa437f">const_iterator_tuple</a>&gt;::type <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra_thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::begin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1017073974b6f6753a1f5126f2edfa16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1017073974b6f6753a1f5126f2edfa16">&#9670;&nbsp;</a></span>capacity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a1b4376d1bae60e70d657ed2b02cd3943">size_type</a> <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra_thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::capacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of elements which have been reserved in this <code>multivector</code>. </p>

</div>
</div>
<a id="a995ff9749d91510471b7d34fd971ef9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a995ff9749d91510471b7d34fd971ef9f">&#9670;&nbsp;</a></span>cbegin() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a71a6a4d1056c6a0ec9f8e08f46202b5a">const_iterator</a> <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra_thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0679d559053d6096dec77eaa2492ab20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0679d559053d6096dec77eaa2492ab20">&#9670;&nbsp;</a></span>cbegin() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<div class="memtemplate">
template&lt;unsigned int I1, unsigned int I2, unsigned int ... IN&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a9ec51e41d8e29e5c8c47660b4129792c">columns_iterator</a>&lt; <a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a1f4d85a519c1b1070dacefe6e8aa437f">const_iterator_tuple</a>, I1, I2,IN...&gt; <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra_thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::cbegin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I1 &gt;&#160;</td>
          <td class="paramname"><em>c1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I2 &gt;&#160;</td>
          <td class="paramname"><em>c2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; IN &gt; ...&#160;</td>
          <td class="paramname"><em>cn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a93c03a63046c4595a8d660208ddc7aa3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93c03a63046c4595a8d660208ddc7aa3">&#9670;&nbsp;</a></span>cbegin() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<div class="memtemplate">
template&lt;unsigned int I&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">hydra_thrust::tuple_element&lt;I, <a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a1f4d85a519c1b1070dacefe6e8aa437f">const_iterator_tuple</a>&gt;::type <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra_thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::cbegin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab91684e6e614739af2a950fc8762fa83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab91684e6e614739af2a950fc8762fa83">&#9670;&nbsp;</a></span>cend() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a71a6a4d1056c6a0ec9f8e08f46202b5a">const_iterator</a> <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra_thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::cend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a744666b5687f539f3559f93f462f44f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a744666b5687f539f3559f93f462f44f6">&#9670;&nbsp;</a></span>cend() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<div class="memtemplate">
template&lt;unsigned int I1, unsigned int I2, unsigned int ... IN&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a9ec51e41d8e29e5c8c47660b4129792c">columns_iterator</a>&lt; <a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a1f4d85a519c1b1070dacefe6e8aa437f">const_iterator_tuple</a>, I1, I2,IN...&gt; <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra_thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::cend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I1 &gt;&#160;</td>
          <td class="paramname"><em>c1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I2 &gt;&#160;</td>
          <td class="paramname"><em>c2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; IN &gt; ...&#160;</td>
          <td class="paramname"><em>cn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab183b678996c884cf6cdce9354eaa878"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab183b678996c884cf6cdce9354eaa878">&#9670;&nbsp;</a></span>cend() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<div class="memtemplate">
template&lt;unsigned int I&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">hydra_thrust::tuple_element&lt;I, <a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a1f4d85a519c1b1070dacefe6e8aa437f">const_iterator_tuple</a>&gt;::type <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra_thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::cend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1551ff4ddc34475c2493ab098cba7a91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1551ff4ddc34475c2493ab098cba7a91">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra_thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method resizes this <code>multivector</code> to 0. </p>

</div>
</div>
<a id="aab2f3363a65fd062a4d437099c72eb9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab2f3363a65fd062a4d437099c72eb9b">&#9670;&nbsp;</a></span>column() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<div class="memtemplate">
template&lt;typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">hydra_thrust::tuple_element&lt;<a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1index__in__tuple">detail::index_in_tuple</a>&lt;Type, tuple_type&gt;::value , <a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a2f0d95d51817756d0f5e156d89efb89d">storage_tuple</a>&gt;::type&amp; <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra_thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::column </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af863224788e374a43efc4454f91ab3e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af863224788e374a43efc4454f91ab3e9">&#9670;&nbsp;</a></span>column() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<div class="memtemplate">
template&lt;unsigned int I&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">hydra_thrust::tuple_element&lt;I, <a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a2f0d95d51817756d0f5e156d89efb89d">storage_tuple</a>&gt;::type&amp; <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra_thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::column </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a747b6715f5f1349737f4df9ed2c75461"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a747b6715f5f1349737f4df9ed2c75461">&#9670;&nbsp;</a></span>column() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<div class="memtemplate">
template&lt;unsigned int I1, unsigned int I2, unsigned int ... IN&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacehydra.html#classhydra_1_1Range">hydra::Range</a>&lt;<a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a9ec51e41d8e29e5c8c47660b4129792c">columns_iterator</a>&lt; <a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#afb10cbc3fe7918b8a6bf5e38d2130a11">iterator_tuple</a>, I1, I2,IN...&gt; &gt; <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra_thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::column </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I1 &gt;&#160;</td>
          <td class="paramname"><em>c1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I2 &gt;&#160;</td>
          <td class="paramname"><em>c2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; IN &gt; ...&#160;</td>
          <td class="paramname"><em>cn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a77a0c0a82d6b42e616d892af2d9a9e7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77a0c0a82d6b42e616d892af2d9a9e7b">&#9670;&nbsp;</a></span>column() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<div class="memtemplate">
template&lt;unsigned int I&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const hydra_thrust::tuple_element&lt;I, <a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a2f0d95d51817756d0f5e156d89efb89d">storage_tuple</a>&gt;::type&amp; <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra_thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::column </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1828c9c7ba1435e9a2e801edcdb3b778"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1828c9c7ba1435e9a2e801edcdb3b778">&#9670;&nbsp;</a></span>column() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<div class="memtemplate">
template&lt;unsigned int I1, unsigned int I2, unsigned int ... IN&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacehydra.html#classhydra_1_1Range">hydra::Range</a>&lt;<a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a9ec51e41d8e29e5c8c47660b4129792c">columns_iterator</a>&lt; <a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a1f4d85a519c1b1070dacefe6e8aa437f">const_iterator_tuple</a>, I1, I2,IN...&gt; &gt; <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra_thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::column </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I1 &gt;&#160;</td>
          <td class="paramname"><em>c1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I2 &gt;&#160;</td>
          <td class="paramname"><em>c2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; IN &gt; ...&#160;</td>
          <td class="paramname"><em>cn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="acb82527a728d1a762632a10a6fe9f809"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb82527a728d1a762632a10a6fe9f809">&#9670;&nbsp;</a></span>crbegin() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#ab7f1d7e76570ebd2e3cd11837a83f84e">const_reverse_iterator</a> <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra_thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::crbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af40b45a085f6ac290fbc431002eca16d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af40b45a085f6ac290fbc431002eca16d">&#9670;&nbsp;</a></span>crbegin() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<div class="memtemplate">
template&lt;unsigned int I1, unsigned int I2, unsigned int ... IN&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a9ec51e41d8e29e5c8c47660b4129792c">columns_iterator</a>&lt; <a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#aae46b9560d4a66e8ff5197d083352b40">const_reverse_iterator_tuple</a>, I1, I2,IN...&gt; <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra_thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::crbegin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I1 &gt;&#160;</td>
          <td class="paramname"><em>c1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I2 &gt;&#160;</td>
          <td class="paramname"><em>c2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; IN &gt; ...&#160;</td>
          <td class="paramname"><em>cn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a46544d906edb258cb38d0854e4dd8eaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46544d906edb258cb38d0854e4dd8eaa">&#9670;&nbsp;</a></span>crbegin() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<div class="memtemplate">
template&lt;unsigned int I&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">hydra_thrust::tuple_element&lt;I, <a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#aae46b9560d4a66e8ff5197d083352b40">const_reverse_iterator_tuple</a>&gt;::type <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra_thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::crbegin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afd605b49101f47f6d967132d467e7e76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd605b49101f47f6d967132d467e7e76">&#9670;&nbsp;</a></span>crend() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#ab7f1d7e76570ebd2e3cd11837a83f84e">const_reverse_iterator</a> <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra_thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::crend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0420b8fc24ca4d9bb7df862ea183f910"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0420b8fc24ca4d9bb7df862ea183f910">&#9670;&nbsp;</a></span>crend() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<div class="memtemplate">
template&lt;unsigned int I1, unsigned int I2, unsigned int ... IN&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a9ec51e41d8e29e5c8c47660b4129792c">columns_iterator</a>&lt; <a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#aae46b9560d4a66e8ff5197d083352b40">const_reverse_iterator_tuple</a>, I1, I2,IN...&gt; <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra_thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::crend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I1 &gt;&#160;</td>
          <td class="paramname"><em>c1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I2 &gt;&#160;</td>
          <td class="paramname"><em>c2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; IN &gt; ...&#160;</td>
          <td class="paramname"><em>cn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aae869686999dbf21de21c83168f1ba14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae869686999dbf21de21c83168f1ba14">&#9670;&nbsp;</a></span>crend() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<div class="memtemplate">
template&lt;unsigned int I&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">hydra_thrust::tuple_element&lt;I, <a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#aae46b9560d4a66e8ff5197d083352b40">const_reverse_iterator_tuple</a>&gt;::type <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra_thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::crend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab27484f2f9f68faa27d5602dd819e3d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab27484f2f9f68faa27d5602dd819e3d8">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra_thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method returns true iff <a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a53247dddff1f2a2e7435b88e22f4c25b" title="Returns the number of elements in this multivector. ">size()</a> == 0. </p>
<dl class="section return"><dt>Returns</dt><dd>true if <a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a53247dddff1f2a2e7435b88e22f4c25b" title="Returns the number of elements in this multivector. ">size()</a> == 0; false, otherwise. </dd></dl>

</div>
</div>
<a id="aa05ff39f52149a6517392257df870278"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa05ff39f52149a6517392257df870278">&#9670;&nbsp;</a></span>end() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#acb4a3f31c0da46090cee5305029dbbdd">iterator</a> <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra_thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method returns a const_iterator pointing to one element past the last of this <code>multivector</code>. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a55c4a877dcdedbd34ec35a2715a9c5ab" title="This method returns an iterator pointing to the beginning of this multivector. ">begin()</a> + <a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a53247dddff1f2a2e7435b88e22f4c25b" title="Returns the number of elements in this multivector. ">size()</a>. </dd></dl>

</div>
</div>
<a id="ad35d82b4b5c34215dcbb0395c95c06e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad35d82b4b5c34215dcbb0395c95c06e3">&#9670;&nbsp;</a></span>end() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<div class="memtemplate">
template&lt;typename Functor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a078c8b850c68262e93f4620a3d093780">caster_iterator</a>&lt;Functor&gt; <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra_thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::end </td>
          <td>(</td>
          <td class="paramtype">Functor const &amp;&#160;</td>
          <td class="paramname"><em>caster</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1eb49c27e29c137bc0517d824209fb6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1eb49c27e29c137bc0517d824209fb6a">&#9670;&nbsp;</a></span>end() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a71a6a4d1056c6a0ec9f8e08f46202b5a">const_iterator</a> <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra_thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a56e7b095173a1d145981d770a8b4c134"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56e7b095173a1d145981d770a8b4c134">&#9670;&nbsp;</a></span>end() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<div class="memtemplate">
template&lt;unsigned int I1, unsigned int I2, unsigned int ... IN&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a9ec51e41d8e29e5c8c47660b4129792c">columns_iterator</a>&lt; <a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#afb10cbc3fe7918b8a6bf5e38d2130a11">iterator_tuple</a>, I1, I2,IN...&gt; <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra_thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I1 &gt;&#160;</td>
          <td class="paramname"><em>c1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I2 &gt;&#160;</td>
          <td class="paramname"><em>c2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; IN &gt; ...&#160;</td>
          <td class="paramname"><em>cn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2319a03127b89a84c9a258bca762cc72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2319a03127b89a84c9a258bca762cc72">&#9670;&nbsp;</a></span>end() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<div class="memtemplate">
template&lt;unsigned int I&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">hydra_thrust::tuple_element&lt;I, <a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#afb10cbc3fe7918b8a6bf5e38d2130a11">iterator_tuple</a>&gt;::type <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra_thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a39c46ef4a4a9b172cf88e1d968dcf882"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39c46ef4a4a9b172cf88e1d968dcf882">&#9670;&nbsp;</a></span>end() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<div class="memtemplate">
template&lt;typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">hydra_thrust::tuple_element&lt; <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1index__in__tuple">detail::index_in_tuple</a>&lt;Type, tuple_type&gt;::value , <a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#afb10cbc3fe7918b8a6bf5e38d2130a11">iterator_tuple</a> &gt;::type <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra_thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ade0d769bc8e6a5ffc1faaf55cff518f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade0d769bc8e6a5ffc1faaf55cff518f2">&#9670;&nbsp;</a></span>end() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<div class="memtemplate">
template&lt;unsigned int I1, unsigned int I2, unsigned int ... IN&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a9ec51e41d8e29e5c8c47660b4129792c">columns_iterator</a>&lt; <a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a1f4d85a519c1b1070dacefe6e8aa437f">const_iterator_tuple</a>, I1, I2,IN...&gt; <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra_thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I1 &gt;&#160;</td>
          <td class="paramname"><em>c1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I2 &gt;&#160;</td>
          <td class="paramname"><em>c2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; IN &gt; ...&#160;</td>
          <td class="paramname"><em>cn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa1933cccc198035386416d4d154edb7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1933cccc198035386416d4d154edb7f">&#9670;&nbsp;</a></span>end() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<div class="memtemplate">
template&lt;unsigned int I&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">hydra_thrust::tuple_element&lt;I, <a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a1f4d85a519c1b1070dacefe6e8aa437f">const_iterator_tuple</a>&gt;::type <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra_thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aca7980e5d4aefb1904439da575e4014b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca7980e5d4aefb1904439da575e4014b">&#9670;&nbsp;</a></span>erase() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#acb4a3f31c0da46090cee5305029dbbdd">iterator</a> <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra_thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#acb4a3f31c0da46090cee5305029dbbdd">iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method removes the element at position pos. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The position of the element of interest. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator pointing to the new location of the element that followed the element at position pos. </dd></dl>

</div>
</div>
<a id="a99a1b96abef00395b4d6addb1aed4577"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99a1b96abef00395b4d6addb1aed4577">&#9670;&nbsp;</a></span>erase() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#acb4a3f31c0da46090cee5305029dbbdd">iterator</a> <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra_thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#acb4a3f31c0da46090cee5305029dbbdd">iterator</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#acb4a3f31c0da46090cee5305029dbbdd">iterator</a>&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method removes the range of elements [first,last) from this <code>multivector</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The beginning of the range of elements to remove. </td></tr>
    <tr><td class="paramname">last</td><td>The end of the range of elements to remove. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator pointing to the new location of the element that followed the last element in the sequence [first,last). </dd></dl>

</div>
</div>
<a id="a783fe47977740366fed001ce519c906a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a783fe47977740366fed001ce519c906a">&#9670;&nbsp;</a></span>front() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#ad1919b26bba6bbba43c62a450363e35c">reference</a> <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra_thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method returns a const_reference referring to the first element of this <code>multivector</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>The first element of this <code>multivector</code>. </dd></dl>

</div>
</div>
<a id="a1a926b7063631254f19f36bed0474913"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a926b7063631254f19f36bed0474913">&#9670;&nbsp;</a></span>front() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a3f91f3a2c0944f43b148ecf1a33e3445">const_reference</a> <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra_thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method returns a reference pointing to the first element of this <code>multivector</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>The first element of this <code>multivector</code>. </dd></dl>

</div>
</div>
<a id="a8c345f12f7f58b379830cb9635325e71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c345f12f7f58b379830cb9635325e71">&#9670;&nbsp;</a></span>insert() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#acb4a3f31c0da46090cee5305029dbbdd">iterator</a> <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra_thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#acb4a3f31c0da46090cee5305029dbbdd">iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#acbe86be6605b41cd82d238c44afb9531">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method inserts a single copy of a given exemplar value at the specified position in this <code>multivector</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>The insertion position. </td></tr>
    <tr><td class="paramname">x</td><td>The exemplar element to copy &amp; insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator pointing to the newly inserted element. </dd></dl>

</div>
</div>
<a id="aa485cabe13ab716769592a54c42f96cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa485cabe13ab716769592a54c42f96cf">&#9670;&nbsp;</a></span>insert() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra_thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#acb4a3f31c0da46090cee5305029dbbdd">iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a1b4376d1bae60e70d657ed2b02cd3943">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#acbe86be6605b41cd82d238c44afb9531">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method inserts a copy of an exemplar value to a range at the specified position in this <code>multivector</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>The insertion position </td></tr>
    <tr><td class="paramname">n</td><td>The number of insertions to perform. </td></tr>
    <tr><td class="paramname">x</td><td>The value to replicate and insert. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afde85df98fe9062b364ffa43f6b857b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afde85df98fe9062b364ffa43f6b857b2">&#9670;&nbsp;</a></span>insert() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<div class="memtemplate">
template&lt;typename InputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">hydra_thrust::detail::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__zip__iterator.html">detail::is_zip_iterator</a>&lt;InputIterator&gt;::value &amp;&amp; std::is_convertible&lt;typename hydra_thrust::iterator_traits&lt;InputIterator&gt;::<a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#acbe86be6605b41cd82d238c44afb9531">value_type</a>, <a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#acbe86be6605b41cd82d238c44afb9531">value_type</a>&gt;::value, void&gt;::type <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra_thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#acb4a3f31c0da46090cee5305029dbbdd">iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method inserts a copy of an input range at the specified position in this <code>multivector</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>The insertion position. </td></tr>
    <tr><td class="paramname">first</td><td>The beginning of the range to copy. </td></tr>
    <tr><td class="paramname">last</td><td>The end of the range to copy.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">InputIterator</td><td>is a model of &lt;a href="http://www.sgi.com/tech/stl/InputIterator.html&gt;Input Iterator&lt;/a&gt;,
                      and \p InputIterator's \c value_type is a model of &lt;a href="<a href="http://www.sgi.com/tech/stl/Assignable.html">http://www.sgi.com/tech/stl/Assignable.html</a>"&gt;Assignable. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8a0b79e9a500bfe7469deede51586dbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a0b79e9a500bfe7469deede51586dbd">&#9670;&nbsp;</a></span>meld()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<div class="memtemplate">
template&lt;typename ... Iterables&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra_thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::meld </td>
          <td>(</td>
          <td class="paramtype">Iterables &amp;&amp;...&#160;</td>
          <td class="paramname"><em>iterables</em></td><td>)</td>
          <td> -&gt; typename std::enable_if&lt;<a class="el" href="structhydra_1_1detail_1_1all__true.html">detail::all_true</a>&lt;<a class="el" href="structhydra_1_1detail_1_1is__iterable.html">detail::is_iterable</a>&lt;Iterables&gt;::value...&gt;::value,
	<a class="el" href="namespacehydra.html#classhydra_1_1Range">hydra::Range</a>&lt;decltype(<a class="el" href="namespacehydra_1_1detail.html#ac36de892880609f667e4d5cc9718a5e1">detail::meld_iterators</a>(<a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a55c4a877dcdedbd34ec35a2715a9c5ab">begin</a>(), std::forward&lt;Iterables&gt;(iterables).<a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a55c4a877dcdedbd34ec35a2715a9c5ab">begin</a>()... ))&gt;&gt;::type
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a47cb83cabed52f7215e6d715a2a62515"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47cb83cabed52f7215e6d715a2a62515">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt;hydra_thrust::tuple&lt;T...&gt;,<a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt;BACKEND&gt; &gt;&amp; <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra_thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; hydra_thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assignment operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="ad249df7641011b6873cd0279f00bd6be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad249df7641011b6873cd0279f00bd6be">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt;hydra_thrust::tuple&lt;T...&gt;,<a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt;BACKEND&gt; &gt;&amp; <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra_thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; hydra_thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt; &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move-assignment operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a32d1bd50c3927a7e20c8aa0222d57386"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32d1bd50c3927a7e20c8aa0222d57386">&#9670;&nbsp;</a></span>operator=() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<div class="memtemplate">
template&lt;hydra::detail::Backend BACKEND2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt;hydra_thrust::tuple&lt;T...&gt;,<a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt;BACKEND&gt; &gt;&amp; <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra_thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; hydra_thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND2 &gt; &gt; const &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assignment operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a98058ec881b21d5cd75c64338c591637"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98058ec881b21d5cd75c64338c591637">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<div class="memtemplate">
template&lt;typename Functor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a078c8b850c68262e93f4620a3d093780">caster_iterator</a>&lt;Functor&gt; <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra_thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">Functor const &amp;&#160;</td>
          <td class="paramname"><em>caster</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afc95babea4a3241cc7a9764db47bc307"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc95babea4a3241cc7a9764db47bc307">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<div class="memtemplate">
template&lt;unsigned int I&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">hydra_thrust::tuple_element&lt;I, <a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#afb10cbc3fe7918b8a6bf5e38d2130a11">iterator_tuple</a>&gt;::type <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra_thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3e4684917cd63e762fb7c73a310b92fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e4684917cd63e762fb7c73a310b92fd">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<div class="memtemplate">
template&lt;unsigned int I&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">hydra_thrust::tuple_element&lt;I, <a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a1f4d85a519c1b1070dacefe6e8aa437f">const_iterator_tuple</a>&gt;::type <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra_thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a09f6dbd5d669e5fcc64ff9b98fe3c46c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09f6dbd5d669e5fcc64ff9b98fe3c46c">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#ad1919b26bba6bbba43c62a450363e35c">reference</a> <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra_thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscript access to the data contained in this vector_dev. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The index of the element for which data should be accessed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Read/write reference to data.</dd></dl>
<p>This operator allows for easy, array-style, data access. Note that data access with this operator is unchecked and out_of_range lookups are not defined. </p>

</div>
</div>
<a id="a85b55185d038c62b51b2413dc2d82dca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85b55185d038c62b51b2413dc2d82dca">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a3f91f3a2c0944f43b148ecf1a33e3445">const_reference</a> <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra_thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscript read access to the data contained in this vector_dev. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The index of the element for which data should be accessed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Read reference to data.</dd></dl>
<p>This operator allows for easy, array-style, data access. Note that data access with this operator is unchecked and out_of_range lookups are not defined. </p>

</div>
</div>
<a id="ad507163f768e014ffb6c2ff7f3844de5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad507163f768e014ffb6c2ff7f3844de5">&#9670;&nbsp;</a></span>pop_back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra_thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::pop_back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method erases the last element of this <code>multivector</code>, invalidating all iterators and references to it. </p>

</div>
</div>
<a id="ac28b1092da5806d9aaa5c2253fd3518a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac28b1092da5806d9aaa5c2253fd3518a">&#9670;&nbsp;</a></span>push_back() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra_thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#acbe86be6605b41cd82d238c44afb9531">value_type</a> const &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method appends the given element to the end of this <code>multivector</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The element to append. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7fe81273dd8bb3c88b0ad9fa7e1acd63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fe81273dd8bb3c88b0ad9fa7e1acd63">&#9670;&nbsp;</a></span>push_back() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<div class="memtemplate">
template&lt;typename Functor , typename Obj &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra_thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">Functor const &amp;&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Obj const &amp;&#160;</td>
          <td class="paramname"><em>obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method appends the given element to the end of this <code>multivector</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The element to append. </td></tr>
    <tr><td class="paramname">functor</td><td>Functor to convert the element to a value_type tuple </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7edf28e6d6ebab592397df04a7c65c74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7edf28e6d6ebab592397df04a7c65c74">&#9670;&nbsp;</a></span>rbegin() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<div class="memtemplate">
template&lt;typename Functor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a0988496061e5840b59a01a5db64e74e2">caster_reverse_iterator</a>&lt;Functor&gt; <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra_thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::rbegin </td>
          <td>(</td>
          <td class="paramtype">Functor const &amp;&#160;</td>
          <td class="paramname"><em>caster</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a35ca773245947facfbebee9c19f4d23b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35ca773245947facfbebee9c19f4d23b">&#9670;&nbsp;</a></span>rbegin() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a6423ffbd452a09377a43143229712f47">reverse_iterator</a> <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra_thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a93583436f2764d7788acd0c4e82b4a44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93583436f2764d7788acd0c4e82b4a44">&#9670;&nbsp;</a></span>rbegin() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#ab7f1d7e76570ebd2e3cd11837a83f84e">const_reverse_iterator</a> <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra_thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="adf9eca46149984778c67e7ffd9896ba9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf9eca46149984778c67e7ffd9896ba9">&#9670;&nbsp;</a></span>rbegin() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<div class="memtemplate">
template&lt;unsigned int I1, unsigned int I2, unsigned int ... IN&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a9ec51e41d8e29e5c8c47660b4129792c">columns_iterator</a>&lt; <a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a9f11226368dc730b94cd85e4c734f3b2">reverse_iterator_tuple</a>, I1, I2,IN...&gt; <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra_thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::rbegin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I1 &gt;&#160;</td>
          <td class="paramname"><em>c1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I2 &gt;&#160;</td>
          <td class="paramname"><em>c2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; IN &gt; ...&#160;</td>
          <td class="paramname"><em>cn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aff56b6213764b1a64b157992c6a7960e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff56b6213764b1a64b157992c6a7960e">&#9670;&nbsp;</a></span>rbegin() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<div class="memtemplate">
template&lt;unsigned int I&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">hydra_thrust::tuple_element&lt;I, <a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a9f11226368dc730b94cd85e4c734f3b2">reverse_iterator_tuple</a>&gt;::type <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra_thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::rbegin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a29e30e23cc5418d18e9f851de47ae4fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29e30e23cc5418d18e9f851de47ae4fb">&#9670;&nbsp;</a></span>rbegin() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<div class="memtemplate">
template&lt;typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">hydra_thrust::tuple_element&lt; <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1index__in__tuple">detail::index_in_tuple</a>&lt;Type, tuple_type&gt;::value , <a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a9f11226368dc730b94cd85e4c734f3b2">reverse_iterator_tuple</a>&gt;::type <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra_thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5302606da9a9aa66096ebcecd08a61f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5302606da9a9aa66096ebcecd08a61f1">&#9670;&nbsp;</a></span>rbegin() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<div class="memtemplate">
template&lt;unsigned int I1, unsigned int I2, unsigned int ... IN&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a9ec51e41d8e29e5c8c47660b4129792c">columns_iterator</a>&lt; <a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#aae46b9560d4a66e8ff5197d083352b40">const_reverse_iterator_tuple</a>, I1, I2,IN...&gt; <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra_thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::rbegin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I1 &gt;&#160;</td>
          <td class="paramname"><em>c1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I2 &gt;&#160;</td>
          <td class="paramname"><em>c2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; IN &gt; ...&#160;</td>
          <td class="paramname"><em>cn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a36295d17511c24e6afdd152f13b3f0e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36295d17511c24e6afdd152f13b3f0e8">&#9670;&nbsp;</a></span>rbegin() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<div class="memtemplate">
template&lt;unsigned int I&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">hydra_thrust::tuple_element&lt;I, <a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#aae46b9560d4a66e8ff5197d083352b40">const_reverse_iterator_tuple</a>&gt;::type <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra_thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::rbegin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1dae9cf6be1cc6f2cec300e9aa64668e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dae9cf6be1cc6f2cec300e9aa64668e">&#9670;&nbsp;</a></span>rend() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<div class="memtemplate">
template&lt;typename Functor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a0988496061e5840b59a01a5db64e74e2">caster_reverse_iterator</a>&lt;Functor&gt; <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra_thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::rend </td>
          <td>(</td>
          <td class="paramtype">Functor const &amp;&#160;</td>
          <td class="paramname"><em>caster</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5c39ec2fc8d1b6fdb7029eec793bfbdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c39ec2fc8d1b6fdb7029eec793bfbdc">&#9670;&nbsp;</a></span>rend() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a6423ffbd452a09377a43143229712f47">reverse_iterator</a> <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra_thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="accb118d4017c7dea4d09a627231fb115"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accb118d4017c7dea4d09a627231fb115">&#9670;&nbsp;</a></span>rend() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#ab7f1d7e76570ebd2e3cd11837a83f84e">const_reverse_iterator</a> <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra_thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a300dd00f2bdc6452a7a4392918363b07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a300dd00f2bdc6452a7a4392918363b07">&#9670;&nbsp;</a></span>rend() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<div class="memtemplate">
template&lt;unsigned int I1, unsigned int I2, unsigned int ... IN&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a9ec51e41d8e29e5c8c47660b4129792c">columns_iterator</a>&lt; <a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a9f11226368dc730b94cd85e4c734f3b2">reverse_iterator_tuple</a>, I1, I2,IN...&gt; <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra_thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::rend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I1 &gt;&#160;</td>
          <td class="paramname"><em>c1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I2 &gt;&#160;</td>
          <td class="paramname"><em>c2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; IN &gt; ...&#160;</td>
          <td class="paramname"><em>cn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a39652434793d17772d17022d7bd30149"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39652434793d17772d17022d7bd30149">&#9670;&nbsp;</a></span>rend() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<div class="memtemplate">
template&lt;unsigned int I&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">hydra_thrust::tuple_element&lt;I, <a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a9f11226368dc730b94cd85e4c734f3b2">reverse_iterator_tuple</a>&gt;::type <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra_thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::rend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a02d3f5327cf7d23adef655c84037d1d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02d3f5327cf7d23adef655c84037d1d1">&#9670;&nbsp;</a></span>rend() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<div class="memtemplate">
template&lt;typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">hydra_thrust::tuple_element&lt; <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1index__in__tuple">detail::index_in_tuple</a>&lt;Type, tuple_type&gt;::value , <a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a9f11226368dc730b94cd85e4c734f3b2">reverse_iterator_tuple</a> &gt;::type <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra_thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa7e335266c6423a7c94a989072b13b2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7e335266c6423a7c94a989072b13b2c">&#9670;&nbsp;</a></span>rend() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<div class="memtemplate">
template&lt;unsigned int I1, unsigned int I2, unsigned int ... IN&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a9ec51e41d8e29e5c8c47660b4129792c">columns_iterator</a>&lt; <a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#aae46b9560d4a66e8ff5197d083352b40">const_reverse_iterator_tuple</a>, I1, I2,IN...&gt; <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra_thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::rend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I1 &gt;&#160;</td>
          <td class="paramname"><em>c1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I2 &gt;&#160;</td>
          <td class="paramname"><em>c2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; IN &gt; ...&#160;</td>
          <td class="paramname"><em>cn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a601e20f9b24a8179e550398ff635310e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a601e20f9b24a8179e550398ff635310e">&#9670;&nbsp;</a></span>rend() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<div class="memtemplate">
template&lt;unsigned int I&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">hydra_thrust::tuple_element&lt;I, <a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#aae46b9560d4a66e8ff5197d083352b40">const_reverse_iterator_tuple</a>&gt;::type <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra_thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::rend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7c9f90c4bafad536921212e42ef90e86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c9f90c4bafad536921212e42ef90e86">&#9670;&nbsp;</a></span>reserve()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra_thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::reserve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a1b4376d1bae60e70d657ed2b02cd3943">size_type</a>&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If n is less than or equal to <a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a1017073974b6f6753a1f5126f2edfa16" title="Returns the number of elements which have been reserved in this multivector. ">capacity()</a>, this call has no effect. </p>
<p>Otherwise, this method is a request for allocation of additional memory. If the request is successful, then <a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a1017073974b6f6753a1f5126f2edfa16" title="Returns the number of elements which have been reserved in this multivector. ">capacity()</a> is greater than or equal to n; otherwise, <a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a1017073974b6f6753a1f5126f2edfa16" title="Returns the number of elements which have been reserved in this multivector. ">capacity()</a> is unchanged. In either case, <a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a53247dddff1f2a2e7435b88e22f4c25b" title="Returns the number of elements in this multivector. ">size()</a> is unchanged. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::length_error</td><td>If n exceeds max_size(). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4588a4a5637cc32329e48ca8146b99af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4588a4a5637cc32329e48ca8146b99af">&#9670;&nbsp;</a></span>resize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra_thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::resize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a1b4376d1bae60e70d657ed2b02cd3943">size_type</a>&#160;</td>
          <td class="paramname"><em>new_size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resizes this <code>multivector</code> to the specified number of elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_size</td><td>Number of elements this <code>multivector</code> should contain. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::length_error</td><td>If n exceeds max_size().</td></tr>
  </table>
  </dd>
</dl>
<p>This method will resize this <code>multivector</code> to the specified number of elements. If the number is smaller than this <code>multivector's</code> current size this <code>multivector</code> is truncated, otherwise this <code>multivector</code> is extended and new default initialized elements are populated. </p>

</div>
</div>
<a id="accae8cdc72df3f029595139321b29502"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accae8cdc72df3f029595139321b29502">&#9670;&nbsp;</a></span>shrink_to_fit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra_thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::shrink_to_fit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method shrinks the capacity of this <code>multivector</code> to exactly fit its elements. </p>

</div>
</div>
<a id="a53247dddff1f2a2e7435b88e22f4c25b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53247dddff1f2a2e7435b88e22f4c25b">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#a1b4376d1bae60e70d657ed2b02cd3943">size_type</a> <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra_thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of elements in this <code>multivector</code>. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="">multivector.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacehydra.html">hydra</a></li><li class="navelem"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html">multivector&lt; hydra_thrust::tuple&lt; T... &gt;, hydra::detail::BackendPolicy&lt; BACKEND &gt; &gt;</a></li>
    <li class="footer">Generated on Sun Jun 28 2020 00:00:02 for Hydra by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.14 </li>
  </ul>
</div>
</body>
</html>
