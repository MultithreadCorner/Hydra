<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Hydra: hydra Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo_Hydra2.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Hydra
   &#160;<span id="projectnumber">4.0.1</span>
   </div>
   <div id="projectbrief">A header-only templated C++ framework to perform data analysis on massively parallel platforms.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('namespacehydra.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">hydra Namespace Reference<div class="ingroups"><a class="el" href="group__policy.html">Policy</a> &#124; <a class="el" href="group__common__functions.html">Common functors</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Generic policies definition.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacehydra_1_1arguments"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1arguments.html">arguments</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacehydra_1_1cpp"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1cpp.html">cpp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacehydra_1_1cuda"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1cuda.html">cuda</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacehydra_1_1detail"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html">detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacehydra_1_1device"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1device.html">device</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacehydra_1_1experimental"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1experimental.html">experimental</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacehydra_1_1fft"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1fft.html">fft</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacehydra_1_1host"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1host.html">host</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacehydra_1_1math__constants"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1math__constants.html">math_constants</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacehydra_1_1omp"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1omp.html">omp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacehydra_1_1placeholders"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1placeholders.html">placeholders</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacehydra_1_1random"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1random.html">random</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacehydra_1_1tbb"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1tbb.html">tbb</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1AnalyticalIntegral.html">AnalyticalIntegral</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1AnalyticalIntegral_3_01Functor_00_011_01_4.html">AnalyticalIntegral&lt; Functor, 1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1Argument.html">Argument</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1ArgusShape"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common__functions.html#classhydra_1_1ArgusShape">ArgusShape</a></td></tr>
<tr class="memdesc:classhydra_1_1ArgusShape"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation describing the ARGUS background shape.  <a href="group__common__functions.html#classhydra_1_1ArgusShape">More...</a><br /></td></tr>
<tr class="separator:classhydra_1_1ArgusShape"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1BaseCompositeFunctor"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#classhydra_1_1BaseCompositeFunctor">BaseCompositeFunctor</a></td></tr>
<tr class="separator:classhydra_1_1BaseCompositeFunctor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1BaseCompositeFunctor_3_01Composite_00_01hydra_1_1thrust_1_1tuple_3_01F1_00_01F2_00fb82ec25e61e3369688e5c89e18d74c0.html">BaseCompositeFunctor&lt; Composite, hydra::thrust::tuple&lt; F1, F2, Fs... &gt;, Signature &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1BaseCuFFT.html">BaseCuFFT</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1BaseFFTW.html">BaseFFTW</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1BaseFunctor"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__functor.html#classhydra_1_1BaseFunctor">BaseFunctor</a></td></tr>
<tr class="memdesc:classhydra_1_1BaseFunctor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all functors in hydra.  <a href="group__functor.html#classhydra_1_1BaseFunctor">More...</a><br /></td></tr>
<tr class="separator:classhydra_1_1BaseFunctor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1BifurcatedGaussian"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common__functions.html#classhydra_1_1BifurcatedGaussian">BifurcatedGaussian</a></td></tr>
<tr class="separator:classhydra_1_1BifurcatedGaussian"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1BreitWignerLineShape"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common__functions.html#classhydra_1_1BreitWignerLineShape">BreitWignerLineShape</a></td></tr>
<tr class="memdesc:classhydra_1_1BreitWignerLineShape"><td class="mdescLeft">&#160;</td><td class="mdescRight">Breit-Wigner line shape for 3 body resonant decays \( A -&gt; r c , r-&gt; a b\) , where A is a "long-lived" particle and \( a, b\) and \(c\) are the final states.  <a href="group__common__functions.html#classhydra_1_1BreitWignerLineShape">More...</a><br /></td></tr>
<tr class="separator:classhydra_1_1BreitWignerLineShape"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1BreitWignerNR.html">BreitWignerNR</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1Chebychev"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common__functions.html#classhydra_1_1Chebychev">Chebychev</a></td></tr>
<tr class="memdesc:classhydra_1_1Chebychev"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Chebyshev polynomials \( T_n \) (first kind) are polynomials with the largest possible leading coefficient, but subject to the condition that their absolute value on the interval [−1,1] is bounded by 1.  <a href="group__common__functions.html#classhydra_1_1Chebychev">More...</a><br /></td></tr>
<tr class="separator:classhydra_1_1Chebychev"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1ChiSquare"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common__functions.html#classhydra_1_1ChiSquare">ChiSquare</a></td></tr>
<tr class="memdesc:classhydra_1_1ChiSquare"><td class="mdescLeft">&#160;</td><td class="mdescRight">The chi-squared distribution (also chi-square or \( \chi^2 \) -distribution) with \( k \) degrees of freedom is the distribution of a sum of the squares of k independent standard normal random variables.  <a href="group__common__functions.html#classhydra_1_1ChiSquare">More...</a><br /></td></tr>
<tr class="separator:classhydra_1_1ChiSquare"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1ComplexToComplexCuFFT.html">ComplexToComplexCuFFT</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1ComplexToComplexFFTW.html">ComplexToComplexFFTW</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1ComplexToRealCuFFT.html">ComplexToRealCuFFT</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1ComplexToRealFFTW.html">ComplexToRealFFTW</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1Compose.html">Compose</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1Constant.html">Constant</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1ConvolutionFunctor"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#classhydra_1_1ConvolutionFunctor">ConvolutionFunctor</a></td></tr>
<tr class="separator:classhydra_1_1ConvolutionFunctor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1ConvolutionFunctor_3_01Functor_00_01Kernel_00_01detail_1_1BackendPolicy_3_01BACKENb3b342af36a60e84be1085f455499e1d.html">ConvolutionFunctor&lt; Functor, Kernel, detail::BackendPolicy&lt; BACKEND &gt;, detail::FFTPolicy&lt; typename std::common_type&lt; typename Functor::return_type, typename Kernel::return_type &gt;::type, FFT &gt;, ArgType &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1CosHelicityAngle.html">CosHelicityAngle</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1CrystalBallShape.html">CrystalBallShape</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation the Crystal Ball line shape.  <a href="classhydra_1_1CrystalBallShape.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1CubicSpiline.html">CubicSpiline</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><br />
<br />
 A simple method for a one—dimensional interpolation on a given set of data points (xi, yi).  <a href="classhydra_1_1CubicSpiline.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1Decays"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__phsp.html#classhydra_1_1Decays">Decays</a></td></tr>
<tr class="separator:classhydra_1_1Decays"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1Decays_3_01hydra_1_1tuple_3_01Particles_8_8_8_01_4_00_01hydra_1_1detail_1_1BackendPolicy_3_01Backend_01_4_01_4"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__phsp.html#classhydra_1_1Decays_3_01hydra_1_1tuple_3_01Particles_8_8_8_01_4_00_01hydra_1_1detail_1_1BackendPolicy_3_01Backend_01_4_01_4">Decays&lt; hydra::tuple&lt; Particles... &gt;, hydra::detail::BackendPolicy&lt; Backend &gt; &gt;</a></td></tr>
<tr class="memdesc:classhydra_1_1Decays_3_01hydra_1_1tuple_3_01Particles_8_8_8_01_4_00_01hydra_1_1detail_1_1BackendPolicy_3_01Backend_01_4_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides storage for N-particle states.  <a href="group__phsp.html#classhydra_1_1Decays_3_01hydra_1_1tuple_3_01Particles_8_8_8_01_4_00_01hydra_1_1detail_1_1BackendPolicy_3_01Backend_01_4_01_4">More...</a><br /></td></tr>
<tr class="separator:classhydra_1_1Decays_3_01hydra_1_1tuple_3_01Particles_8_8_8_01_4_00_01hydra_1_1detail_1_1BackendPolicy_3_01Backend_01_4_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1DeltaDMassBackground"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common__functions.html#classhydra_1_1DeltaDMassBackground">DeltaDMassBackground</a></td></tr>
<tr class="separator:classhydra_1_1DeltaDMassBackground"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1DenseHistogram"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__histogram.html#classhydra_1_1DenseHistogram">DenseHistogram</a></td></tr>
<tr class="separator:classhydra_1_1DenseHistogram"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1DenseHistogram_3_01T_00_011_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_47e77d3fa69b0393593bb979d3c5f9775"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__histogram.html#classhydra_1_1DenseHistogram_3_01T_00_011_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_47e77d3fa69b0393593bb979d3c5f9775">DenseHistogram&lt; T, 1, hydra::detail::BackendPolicy&lt; BACKEND &gt;, detail::unidimensional &gt;</a></td></tr>
<tr class="memdesc:classhydra_1_1DenseHistogram_3_01T_00_011_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_47e77d3fa69b0393593bb979d3c5f9775"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing one-dimensional dense histogram.  <a href="group__histogram.html#classhydra_1_1DenseHistogram_3_01T_00_011_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_47e77d3fa69b0393593bb979d3c5f9775">More...</a><br /></td></tr>
<tr class="separator:classhydra_1_1DenseHistogram_3_01T_00_011_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_47e77d3fa69b0393593bb979d3c5f9775"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1DenseHistogram_3_01T_00_01N_00_01detail_1_1BackendPolicy_3_01BACKEND_01_4_00_01detail_1_1multidimensional_01_4"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__histogram.html#classhydra_1_1DenseHistogram_3_01T_00_01N_00_01detail_1_1BackendPolicy_3_01BACKEND_01_4_00_01detail_1_1multidimensional_01_4">DenseHistogram&lt; T, N, detail::BackendPolicy&lt; BACKEND &gt;, detail::multidimensional &gt;</a></td></tr>
<tr class="memdesc:classhydra_1_1DenseHistogram_3_01T_00_01N_00_01detail_1_1BackendPolicy_3_01BACKEND_01_4_00_01detail_1_1multidimensional_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing multidimensional dense histograms.  <a href="group__histogram.html#classhydra_1_1DenseHistogram_3_01T_00_01N_00_01detail_1_1BackendPolicy_3_01BACKEND_01_4_00_01detail_1_1multidimensional_01_4">More...</a><br /></td></tr>
<tr class="separator:classhydra_1_1DenseHistogram_3_01T_00_01N_00_01detail_1_1BackendPolicy_3_01BACKEND_01_4_00_01detail_1_1multidimensional_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1Distribution"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#classhydra_1_1Distribution">Distribution</a></td></tr>
<tr class="separator:classhydra_1_1Distribution"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1Distribution_3_01Class_00_01false_01_4"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#structhydra_1_1Distribution_3_01Class_00_01false_01_4">Distribution&lt; Class, false &gt;</a></td></tr>
<tr class="separator:structhydra_1_1Distribution_3_01Class_00_01false_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1Distribution_3_01Functor_00_01true_01_4.html">Distribution&lt; Functor, true &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1Divide.html">Divide</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1DoubleExponential"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common__functions.html#classhydra_1_1DoubleExponential">DoubleExponential</a></td></tr>
<tr class="memdesc:classhydra_1_1DoubleExponential"><td class="mdescLeft">&#160;</td><td class="mdescRight">distribution <a href="https://en.wikipedia.org/wiki/Laplace_distribution">https://en.wikipedia.org/wiki/Laplace_distribution</a>  <a href="group__common__functions.html#classhydra_1_1DoubleExponential">More...</a><br /></td></tr>
<tr class="separator:classhydra_1_1DoubleExponential"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1Exponential"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common__functions.html#classhydra_1_1Exponential">Exponential</a></td></tr>
<tr class="memdesc:classhydra_1_1Exponential"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a href="https://en.wikipedia.org/wiki/Exponential_function">https://en.wikipedia.org/wiki/Exponential_function</a>  <a href="group__common__functions.html#classhydra_1_1Exponential">More...</a><br /></td></tr>
<tr class="separator:classhydra_1_1Exponential"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1FCN"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fit.html#classhydra_1_1FCN">FCN</a></td></tr>
<tr class="memdesc:classhydra_1_1FCN"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="group__fit.html#classhydra_1_1FCN" title="FCN base class. ">FCN</a> base class.  <a href="group__fit.html#classhydra_1_1FCN">More...</a><br /></td></tr>
<tr class="separator:classhydra_1_1FCN"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1FCN_3_01Estimator_3_01PDF_00_01Iterator_01_4_00_01true_01_4"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fit.html#classhydra_1_1FCN_3_01Estimator_3_01PDF_00_01Iterator_01_4_00_01true_01_4">FCN&lt; Estimator&lt; PDF, Iterator &gt;, true &gt;</a></td></tr>
<tr class="separator:classhydra_1_1FCN_3_01Estimator_3_01PDF_00_01Iterator_01_4_00_01true_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1FCN_3_01Estimator_3_01PDF_00_01Iterator_00_01Iterators_8_8_8_01_4_00_01true_01_4"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fit.html#classhydra_1_1FCN_3_01Estimator_3_01PDF_00_01Iterator_00_01Iterators_8_8_8_01_4_00_01true_01_4">FCN&lt; Estimator&lt; PDF, Iterator, Iterators... &gt;, true &gt;</a></td></tr>
<tr class="separator:classhydra_1_1FCN_3_01Estimator_3_01PDF_00_01Iterator_00_01Iterators_8_8_8_01_4_00_01true_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1FCN_3_01hydra_1_1thrust_1_1tuple_3_01FCN_3_01ESTIMATORS_01_4_8_8_8_01_4_00_01false_01_4"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fit.html#classhydra_1_1FCN_3_01hydra_1_1thrust_1_1tuple_3_01FCN_3_01ESTIMATORS_01_4_8_8_8_01_4_00_01false_01_4">FCN&lt; hydra::thrust::tuple&lt; FCN&lt; ESTIMATORS &gt;... &gt;, false &gt;</a></td></tr>
<tr class="separator:classhydra_1_1FCN_3_01hydra_1_1thrust_1_1tuple_3_01FCN_3_01ESTIMATORS_01_4_8_8_8_01_4_00_01false_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1Gaussian"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common__functions.html#classhydra_1_1Gaussian">Gaussian</a></td></tr>
<tr class="memdesc:classhydra_1_1Gaussian"><td class="mdescLeft">&#160;</td><td class="mdescRight"><br />
<br />
 <a class="el" href="group__common__functions.html#classhydra_1_1Gaussian" title="   Gaussian functions are often used to represent the probability density function of a normally dist...">Gaussian</a> functions are often used to represent the probability density function of a normally distributed random variable with expected value \( \mu \) and variance \( \sigma \).  <a href="group__common__functions.html#classhydra_1_1Gaussian">More...</a><br /></td></tr>
<tr class="separator:classhydra_1_1Gaussian"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1GaussianKDE"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common__functions.html#classhydra_1_1GaussianKDE">GaussianKDE</a></td></tr>
<tr class="separator:classhydra_1_1GaussianKDE"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1GaussKronrodAdaptiveQuadrature"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#classhydra_1_1GaussKronrodAdaptiveQuadrature">GaussKronrodAdaptiveQuadrature</a></td></tr>
<tr class="separator:classhydra_1_1GaussKronrodAdaptiveQuadrature"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1GaussKronrodAdaptiveQuadrature_3_01NRULE_00_01NBIN_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_4_01_4.html">GaussKronrodAdaptiveQuadrature&lt; NRULE, NBIN, hydra::detail::BackendPolicy&lt; BACKEND &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1GaussKronrodBinary.html">GaussKronrodBinary</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1GaussKronrodCall.html">GaussKronrodCall</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1GaussKronrodQuadrature"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#classhydra_1_1GaussKronrodQuadrature">GaussKronrodQuadrature</a></td></tr>
<tr class="separator:classhydra_1_1GaussKronrodQuadrature"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1GaussKronrodQuadrature_3_01NRULE_00_01NBIN_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_4_01_4.html">GaussKronrodQuadrature&lt; NRULE, NBIN, hydra::detail::BackendPolicy&lt; BACKEND &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1GaussKronrodRule"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__numerical__integration.html#structhydra_1_1GaussKronrodRule">GaussKronrodRule</a></td></tr>
<tr class="memdesc:structhydra_1_1GaussKronrodRule"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rules for Gauss-Kronrod quadrature.  <a href="group__numerical__integration.html#structhydra_1_1GaussKronrodRule">More...</a><br /></td></tr>
<tr class="separator:structhydra_1_1GaussKronrodRule"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1GaussKronrodRuleSelector"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#structhydra_1_1GaussKronrodRuleSelector">GaussKronrodRuleSelector</a></td></tr>
<tr class="separator:structhydra_1_1GaussKronrodRuleSelector"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1GaussKronrodRuleSelector_3_0115_01_4"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__numerical__integration.html#structhydra_1_1GaussKronrodRuleSelector_3_0115_01_4">GaussKronrodRuleSelector&lt; 15 &gt;</a></td></tr>
<tr class="memdesc:structhydra_1_1GaussKronrodRuleSelector_3_0115_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rules for Gauss-Kronrod quadrature.  <a href="group__numerical__integration.html#structhydra_1_1GaussKronrodRuleSelector_3_0115_01_4">More...</a><br /></td></tr>
<tr class="separator:structhydra_1_1GaussKronrodRuleSelector_3_0115_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1GaussKronrodRuleSelector_3_0121_01_4"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__numerical__integration.html#structhydra_1_1GaussKronrodRuleSelector_3_0121_01_4">GaussKronrodRuleSelector&lt; 21 &gt;</a></td></tr>
<tr class="memdesc:structhydra_1_1GaussKronrodRuleSelector_3_0121_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rules for Gauss-Kronrod quadrature.  <a href="group__numerical__integration.html#structhydra_1_1GaussKronrodRuleSelector_3_0121_01_4">More...</a><br /></td></tr>
<tr class="separator:structhydra_1_1GaussKronrodRuleSelector_3_0121_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1GaussKronrodRuleSelector_3_0131_01_4"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__numerical__integration.html#structhydra_1_1GaussKronrodRuleSelector_3_0131_01_4">GaussKronrodRuleSelector&lt; 31 &gt;</a></td></tr>
<tr class="memdesc:structhydra_1_1GaussKronrodRuleSelector_3_0131_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rules for Gauss-Kronrod quadrature.  <a href="group__numerical__integration.html#structhydra_1_1GaussKronrodRuleSelector_3_0131_01_4">More...</a><br /></td></tr>
<tr class="separator:structhydra_1_1GaussKronrodRuleSelector_3_0131_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1GaussKronrodRuleSelector_3_0141_01_4"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__numerical__integration.html#structhydra_1_1GaussKronrodRuleSelector_3_0141_01_4">GaussKronrodRuleSelector&lt; 41 &gt;</a></td></tr>
<tr class="memdesc:structhydra_1_1GaussKronrodRuleSelector_3_0141_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rules for Gauss-Kronrod quadrature.  <a href="group__numerical__integration.html#structhydra_1_1GaussKronrodRuleSelector_3_0141_01_4">More...</a><br /></td></tr>
<tr class="separator:structhydra_1_1GaussKronrodRuleSelector_3_0141_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1GaussKronrodRuleSelector_3_0151_01_4"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__numerical__integration.html#structhydra_1_1GaussKronrodRuleSelector_3_0151_01_4">GaussKronrodRuleSelector&lt; 51 &gt;</a></td></tr>
<tr class="memdesc:structhydra_1_1GaussKronrodRuleSelector_3_0151_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rules for Gauss-Kronrod quadrature.  <a href="group__numerical__integration.html#structhydra_1_1GaussKronrodRuleSelector_3_0151_01_4">More...</a><br /></td></tr>
<tr class="separator:structhydra_1_1GaussKronrodRuleSelector_3_0151_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1GaussKronrodRuleSelector_3_0161_01_4"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__numerical__integration.html#structhydra_1_1GaussKronrodRuleSelector_3_0161_01_4">GaussKronrodRuleSelector&lt; 61 &gt;</a></td></tr>
<tr class="memdesc:structhydra_1_1GaussKronrodRuleSelector_3_0161_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rules for Gauss-Kronrod quadrature.  <a href="group__numerical__integration.html#structhydra_1_1GaussKronrodRuleSelector_3_0161_01_4">More...</a><br /></td></tr>
<tr class="separator:structhydra_1_1GaussKronrodRuleSelector_3_0161_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1GaussKronrodUnary.html">GaussKronrodUnary</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1GenzMalikQuadrature"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#classhydra_1_1GenzMalikQuadrature">GenzMalikQuadrature</a></td></tr>
<tr class="separator:classhydra_1_1GenzMalikQuadrature"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1GenzMalikQuadrature_3_01N_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_4_01_4"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__numerical__integration.html#classhydra_1_1GenzMalikQuadrature_3_01N_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_4_01_4">GenzMalikQuadrature&lt; N, hydra::detail::BackendPolicy&lt; BACKEND &gt; &gt;</a></td></tr>
<tr class="memdesc:classhydra_1_1GenzMalikQuadrature_3_01N_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_4_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-adaptive Genz-Malik multidimensional quadrature.  <a href="group__numerical__integration.html#classhydra_1_1GenzMalikQuadrature_3_01N_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_4_01_4">More...</a><br /></td></tr>
<tr class="separator:classhydra_1_1GenzMalikQuadrature_3_01N_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_4_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1GenzMalikRule"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#classhydra_1_1GenzMalikRule">GenzMalikRule</a></td></tr>
<tr class="separator:classhydra_1_1GenzMalikRule"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1GenzMalikRule_3_01DIM_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_4_01_4"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__numerical__integration.html#classhydra_1_1GenzMalikRule_3_01DIM_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_4_01_4">GenzMalikRule&lt; DIM, hydra::detail::BackendPolicy&lt; BACKEND &gt; &gt;</a></td></tr>
<tr class="memdesc:classhydra_1_1GenzMalikRule_3_01DIM_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_4_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing Genz-Malik rule.  <a href="group__numerical__integration.html#classhydra_1_1GenzMalikRule_3_01DIM_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_4_01_4">More...</a><br /></td></tr>
<tr class="separator:classhydra_1_1GenzMalikRule_3_01DIM_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_4_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1GenzMalikRuleBase.html">GenzMalikRuleBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1Integral.html">Integral</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1Integral_3_01Algorithm_00_011_01_4.html">Integral&lt; Algorithm, 1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1IntegrationFormula.html">IntegrationFormula</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1IntegrationFormula_3_01ArgusShape_3_01ArgType_01_4_00_011_01_4.html">IntegrationFormula&lt; ArgusShape&lt; ArgType &gt;, 1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1IntegrationFormula_3_01BifurcatedGaussian_3_01ArgType_01_4_00_011_01_4.html">IntegrationFormula&lt; BifurcatedGaussian&lt; ArgType &gt;, 1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1IntegrationFormula_3_01BreitWignerNR_3_01ArgType_01_4_00_011_01_4.html">IntegrationFormula&lt; BreitWignerNR&lt; ArgType &gt;, 1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1IntegrationFormula_3_01Chebychev_3_01Order_00_01ArgType_01_4_00_011_01_4.html">IntegrationFormula&lt; Chebychev&lt; Order, ArgType &gt;, 1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1IntegrationFormula_3_01ChiSquare_3_01ArgType_01_4_00_011_01_4"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common__functions.html#classhydra_1_1IntegrationFormula_3_01ChiSquare_3_01ArgType_01_4_00_011_01_4">IntegrationFormula&lt; ChiSquare&lt; ArgType &gt;, 1 &gt;</a></td></tr>
<tr class="separator:classhydra_1_1IntegrationFormula_3_01ChiSquare_3_01ArgType_01_4_00_011_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1IntegrationFormula_3_01CrystalBallShape_3_01ArgType_01_4_00_011_01_4.html">IntegrationFormula&lt; CrystalBallShape&lt; ArgType &gt;, 1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1IntegrationFormula_3_01DeltaDMassBackground_3_01ArgType_01_4_00_011_01_4.html">IntegrationFormula&lt; DeltaDMassBackground&lt; ArgType &gt;, 1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1IntegrationFormula_3_01DoubleExponential_3_01ArgType_01_4_00_012_01_4.html">IntegrationFormula&lt; DoubleExponential&lt; ArgType &gt;, 2 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1IntegrationFormula_3_01Exponential_3_01ArgType_01_4_00_011_01_4.html">IntegrationFormula&lt; Exponential&lt; ArgType &gt;, 1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1IntegrationFormula_3_01Gaussian_3_01ArgType_01_4_00_011_01_4.html">IntegrationFormula&lt; Gaussian&lt; ArgType &gt;, 1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1IntegrationFormula_3_01Ipatia_3_01ArgType_01_4_00_011_01_4.html">IntegrationFormula&lt; Ipatia&lt; ArgType &gt;, 1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1IntegrationFormula_3_01JohnsonSU_3_01ArgType_01_4_00_011_01_4.html">IntegrationFormula&lt; JohnsonSU&lt; ArgType &gt;, 1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1IntegrationFormula_3_01LogNormal_3_01ArgType_01_4_00_011_01_4.html">IntegrationFormula&lt; LogNormal&lt; ArgType &gt;, 1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1IntegrationFormula_3_01Polynomial_3_01Order_00_01ArgType_01_4_00_011_01_4.html">IntegrationFormula&lt; Polynomial&lt; Order, ArgType &gt;, 1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1IntegrationFormula_3_01TrapezoidalShape_3_01ArgType_01_4_00_011_01_4.html">IntegrationFormula&lt; TrapezoidalShape&lt; ArgType &gt;, 1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1IntegrationFormula_3_01TriangularShape_3_01ArgType_01_4_00_011_01_4.html">IntegrationFormula&lt; TriangularShape&lt; ArgType &gt;, 1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1IntegrationFormula_3_01UniformShape_3_01ArgType_01_4_00_011_01_4.html">IntegrationFormula&lt; UniformShape&lt; ArgType &gt;, 1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1Ipatia"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common__functions.html#classhydra_1_1Ipatia">Ipatia</a></td></tr>
<tr class="memdesc:classhydra_1_1Ipatia"><td class="mdescLeft">&#160;</td><td class="mdescRight">version of the <a class="el" href="group__common__functions.html#classhydra_1_1Ipatia" title="version of the Ipatia distribution as described in the reference https://doi.org/10.1016/j.nima.2014.06.081. ">Ipatia</a> distribution as described in the reference <a href="https://doi.org/10.1016/j.nima.2014.06.081">https://doi.org/10.1016/j.nima.2014.06.081</a>.  <a href="group__common__functions.html#classhydra_1_1Ipatia">More...</a><br /></td></tr>
<tr class="separator:classhydra_1_1Ipatia"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1JohnsonSU.html">JohnsonSU</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1Lambda.html">Lambda</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1Lambda_3_01LambdaType_00_010_01_4.html">Lambda&lt; LambdaType, 0 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1LogLikelihoodFCN"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#classhydra_1_1LogLikelihoodFCN">LogLikelihoodFCN</a></td></tr>
<tr class="separator:classhydra_1_1LogLikelihoodFCN"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1LogLikelihoodFCN_3_01Pdf_3_01Functor_00_01Integrator_01_4_00_01IteratorD_00_01IteratorW_8_8_8_01_4.html">LogLikelihoodFCN&lt; Pdf&lt; Functor, Integrator &gt;, IteratorD, IteratorW... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1LogLikelihoodFCN_3_01PDFSumExtendable_3_01Pdfs_8_8_8_01_4_00_01IteratorD_00_01IteratorW_8_8_8_01_4.html">LogLikelihoodFCN&lt; PDFSumExtendable&lt; Pdfs... &gt;, IteratorD, IteratorW... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1LogLikelihoodFCN_3_01PDFSumNonExtendable_3_01Pdfs_8_8_8_01_4_00_01IteratorD_00_01IteratorW_8_8_8_01_4.html">LogLikelihoodFCN&lt; PDFSumNonExtendable&lt; Pdfs... &gt;, IteratorD, IteratorW... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1LogNormal"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common__functions.html#classhydra_1_1LogNormal">LogNormal</a></td></tr>
<tr class="memdesc:classhydra_1_1LogNormal"><td class="mdescLeft">&#160;</td><td class="mdescRight">In probability theory, a log-normal (or lognormal) distribution is a continuous probability distribution of a random variable whose logarithm is normally distributed.  <a href="group__common__functions.html#classhydra_1_1LogNormal">More...</a><br /></td></tr>
<tr class="separator:classhydra_1_1LogNormal"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1M12PhaseSpaceLineShape"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common__functions.html#classhydra_1_1M12PhaseSpaceLineShape">M12PhaseSpaceLineShape</a></td></tr>
<tr class="memdesc:classhydra_1_1M12PhaseSpaceLineShape"><td class="mdescLeft">&#160;</td><td class="mdescRight">Two-body phase-space distribution for \( m_{12}\): </p><p class="formulaDsp">
\[ \frac{dN}{dm_{m_12}} \propto q.p \]
</p>
<p>.  <a href="group__common__functions.html#classhydra_1_1M12PhaseSpaceLineShape">More...</a><br /></td></tr>
<tr class="separator:classhydra_1_1M12PhaseSpaceLineShape"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1M12SqPhaseSpaceLineShape"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common__functions.html#classhydra_1_1M12SqPhaseSpaceLineShape">M12SqPhaseSpaceLineShape</a></td></tr>
<tr class="memdesc:classhydra_1_1M12SqPhaseSpaceLineShape"><td class="mdescLeft">&#160;</td><td class="mdescRight">Two-body phase-space distribution for \( m_{12}^2\): </p><p class="formulaDsp">
\[ \frac{dN}{dm^2_{12}} \propto q.p/m^2_{12} \]
</p>
<p>.  <a href="group__common__functions.html#classhydra_1_1M12SqPhaseSpaceLineShape">More...</a><br /></td></tr>
<tr class="separator:classhydra_1_1M12SqPhaseSpaceLineShape"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1Minus.html">Minus</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1multiarray"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#classhydra_1_1multiarray">multiarray</a></td></tr>
<tr class="separator:classhydra_1_1multiarray"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multiarray_3_01T_00_01N_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_4_01_4.html">multiarray&lt; T, N, hydra::detail::BackendPolicy&lt; BACKEND &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1Multiply.html">Multiply</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1multivector"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a></td></tr>
<tr class="separator:classhydra_1_1multivector"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html">multivector&lt; hydra::thrust::tuple&lt; T... &gt;, hydra::detail::BackendPolicy&lt; BACKEND &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements storage in SoA layouts for table where all elements have the same type.  <a href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1null__type"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#structhydra_1_1null__type">null_type</a></td></tr>
<tr class="separator:structhydra_1_1null__type"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1NumericalIntegral.html">NumericalIntegral</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1Parameter"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a></td></tr>
<tr class="memdesc:structhydra_1_1Parameter"><td class="mdescLeft">&#160;</td><td class="mdescRight"><br />
,  <a href="group__fit.html#structhydra_1_1Parameter">More...</a><br /></td></tr>
<tr class="separator:structhydra_1_1Parameter"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1Pdf"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fit.html#classhydra_1_1Pdf">Pdf</a></td></tr>
<tr class="memdesc:classhydra_1_1Pdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing probability density functions.  <a href="group__fit.html#classhydra_1_1Pdf">More...</a><br /></td></tr>
<tr class="separator:classhydra_1_1Pdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1PDFSumExtendable"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fit.html#classhydra_1_1PDFSumExtendable">PDFSumExtendable</a></td></tr>
<tr class="memdesc:classhydra_1_1PDFSumExtendable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing a pdf object built summing up other pdfs.  <a href="group__fit.html#classhydra_1_1PDFSumExtendable">More...</a><br /></td></tr>
<tr class="separator:classhydra_1_1PDFSumExtendable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1PDFSumNonExtendable"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fit.html#classhydra_1_1PDFSumNonExtendable">PDFSumNonExtendable</a></td></tr>
<tr class="memdesc:classhydra_1_1PDFSumNonExtendable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing a pdf object built summing a pdf adding other pdfs.  <a href="group__fit.html#classhydra_1_1PDFSumNonExtendable">More...</a><br /></td></tr>
<tr class="separator:classhydra_1_1PDFSumNonExtendable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1PhaseSpace"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__phsp.html#classhydra_1_1PhaseSpace">PhaseSpace</a></td></tr>
<tr class="memdesc:classhydra_1_1PhaseSpace"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements phase-space Monte Carlo generation in hydra.  <a href="group__phsp.html#classhydra_1_1PhaseSpace">More...</a><br /></td></tr>
<tr class="separator:classhydra_1_1PhaseSpace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1PhaseSpaceIntegrator"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__phsp.html#classhydra_1_1PhaseSpaceIntegrator">PhaseSpaceIntegrator</a></td></tr>
<tr class="separator:classhydra_1_1PhaseSpaceIntegrator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1PhaseSpaceIntegrator_3_01N_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_4_00_01GRND_01_4"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__phsp.html#classhydra_1_1PhaseSpaceIntegrator_3_01N_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_4_00_01GRND_01_4">PhaseSpaceIntegrator&lt; N, hydra::detail::BackendPolicy&lt; BACKEND &gt;, GRND &gt;</a></td></tr>
<tr class="separator:classhydra_1_1PhaseSpaceIntegrator_3_01N_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_4_00_01GRND_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1PhaseSpaceReweight.html">PhaseSpaceReweight</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1PhaseSpaceWeight.html">PhaseSpaceWeight</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1Plain"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#structhydra_1_1Plain">Plain</a></td></tr>
<tr class="separator:structhydra_1_1Plain"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1Plain_3_01N_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_4_00_01GRND_01_4"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__numerical__integration.html#classhydra_1_1Plain_3_01N_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_4_00_01GRND_01_4">Plain&lt; N, hydra::detail::BackendPolicy&lt; BACKEND &gt;, GRND &gt;</a></td></tr>
<tr class="memdesc:classhydra_1_1Plain_3_01N_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_4_00_01GRND_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements the <a class="el" href="namespacehydra.html#structhydra_1_1Plain">Plain</a> MC numerical integration algorithm in Hydra.  <a href="group__numerical__integration.html#classhydra_1_1Plain_3_01N_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_4_00_01GRND_01_4">More...</a><br /></td></tr>
<tr class="separator:classhydra_1_1Plain_3_01N_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_4_00_01GRND_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1PlainState"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__numerical__integration.html#structhydra_1_1PlainState">PlainState</a></td></tr>
<tr class="memdesc:structhydra_1_1PlainState"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple structure to hold the results of the <a class="el" href="namespacehydra.html#structhydra_1_1Plain">Plain</a> MC numerical integration.  <a href="group__numerical__integration.html#structhydra_1_1PlainState">More...</a><br /></td></tr>
<tr class="separator:structhydra_1_1PlainState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1PlanesDeltaAngle"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common__functions.html#classhydra_1_1PlanesDeltaAngle">PlanesDeltaAngle</a></td></tr>
<tr class="memdesc:classhydra_1_1PlanesDeltaAngle"><td class="mdescLeft">&#160;</td><td class="mdescRight">This functor calculates the delta angle between decay plane of the particle with four-vector d2 and d3 (same plane) and h1 (other plane)  <a href="group__common__functions.html#classhydra_1_1PlanesDeltaAngle">More...</a><br /></td></tr>
<tr class="separator:classhydra_1_1PlanesDeltaAngle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1Polynomial"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common__functions.html#classhydra_1_1Polynomial">Polynomial</a></td></tr>
<tr class="memdesc:classhydra_1_1Polynomial"><td class="mdescLeft">&#160;</td><td class="mdescRight"><br />
<br />
 From : <a href="https://en.wikipedia.org/wiki/Polynomial">https://en.wikipedia.org/wiki/Polynomial</a>  <a href="group__common__functions.html#classhydra_1_1Polynomial">More...</a><br /></td></tr>
<tr class="separator:classhydra_1_1Polynomial"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1Print.html">Print</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1ProcessGaussKronrodAdaptiveQuadrature.html">ProcessGaussKronrodAdaptiveQuadrature</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1Range"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a></td></tr>
<tr class="separator:classhydra_1_1Range"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1Range_3_01Iterator_01_4.html">Range&lt; Iterator &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1Range_3_01Iterator_00_01Functor_01_4.html">Range&lt; Iterator, Functor &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1RealToComplexCuFFT.html">RealToComplexCuFFT</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1RealToComplexFFTW.html">RealToComplexFFTW</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1RngBase.html">RngBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1RngFormula.html">RngFormula</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1RngFormula_3_01BifurcatedGaussian_3_01ArgType_01_4_01_4.html">RngFormula&lt; BifurcatedGaussian&lt; ArgType &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1RngFormula_3_01BreitWignerNR_3_01ArgType_01_4_01_4.html">RngFormula&lt; BreitWignerNR&lt; ArgType &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1RngFormula_3_01ChiSquare_3_01ArgType_01_4_01_4"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common__functions.html#structhydra_1_1RngFormula_3_01ChiSquare_3_01ArgType_01_4_01_4">RngFormula&lt; ChiSquare&lt; ArgType &gt; &gt;</a></td></tr>
<tr class="separator:structhydra_1_1RngFormula_3_01ChiSquare_3_01ArgType_01_4_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1RngFormula_3_01Exponential_3_01ArgType_01_4_01_4.html">RngFormula&lt; Exponential&lt; ArgType &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1RngFormula_3_01Gaussian_3_01ArgType_01_4_01_4.html">RngFormula&lt; Gaussian&lt; ArgType &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1RngFormula_3_01JohnsonSU_3_01ArgType_01_4_01_4.html">RngFormula&lt; JohnsonSU&lt; ArgType &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1RngFormula_3_01LogNormal_3_01ArgType_01_4_01_4.html">RngFormula&lt; LogNormal&lt; ArgType &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1RngFormula_3_01TrapezoidalShape_3_01ArgType_01_4_01_4.html">RngFormula&lt; TrapezoidalShape&lt; ArgType &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1RngFormula_3_01TriangularShape_3_01ArgType_01_4_01_4.html">RngFormula&lt; TriangularShape&lt; ArgType &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1RngFormula_3_01UniformShape_3_01ArgType_01_4_01_4.html">RngFormula&lt; UniformShape&lt; ArgType &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1ScopedBuffer"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#classhydra_1_1ScopedBuffer">ScopedBuffer</a></td></tr>
<tr class="separator:classhydra_1_1ScopedBuffer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1ScopedBuffer_3_01T_00_01detail_1_1BackendPolicy_3_01BACKEND_01_4_01_4.html">ScopedBuffer&lt; T, detail::BackendPolicy&lt; BACKEND &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1SeedRNG.html">SeedRNG</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1sobol__engine.html">sobol_engine</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instantiations of class template sobol. The <a class="el" href="classhydra_1_1sobol__engine.html" title="Instantiations of class template sobol. The sobol_engine uses the algorithm described in  [Bratley+Fo...">sobol_engine</a> uses the algorithm described in  [Bratley+Fox, TOMS 14, 88 (1988)] and [Antonov+Saleev, USSR Comput. Maths. Math. Phys. 19, 252 (1980)] .  <a href="classhydra_1_1sobol__engine.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1SparseHistogram"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__histogram.html#classhydra_1_1SparseHistogram">SparseHistogram</a></td></tr>
<tr class="separator:classhydra_1_1SparseHistogram"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1SparseHistogram_3_01T_00_011_00_01detail_1_1BackendPolicy_3_01BACKEND_01_4_00_01detail_1_1unidimensional_01_4"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__histogram.html#classhydra_1_1SparseHistogram_3_01T_00_011_00_01detail_1_1BackendPolicy_3_01BACKEND_01_4_00_01detail_1_1unidimensional_01_4">SparseHistogram&lt; T, 1, detail::BackendPolicy&lt; BACKEND &gt;, detail::unidimensional &gt;</a></td></tr>
<tr class="memdesc:classhydra_1_1SparseHistogram_3_01T_00_011_00_01detail_1_1BackendPolicy_3_01BACKEND_01_4_00_01detail_1_1unidimensional_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing one-dimensional sparse histogram.  <a href="group__histogram.html#classhydra_1_1SparseHistogram_3_01T_00_011_00_01detail_1_1BackendPolicy_3_01BACKEND_01_4_00_01detail_1_1unidimensional_01_4">More...</a><br /></td></tr>
<tr class="separator:classhydra_1_1SparseHistogram_3_01T_00_011_00_01detail_1_1BackendPolicy_3_01BACKEND_01_4_00_01detail_1_1unidimensional_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1SparseHistogram_3_01T_00_01N_00_01detail_1_1BackendPolicy_3_01BACKEND_01_4_00_01detail_1_1multidimensional_01_4"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__histogram.html#classhydra_1_1SparseHistogram_3_01T_00_01N_00_01detail_1_1BackendPolicy_3_01BACKEND_01_4_00_01detail_1_1multidimensional_01_4">SparseHistogram&lt; T, N, detail::BackendPolicy&lt; BACKEND &gt;, detail::multidimensional &gt;</a></td></tr>
<tr class="memdesc:classhydra_1_1SparseHistogram_3_01T_00_01N_00_01detail_1_1BackendPolicy_3_01BACKEND_01_4_00_01detail_1_1multidimensional_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing multidimensional sparse histogram.  <a href="group__histogram.html#classhydra_1_1SparseHistogram_3_01T_00_01N_00_01detail_1_1BackendPolicy_3_01BACKEND_01_4_00_01detail_1_1multidimensional_01_4">More...</a><br /></td></tr>
<tr class="separator:classhydra_1_1SparseHistogram_3_01T_00_01N_00_01detail_1_1BackendPolicy_3_01BACKEND_01_4_00_01detail_1_1multidimensional_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1Spline2DFunctor.html">Spline2DFunctor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1Spline3DFunctor.html">Spline3DFunctor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1Spline4DFunctor.html">Spline4DFunctor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1SplineFunctor.html">SplineFunctor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1SPlot"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fit.html#classhydra_1_1SPlot">SPlot</a></td></tr>
<tr class="memdesc:classhydra_1_1SPlot"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of {s}_{Plot} technique for statistical unfolding of sample containing events from different sources.  <a href="group__fit.html#classhydra_1_1SPlot">More...</a><br /></td></tr>
<tr class="separator:classhydra_1_1SPlot"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1Sum.html">Sum</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1ThreeBodyMassThresholdBackground"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common__functions.html#classhydra_1_1ThreeBodyMassThresholdBackground">ThreeBodyMassThresholdBackground</a></td></tr>
<tr class="separator:classhydra_1_1ThreeBodyMassThresholdBackground"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1TrapezoidalShape"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common__functions.html#classhydra_1_1TrapezoidalShape">TrapezoidalShape</a></td></tr>
<tr class="memdesc:classhydra_1_1TrapezoidalShape"><td class="mdescLeft">&#160;</td><td class="mdescRight">In probability theory and statistics, the trapezoidal distribution is a continuous probability distribution the graph of whose probability density function resembles a trapezoid.  <a href="group__common__functions.html#classhydra_1_1TrapezoidalShape">More...</a><br /></td></tr>
<tr class="separator:classhydra_1_1TrapezoidalShape"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1TriangularShape"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common__functions.html#classhydra_1_1TriangularShape">TriangularShape</a></td></tr>
<tr class="memdesc:classhydra_1_1TriangularShape"><td class="mdescLeft">&#160;</td><td class="mdescRight">From: <a href="https://en.wikipedia.org/wiki/Triangular_distribution">https://en.wikipedia.org/wiki/Triangular_distribution</a>.  <a href="group__common__functions.html#classhydra_1_1TriangularShape">More...</a><br /></td></tr>
<tr class="separator:classhydra_1_1TriangularShape"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1UniformShape"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common__functions.html#classhydra_1_1UniformShape">UniformShape</a></td></tr>
<tr class="memdesc:classhydra_1_1UniformShape"><td class="mdescLeft">&#160;</td><td class="mdescRight">From: <a href="https://en.wikipedia.org/wiki/Uniform_distribution_(continuous)">https://en.wikipedia.org/wiki/Uniform_distribution_(continuous)</a>  <a href="group__common__functions.html#classhydra_1_1UniformShape">More...</a><br /></td></tr>
<tr class="separator:classhydra_1_1UniformShape"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1UserParameters"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fit.html#classhydra_1_1UserParameters">UserParameters</a></td></tr>
<tr class="memdesc:classhydra_1_1UserParameters"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class implementing a interface to ROOT::Minuit2::MnUserParameters.  <a href="group__fit.html#classhydra_1_1UserParameters">More...</a><br /></td></tr>
<tr class="separator:classhydra_1_1UserParameters"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1Vegas"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#classhydra_1_1Vegas">Vegas</a></td></tr>
<tr class="separator:classhydra_1_1Vegas"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1Vegas_3_01N_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_4_00_01GRND_01_4"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__numerical__integration.html#classhydra_1_1Vegas_3_01N_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_4_00_01GRND_01_4">Vegas&lt; N, hydra::detail::BackendPolicy&lt; BACKEND &gt;, GRND &gt;</a></td></tr>
<tr class="memdesc:classhydra_1_1Vegas_3_01N_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_4_00_01GRND_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to perform numerical integration using <a class="el" href="namespacehydra.html#classhydra_1_1Vegas">Vegas</a> algorithm.  <a href="group__numerical__integration.html#classhydra_1_1Vegas_3_01N_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_4_00_01GRND_01_4">More...</a><br /></td></tr>
<tr class="separator:classhydra_1_1Vegas_3_01N_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_4_00_01GRND_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1VegasState"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__numerical__integration.html#classhydra_1_1VegasState">VegasState</a></td></tr>
<tr class="memdesc:classhydra_1_1VegasState"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to hold resources and state of <a class="el" href="namespacehydra.html#classhydra_1_1Vegas">hydra::Vegas</a> integration algorithm.  <a href="group__numerical__integration.html#classhydra_1_1VegasState">More...</a><br /></td></tr>
<tr class="separator:classhydra_1_1VegasState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1VegasState_3_01N_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_4_01_4"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__numerical__integration.html#classhydra_1_1VegasState_3_01N_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_4_01_4">VegasState&lt; N, hydra::detail::BackendPolicy&lt; BACKEND &gt; &gt;</a></td></tr>
<tr class="memdesc:classhydra_1_1VegasState_3_01N_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_4_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to hold resources and state of <a class="el" href="namespacehydra.html#classhydra_1_1Vegas">hydra::Vegas</a> integration algorithm.  <a href="group__numerical__integration.html#classhydra_1_1VegasState_3_01N_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_4_01_4">More...</a><br /></td></tr>
<tr class="separator:classhydra_1_1VegasState_3_01N_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_4_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1WignerDMatrix"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common__functions.html#classhydra_1_1WignerDMatrix">WignerDMatrix</a></td></tr>
<tr class="memdesc:classhydra_1_1WignerDMatrix"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the beta-term </p><p class="formulaDsp">
\[ d^j_{mn}(beta) \]
</p>
<p> in the matrix element of the finite rotation operator (Wigner's D-function), according to formula 4.3.4(eq.  <a href="group__common__functions.html#classhydra_1_1WignerDMatrix">More...</a><br /></td></tr>
<tr class="separator:classhydra_1_1WignerDMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1ZemachFunction"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common__functions.html#classhydra_1_1ZemachFunction">ZemachFunction</a></td></tr>
<tr class="memdesc:classhydra_1_1ZemachFunction"><td class="mdescLeft">&#160;</td><td class="mdescRight">Zemach's angular probability distribution for 3-body decays of spinless particle into spinless final states as a function of \(\theta\), the helicity angle:  <a href="group__common__functions.html#classhydra_1_1ZemachFunction">More...</a><br /></td></tr>
<tr class="separator:classhydra_1_1ZemachFunction"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a2d2c6b5545615d4ad77efa8cd3d190f8"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="namespacehydra_1_1random.html#a8db464b150e6a1de1784f1774f0efb25">hydra::random::ars</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a2d2c6b5545615d4ad77efa8cd3d190f8">ars</a></td></tr>
<tr class="memdesc:a2d2c6b5545615d4ad77efa8cd3d190f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ars uses the crypotgraphic AES round function, but a <b>non-cryptographc</b> key schedule to save time and space.  <a href="#a2d2c6b5545615d4ad77efa8cd3d190f8">More...</a><br /></td></tr>
<tr class="separator:a2d2c6b5545615d4ad77efa8cd3d190f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d2c06cb9672fe86dbeaa65e8f35a2bf"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9d2c06cb9672fe86dbeaa65e8f35a2bf"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a9d2c06cb9672fe86dbeaa65e8f35a2bf">complex</a> = hydra::thrust::complex&lt; T &gt;</td></tr>
<tr class="separator:a9d2c06cb9672fe86dbeaa65e8f35a2bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e747e9ec41024e3efe0349f8ac10062"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classhydra_1_1random_1_1squares3.html">hydra::random::squares3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a1e747e9ec41024e3efe0349f8ac10062">default_random_engine</a></td></tr>
<tr class="memdesc:a1e747e9ec41024e3efe0349f8ac10062"><td class="mdescLeft">&#160;</td><td class="mdescRight">An implementation-defined "default" random number engine.  <a href="#a1e747e9ec41024e3efe0349f8ac10062">More...</a><br /></td></tr>
<tr class="separator:a1e747e9ec41024e3efe0349f8ac10062"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad614c0d4d1799d691f39110ece55090c"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structhydra_1_1detail_1_1SobolTable.html">detail::SobolTable</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ad614c0d4d1799d691f39110ece55090c">default_sobol_table</a></td></tr>
<tr class="separator:ad614c0d4d1799d691f39110ece55090c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8c251ed5017d0638da929130062bcad"><td class="memItemLeft" align="right" valign="top">typedef bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#aa8c251ed5017d0638da929130062bcad">GBool_t</a></td></tr>
<tr class="memdesc:aa8c251ed5017d0638da929130062bcad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boolean (0=false, 1=true) (bool)  <a href="#aa8c251ed5017d0638da929130062bcad">More...</a><br /></td></tr>
<tr class="separator:aa8c251ed5017d0638da929130062bcad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2da2ab0037e6bca3cb7c15adc5c4125"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="namespace_3globalScope_4.html#classunsigned">unsigned</a> char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ae2da2ab0037e6bca3cb7c15adc5c4125">GByte_t</a></td></tr>
<tr class="memdesc:ae2da2ab0037e6bca3cb7c15adc5c4125"><td class="mdescLeft">&#160;</td><td class="mdescRight">Byte (8 bits) (unsigned char)  <a href="#ae2da2ab0037e6bca3cb7c15adc5c4125">More...</a><br /></td></tr>
<tr class="separator:ae2da2ab0037e6bca3cb7c15adc5c4125"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ab04a199389c4989174dc115507fa89"><td class="memItemLeft" align="right" valign="top">typedef char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a7ab04a199389c4989174dc115507fa89">GChar_t</a></td></tr>
<tr class="memdesc:a7ab04a199389c4989174dc115507fa89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed Character 1 byte (char)  <a href="#a7ab04a199389c4989174dc115507fa89">More...</a><br /></td></tr>
<tr class="separator:a7ab04a199389c4989174dc115507fa89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af986267d40d932c5cbf0ae874a506f83"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#af986267d40d932c5cbf0ae874a506f83">GDouble_t</a></td></tr>
<tr class="memdesc:af986267d40d932c5cbf0ae874a506f83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Double 8 bytes.  <a href="#af986267d40d932c5cbf0ae874a506f83">More...</a><br /></td></tr>
<tr class="separator:af986267d40d932c5cbf0ae874a506f83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71bab7b854d7b3c3042fe47201b765eb"><td class="memItemLeft" align="right" valign="top">typedef float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a71bab7b854d7b3c3042fe47201b765eb">GFloat_t</a></td></tr>
<tr class="memdesc:a71bab7b854d7b3c3042fe47201b765eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Float 4 bytes (float)  <a href="#a71bab7b854d7b3c3042fe47201b765eb">More...</a><br /></td></tr>
<tr class="separator:a71bab7b854d7b3c3042fe47201b765eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c9fb4d7195ab952da10a82d5c4ad30e"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="namespace_3globalScope_4.html#classint">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a0c9fb4d7195ab952da10a82d5c4ad30e">GInt_t</a></td></tr>
<tr class="memdesc:a0c9fb4d7195ab952da10a82d5c4ad30e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed integer 4 bytes (int)  <a href="#a0c9fb4d7195ab952da10a82d5c4ad30e">More...</a><br /></td></tr>
<tr class="separator:a0c9fb4d7195ab952da10a82d5c4ad30e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d68c21fb715bbfb1edc5b1933b173e9"><td class="memItemLeft" align="right" valign="top">typedef long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a9d68c21fb715bbfb1edc5b1933b173e9">GLong64_t</a></td></tr>
<tr class="memdesc:a9d68c21fb715bbfb1edc5b1933b173e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Portable signed long integer 8 bytes.  <a href="#a9d68c21fb715bbfb1edc5b1933b173e9">More...</a><br /></td></tr>
<tr class="separator:a9d68c21fb715bbfb1edc5b1933b173e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f57a4025b40929c2708cd544c3a1ccd"><td class="memItemLeft" align="right" valign="top">typedef long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a5f57a4025b40929c2708cd544c3a1ccd">GLong_t</a></td></tr>
<tr class="memdesc:a5f57a4025b40929c2708cd544c3a1ccd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed long integer 4 bytes (long)  <a href="#a5f57a4025b40929c2708cd544c3a1ccd">More...</a><br /></td></tr>
<tr class="separator:a5f57a4025b40929c2708cd544c3a1ccd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a751abe69b482cde879c718fd4775733f"><td class="memItemLeft" align="right" valign="top">typedef long <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a751abe69b482cde879c718fd4775733f">GLongDouble_t</a></td></tr>
<tr class="memdesc:a751abe69b482cde879c718fd4775733f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Long Double.  <a href="#a751abe69b482cde879c718fd4775733f">More...</a><br /></td></tr>
<tr class="separator:a751abe69b482cde879c718fd4775733f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a971e94bcb8c43741d11f9d8eb98f5fab"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a></td></tr>
<tr class="memdesc:a971e94bcb8c43741d11f9d8eb98f5fab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Double 16 bytes or float 4 bytes.  <a href="#a971e94bcb8c43741d11f9d8eb98f5fab">More...</a><br /></td></tr>
<tr class="separator:a971e94bcb8c43741d11f9d8eb98f5fab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a589c60d92ba893c28d814edd6e149a9c"><td class="memItemLeft" align="right" valign="top">typedef short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a589c60d92ba893c28d814edd6e149a9c">GShort_t</a></td></tr>
<tr class="memdesc:a589c60d92ba893c28d814edd6e149a9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed Short integer 2 bytes (short)  <a href="#a589c60d92ba893c28d814edd6e149a9c">More...</a><br /></td></tr>
<tr class="separator:a589c60d92ba893c28d814edd6e149a9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc842c1ec8321e9637dee714dcdaebff"><td class="memItemLeft" align="right" valign="top">typedef char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#abc842c1ec8321e9637dee714dcdaebff">GText_t</a></td></tr>
<tr class="memdesc:abc842c1ec8321e9637dee714dcdaebff"><td class="mdescLeft">&#160;</td><td class="mdescRight">General string (char)  <a href="#abc842c1ec8321e9637dee714dcdaebff">More...</a><br /></td></tr>
<tr class="separator:abc842c1ec8321e9637dee714dcdaebff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51ef97faee95aa79f3839eb7abdf5238"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="namespace_3globalScope_4.html#classunsigned">unsigned</a> char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a51ef97faee95aa79f3839eb7abdf5238">GUChar_t</a></td></tr>
<tr class="memdesc:a51ef97faee95aa79f3839eb7abdf5238"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsigned Character 1 byte (unsigned char)  <a href="#a51ef97faee95aa79f3839eb7abdf5238">More...</a><br /></td></tr>
<tr class="separator:a51ef97faee95aa79f3839eb7abdf5238"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a251a7b1f515ac1ed9409afd67252a32b"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="namespace_3globalScope_4.html#classunsigned">unsigned</a> <a class="el" href="namespace_3globalScope_4.html#classint">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a251a7b1f515ac1ed9409afd67252a32b">GUInt_t</a></td></tr>
<tr class="memdesc:a251a7b1f515ac1ed9409afd67252a32b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsigned integer 4 bytes (unsigned int)  <a href="#a251a7b1f515ac1ed9409afd67252a32b">More...</a><br /></td></tr>
<tr class="separator:a251a7b1f515ac1ed9409afd67252a32b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55e8443cd746900da90cb1f77807e7c0"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="namespace_3globalScope_4.html#classunsigned">unsigned</a> long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a55e8443cd746900da90cb1f77807e7c0">GULong64_t</a></td></tr>
<tr class="memdesc:a55e8443cd746900da90cb1f77807e7c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Portable unsigned long integer 8 bytes.  <a href="#a55e8443cd746900da90cb1f77807e7c0">More...</a><br /></td></tr>
<tr class="separator:a55e8443cd746900da90cb1f77807e7c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf9a0d54fd4ed46052939549edd086c5"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="namespace_3globalScope_4.html#classunsigned">unsigned</a> long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#abf9a0d54fd4ed46052939549edd086c5">GULong_t</a></td></tr>
<tr class="separator:abf9a0d54fd4ed46052939549edd086c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a911a3042526fac189d0c87a089f52955"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="namespace_3globalScope_4.html#classunsigned">unsigned</a> short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a911a3042526fac189d0c87a089f52955">GUShort_t</a></td></tr>
<tr class="memdesc:a911a3042526fac189d0c87a089f52955"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsigned Short integer 2 bytes (unsigned short)  <a href="#a911a3042526fac189d0c87a089f52955">More...</a><br /></td></tr>
<tr class="separator:a911a3042526fac189d0c87a089f52955"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaf935e1b294f95c8bde7769a0e60468"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:adaf935e1b294f95c8bde7769a0e60468"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#adaf935e1b294f95c8bde7769a0e60468">mc_device_vector</a> = hydra::thrust::device_vector&lt; T &gt;</td></tr>
<tr class="memdesc:adaf935e1b294f95c8bde7769a0e60468"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic template typedef for hydra::thrust::host_vector.  <a href="#adaf935e1b294f95c8bde7769a0e60468">More...</a><br /></td></tr>
<tr class="separator:adaf935e1b294f95c8bde7769a0e60468"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f1cb44a968c99a7fae4678eff452b12"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7f1cb44a968c99a7fae4678eff452b12"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a7f1cb44a968c99a7fae4678eff452b12">mc_host_vector</a> = hydra::thrust::host_vector&lt; T, hydra::thrust::system::cuda::experimental::pinned_allocator&lt; T &gt; &gt;</td></tr>
<tr class="memdesc:a7f1cb44a968c99a7fae4678eff452b12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic template typedef for hydra::thrust::host_vector.  <a href="#a7f1cb44a968c99a7fae4678eff452b12">More...</a><br /></td></tr>
<tr class="separator:a7f1cb44a968c99a7fae4678eff452b12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeccdd58e3a4c27246dadd0930e3fb569"><td class="memItemLeft" align="right" valign="top">typedef hydra::thrust::random::minstd_rand&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#aeccdd58e3a4c27246dadd0930e3fb569">minstd_rand</a></td></tr>
<tr class="memdesc:aeccdd58e3a4c27246dadd0930e3fb569"><td class="mdescLeft">&#160;</td><td class="mdescRight">A random number engine with predefined parameters which implements a version of the Minimal Standard random number generation algorithm.  <a href="#aeccdd58e3a4c27246dadd0930e3fb569">More...</a><br /></td></tr>
<tr class="separator:aeccdd58e3a4c27246dadd0930e3fb569"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7c3603cf7a6c467176d8be9dd2c82fd"><td class="memItemLeft" align="right" valign="top">typedef hydra::thrust::random::minstd_rand0&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ab7c3603cf7a6c467176d8be9dd2c82fd">minstd_rand0</a></td></tr>
<tr class="memdesc:ab7c3603cf7a6c467176d8be9dd2c82fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">A random number engine with predefined parameters which implements a version of the Minimal Standard random number generation algorithm.  <a href="#ab7c3603cf7a6c467176d8be9dd2c82fd">More...</a><br /></td></tr>
<tr class="separator:ab7c3603cf7a6c467176d8be9dd2c82fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f40581ef3c81ef08844d3beb59842f7"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a1f40581ef3c81ef08844d3beb59842f7"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a1f40581ef3c81ef08844d3beb59842f7">pair</a> = hydra::thrust::pair&lt; T1, T2 &gt;</td></tr>
<tr class="memdesc:a1f40581ef3c81ef08844d3beb59842f7"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>pair</code> template is an alias to the hydra::thrust::pair structure.  <a href="#a1f40581ef3c81ef08844d3beb59842f7">More...</a><br /></td></tr>
<tr class="separator:a1f40581ef3c81ef08844d3beb59842f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1501ab96b6a1b76d1f6a1bdd63efd5d"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="namespacehydra_1_1random.html#aeb7b02296b6acdacd74cb15714f79289">hydra::random::philox</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ad1501ab96b6a1b76d1f6a1bdd63efd5d">philox</a></td></tr>
<tr class="memdesc:ad1501ab96b6a1b76d1f6a1bdd63efd5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Philox family of counter-based RNGs use integer multiplication, xor and permutation of W-bit words to scramble its N-word input key.  <a href="#ad1501ab96b6a1b76d1f6a1bdd63efd5d">More...</a><br /></td></tr>
<tr class="separator:ad1501ab96b6a1b76d1f6a1bdd63efd5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45b538d4a1c53d043ba20318da7bbcff"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="namespacehydra_1_1random.html#a983737b2c7216258a407aec6a65705c6">hydra::random::philox_long</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a45b538d4a1c53d043ba20318da7bbcff">philox_long</a></td></tr>
<tr class="separator:a45b538d4a1c53d043ba20318da7bbcff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a943a0571fdadbbb4bc9b17ba7ae4b59b"><td class="memItemLeft" align="right" valign="top">typedef hydra::thrust::random::ranlux24&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a943a0571fdadbbb4bc9b17ba7ae4b59b">ranlux24</a></td></tr>
<tr class="memdesc:a943a0571fdadbbb4bc9b17ba7ae4b59b"><td class="mdescLeft">&#160;</td><td class="mdescRight">A random number engine with predefined parameters which implements the RANLUX level-3 random number generation algorithm.  <a href="#a943a0571fdadbbb4bc9b17ba7ae4b59b">More...</a><br /></td></tr>
<tr class="separator:a943a0571fdadbbb4bc9b17ba7ae4b59b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6950c5abef4e2015f833501684940b5d"><td class="memItemLeft" align="right" valign="top">typedef hydra::thrust::random::ranlux48&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a6950c5abef4e2015f833501684940b5d">ranlux48</a></td></tr>
<tr class="memdesc:a6950c5abef4e2015f833501684940b5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A random number engine with predefined parameters which implements the RANLUX level-4 random number generation algorithm.  <a href="#a6950c5abef4e2015f833501684940b5d">More...</a><br /></td></tr>
<tr class="separator:a6950c5abef4e2015f833501684940b5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27378ecbb012326012d334cf11431549"><td class="memTemplParams" colspan="2">template&lt;unsigned D&gt; </td></tr>
<tr class="memitem:a27378ecbb012326012d334cf11431549"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a27378ecbb012326012d334cf11431549">sobol</a> = <a class="el" href="classhydra_1_1sobol__engine.html">sobol_engine</a>&lt; uint_least64_t, <a class="el" href="basic__distributions_8inl.html#a6f9cfa21f3993da1ed1a77acbc9bd9be">D</a>, 64u, default_sobol_table &gt;</td></tr>
<tr class="separator:a27378ecbb012326012d334cf11431549"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0465592a7919d064d2cdb934f6eedce"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classhydra_1_1random_1_1squares3.html">hydra::random::squares3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#aa0465592a7919d064d2cdb934f6eedce">squares3</a></td></tr>
<tr class="memdesc:aa0465592a7919d064d2cdb934f6eedce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ars uses the crypotgraphic AES round function, but a <b>non-cryptographc</b> key schedule to save time and space.  <a href="#aa0465592a7919d064d2cdb934f6eedce">More...</a><br /></td></tr>
<tr class="separator:aa0465592a7919d064d2cdb934f6eedce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa99a8402f27d47792099e50efce10c6a"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classhydra_1_1random_1_1squares4.html">hydra::random::squares4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#aa99a8402f27d47792099e50efce10c6a">squares4</a></td></tr>
<tr class="memdesc:aa99a8402f27d47792099e50efce10c6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ars uses the crypotgraphic AES round function, but a <b>non-cryptographc</b> key schedule to save time and space.  <a href="#aa99a8402f27d47792099e50efce10c6a">More...</a><br /></td></tr>
<tr class="separator:aa99a8402f27d47792099e50efce10c6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2633cfe1492c02cfb2aef6a79804f191"><td class="memItemLeft" align="right" valign="top">typedef hydra::thrust::random::taus88&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a2633cfe1492c02cfb2aef6a79804f191">taus88</a></td></tr>
<tr class="memdesc:a2633cfe1492c02cfb2aef6a79804f191"><td class="mdescLeft">&#160;</td><td class="mdescRight">A random number engine with predefined parameters which implements L'Ecuyer's 1996 three-component Tausworthe random number generator.  <a href="#a2633cfe1492c02cfb2aef6a79804f191">More...</a><br /></td></tr>
<tr class="separator:a2633cfe1492c02cfb2aef6a79804f191"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a211bb34d13be9d9796acd4b9c3303dae"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="namespacehydra_1_1random.html#acfa5fba739bc2ec7363fe9d194b53fe0">hydra::random::threefry</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a211bb34d13be9d9796acd4b9c3303dae">threefry</a></td></tr>
<tr class="memdesc:a211bb34d13be9d9796acd4b9c3303dae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Threefry uses integer addition, bitwise rotation, xor and permutation of words to randomize its output.  <a href="#a211bb34d13be9d9796acd4b9c3303dae">More...</a><br /></td></tr>
<tr class="separator:a211bb34d13be9d9796acd4b9c3303dae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1cbf60d1726087cc7968bab8aabf7a4"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="namespacehydra_1_1random.html#a9897cee1d73c67e36dcca39b1cc81bb6">hydra::random::threefry_long</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ad1cbf60d1726087cc7968bab8aabf7a4">threefry_long</a></td></tr>
<tr class="memdesc:ad1cbf60d1726087cc7968bab8aabf7a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Threefry uses integer addition, bitwise rotation, xor and permutation of words to randomize its output.  <a href="#ad1cbf60d1726087cc7968bab8aabf7a4">More...</a><br /></td></tr>
<tr class="separator:ad1cbf60d1726087cc7968bab8aabf7a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3486502b2db72187626125cea971683"><td class="memTemplParams" colspan="2">template&lt;typename... T&gt; </td></tr>
<tr class="memitem:ac3486502b2db72187626125cea971683"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ac3486502b2db72187626125cea971683">tuple</a> = hydra::thrust::tuple&lt; T... &gt;</td></tr>
<tr class="memdesc:ac3486502b2db72187626125cea971683"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>tuple</code> template is an alias to the variadic version of hydra::thrust::tuple and that can be instantiated with a indefinite number of arguments.  <a href="#ac3486502b2db72187626125cea971683">More...</a><br /></td></tr>
<tr class="separator:ac3486502b2db72187626125cea971683"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab09551bcd98d1cd273b2001cdcc33b9c"><td class="memTemplParams" colspan="2">template&lt;int N, class T &gt; </td></tr>
<tr class="memitem:ab09551bcd98d1cd273b2001cdcc33b9c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ab09551bcd98d1cd273b2001cdcc33b9c">tuple_element</a> = hydra::thrust::tuple_element&lt; N, T &gt;</td></tr>
<tr class="memdesc:ab09551bcd98d1cd273b2001cdcc33b9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <code>get</code> function returns a <code>const</code> reference to a <code>tuple</code> element of interest.  <a href="#ab09551bcd98d1cd273b2001cdcc33b9c">More...</a><br /></td></tr>
<tr class="separator:ab09551bcd98d1cd273b2001cdcc33b9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58298133d4826dc6f35253762a7d6788"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a58298133d4826dc6f35253762a7d6788"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a58298133d4826dc6f35253762a7d6788">tuple_size</a> = hydra::thrust::tuple_size&lt; T &gt;</td></tr>
<tr class="memdesc:a58298133d4826dc6f35253762a7d6788"><td class="mdescLeft">&#160;</td><td class="mdescRight">This metafunction returns the number of elements of a <code>tuple</code> type of interest.  <a href="#a58298133d4826dc6f35253762a7d6788">More...</a><br /></td></tr>
<tr class="separator:a58298133d4826dc6f35253762a7d6788"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a798d2fe7cacd6711fb3c975052992398"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="namespacehydra.html#a798d2fe7cacd6711fb3c975052992398aae772e8b4c5ada0e1e4c65495702176a">MODE_IMPORTANCE</a> = 1, 
<a class="el" href="namespacehydra.html#a798d2fe7cacd6711fb3c975052992398a28550661921a3af1306fa74a26b8569c">MODE_IMPORTANCE_ONLY</a> = 0, 
<a class="el" href="namespacehydra.html#a798d2fe7cacd6711fb3c975052992398acb2c0124fecbf6c1182f1cf7cd9bc37a">MODE_STRATIFIED</a> = -1, 
<a class="el" href="namespacehydra.html#a798d2fe7cacd6711fb3c975052992398aba2629d0445cc7ef401fd6793f047da0">BINS_MAX</a> = 50
 }</td></tr>
<tr class="separator:a798d2fe7cacd6711fb3c975052992398"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1107488f838687e73b39ddd8245f40d0"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="namespacehydra.html#a1107488f838687e73b39ddd8245f40d0a4517ec382985cb7a39393c0da09e58d5">INFO</a> =0, 
<a class="el" href="namespacehydra.html#a1107488f838687e73b39ddd8245f40d0a1bf857a06d5b8463494a6fcac6f4ea26">WARNING</a> =1, 
<a class="el" href="namespacehydra.html#a1107488f838687e73b39ddd8245f40d0adbc96f88184ea3a51f68df95e2b44851">ERROR</a> =2
 }</td></tr>
<tr class="separator:a1107488f838687e73b39ddd8245f40d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0dc858c0fb14ade1e8abc19cdd0959e2"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common__functions.html#ga0dc858c0fb14ade1e8abc19cdd0959e2">Wave</a> { <br />
&#160;&#160;<a class="el" href="group__common__functions.html#gga0dc858c0fb14ade1e8abc19cdd0959e2a4f4fc5545002d4eada7e2a14c27c5dfd">SWave</a> =0, 
<a class="el" href="group__common__functions.html#gga0dc858c0fb14ade1e8abc19cdd0959e2ae382eaafad7afe6dee68693249ff8a45">PWave</a>, 
<a class="el" href="group__common__functions.html#gga0dc858c0fb14ade1e8abc19cdd0959e2a74097dfe50b93307e587c23f9180b6b3">DWave</a>, 
<a class="el" href="group__common__functions.html#gga0dc858c0fb14ade1e8abc19cdd0959e2a82415de987820fb86ab995f1dee87db1">FWave</a>, 
<br />
&#160;&#160;<a class="el" href="group__common__functions.html#gga0dc858c0fb14ade1e8abc19cdd0959e2a113622b6b528bfd4a76d68e9a99ac032">GWave</a>, 
<a class="el" href="group__common__functions.html#gga0dc858c0fb14ade1e8abc19cdd0959e2af168d5a7a174aa70e881f13fdeaf4426">HWave</a>
<br />
 }</td></tr>
<tr class="memdesc:ga0dc858c0fb14ade1e8abc19cdd0959e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Orbital angular momentum tags.  <a href="group__common__functions.html#ga0dc858c0fb14ade1e8abc19cdd0959e2">More...</a><br /></td></tr>
<tr class="separator:ga0dc858c0fb14ade1e8abc19cdd0959e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga315c1e042b983e5b623b5046074b7c56"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__phsp.html#ga315c1e042b983e5b623b5046074b7c56">__hydra_align__</a> (16) Vector3R</td></tr>
<tr class="memdesc:ga315c1e042b983e5b623b5046074b7c56"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents three-dimensional Euclidian vectors and implements common operation performed on it.  <a href="group__phsp.html#ga315c1e042b983e5b623b5046074b7c56">More...</a><br /></td></tr>
<tr class="separator:ga315c1e042b983e5b623b5046074b7c56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e095cca28f6bec603156fd48914aefe"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5e095cca28f6bec603156fd48914aefe"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a5e095cca28f6bec603156fd48914aefe">abs</a> (const <a class="el" href="namespacehydra.html#a9d2c06cb9672fe86dbeaa65e8f35a2bf">complex</a>&lt; T &gt; &amp;z)</td></tr>
<tr class="separator:a5e095cca28f6bec603156fd48914aefe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a256097a85b1ce0eafa6e497f46d87383"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a256097a85b1ce0eafa6e497f46d87383"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespacehydra.html#a9d2c06cb9672fe86dbeaa65e8f35a2bf">complex</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a256097a85b1ce0eafa6e497f46d87383">acos</a> (const <a class="el" href="namespacehydra.html#a9d2c06cb9672fe86dbeaa65e8f35a2bf">complex</a>&lt; T &gt; &amp;z)</td></tr>
<tr class="separator:a256097a85b1ce0eafa6e497f46d87383"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec91f5ec5ff214023b38f72ec4ac1e76"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aec91f5ec5ff214023b38f72ec4ac1e76"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespacehydra.html#a9d2c06cb9672fe86dbeaa65e8f35a2bf">complex</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#aec91f5ec5ff214023b38f72ec4ac1e76">acosh</a> (const <a class="el" href="namespacehydra.html#a9d2c06cb9672fe86dbeaa65e8f35a2bf">complex</a>&lt; T &gt; &amp;z)</td></tr>
<tr class="separator:aec91f5ec5ff214023b38f72ec4ac1e76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5917e6644c8742bd0d3586066ee5de0"><td class="memTemplParams" colspan="2">template&lt;typename PDF1 , typename PDF2 , typename ... PDFs&gt; </td></tr>
<tr class="memitem:gad5917e6644c8742bd0d3586066ee5de0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__fit.html#classhydra_1_1PDFSumNonExtendable">PDFSumNonExtendable</a>&lt; PDF1, PDF2, PDFs... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__fit.html#gad5917e6644c8742bd0d3586066ee5de0">add_pdfs</a> (std::array&lt; <a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a>, sizeof...(PDFs)+1 &gt;const &amp;var_list, PDF1 const &amp;pdf1, PDF2 const &amp;pdf2, PDFs const &amp;...pdfs)</td></tr>
<tr class="memdesc:gad5917e6644c8742bd0d3586066ee5de0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to build up non-extendable pdfs models.  <a href="group__fit.html#gad5917e6644c8742bd0d3586066ee5de0">More...</a><br /></td></tr>
<tr class="separator:gad5917e6644c8742bd0d3586066ee5de0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e7cc3bb04eac1d1350bb41b254fc92b"><td class="memTemplParams" colspan="2">template&lt;typename PDF1 , typename PDF2 , typename ... PDFs&gt; </td></tr>
<tr class="memitem:ga7e7cc3bb04eac1d1350bb41b254fc92b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__fit.html#classhydra_1_1PDFSumExtendable">PDFSumExtendable</a>&lt; PDF1, PDF2, PDFs... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__fit.html#ga7e7cc3bb04eac1d1350bb41b254fc92b">add_pdfs</a> (std::array&lt; <a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a>, sizeof...(PDFs)+2 &gt;const &amp;var_list, PDF1 const &amp;pdf1, PDF2 const &amp;pdf2, PDFs const &amp;...pdfs)</td></tr>
<tr class="memdesc:ga7e7cc3bb04eac1d1350bb41b254fc92b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to build up extendable pdfs models.  <a href="group__fit.html#ga7e7cc3bb04eac1d1350bb41b254fc92b">More...</a><br /></td></tr>
<tr class="separator:ga7e7cc3bb04eac1d1350bb41b254fc92b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae96191cbaa62c58f63b7e58924362c24"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae96191cbaa62c58f63b7e58924362c24"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ae96191cbaa62c58f63b7e58924362c24">arg</a> (const <a class="el" href="namespacehydra.html#a9d2c06cb9672fe86dbeaa65e8f35a2bf">complex</a>&lt; T &gt; &amp;z)</td></tr>
<tr class="separator:ae96191cbaa62c58f63b7e58924362c24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a7e65b9bb4aca1f24356f2d43f91bda"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9a7e65b9bb4aca1f24356f2d43f91bda"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespacehydra.html#a9d2c06cb9672fe86dbeaa65e8f35a2bf">complex</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a9a7e65b9bb4aca1f24356f2d43f91bda">asin</a> (const <a class="el" href="namespacehydra.html#a9d2c06cb9672fe86dbeaa65e8f35a2bf">complex</a>&lt; T &gt; &amp;z)</td></tr>
<tr class="separator:a9a7e65b9bb4aca1f24356f2d43f91bda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd779382ac3242158686664a9a3ca3a0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abd779382ac3242158686664a9a3ca3a0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespacehydra.html#a9d2c06cb9672fe86dbeaa65e8f35a2bf">complex</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#abd779382ac3242158686664a9a3ca3a0">asinh</a> (const <a class="el" href="namespacehydra.html#a9d2c06cb9672fe86dbeaa65e8f35a2bf">complex</a>&lt; T &gt; &amp;z)</td></tr>
<tr class="separator:abd779382ac3242158686664a9a3ca3a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9772b7e92ecdf60524cde428c1670bd4"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9772b7e92ecdf60524cde428c1670bd4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespacehydra.html#a9d2c06cb9672fe86dbeaa65e8f35a2bf">complex</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a9772b7e92ecdf60524cde428c1670bd4">atan</a> (const <a class="el" href="namespacehydra.html#a9d2c06cb9672fe86dbeaa65e8f35a2bf">complex</a>&lt; T &gt; &amp;z)</td></tr>
<tr class="separator:a9772b7e92ecdf60524cde428c1670bd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24b7bc13880335fdf6964df5034ade29"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a24b7bc13880335fdf6964df5034ade29"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespacehydra.html#a9d2c06cb9672fe86dbeaa65e8f35a2bf">complex</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a24b7bc13880335fdf6964df5034ade29">atanh</a> (const <a class="el" href="namespacehydra.html#a9d2c06cb9672fe86dbeaa65e8f35a2bf">complex</a>&lt; T &gt; &amp;z)</td></tr>
<tr class="separator:a24b7bc13880335fdf6964df5034ade29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd995d684b15024c891571fe47518404"><td class="memTemplParams" colspan="2">template&lt;hydra::Wave L&gt; </td></tr>
<tr class="memitem:gacd995d684b15024c891571fe47518404"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common__functions.html#gacd995d684b15024c891571fe47518404">BarrierFactor</a> (const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> d, const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> p0, const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> p)</td></tr>
<tr class="memdesc:gacd995d684b15024c891571fe47518404"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blatt-Weisskopf B' functions.  <a href="group__common__functions.html#gacd995d684b15024c891571fe47518404">More...</a><br /></td></tr>
<tr class="separator:gacd995d684b15024c891571fe47518404"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03f4e98f986e55037e1a01fe4d9b8fc8"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a03f4e98f986e55037e1a01fe4d9b8fc8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a03f4e98f986e55037e1a01fe4d9b8fc8">BarrierFactor&lt; hydra::DWave &gt;</a> (const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> radi, const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> p0, const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> p)</td></tr>
<tr class="separator:a03f4e98f986e55037e1a01fe4d9b8fc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5a1e302e48427c947ab2084811df1df"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:ac5a1e302e48427c947ab2084811df1df"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ac5a1e302e48427c947ab2084811df1df">BarrierFactor&lt; hydra::FWave &gt;</a> (const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> radi, const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> p0, const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> p)</td></tr>
<tr class="separator:ac5a1e302e48427c947ab2084811df1df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0e0a9c294368d8d5b74fb919e261bef"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:ac0e0a9c294368d8d5b74fb919e261bef"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ac0e0a9c294368d8d5b74fb919e261bef">BarrierFactor&lt; hydra::GWave &gt;</a> (const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> radi, const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> p0, const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> p)</td></tr>
<tr class="separator:ac0e0a9c294368d8d5b74fb919e261bef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae223d417259cf7e660fd89a54438d45b"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:ae223d417259cf7e660fd89a54438d45b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ae223d417259cf7e660fd89a54438d45b">BarrierFactor&lt; hydra::HWave &gt;</a> (const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> radi, const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> p0, const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> p)</td></tr>
<tr class="separator:ae223d417259cf7e660fd89a54438d45b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa78649879f76b3b52249830df2482980"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:aa78649879f76b3b52249830df2482980"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#aa78649879f76b3b52249830df2482980">BarrierFactor&lt; hydra::PWave &gt;</a> (const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> radi, const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> p0, const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> p)</td></tr>
<tr class="separator:aa78649879f76b3b52249830df2482980"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab59597f876fc220d388f5911bb9822c"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:aab59597f876fc220d388f5911bb9822c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#aab59597f876fc220d388f5911bb9822c">BarrierFactor&lt; hydra::SWave &gt;</a> (const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>, const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>, const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>)</td></tr>
<tr class="separator:aab59597f876fc220d388f5911bb9822c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9d562f964ef193664077363da8859e2"><td class="memTemplParams" colspan="2">template&lt;class C &gt; </td></tr>
<tr class="memitem:ab9d562f964ef193664077363da8859e2"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a> (const <a class="el" href="basic__distributions_8inl.html#a4900ef306eb9271438791f1a98b8ccba">C</a> &amp;c) -&gt; decltype(c.begin())</td></tr>
<tr class="separator:ab9d562f964ef193664077363da8859e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e149bee61e4ddabca7fa0aafa121fe1"><td class="memTemplParams" colspan="2">template&lt;class C &gt; </td></tr>
<tr class="memitem:a7e149bee61e4ddabca7fa0aafa121fe1"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a7e149bee61e4ddabca7fa0aafa121fe1">begin</a> (<a class="el" href="basic__distributions_8inl.html#a4900ef306eb9271438791f1a98b8ccba">C</a> &amp;&amp;c) -&gt; decltype(std::forward&lt; <a class="el" href="basic__distributions_8inl.html#a4900ef306eb9271438791f1a98b8ccba">C</a> &gt;(c).begin())</td></tr>
<tr class="separator:a7e149bee61e4ddabca7fa0aafa121fe1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c64031cbdf1765fdf74577297ddb758"><td class="memTemplParams" colspan="2">template&lt;class T , size_t N&gt; </td></tr>
<tr class="memitem:a6c64031cbdf1765fdf74577297ddb758"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a6c64031cbdf1765fdf74577297ddb758">begin</a> (T(&amp;array)[N])</td></tr>
<tr class="separator:a6c64031cbdf1765fdf74577297ddb758"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd4f46840c85ee014f1d237601913ae1"><td class="memTemplParams" colspan="2">template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename T , size_t N&gt; </td></tr>
<tr class="memitem:afd4f46840c85ee014f1d237601913ae1"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#afd4f46840c85ee014f1d237601913ae1">begin</a> (<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;, <a class="el" href="namespacehydra.html#classhydra_1_1multiarray">multiarray</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; const &amp;other) -&gt; decltype(other.begin(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;</td></tr>
<tr class="separator:afd4f46840c85ee014f1d237601913ae1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6483cec578e17112f07ba012a4dc50ed"><td class="memTemplParams" colspan="2">template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename T , size_t N&gt; </td></tr>
<tr class="memitem:a6483cec578e17112f07ba012a4dc50ed"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a6483cec578e17112f07ba012a4dc50ed">begin</a> (<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;, <a class="el" href="namespacehydra.html#classhydra_1_1multiarray">multiarray</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; &amp;other) -&gt; decltype(other.begin(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;</td></tr>
<tr class="separator:a6483cec578e17112f07ba012a4dc50ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f9aebde030525eb216e14815d87a16f"><td class="memTemplParams" colspan="2">template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename ... T&gt; </td></tr>
<tr class="memitem:a8f9aebde030525eb216e14815d87a16f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a8f9aebde030525eb216e14815d87a16f">begin</a> (<a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; hydra::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; const &amp;other) -&gt; decltype(other.begin(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;</td></tr>
<tr class="separator:a8f9aebde030525eb216e14815d87a16f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13db31ab59bd6f8c2dc4bfcb0ce4fc1d"><td class="memTemplParams" colspan="2">template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename ... T&gt; </td></tr>
<tr class="memitem:a13db31ab59bd6f8c2dc4bfcb0ce4fc1d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a13db31ab59bd6f8c2dc4bfcb0ce4fc1d">begin</a> (<a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; hydra::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; &amp;other) -&gt; decltype(other.begin(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;</td></tr>
<tr class="separator:a13db31ab59bd6f8c2dc4bfcb0ce4fc1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0da471ad7818c9c8aa4c743360952240"><td class="memItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a0da471ad7818c9c8aa4c743360952240">bessel_i</a> (const <a class="el" href="namespace_3globalScope_4.html#classint">int</a> <a class="el" href="crystal__ball__plus__exponential_8inl.html#a21f77208d6bc667560ff8aaf8f943b6a">n</a>, const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> x)</td></tr>
<tr class="memdesc:a0da471ad7818c9c8aa4c743360952240"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modified Bessel function of first kind and order n.  <a href="#a0da471ad7818c9c8aa4c743360952240">More...</a><br /></td></tr>
<tr class="separator:a0da471ad7818c9c8aa4c743360952240"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a863ac23066d7b53623db033ee1ac3ca8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a863ac23066d7b53623db033ee1ac3ca8">bessel_i0</a> (const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> x)</td></tr>
<tr class="memdesc:a863ac23066d7b53623db033ee1ac3ca8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modified Bessel function of first kind and order 0.  <a href="#a863ac23066d7b53623db033ee1ac3ca8">More...</a><br /></td></tr>
<tr class="separator:a863ac23066d7b53623db033ee1ac3ca8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd0944fc0cf328edf5747e1401144172"><td class="memItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#abd0944fc0cf328edf5747e1401144172">bessel_i1</a> (const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> x)</td></tr>
<tr class="memdesc:abd0944fc0cf328edf5747e1401144172"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modified Bessel function of first kind and order 1.  <a href="#abd0944fc0cf328edf5747e1401144172">More...</a><br /></td></tr>
<tr class="separator:abd0944fc0cf328edf5747e1401144172"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28212504a23a89b5dd376831503d5b4b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a28212504a23a89b5dd376831503d5b4b">bessel_j</a> (const <a class="el" href="namespace_3globalScope_4.html#classint">int</a> <a class="el" href="crystal__ball__plus__exponential_8inl.html#a21f77208d6bc667560ff8aaf8f943b6a">n</a>, const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> x)</td></tr>
<tr class="memdesc:a28212504a23a89b5dd376831503d5b4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bessel function of first kind and order n.  <a href="#a28212504a23a89b5dd376831503d5b4b">More...</a><br /></td></tr>
<tr class="separator:a28212504a23a89b5dd376831503d5b4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4de83802cdb05bd73882b760a777000"><td class="memItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#aa4de83802cdb05bd73882b760a777000">bessel_j0</a> (const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> x)</td></tr>
<tr class="memdesc:aa4de83802cdb05bd73882b760a777000"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bessel function of first kind and order 0.  <a href="#aa4de83802cdb05bd73882b760a777000">More...</a><br /></td></tr>
<tr class="separator:aa4de83802cdb05bd73882b760a777000"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa49ac19ea37c518db0592dbaf9e6f9b2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#aa49ac19ea37c518db0592dbaf9e6f9b2">bessel_j1</a> (const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> x)</td></tr>
<tr class="memdesc:aa49ac19ea37c518db0592dbaf9e6f9b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bessel function of first kind and order 1.  <a href="#aa49ac19ea37c518db0592dbaf9e6f9b2">More...</a><br /></td></tr>
<tr class="separator:aa49ac19ea37c518db0592dbaf9e6f9b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99c82254ed81e63682342ebb3b8a0a39"><td class="memItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a99c82254ed81e63682342ebb3b8a0a39">bessel_k</a> (const <a class="el" href="namespace_3globalScope_4.html#classint">int</a> <a class="el" href="crystal__ball__plus__exponential_8inl.html#a21f77208d6bc667560ff8aaf8f943b6a">n</a>, const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> x)</td></tr>
<tr class="memdesc:a99c82254ed81e63682342ebb3b8a0a39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modified Bessel function of second kind and order n.  <a href="#a99c82254ed81e63682342ebb3b8a0a39">More...</a><br /></td></tr>
<tr class="separator:a99c82254ed81e63682342ebb3b8a0a39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae823549b0cbc2c65b52c780568d6149f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ae823549b0cbc2c65b52c780568d6149f">bessel_k0</a> (const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> x)</td></tr>
<tr class="memdesc:ae823549b0cbc2c65b52c780568d6149f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modified Bessel function of second kind and order 0.  <a href="#ae823549b0cbc2c65b52c780568d6149f">More...</a><br /></td></tr>
<tr class="separator:ae823549b0cbc2c65b52c780568d6149f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad12f1f40a1a2ea2d50b6fdc3630a60e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#aad12f1f40a1a2ea2d50b6fdc3630a60e">bessel_k1</a> (const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> x)</td></tr>
<tr class="memdesc:aad12f1f40a1a2ea2d50b6fdc3630a60e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modified Bessel function of second kind and order 1.  <a href="#aad12f1f40a1a2ea2d50b6fdc3630a60e">More...</a><br /></td></tr>
<tr class="separator:aad12f1f40a1a2ea2d50b6fdc3630a60e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a050d42bcab45eeac4f9258ea328feb9e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a050d42bcab45eeac4f9258ea328feb9e">bessel_y</a> (const <a class="el" href="namespace_3globalScope_4.html#classint">int</a> <a class="el" href="crystal__ball__plus__exponential_8inl.html#a21f77208d6bc667560ff8aaf8f943b6a">n</a>, const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> x)</td></tr>
<tr class="memdesc:a050d42bcab45eeac4f9258ea328feb9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bessel function of second kind and order n.  <a href="#a050d42bcab45eeac4f9258ea328feb9e">More...</a><br /></td></tr>
<tr class="separator:a050d42bcab45eeac4f9258ea328feb9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a607169f1794b7262c178c13637daceae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a607169f1794b7262c178c13637daceae">bessel_y0</a> (const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> x)</td></tr>
<tr class="memdesc:a607169f1794b7262c178c13637daceae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bessel function of second kind and order 0.  <a href="#a607169f1794b7262c178c13637daceae">More...</a><br /></td></tr>
<tr class="separator:a607169f1794b7262c178c13637daceae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a191a30b1209e25f34f98584dee43e067"><td class="memItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a191a30b1209e25f34f98584dee43e067">bessel_y1</a> (const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> x)</td></tr>
<tr class="memdesc:a191a30b1209e25f34f98584dee43e067"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bessel function of second kind and order 1.  <a href="#a191a30b1209e25f34f98584dee43e067">More...</a><br /></td></tr>
<tr class="separator:a191a30b1209e25f34f98584dee43e067"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabecf2c4fcb00adefa79bd93786ec18b"><td class="memTemplParams" colspan="2">template&lt;typename Iterable &gt; </td></tr>
<tr class="memitem:aabecf2c4fcb00adefa79bd93786ec18b"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; Iterable &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; hydra::thrust::permutation_iterator&lt; decltype(std::declval&lt; Iterable &amp; &gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()), hydra::thrust::transform_iterator&lt; <a class="el" href="structhydra_1_1detail_1_1RndUniform.html">detail::RndUniform</a>&lt; size_t, hydra::thrust::random::default_random_engine &gt;,hydra::thrust::counting_iterator&lt; size_t &gt;, size_t &gt; &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#aabecf2c4fcb00adefa79bd93786ec18b">boost_strapped_range</a> (Iterable &amp;&amp;iterable, size_t seed)</td></tr>
<tr class="separator:aabecf2c4fcb00adefa79bd93786ec18b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39ca77c714b3e8b913c37d323cfd5640"><td class="memItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> Vector4R&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a39ca77c714b3e8b913c37d323cfd5640">boostTo</a> (const Vector4R &amp;rs, const Vector4R &amp;p4, bool inverse=false)</td></tr>
<tr class="separator:a39ca77c714b3e8b913c37d323cfd5640"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c1de9e4fabdb747b9e3352ef6298476"><td class="memItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> Vector4R&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a1c1de9e4fabdb747b9e3352ef6298476">boostTo</a> (const Vector4R &amp;rs, const Vector3R &amp;boost, bool inverse=false)</td></tr>
<tr class="separator:a1c1de9e4fabdb747b9e3352ef6298476"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa60325f68cb5ff194182e0fb67ce11d6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#aa60325f68cb5ff194182e0fb67ce11d6">chebychev_1st_kind</a> (<a class="el" href="namespace_3globalScope_4.html#classunsigned">unsigned</a> <a class="el" href="crystal__ball__plus__exponential_8inl.html#a21f77208d6bc667560ff8aaf8f943b6a">n</a>, const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> x)</td></tr>
<tr class="memdesc:aa60325f68cb5ff194182e0fb67ce11d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of <a class="el" href="group__common__functions.html#classhydra_1_1Chebychev" title="The Chebyshev polynomials  (first kind) are polynomials with the largest possible leading coefficient...">Chebychev</a> polynomials of first kind \( P_n(n) \) using the recursive relation.  <a href="#aa60325f68cb5ff194182e0fb67ce11d6">More...</a><br /></td></tr>
<tr class="separator:aa60325f68cb5ff194182e0fb67ce11d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89c5073655dc6f793f63d7364e490fde"><td class="memItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a89c5073655dc6f793f63d7364e490fde">chebychev_2nd_kind</a> (<a class="el" href="namespace_3globalScope_4.html#classunsigned">unsigned</a> <a class="el" href="crystal__ball__plus__exponential_8inl.html#a21f77208d6bc667560ff8aaf8f943b6a">n</a>, const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> x)</td></tr>
<tr class="memdesc:a89c5073655dc6f793f63d7364e490fde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of <a class="el" href="group__common__functions.html#classhydra_1_1Chebychev" title="The Chebyshev polynomials  (first kind) are polynomials with the largest possible leading coefficient...">Chebychev</a> polynomials of second kind \( P_n(n) \) using the recursive relation.  <a href="#a89c5073655dc6f793f63d7364e490fde">More...</a><br /></td></tr>
<tr class="separator:a89c5073655dc6f793f63d7364e490fde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58e3aa55839abeda676e6a8ede0902a7"><td class="memTemplParams" colspan="2">template&lt;typename Iterable_Index , typename Iterable_Values &gt; </td></tr>
<tr class="memitem:a58e3aa55839abeda676e6a8ede0902a7"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a58e3aa55839abeda676e6a8ede0902a7">collect</a> (Iterable_Index &amp;indexing_scheme, Iterable_Values &amp;collected_values) -&gt; typename std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; Iterable_Index &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; Iterable_Values &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; hydra::thrust::permutation_iterator&lt; decltype(std::declval&lt; Iterable_Values &amp;&gt;().<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()), decltype(std::declval&lt; Iterable_Index &amp;&gt;().<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>())&gt; &gt;::type</td></tr>
<tr class="separator:a58e3aa55839abeda676e6a8ede0902a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec19ef09aa95bbdb2230bd31d879b94d"><td class="memTemplParams" colspan="2">template&lt;hydra::detail::Backend BACKEND, typename T , size_t N, unsigned int... I&gt; </td></tr>
<tr class="memitem:aec19ef09aa95bbdb2230bd31d879b94d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#aec19ef09aa95bbdb2230bd31d879b94d">columns</a> (<a class="el" href="namespacehydra.html#classhydra_1_1multiarray">multiarray</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt;const &amp;other, <a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;...cls) -&gt; <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; decltype(std::declval&lt; <a class="el" href="namespacehydra.html#classhydra_1_1multiarray">multiarray</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt;const &amp;&gt;().<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;</td></tr>
<tr class="separator:aec19ef09aa95bbdb2230bd31d879b94d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac897e7fcbfbb068d5d29122253491201"><td class="memTemplParams" colspan="2">template&lt;hydra::detail::Backend BACKEND, typename T , size_t N, unsigned int... I&gt; </td></tr>
<tr class="memitem:ac897e7fcbfbb068d5d29122253491201"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ac897e7fcbfbb068d5d29122253491201">columns</a> (<a class="el" href="namespacehydra.html#classhydra_1_1multiarray">multiarray</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; &amp;other, <a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;...cls) -&gt; <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; decltype(std::declval&lt; <a class="el" href="namespacehydra.html#classhydra_1_1multiarray">multiarray</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; &amp;&amp;&gt;().<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;</td></tr>
<tr class="separator:ac897e7fcbfbb068d5d29122253491201"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f66637e61ac9f1a4254b43131f3d450"><td class="memTemplParams" colspan="2">template&lt;hydra::detail::Backend BACKEND, typename ... T, unsigned int... I&gt; </td></tr>
<tr class="memitem:a5f66637e61ac9f1a4254b43131f3d450"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a5f66637e61ac9f1a4254b43131f3d450">columns</a> (<a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; hydra::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt;&gt;const &amp;other, <a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;...cls) -&gt; <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; decltype(std::declval&lt; <a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; hydra::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; const &amp;&gt;().<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;</td></tr>
<tr class="separator:a5f66637e61ac9f1a4254b43131f3d450"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f3ece26d764846bc2f62db61a01cc49"><td class="memTemplParams" colspan="2">template&lt;hydra::detail::Backend BACKEND, typename ... T, unsigned int... I&gt; </td></tr>
<tr class="memitem:a2f3ece26d764846bc2f62db61a01cc49"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a2f3ece26d764846bc2f62db61a01cc49">columns</a> (<a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; hydra::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; &amp;other, <a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;...cls) -&gt; <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; decltype(std::declval&lt; <a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; hydra::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; &amp;&gt;().<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;</td></tr>
<tr class="separator:a2f3ece26d764846bc2f62db61a01cc49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb0c6c5638e245ee1fdb17b516b0a455"><td class="memTemplParams" colspan="2">template&lt;typename Type , hydra::detail::Backend BACKEND, typename ... T&gt; </td></tr>
<tr class="memitem:abb0c6c5638e245ee1fdb17b516b0a455"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#abb0c6c5638e245ee1fdb17b516b0a455">columns</a> (<a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; hydra::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; &amp;other) -&gt; <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; decltype(std::declval&lt; <a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; hydra::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; &amp;&gt;().<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1index__in__tuple">detail::index_in_tuple</a>&lt; Type, hydra::thrust::tuple&lt; T... &gt; &gt;::value &gt;</td></tr>
<tr class="separator:abb0c6c5638e245ee1fdb17b516b0a455"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86c018d960aacf7e0b79a20946aff059"><td class="memTemplParams" colspan="2">template&lt;typename T0 , typename T1 , typename ... Ts&gt; </td></tr>
<tr class="memitem:a86c018d960aacf7e0b79a20946aff059"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;(<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt; T0 &gt;::value||<a class="el" href="structhydra_1_1detail_1_1is__hydra__lambda.html">detail::is_hydra_lambda</a>&lt; T0 &gt;::value) &amp;&amp;(<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt; T1 &gt;::value||<a class="el" href="structhydra_1_1detail_1_1is__hydra__lambda.html">detail::is_hydra_lambda</a>&lt; T1 &gt;::value) &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1all__true.html">detail::all_true</a>&lt;(<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt; Ts &gt;::value||<a class="el" href="structhydra_1_1detail_1_1is__hydra__lambda.html">detail::is_hydra_lambda</a>&lt; Ts &gt;::value)... &gt;::value, <a class="el" href="classhydra_1_1Compose.html">Compose</a>&lt; T0, T1, Ts... &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a86c018d960aacf7e0b79a20946aff059">compose</a> (T0 const &amp;F0, T1 const &amp;F1, Ts const &amp;...Fs)</td></tr>
<tr class="separator:a86c018d960aacf7e0b79a20946aff059"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2ffe3ace108474a31b8cb84ceae7f14"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad2ffe3ace108474a31b8cb84ceae7f14"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespacehydra.html#a9d2c06cb9672fe86dbeaa65e8f35a2bf">complex</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ad2ffe3ace108474a31b8cb84ceae7f14">conj</a> (const <a class="el" href="namespacehydra.html#a9d2c06cb9672fe86dbeaa65e8f35a2bf">complex</a>&lt; T &gt; &amp;z)</td></tr>
<tr class="separator:ad2ffe3ace108474a31b8cb84ceae7f14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4de27927128c4f574aa5d2d8715ab58c"><td class="memTemplParams" colspan="2">template&lt;typename Value_Type &gt; </td></tr>
<tr class="memitem:a4de27927128c4f574aa5d2d8715ab58c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; hydra::thrust::constant_iterator&lt; Value_Type &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a4de27927128c4f574aa5d2d8715ab58c">constant_range</a> (const Value_Type &amp;value)</td></tr>
<tr class="separator:a4de27927128c4f574aa5d2d8715ab58c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade5b435c4a37bbda1d67cd8fe18b526f"><td class="memTemplParams" colspan="2">template&lt;detail::Backend BACKEND, detail::FFTCalculator FFTBackend, typename Functor , typename Kernel , typename Iterable , typename T  = typename detail::stripped_type&lt;typename hydra::thrust::iterator_traits&lt;decltype(std::declval&lt;Iterable&gt;().begin())&gt;::value_type&gt;::type, typename USING_CUDA_BACKEND  = typename std::conditional&lt; std::is_convertible&lt;detail::BackendPolicy&lt;BACKEND&gt;,hydra::thrust::system::cuda::tag &gt;::value, std::integral_constant&lt;int, 1&gt;,std::integral_constant&lt;int, 0&gt;&gt;::type, typename USING_CUFFT  = typename std::conditional&lt; FFTBackend==detail::CuFFT, std::integral_constant&lt;int, 1&gt;,std::integral_constant&lt;int, 0&gt;&gt;::type, typename GPU_DATA  = typename std::conditional&lt; std::is_convertible&lt;typename hydra::thrust::iterator_system&lt; decltype(std::declval&lt;Iterable&gt;().begin())&gt;::type, hydra::thrust::system::cuda::tag&gt;::value , std::integral_constant&lt;int, 1&gt;, std::integral_constant&lt;int, 0&gt; &gt;::type&gt; </td></tr>
<tr class="memitem:ade5b435c4a37bbda1d67cd8fe18b526f"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_floating_point&lt; T &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; Iterable &gt;::value,void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ade5b435c4a37bbda1d67cd8fe18b526f">convolute</a> (<a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt; policy, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1FFTPolicy">detail::FFTPolicy</a>&lt; T, FFTBackend &gt; fft_policy, Functor const &amp;functor, Kernel const &amp;kernel, T <a class="el" href="particle__mass_8inl.html#aad36546e8175d2922bee165fe028fedc">min</a>, T <a class="el" href="particle__mass_8inl.html#a0b0ede69e8156eb97acc579b88e883de">max</a>, Iterable &amp;&amp;output, bool power_up=true)</td></tr>
<tr class="separator:ade5b435c4a37bbda1d67cd8fe18b526f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b928198a46f83eb9d2793e8e079ba5a"><td class="memTemplParams" colspan="2">template&lt;typename Iterable_Source , typename Iterable_Target &gt; </td></tr>
<tr class="memitem:a0b928198a46f83eb9d2793e8e079ba5a"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; Iterable_Source &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; Iterable_Target &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; decltype(std::declval&lt; Iterable_Target &amp; &gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>())&gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a0b928198a46f83eb9d2793e8e079ba5a">copy</a> (Iterable_Source &amp;&amp;source, Iterable_Target &amp;&amp;destination)</td></tr>
<tr class="separator:a0b928198a46f83eb9d2793e8e079ba5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28aa8ffeea73bf98ccab0fb7cd1c8116"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename OutputIterator &gt; </td></tr>
<tr class="memitem:a28aa8ffeea73bf98ccab0fb7cd1c8116"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a28aa8ffeea73bf98ccab0fb7cd1c8116">copy</a> (InputIterator first, InputIterator last, OutputIterator result)</td></tr>
<tr class="separator:a28aa8ffeea73bf98ccab0fb7cd1c8116"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98b97d9c4a1b0350ef7c2d646c8c504a"><td class="memTemplParams" colspan="2">template&lt;detail::Backend Backend, typename InputIterator , typename OutputIterator &gt; </td></tr>
<tr class="memitem:a98b97d9c4a1b0350ef7c2d646c8c504a"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a98b97d9c4a1b0350ef7c2d646c8c504a">copy</a> (<a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; Backend &gt; const &amp;policy, InputIterator first, InputIterator last, OutputIterator result)</td></tr>
<tr class="separator:a98b97d9c4a1b0350ef7c2d646c8c504a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82497912f037617b630d048bfcc515c0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a82497912f037617b630d048bfcc515c0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespacehydra.html#a9d2c06cb9672fe86dbeaa65e8f35a2bf">complex</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a82497912f037617b630d048bfcc515c0">cos</a> (const <a class="el" href="namespacehydra.html#a9d2c06cb9672fe86dbeaa65e8f35a2bf">complex</a>&lt; T &gt; &amp;z)</td></tr>
<tr class="separator:a82497912f037617b630d048bfcc515c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9aa7456a15f61cd1ed2b5ef7227409e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac9aa7456a15f61cd1ed2b5ef7227409e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespacehydra.html#a9d2c06cb9672fe86dbeaa65e8f35a2bf">complex</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ac9aa7456a15f61cd1ed2b5ef7227409e">cosh</a> (const <a class="el" href="namespacehydra.html#a9d2c06cb9672fe86dbeaa65e8f35a2bf">complex</a>&lt; T &gt; &amp;z)</td></tr>
<tr class="separator:ac9aa7456a15f61cd1ed2b5ef7227409e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d55d71b4eca1da2fac83a615ea4b990"><td class="memItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> Vector3R&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a6d55d71b4eca1da2fac83a615ea4b990">cross</a> (const Vector3R &amp;p1, const Vector3R &amp;p2)</td></tr>
<tr class="separator:a6d55d71b4eca1da2fac83a615ea4b990"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f97451ec9f21c866bbe94c68c4b985e"><td class="memTemplParams" colspan="2">template&lt;typename Iterator &gt; </td></tr>
<tr class="memitem:a6f97451ec9f21c866bbe94c68c4b985e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a6f97451ec9f21c866bbe94c68c4b985e">distance</a> (Iterator first, Iterator last) -&gt; decltype(hydra::thrust::distance&lt; Iterator &gt;(first, last))</td></tr>
<tr class="separator:a6f97451ec9f21c866bbe94c68c4b985e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6afbe062f479abb939d72e60c387ff05"><td class="memTemplParams" colspan="2">template&lt;typename F1 , typename F2 , typename ... Fs&gt; </td></tr>
<tr class="memitem:a6afbe062f479abb939d72e60c387ff05"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;(<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt; F1 &gt;::value||<a class="el" href="structhydra_1_1detail_1_1is__hydra__lambda.html">detail::is_hydra_lambda</a>&lt; F1 &gt;::value) &amp;&amp;(<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt; F2 &gt;::value||<a class="el" href="structhydra_1_1detail_1_1is__hydra__lambda.html">detail::is_hydra_lambda</a>&lt; F2 &gt;::value), <a class="el" href="classhydra_1_1Divide.html">Divide</a>&lt; F1, F2 &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a6afbe062f479abb939d72e60c387ff05">divide</a> (F1 const &amp;f1, F2 const &amp;f2)</td></tr>
<tr class="separator:a6afbe062f479abb939d72e60c387ff05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4274268d147e9a988f379326b73682b0"><td class="memTemplParams" colspan="2">template&lt;class C &gt; </td></tr>
<tr class="memitem:a4274268d147e9a988f379326b73682b0"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a4274268d147e9a988f379326b73682b0">end</a> (const <a class="el" href="basic__distributions_8inl.html#a4900ef306eb9271438791f1a98b8ccba">C</a> &amp;c) -&gt; decltype(c.end())</td></tr>
<tr class="separator:a4274268d147e9a988f379326b73682b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d1cd86c2f2c422730b87a5890dbaee3"><td class="memTemplParams" colspan="2">template&lt;class C &gt; </td></tr>
<tr class="memitem:a1d1cd86c2f2c422730b87a5890dbaee3"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a1d1cd86c2f2c422730b87a5890dbaee3">end</a> (<a class="el" href="basic__distributions_8inl.html#a4900ef306eb9271438791f1a98b8ccba">C</a> &amp;&amp;c) -&gt; decltype(std::forward&lt; <a class="el" href="basic__distributions_8inl.html#a4900ef306eb9271438791f1a98b8ccba">C</a> &gt;(c).end())</td></tr>
<tr class="separator:a1d1cd86c2f2c422730b87a5890dbaee3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e7ed93e81eae920f0c85fea012dc23c"><td class="memTemplParams" colspan="2">template&lt;class T , size_t N&gt; </td></tr>
<tr class="memitem:a3e7ed93e81eae920f0c85fea012dc23c"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a3e7ed93e81eae920f0c85fea012dc23c">end</a> (T(&amp;array)[N])</td></tr>
<tr class="separator:a3e7ed93e81eae920f0c85fea012dc23c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03f64a7db637f2f1865093311d69f0bc"><td class="memTemplParams" colspan="2">template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename T , size_t N&gt; </td></tr>
<tr class="memitem:a03f64a7db637f2f1865093311d69f0bc"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a03f64a7db637f2f1865093311d69f0bc">end</a> (<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;, <a class="el" href="namespacehydra.html#classhydra_1_1multiarray">multiarray</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; const &amp;other) -&gt; decltype(other.end(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;</td></tr>
<tr class="separator:a03f64a7db637f2f1865093311d69f0bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab07ef1a981144fec2ec0227a346bedf8"><td class="memTemplParams" colspan="2">template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename T , size_t N&gt; </td></tr>
<tr class="memitem:ab07ef1a981144fec2ec0227a346bedf8"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ab07ef1a981144fec2ec0227a346bedf8">end</a> (<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;, <a class="el" href="namespacehydra.html#classhydra_1_1multiarray">multiarray</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; &amp;other) -&gt; decltype(other.end(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;</td></tr>
<tr class="separator:ab07ef1a981144fec2ec0227a346bedf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a149ddb5e1cfb584bb8f0c680f6413917"><td class="memTemplParams" colspan="2">template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename ... T&gt; </td></tr>
<tr class="memitem:a149ddb5e1cfb584bb8f0c680f6413917"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a149ddb5e1cfb584bb8f0c680f6413917">end</a> (<a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; hydra::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; const &amp;other) -&gt; decltype(other.end(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;</td></tr>
<tr class="separator:a149ddb5e1cfb584bb8f0c680f6413917"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e410df30c5ed179d15ebab858960584"><td class="memTemplParams" colspan="2">template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename ... T&gt; </td></tr>
<tr class="memitem:a3e410df30c5ed179d15ebab858960584"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a3e410df30c5ed179d15ebab858960584">end</a> (<a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; hydra::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; &amp;other) -&gt; decltype(other.end(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;</td></tr>
<tr class="separator:a3e410df30c5ed179d15ebab858960584"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a9d4c5b0ed8b81a1ddc80ac67189b6f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> long <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a5a9d4c5b0ed8b81a1ddc80ac67189b6f">erfinv</a> (<a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> x)</td></tr>
<tr class="separator:a5a9d4c5b0ed8b81a1ddc80ac67189b6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadea4fcd2b0a13095c4408fbee01c2c72"><td class="memTemplParams" colspan="2">template&lt;hydra::detail::Backend BACKEND, typename Iterator , typename Functor &gt; </td></tr>
<tr class="memitem:gadea4fcd2b0a13095c4408fbee01c2c72"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__generic.html#gadea4fcd2b0a13095c4408fbee01c2c72">eval</a> (<a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt;, Functor const  &amp;functor, Iterator <a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>, Iterator <a class="el" href="namespacehydra.html#a4274268d147e9a988f379326b73682b0">end</a>) -&gt; typename <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt;::template container&lt; typename Functor::return_type &gt;</td></tr>
<tr class="memdesc:gadea4fcd2b0a13095c4408fbee01c2c72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate a hydra functor on a range using the parallel policy.  <a href="group__generic.html#gadea4fcd2b0a13095c4408fbee01c2c72">More...</a><br /></td></tr>
<tr class="separator:gadea4fcd2b0a13095c4408fbee01c2c72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a17d8f289e951a4e6db944ffe7810df"><td class="memTemplParams" colspan="2">template&lt;hydra::detail::Backend BACKEND, typename Iterator , typename ... Functors&gt; </td></tr>
<tr class="memitem:ga0a17d8f289e951a4e6db944ffe7810df"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__generic.html#ga0a17d8f289e951a4e6db944ffe7810df">eval</a> (<a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt;,hydra::thrust::tuple&lt; Functors... &gt; const  &amp;functors, Iterator <a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>, Iterator <a class="el" href="namespacehydra.html#a4274268d147e9a988f379326b73682b0">end</a>) -&gt; <a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; hydra::thrust::tuple&lt; typename Functors::return_type ... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt;&gt;</td></tr>
<tr class="memdesc:ga0a17d8f289e951a4e6db944ffe7810df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate a tuple of hydra functors on a range using the parallel policy.  <a href="group__generic.html#ga0a17d8f289e951a4e6db944ffe7810df">More...</a><br /></td></tr>
<tr class="separator:ga0a17d8f289e951a4e6db944ffe7810df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8564abe3d04aa014ba0a6a40e6c5d599"><td class="memTemplParams" colspan="2">template&lt;hydra::detail::Backend BACKEND, typename Functor , typename Iterator , typename ... Iterators&gt; </td></tr>
<tr class="memitem:ga8564abe3d04aa014ba0a6a40e6c5d599"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__generic.html#ga8564abe3d04aa014ba0a6a40e6c5d599">eval</a> (<a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt;, Functor const  &amp;functor, Iterator <a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>, Iterator <a class="el" href="namespacehydra.html#a4274268d147e9a988f379326b73682b0">end</a>, Iterators... begins) -&gt; typename <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt;::template container&lt; typename Functor::return_type &gt;</td></tr>
<tr class="memdesc:ga8564abe3d04aa014ba0a6a40e6c5d599"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate a functor over a list of ranges.  <a href="group__generic.html#ga8564abe3d04aa014ba0a6a40e6c5d599">More...</a><br /></td></tr>
<tr class="separator:ga8564abe3d04aa014ba0a6a40e6c5d599"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga652c2803a7acd9d917a76900150e99dc"><td class="memTemplParams" colspan="2">template&lt;hydra::detail::Backend BACKEND, typename Iterator , typename ... Iterators, typename ... Functors&gt; </td></tr>
<tr class="memitem:ga652c2803a7acd9d917a76900150e99dc"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__generic.html#ga652c2803a7acd9d917a76900150e99dc">eval</a> (<a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt;, hydra::thrust::tuple&lt; Functors... &gt; const  &amp;functors, Iterator <a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>, Iterator <a class="el" href="namespacehydra.html#a4274268d147e9a988f379326b73682b0">end</a>, Iterators... begins) -&gt; <a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; hydra::thrust::tuple&lt; typename Functors::return_type ... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;</td></tr>
<tr class="memdesc:ga652c2803a7acd9d917a76900150e99dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate a tuple of functors over a list of ranges.  <a href="group__generic.html#ga652c2803a7acd9d917a76900150e99dc">More...</a><br /></td></tr>
<tr class="separator:ga652c2803a7acd9d917a76900150e99dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5acb87c4eb594ddbf0c4322a11cf4d8a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5acb87c4eb594ddbf0c4322a11cf4d8a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespacehydra.html#a9d2c06cb9672fe86dbeaa65e8f35a2bf">complex</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a5acb87c4eb594ddbf0c4322a11cf4d8a">exp</a> (const <a class="el" href="namespacehydra.html#a9d2c06cb9672fe86dbeaa65e8f35a2bf">complex</a>&lt; T &gt; &amp;z)</td></tr>
<tr class="separator:a5acb87c4eb594ddbf0c4322a11cf4d8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d88d9e0baa81e633c5eb3f455a57221"><td class="memTemplParams" colspan="2">template&lt;typename Engine , hydra::detail::Backend BACKEND, typename Iterator , typename FUNCTOR &gt; </td></tr>
<tr class="memitem:a9d88d9e0baa81e633c5eb3f455a57221"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1has__rng__formula.html">hydra::detail::has_rng_formula</a>&lt; FUNCTOR &gt;::value &amp;&amp;std::is_convertible&lt; decltype(std::declval&lt; <a class="el" href="classhydra_1_1RngFormula.html">RngFormula</a>&lt; FUNCTOR &gt; &gt;).<a class="el" href="phsp__unweighting_8inl.html#aae0754269ece74173f4afd72643b7e3e">Generate</a>(std::declval&lt; Engine &amp; &gt;), std::declval&lt; FUNCTOR const  &amp; &gt;))), typename hydra::thrust::iterator_traits&lt; Iterator &gt;::value_type &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a9d88d9e0baa81e633c5eb3f455a57221">fill_random</a> (<a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; const &amp;policy, Iterator <a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>, Iterator <a class="el" href="namespacehydra.html#a4274268d147e9a988f379326b73682b0">end</a>, FUNCTOR const &amp;functor, size_t seed, size_t rng_jump)</td></tr>
<tr class="memdesc:a9d88d9e0baa81e633c5eb3f455a57221"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill a range with numbers distributed according a user defined distribution using a RNG analytical formula.  <a href="#a9d88d9e0baa81e633c5eb3f455a57221">More...</a><br /></td></tr>
<tr class="separator:a9d88d9e0baa81e633c5eb3f455a57221"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga64b2d1486052fdd0ecf8e48ef9cb89d6"><td class="memTemplParams" colspan="2">template&lt;typename Engine , typename Iterator , typename FUNCTOR &gt; </td></tr>
<tr class="memitem:ga64b2d1486052fdd0ecf8e48ef9cb89d6"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1has__rng__formula.html">hydra::detail::has_rng_formula</a>&lt; FUNCTOR &gt;::value &amp;&amp;std::is_convertible&lt; decltype(std::declval&lt; <a class="el" href="classhydra_1_1RngFormula.html">RngFormula</a>&lt; FUNCTOR &gt; &gt;).<a class="el" href="phsp__unweighting_8inl.html#aae0754269ece74173f4afd72643b7e3e">Generate</a>(std::declval&lt; Engine &amp; &gt;), std::declval&lt; FUNCTOR const  &amp; &gt;))), typename hydra::thrust::iterator_traits&lt; Iterator &gt;::value_type &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ga64b2d1486052fdd0ecf8e48ef9cb89d6">fill_random</a> (Iterator <a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>, Iterator <a class="el" href="namespacehydra.html#a4274268d147e9a988f379326b73682b0">end</a>, FUNCTOR const &amp;functor, size_t seed, size_t rng_jump)</td></tr>
<tr class="memdesc:ga64b2d1486052fdd0ecf8e48ef9cb89d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill a range with numbers distributed according a user defined distribution using a RNG analytical formula.  <a href="#ga64b2d1486052fdd0ecf8e48ef9cb89d6">More...</a><br /></td></tr>
<tr class="separator:ga64b2d1486052fdd0ecf8e48ef9cb89d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga17ea099eedec5a25a96e3309b81f6a6f"><td class="memTemplParams" colspan="2">template&lt;typename Engine , hydra::detail::Backend BACKEND, typename Iterable , typename FUNCTOR &gt; </td></tr>
<tr class="memitem:ga17ea099eedec5a25a96e3309b81f6a6f"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1random_1_1is__matching__iterable.html">detail::random::is_matching_iterable</a>&lt; Engine, FUNCTOR, Iterable &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__random.html#ga17ea099eedec5a25a96e3309b81f6a6f">fill_random</a> (<a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; const &amp;policy, Iterable &amp;&amp;iterable, FUNCTOR const &amp;functor, size_t seed, size_t rng_jump)</td></tr>
<tr class="memdesc:ga17ea099eedec5a25a96e3309b81f6a6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill a range with numbers distributed according a user defined distribution.  <a href="group__random.html#ga17ea099eedec5a25a96e3309b81f6a6f">More...</a><br /></td></tr>
<tr class="separator:ga17ea099eedec5a25a96e3309b81f6a6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24cdf95f73d3c78402bef84e0406a9b3"><td class="memTemplParams" colspan="2">template&lt;typename Engine , typename Iterable , typename FUNCTOR &gt; </td></tr>
<tr class="memitem:ga24cdf95f73d3c78402bef84e0406a9b3"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1random_1_1is__matching__iterable.html">detail::random::is_matching_iterable</a>&lt; Engine, FUNCTOR, Iterable &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__random.html#ga24cdf95f73d3c78402bef84e0406a9b3">fill_random</a> (Iterable &amp;&amp;iterable, FUNCTOR const &amp;functor, size_t seed, size_t rng_jump)</td></tr>
<tr class="memdesc:ga24cdf95f73d3c78402bef84e0406a9b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill a range with numbers distributed according a user defined distribution.  <a href="group__random.html#ga24cdf95f73d3c78402bef84e0406a9b3">More...</a><br /></td></tr>
<tr class="separator:ga24cdf95f73d3c78402bef84e0406a9b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga108c406782cf2d5b6b5c71aa876178ba"><td class="memTemplParams" colspan="2">template&lt;typename Engine , hydra::detail::Backend BACKEND, typename Iterator , typename FUNCTOR &gt; </td></tr>
<tr class="memitem:ga108c406782cf2d5b6b5c71aa876178ba"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; !<a class="el" href="structhydra_1_1detail_1_1has__rng__formula.html">hydra::detail::has_rng_formula</a>&lt; FUNCTOR &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__random.html#ga108c406782cf2d5b6b5c71aa876178ba">fill_random</a> (<a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; const &amp;policy, Iterator <a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>, Iterator <a class="el" href="namespacehydra.html#a4274268d147e9a988f379326b73682b0">end</a>, FUNCTOR const &amp;functor, size_t seed, size_t rng_jump)</td></tr>
<tr class="memdesc:ga108c406782cf2d5b6b5c71aa876178ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fall back function if <a class="el" href="classhydra_1_1RngFormula.html">RngFormula</a> is not implemented for the requested functor.  <a href="group__random.html#ga108c406782cf2d5b6b5c71aa876178ba">More...</a><br /></td></tr>
<tr class="separator:ga108c406782cf2d5b6b5c71aa876178ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga64b2d1486052fdd0ecf8e48ef9cb89d6"><td class="memTemplParams" colspan="2">template&lt;typename Engine , typename Iterator , typename FUNCTOR &gt; </td></tr>
<tr class="memitem:ga64b2d1486052fdd0ecf8e48ef9cb89d6"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; !<a class="el" href="structhydra_1_1detail_1_1has__rng__formula.html">hydra::detail::has_rng_formula</a>&lt; FUNCTOR &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__random.html#ga64b2d1486052fdd0ecf8e48ef9cb89d6">fill_random</a> (Iterator <a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>, Iterator <a class="el" href="namespacehydra.html#a4274268d147e9a988f379326b73682b0">end</a>, FUNCTOR const &amp;functor, size_t seed, size_t rng_jump)</td></tr>
<tr class="memdesc:ga64b2d1486052fdd0ecf8e48ef9cb89d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fall back function if <a class="el" href="classhydra_1_1RngFormula.html">RngFormula</a> is not implemented for the requested functor.  <a href="group__random.html#ga64b2d1486052fdd0ecf8e48ef9cb89d6">More...</a><br /></td></tr>
<tr class="separator:ga64b2d1486052fdd0ecf8e48ef9cb89d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga108c406782cf2d5b6b5c71aa876178ba"><td class="memTemplParams" colspan="2">template&lt;typename Engine , hydra::detail::Backend BACKEND, typename Iterator , typename FUNCTOR &gt; </td></tr>
<tr class="memitem:ga108c406782cf2d5b6b5c71aa876178ba"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; !std::is_convertible&lt; decltype(std::declval&lt; <a class="el" href="classhydra_1_1RngFormula.html">RngFormula</a>&lt; FUNCTOR &gt; &gt;).<a class="el" href="phsp__unweighting_8inl.html#aae0754269ece74173f4afd72643b7e3e">Generate</a>(std::declval&lt; Engine &amp; &gt;), std::declval&lt; FUNCTOR const  &amp; &gt;))), typename std::iterator_traits&lt; Iterator &gt;::value_type &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1has__rng__formula.html">hydra::detail::has_rng_formula</a>&lt; FUNCTOR &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ga108c406782cf2d5b6b5c71aa876178ba">fill_random</a> (<a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; const &amp;policy, Iterator <a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>, Iterator <a class="el" href="namespacehydra.html#a4274268d147e9a988f379326b73682b0">end</a>, FUNCTOR const &amp;funct, size_t seed, size_t rng_jump)</td></tr>
<tr class="memdesc:ga108c406782cf2d5b6b5c71aa876178ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fall back function if RngFormula::Generate() return value is not convertible to functor return value.  <a href="#ga108c406782cf2d5b6b5c71aa876178ba">More...</a><br /></td></tr>
<tr class="separator:ga108c406782cf2d5b6b5c71aa876178ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga64b2d1486052fdd0ecf8e48ef9cb89d6"><td class="memTemplParams" colspan="2">template&lt;typename Engine , typename Iterator , typename FUNCTOR &gt; </td></tr>
<tr class="memitem:ga64b2d1486052fdd0ecf8e48ef9cb89d6"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; !std::is_convertible&lt; decltype(std::declval&lt; <a class="el" href="classhydra_1_1RngFormula.html">RngFormula</a>&lt; FUNCTOR &gt; &gt;).<a class="el" href="phsp__unweighting_8inl.html#aae0754269ece74173f4afd72643b7e3e">Generate</a>(std::declval&lt; Engine &amp; &gt;), std::declval&lt; FUNCTOR const  &amp; &gt;))), typename std::iterator_traits&lt; Iterator &gt;::value_type &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1has__rng__formula.html">hydra::detail::has_rng_formula</a>&lt; FUNCTOR &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ga64b2d1486052fdd0ecf8e48ef9cb89d6">fill_random</a> (Iterator <a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>, Iterator <a class="el" href="namespacehydra.html#a4274268d147e9a988f379326b73682b0">end</a>, FUNCTOR const &amp;funct, size_t seed, size_t rng_jump)</td></tr>
<tr class="memdesc:ga64b2d1486052fdd0ecf8e48ef9cb89d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fall back function if RngFormula::Generate() return value is not convertible to functor return value.  <a href="#ga64b2d1486052fdd0ecf8e48ef9cb89d6">More...</a><br /></td></tr>
<tr class="separator:ga64b2d1486052fdd0ecf8e48ef9cb89d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga17ea099eedec5a25a96e3309b81f6a6f"><td class="memTemplParams" colspan="2">template&lt;typename Engine , hydra::detail::Backend BACKEND, typename Iterable , typename FUNCTOR &gt; </td></tr>
<tr class="memitem:ga17ea099eedec5a25a96e3309b81f6a6f"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; !(<a class="el" href="structhydra_1_1detail_1_1random_1_1is__matching__iterable.html">detail::random::is_matching_iterable</a>&lt; Engine, FUNCTOR, Iterable &gt;::value), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ga17ea099eedec5a25a96e3309b81f6a6f">fill_random</a> (<a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; const &amp;policy, Iterable &amp;&amp;iterable, FUNCTOR const &amp;functor, size_t seed, size_t rng_jump)</td></tr>
<tr class="memdesc:ga17ea099eedec5a25a96e3309b81f6a6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fall back function if the argument is not an Iterable or if it is not convertible to the Functor return value.  <a href="#ga17ea099eedec5a25a96e3309b81f6a6f">More...</a><br /></td></tr>
<tr class="separator:ga17ea099eedec5a25a96e3309b81f6a6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24cdf95f73d3c78402bef84e0406a9b3"><td class="memTemplParams" colspan="2">template&lt;typename Engine , typename Iterable , typename FUNCTOR &gt; </td></tr>
<tr class="memitem:ga24cdf95f73d3c78402bef84e0406a9b3"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;!<a class="el" href="structhydra_1_1detail_1_1random_1_1is__matching__iterable.html">detail::random::is_matching_iterable</a>&lt; Engine, FUNCTOR, Iterable &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__random.html#ga24cdf95f73d3c78402bef84e0406a9b3">fill_random</a> (Iterable &amp;&amp;iterable, FUNCTOR const &amp;functor, size_t seed, size_t rng_jump)</td></tr>
<tr class="memdesc:ga24cdf95f73d3c78402bef84e0406a9b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fall back function if the argument is not an Iterable or if it is not convertible to the Functor return value.  <a href="group__random.html#ga24cdf95f73d3c78402bef84e0406a9b3">More...</a><br /></td></tr>
<tr class="separator:ga24cdf95f73d3c78402bef84e0406a9b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24cdf95f73d3c78402bef84e0406a9b3"><td class="memTemplParams" colspan="2">template&lt;typename Engine  = hydra::default_random_engine, typename Iterable , typename FUNCTOR &gt; </td></tr>
<tr class="memitem:ga24cdf95f73d3c78402bef84e0406a9b3"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;!(<a class="el" href="structhydra_1_1detail_1_1random_1_1is__matching__iterable.html">detail::random::is_matching_iterable</a>&lt; Engine, FUNCTOR, Iterable &gt;::value), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__random.html#ga24cdf95f73d3c78402bef84e0406a9b3">fill_random</a> (Iterable &amp;&amp;iterable, FUNCTOR const &amp;functor, size_t seed=0x254a0afcf7da74a2, size_t rng_jump=0)</td></tr>
<tr class="memdesc:ga24cdf95f73d3c78402bef84e0406a9b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fall back function if the argument is not an Iterable or if itis not convertible to the Functor return value.  <a href="group__random.html#ga24cdf95f73d3c78402bef84e0406a9b3">More...</a><br /></td></tr>
<tr class="separator:ga24cdf95f73d3c78402bef84e0406a9b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab0cc380e55d7f4d02106a74165f7162"><td class="memTemplParams" colspan="2">template&lt;typename Iterable , typename Functor &gt; </td></tr>
<tr class="memitem:aab0cc380e55d7f4d02106a74165f7162"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; Iterable &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1Range">hydra::Range</a>&lt; decltype(std::declval&lt; Iterable &gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>())&gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#aab0cc380e55d7f4d02106a74165f7162">filter</a> (Iterable &amp;&amp;container, Functor &amp;&amp;filter)</td></tr>
<tr class="separator:aab0cc380e55d7f4d02106a74165f7162"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10d99a671eb993b054706c645b533533"><td class="memTemplParams" colspan="2">template&lt;typename Iterable , typename Functor &gt; </td></tr>
<tr class="memitem:a10d99a671eb993b054706c645b533533"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; Iterable &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1Range">hydra::Range</a>&lt; decltype(std::declval&lt; Iterable &gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>())&gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a10d99a671eb993b054706c645b533533">filter</a> (Iterable &amp;&amp;container, Functor const &amp;filter)</td></tr>
<tr class="memdesc:a10d99a671eb993b054706c645b533533"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a filter to the range [first, last] and return a pair of iterators for the filtered events.  <a href="#a10d99a671eb993b054706c645b533533">More...</a><br /></td></tr>
<tr class="separator:a10d99a671eb993b054706c645b533533"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab056ed3df61b0755f67d96f8537c657f"><td class="memTemplParams" colspan="2">template&lt;typename Iterable , typename Functor &gt; </td></tr>
<tr class="memitem:ab056ed3df61b0755f67d96f8537c657f"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; Iterable &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; decltype(std::declval&lt; Iterable &amp; &gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>())&gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ab056ed3df61b0755f67d96f8537c657f">for_each</a> (Iterable &amp;&amp;iterable, Functor const &amp;functor)</td></tr>
<tr class="separator:ab056ed3df61b0755f67d96f8537c657f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae76012f51e751385a4a326ab68c01caf"><td class="memTemplParams" colspan="2">template&lt;class ... T&gt; </td></tr>
<tr class="memitem:ae76012f51e751385a4a326ab68c01caf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ae76012f51e751385a4a326ab68c01caf">forward_as_tuple</a> (T &amp;&amp;...t) -&gt; decltype(hydra::thrust::forward_as_tuple(std::forward&lt; T &gt;(t)...))</td></tr>
<tr class="memdesc:ae76012f51e751385a4a326ab68c01caf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a tuple of references to the arguments in args suitable for forwarding as an argument to a function.  <a href="#ae76012f51e751385a4a326ab68c01caf">More...</a><br /></td></tr>
<tr class="separator:ae76012f51e751385a4a326ab68c01caf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75feeef216747fa3b7c90b590f2761e8"><td class="memTemplParams" colspan="2">template&lt;typename Iterable_Source , typename Iterable_Target , typename Iterable_Map &gt; </td></tr>
<tr class="memitem:a75feeef216747fa3b7c90b590f2761e8"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; Iterable_Source &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; Iterable_Target &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; Iterable_Map &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; decltype(std::declval&lt; Iterable_Target &amp; &gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>())&gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a75feeef216747fa3b7c90b590f2761e8">gather</a> (Iterable_Source &amp;&amp;source, Iterable_Map &amp;&amp;map, Iterable_Target &amp;&amp;target)</td></tr>
<tr class="separator:a75feeef216747fa3b7c90b590f2761e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac71b87e64d6dbb15c41c8f77e95a8072"><td class="memTemplParams" colspan="2">template&lt;int I, int N, typename T &gt; </td></tr>
<tr class="memitem:ac71b87e64d6dbb15c41c8f77e95a8072"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ac71b87e64d6dbb15c41c8f77e95a8072">get</a> (T(&amp;array)[N])</td></tr>
<tr class="separator:ac71b87e64d6dbb15c41c8f77e95a8072"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a048ae1166f9c2988a3d1933b0a3843d7"><td class="memTemplParams" colspan="2">template&lt;int I, typename T &gt; </td></tr>
<tr class="memitem:a048ae1166f9c2988a3d1933b0a3843d7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a048ae1166f9c2988a3d1933b0a3843d7">get</a> (T *array)</td></tr>
<tr class="separator:a048ae1166f9c2988a3d1933b0a3843d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a814bb5809cacd8d37e09352725352022"><td class="memTemplParams" colspan="2">template&lt;typename Type , typename ... T&gt; </td></tr>
<tr class="memitem:a814bb5809cacd8d37e09352725352022"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> Type &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a814bb5809cacd8d37e09352725352022">get</a> (hydra::thrust::tuple&lt; T... &gt; const &amp;t)</td></tr>
<tr class="memdesc:a814bb5809cacd8d37e09352725352022"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <code>get</code> function returns a reference to a <code>tuple</code> element of interest.  <a href="#a814bb5809cacd8d37e09352725352022">More...</a><br /></td></tr>
<tr class="separator:a814bb5809cacd8d37e09352725352022"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb26cae3e192ca17f5d682bfc8007fa9"><td class="memTemplParams" colspan="2">template&lt;int N, typename ... T&gt; </td></tr>
<tr class="memitem:afb26cae3e192ca17f5d682bfc8007fa9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> const hydra::thrust::tuple_element&lt; N, hydra::thrust::tuple&lt; T... &gt; &gt;::type &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#afb26cae3e192ca17f5d682bfc8007fa9">get</a> (hydra::thrust::tuple&lt; T... &gt; const &amp;t)</td></tr>
<tr class="separator:afb26cae3e192ca17f5d682bfc8007fa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a91b6f5a6e8ace5a456c5674c3bc648"><td class="memTemplParams" colspan="2">template&lt;typename Type , typename ... T&gt; </td></tr>
<tr class="memitem:a3a91b6f5a6e8ace5a456c5674c3bc648"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> Type &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a3a91b6f5a6e8ace5a456c5674c3bc648">get</a> (hydra::thrust::tuple&lt; T... &gt; &amp;t)</td></tr>
<tr class="separator:a3a91b6f5a6e8ace5a456c5674c3bc648"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af73fcb34d196900b763588aa3e47fd63"><td class="memTemplParams" colspan="2">template&lt;int N, typename ... T&gt; </td></tr>
<tr class="memitem:af73fcb34d196900b763588aa3e47fd63"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::tuple_element&lt; N, hydra::thrust::tuple&lt; T... &gt; &gt;::type &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#af73fcb34d196900b763588aa3e47fd63">get</a> (hydra::thrust::tuple&lt; T... &gt; &amp;t)</td></tr>
<tr class="separator:af73fcb34d196900b763588aa3e47fd63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca9a5101a5abdfded954a3ccc77c0fb0"><td class="memTemplParams" colspan="2">template&lt;typename Type , typename ... T&gt; </td></tr>
<tr class="memitem:aca9a5101a5abdfded954a3ccc77c0fb0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> Type &amp;&amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#aca9a5101a5abdfded954a3ccc77c0fb0">get</a> (hydra::thrust::tuple&lt; T... &gt; &amp;&amp;t)</td></tr>
<tr class="separator:aca9a5101a5abdfded954a3ccc77c0fb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0b90037b5e239de92e89e0e6f8e04e9"><td class="memTemplParams" colspan="2">template&lt;int N, typename ... T&gt; </td></tr>
<tr class="memitem:ab0b90037b5e239de92e89e0e6f8e04e9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::tuple_element&lt; N, hydra::thrust::tuple&lt; T... &gt; &gt;::type &amp;&amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ab0b90037b5e239de92e89e0e6f8e04e9">get</a> (hydra::thrust::tuple&lt; T... &gt; &amp;&amp;t)</td></tr>
<tr class="separator:ab0b90037b5e239de92e89e0e6f8e04e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ff947d6f9d1df1e747890d127bcb5c3"><td class="memTemplParams" colspan="2">template&lt;int N, typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a8ff947d6f9d1df1e747890d127bcb5c3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::tuple_element&lt; N, hydra::thrust::pair&lt; T1, T2 &gt; &gt;::type &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a8ff947d6f9d1df1e747890d127bcb5c3">get</a> (hydra::thrust::pair&lt; T1, T2 &gt; &amp;t)</td></tr>
<tr class="separator:a8ff947d6f9d1df1e747890d127bcb5c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adec0d1c7056a5e7cd2a8c01a934bdfa7"><td class="memTemplParams" colspan="2">template&lt;int N, typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:adec0d1c7056a5e7cd2a8c01a934bdfa7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> const hydra::thrust::tuple_element&lt; N, hydra::thrust::pair&lt; T1, T2 &gt; &gt;::type &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#adec0d1c7056a5e7cd2a8c01a934bdfa7">get</a> (hydra::thrust::pair&lt; T1, T2 &gt; const &amp;t)</td></tr>
<tr class="separator:adec0d1c7056a5e7cd2a8c01a934bdfa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a182f435e1010a0556c543f19feed6f"><td class="memTemplParams" colspan="2">template&lt;int N, typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a7a182f435e1010a0556c543f19feed6f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::tuple_element&lt; N, hydra::thrust::pair&lt; T1, T2 &gt; &gt;::type &amp;&amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a7a182f435e1010a0556c543f19feed6f">get</a> (hydra::thrust::pair&lt; T1, T2 &gt; &amp;&amp;t)</td></tr>
<tr class="separator:a7a182f435e1010a0556c543f19feed6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2658beb74af1f617373f6f640e2949e4"><td class="memTemplParams" colspan="2">template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename T , size_t N&gt; </td></tr>
<tr class="memitem:a2658beb74af1f617373f6f640e2949e4"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a2658beb74af1f617373f6f640e2949e4">get</a> (<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;, <a class="el" href="namespacehydra.html#classhydra_1_1multiarray">multiarray</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; const &amp;other) -&gt; decltype(other.column(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;</td></tr>
<tr class="memdesc:a2658beb74af1f617373f6f640e2949e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the column <code>_I</code> of the <a class="el" href="namespacehydra.html#classhydra_1_1multiarray">hydra::multiarray</a>.  <a href="#a2658beb74af1f617373f6f640e2949e4">More...</a><br /></td></tr>
<tr class="separator:a2658beb74af1f617373f6f640e2949e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af63079c411073c082f1099994bd539af"><td class="memTemplParams" colspan="2">template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename T , size_t N&gt; </td></tr>
<tr class="memitem:af63079c411073c082f1099994bd539af"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#af63079c411073c082f1099994bd539af">get</a> (<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;, <a class="el" href="namespacehydra.html#classhydra_1_1multiarray">multiarray</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; &amp;other) -&gt; decltype(other.column(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;</td></tr>
<tr class="memdesc:af63079c411073c082f1099994bd539af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the column <code>_I</code> of the <a class="el" href="namespacehydra.html#classhydra_1_1multiarray">hydra::multiarray</a>.  <a href="#af63079c411073c082f1099994bd539af">More...</a><br /></td></tr>
<tr class="separator:af63079c411073c082f1099994bd539af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9455f669c9c73c240ae096df0543c241"><td class="memTemplParams" colspan="2">template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename ... T&gt; </td></tr>
<tr class="memitem:a9455f669c9c73c240ae096df0543c241"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a9455f669c9c73c240ae096df0543c241">get</a> (<a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; hydra::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; const &amp;other) -&gt; decltype(other.column(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;</td></tr>
<tr class="separator:a9455f669c9c73c240ae096df0543c241"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9c0317a250fbfc438fda2c5a41218f9"><td class="memTemplParams" colspan="2">template&lt;typename ... T&gt; </td></tr>
<tr class="memitem:ac9c0317a250fbfc438fda2c5a41218f9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="structhydra_1_1detail_1_1tuple__utility_1_1flat__tuple.html">detail::tuple_utility::flat_tuple</a>&lt; T... &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ac9c0317a250fbfc438fda2c5a41218f9">get_flat_tuple</a> (T const &amp;... args)</td></tr>
<tr class="separator:ac9c0317a250fbfc438fda2c5a41218f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7582acf570b53c033d52c6ff0fecb43e"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a7582acf570b53c033d52c6ff0fecb43e"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a7582acf570b53c033d52c6ff0fecb43e">GetFormatedString</a> (const char *format, Args... args)</td></tr>
<tr class="separator:a7582acf570b53c033d52c6ff0fecb43e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fcdf55250e5c7b839127b60ccc1bb08"><td class="memItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a2fcdf55250e5c7b839127b60ccc1bb08">hermite</a> (<a class="el" href="namespace_3globalScope_4.html#classunsigned">unsigned</a> <a class="el" href="crystal__ball__plus__exponential_8inl.html#a21f77208d6bc667560ff8aaf8f943b6a">n</a>, const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> x)</td></tr>
<tr class="memdesc:a2fcdf55250e5c7b839127b60ccc1bb08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of Hermite polynomials \( P_n(n) \) using the recursive relation.  <a href="#a2fcdf55250e5c7b839127b60ccc1bb08">More...</a><br /></td></tr>
<tr class="separator:a2fcdf55250e5c7b839127b60ccc1bb08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80375f44c776f48ac47363edc4f21c49"><td class="memItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a80375f44c776f48ac47363edc4f21c49">jacobi</a> (<a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> a, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> b, <a class="el" href="namespace_3globalScope_4.html#classunsigned">unsigned</a> <a class="el" href="crystal__ball__plus__exponential_8inl.html#a21f77208d6bc667560ff8aaf8f943b6a">n</a>, const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> x)</td></tr>
<tr class="memdesc:a80375f44c776f48ac47363edc4f21c49"><td class="mdescLeft">&#160;</td><td class="mdescRight">P_{n-1}^{(,)}(z) - 2 (n+ - 1) (n + -1) (2n+ + ) P_{n-2}^{(, )}(z), {align}&lt;/math&gt;  <a href="#a80375f44c776f48ac47363edc4f21c49">More...</a><br /></td></tr>
<tr class="separator:a80375f44c776f48ac47363edc4f21c49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab528a52c914909be19583b377cf15dea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ab528a52c914909be19583b377cf15dea">laguerre</a> (<a class="el" href="namespace_3globalScope_4.html#classunsigned">unsigned</a> <a class="el" href="crystal__ball__plus__exponential_8inl.html#a21f77208d6bc667560ff8aaf8f943b6a">n</a>, const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> x)</td></tr>
<tr class="memdesc:ab528a52c914909be19583b377cf15dea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of Laguerre polynomials \( P_n(n) \) using the recursive relation.  <a href="#ab528a52c914909be19583b377cf15dea">More...</a><br /></td></tr>
<tr class="separator:ab528a52c914909be19583b377cf15dea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6f9d2e0f2fbfaf2119679f2ef60c213"><td class="memItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#aa6f9d2e0f2fbfaf2119679f2ef60c213">legendre</a> (<a class="el" href="namespace_3globalScope_4.html#classunsigned">unsigned</a> <a class="el" href="crystal__ball__plus__exponential_8inl.html#a21f77208d6bc667560ff8aaf8f943b6a">n</a>, const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> x)</td></tr>
<tr class="memdesc:aa6f9d2e0f2fbfaf2119679f2ef60c213"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of Legendre polynomials \( P_n(n) \) using the recursive relation.  <a href="#aa6f9d2e0f2fbfaf2119679f2ef60c213">More...</a><br /></td></tr>
<tr class="separator:aa6f9d2e0f2fbfaf2119679f2ef60c213"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2725e178af11595cbeba053c1f84dfa8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2725e178af11595cbeba053c1f84dfa8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespacehydra.html#a9d2c06cb9672fe86dbeaa65e8f35a2bf">complex</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a2725e178af11595cbeba053c1f84dfa8">log</a> (const <a class="el" href="namespacehydra.html#a9d2c06cb9672fe86dbeaa65e8f35a2bf">complex</a>&lt; T &gt; &amp;z)</td></tr>
<tr class="separator:a2725e178af11595cbeba053c1f84dfa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64d53a33e43032b9e482284fd1a38b08"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a64d53a33e43032b9e482284fd1a38b08"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespacehydra.html#a9d2c06cb9672fe86dbeaa65e8f35a2bf">complex</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a64d53a33e43032b9e482284fd1a38b08">log10</a> (const <a class="el" href="namespacehydra.html#a9d2c06cb9672fe86dbeaa65e8f35a2bf">complex</a>&lt; T &gt; &amp;z)</td></tr>
<tr class="separator:a64d53a33e43032b9e482284fd1a38b08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec6434cd5d4090bff5bbac363febb2df"><td class="memTemplParams" colspan="2">template&lt;typename ArgType , typename Functor , typename Kernel , detail::Backend BACKEND, detail::FFTCalculator FFT, typename T  = typename detail::stripped_type&lt;typename std::common_type&lt;typename Functor::return_type, typename Kernel::return_type&gt;::type&gt;::type&gt; </td></tr>
<tr class="memitem:aec6434cd5d4090bff5bbac363febb2df"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_floating_point&lt; T &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1ConvolutionFunctor">ConvolutionFunctor</a>&lt; Functor, Kernel, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1FFTPolicy">detail::FFTPolicy</a>&lt; T, FFT &gt;, ArgType &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#aec6434cd5d4090bff5bbac363febb2df">make_convolution</a> (<a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt; const &amp;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1FFTPolicy">detail::FFTPolicy</a>&lt; T, FFT &gt; const &amp;, Functor const &amp;functor, Kernel const &amp;kernel, T kmin, T kmax, <a class="el" href="namespace_3globalScope_4.html#classunsigned">unsigned</a> nsamples=1024, bool interpolate=true, bool power_up=true)</td></tr>
<tr class="separator:aec6434cd5d4090bff5bbac363febb2df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d38b20da8bf42cb19f79f82b80bbc3e"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Iterator1 , typename Iterator2 , size_t N, hydra::detail::Backend BACKEND&gt; </td></tr>
<tr class="memitem:a5d38b20da8bf42cb19f79f82b80bbc3e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__histogram.html#classhydra_1_1DenseHistogram">DenseHistogram</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1multidimensional">detail::multidimensional</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a5d38b20da8bf42cb19f79f82b80bbc3e">make_dense_histogram</a> (<a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;, std::array&lt; size_t, N &gt; const &amp;grid, std::array&lt; <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>, N &gt; const &amp;lowerlimits, std::array&lt; <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>, N &gt; const &amp;upperlimits, Iterator1 first, Iterator1 <a class="el" href="namespacehydra.html#a4274268d147e9a988f379326b73682b0">end</a>, Iterator2 wfirst)</td></tr>
<tr class="separator:a5d38b20da8bf42cb19f79f82b80bbc3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7620416b81e1aeb9f0f721bedcc1fc0"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Iterator , size_t N, hydra::detail::Backend BACKEND&gt; </td></tr>
<tr class="memitem:gab7620416b81e1aeb9f0f721bedcc1fc0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__histogram.html#classhydra_1_1DenseHistogram">DenseHistogram</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1multidimensional">detail::multidimensional</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__histogram.html#gab7620416b81e1aeb9f0f721bedcc1fc0">make_dense_histogram</a> (<a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt; backend, std::array&lt; size_t, N &gt;const &amp;grid, std::array&lt; <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>, N &gt; const &amp;lowerlimits, std::array&lt; <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>, N &gt; const &amp;upperlimits, Iterator first, Iterator <a class="el" href="namespacehydra.html#a4274268d147e9a988f379326b73682b0">end</a>)</td></tr>
<tr class="memdesc:gab7620416b81e1aeb9f0f721bedcc1fc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to make a N-dimensional dense histogram.  <a href="group__histogram.html#gab7620416b81e1aeb9f0f721bedcc1fc0">More...</a><br /></td></tr>
<tr class="separator:gab7620416b81e1aeb9f0f721bedcc1fc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2473e6bf693982480a25a362fdd63cc9"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N, hydra::detail::Backend BACKEND, typename Iterable &gt; </td></tr>
<tr class="memitem:ga2473e6bf693982480a25a362fdd63cc9"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; Iterable &gt;::value, <a class="el" href="group__histogram.html#classhydra_1_1DenseHistogram">DenseHistogram</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1multidimensional">detail::multidimensional</a> &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__histogram.html#ga2473e6bf693982480a25a362fdd63cc9">make_dense_histogram</a> (<a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt; backend, std::array&lt; size_t, N &gt; const &amp;grid, std::array&lt; <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>, N &gt; const &amp;lowerlimits, std::array&lt; <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>, N &gt; const &amp;upperlimits, Iterable &amp;&amp;<a class="el" href="basic__distributions_8inl.html#a248ea98483ce90baaf65a7682438d72d">data</a>)</td></tr>
<tr class="memdesc:ga2473e6bf693982480a25a362fdd63cc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to make a N-dimensional dense histogram.  <a href="group__histogram.html#ga2473e6bf693982480a25a362fdd63cc9">More...</a><br /></td></tr>
<tr class="separator:ga2473e6bf693982480a25a362fdd63cc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa3ee77b40d763eee2d828b62ee09537c"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N, hydra::detail::Backend BACKEND, typename Iterable1 , typename Iterable2 &gt; </td></tr>
<tr class="memitem:gaa3ee77b40d763eee2d828b62ee09537c"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; Iterable1 &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; Iterable2 &gt;::value, <a class="el" href="group__histogram.html#classhydra_1_1DenseHistogram">DenseHistogram</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1multidimensional">detail::multidimensional</a> &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__histogram.html#gaa3ee77b40d763eee2d828b62ee09537c">make_dense_histogram</a> (<a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt; backend, std::array&lt; size_t, N &gt; const &amp;grid, std::array&lt; <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>, N &gt; const &amp;lowerlimits, std::array&lt; <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>, N &gt; const &amp;upperlimits, Iterable1 &amp;&amp;<a class="el" href="basic__distributions_8inl.html#a248ea98483ce90baaf65a7682438d72d">data</a>, Iterable2 &amp;&amp;weight)</td></tr>
<tr class="memdesc:gaa3ee77b40d763eee2d828b62ee09537c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to make a N-dimensional dense histogram.  <a href="group__histogram.html#gaa3ee77b40d763eee2d828b62ee09537c">More...</a><br /></td></tr>
<tr class="separator:gaa3ee77b40d763eee2d828b62ee09537c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa7c8d3794db72bd6ed086fe753450064"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Iterator , hydra::detail::Backend BACKEND&gt; </td></tr>
<tr class="memitem:gaa7c8d3794db72bd6ed086fe753450064"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__histogram.html#classhydra_1_1DenseHistogram">DenseHistogram</a>&lt; T, 1, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1unidimensional">detail::unidimensional</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__histogram.html#gaa7c8d3794db72bd6ed086fe753450064">make_dense_histogram</a> (<a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt; backend, size_t nbins, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> lowerlimit, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> upperlimit, Iterator first, Iterator <a class="el" href="namespacehydra.html#a4274268d147e9a988f379326b73682b0">end</a>)</td></tr>
<tr class="memdesc:gaa7c8d3794db72bd6ed086fe753450064"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to make a 1-dimensional dense histogram.  <a href="group__histogram.html#gaa7c8d3794db72bd6ed086fe753450064">More...</a><br /></td></tr>
<tr class="separator:gaa7c8d3794db72bd6ed086fe753450064"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa749f1d4034e7b8bb43dccf4738f152e"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Iterator1 , typename Iterator2 , hydra::detail::Backend BACKEND&gt; </td></tr>
<tr class="memitem:gaa749f1d4034e7b8bb43dccf4738f152e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__histogram.html#classhydra_1_1DenseHistogram">DenseHistogram</a>&lt; T, 1, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1unidimensional">detail::unidimensional</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__histogram.html#gaa749f1d4034e7b8bb43dccf4738f152e">make_dense_histogram</a> (<a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt; backend, size_t nbins, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> lowerlimit, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> upperlimit, Iterator1 first, Iterator1 <a class="el" href="namespacehydra.html#a4274268d147e9a988f379326b73682b0">end</a>, Iterator2 wfirst)</td></tr>
<tr class="memdesc:gaa749f1d4034e7b8bb43dccf4738f152e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to make a 1-dimensional dense histogram.  <a href="group__histogram.html#gaa749f1d4034e7b8bb43dccf4738f152e">More...</a><br /></td></tr>
<tr class="separator:gaa749f1d4034e7b8bb43dccf4738f152e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac56cd763e01bdb74bc09de1f29624b8f"><td class="memTemplParams" colspan="2">template&lt;typename T , hydra::detail::Backend BACKEND, typename Iterable &gt; </td></tr>
<tr class="memitem:gac56cd763e01bdb74bc09de1f29624b8f"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; Iterable &gt;::value, <a class="el" href="group__histogram.html#classhydra_1_1DenseHistogram">DenseHistogram</a>&lt; T, 1, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1unidimensional">detail::unidimensional</a> &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__histogram.html#gac56cd763e01bdb74bc09de1f29624b8f">make_dense_histogram</a> (<a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt; backend, size_t nbins, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> lowerlimits, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> upperlimits, Iterable &amp;&amp;<a class="el" href="basic__distributions_8inl.html#a248ea98483ce90baaf65a7682438d72d">data</a>)</td></tr>
<tr class="memdesc:gac56cd763e01bdb74bc09de1f29624b8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to make a N-dimensional dense histogram.  <a href="group__histogram.html#gac56cd763e01bdb74bc09de1f29624b8f">More...</a><br /></td></tr>
<tr class="separator:gac56cd763e01bdb74bc09de1f29624b8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c4020d4319e6061c1845212bdd0b8d9"><td class="memTemplParams" colspan="2">template&lt;typename T , hydra::detail::Backend BACKEND, typename Iterable1 , typename Iterable2 &gt; </td></tr>
<tr class="memitem:ga7c4020d4319e6061c1845212bdd0b8d9"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; Iterable1 &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; Iterable2 &gt;::value, <a class="el" href="group__histogram.html#classhydra_1_1DenseHistogram">DenseHistogram</a>&lt; T, 1, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1unidimensional">detail::unidimensional</a> &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__histogram.html#ga7c4020d4319e6061c1845212bdd0b8d9">make_dense_histogram</a> (<a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt; backend, size_t nbins, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> lowerlimits, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> upperlimits, Iterable1 &amp;&amp;<a class="el" href="basic__distributions_8inl.html#a248ea98483ce90baaf65a7682438d72d">data</a>, Iterable2 &amp;&amp;weight)</td></tr>
<tr class="memdesc:ga7c4020d4319e6061c1845212bdd0b8d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to make a N-dimensional dense histogram.  <a href="group__histogram.html#ga7c4020d4319e6061c1845212bdd0b8d9">More...</a><br /></td></tr>
<tr class="separator:ga7c4020d4319e6061c1845212bdd0b8d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a000e95288951de54d3d420b07d3f13"><td class="memTemplParams" colspan="2">template&lt;typename... Pdfs, typename Iterator , typename ... Iterators&gt; </td></tr>
<tr class="memitem:ga8a000e95288951de54d3d420b07d3f13"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterator.html">detail::is_iterator</a>&lt; Iterator &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1are__iterators.html">detail::are_iterators</a>&lt; Iterators... &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1LogLikelihoodFCN">LogLikelihoodFCN</a>&lt; <a class="el" href="group__fit.html#classhydra_1_1PDFSumExtendable">PDFSumExtendable</a>&lt; Pdfs... &gt;, Iterator, Iterators... &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__fit.html#ga8a000e95288951de54d3d420b07d3f13">make_loglikehood_fcn</a> (<a class="el" href="group__fit.html#classhydra_1_1PDFSumExtendable">PDFSumExtendable</a>&lt; Pdfs... &gt; const &amp;functor, Iterator first, Iterator last, Iterators... weights)</td></tr>
<tr class="memdesc:ga8a000e95288951de54d3d420b07d3f13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conveniency function to build up loglikehood fcns.  <a href="group__fit.html#ga8a000e95288951de54d3d420b07d3f13">More...</a><br /></td></tr>
<tr class="separator:ga8a000e95288951de54d3d420b07d3f13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a000e95288951de54d3d420b07d3f13"><td class="memTemplParams" colspan="2">template&lt;typename... Pdfs, typename Iterator , typename ... Iterators&gt; </td></tr>
<tr class="memitem:ga8a000e95288951de54d3d420b07d3f13"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterator.html">hydra::detail::is_iterator</a>&lt; Iterator &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1are__iterators.html">detail::are_iterators</a>&lt; Iterators... &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1LogLikelihoodFCN">LogLikelihoodFCN</a>&lt; <a class="el" href="group__fit.html#classhydra_1_1PDFSumExtendable">PDFSumExtendable</a>&lt; Pdfs... &gt;, Iterator, Iterators... &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__fit.html#ga8a000e95288951de54d3d420b07d3f13">make_loglikehood_fcn</a> (<a class="el" href="group__fit.html#classhydra_1_1PDFSumExtendable">PDFSumExtendable</a>&lt; Pdfs... &gt; const &amp;functor, Iterator first, Iterator last, Iterators... weights)</td></tr>
<tr class="memdesc:ga8a000e95288951de54d3d420b07d3f13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conveniency function to build up loglikehood fcns.  <a href="group__fit.html#ga8a000e95288951de54d3d420b07d3f13">More...</a><br /></td></tr>
<tr class="separator:ga8a000e95288951de54d3d420b07d3f13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a66809b24de0479eacf80a3fe269c91"><td class="memTemplParams" colspan="2">template&lt;typename Functor , typename Integrator , typename Iterator , typename ... Iterators&gt; </td></tr>
<tr class="memitem:ga9a66809b24de0479eacf80a3fe269c91"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterator.html">detail::is_iterator</a>&lt; Iterator &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1are__iterators.html">detail::are_iterators</a>&lt; Iterators... &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1LogLikelihoodFCN">LogLikelihoodFCN</a>&lt; <a class="el" href="group__fit.html#classhydra_1_1Pdf">Pdf</a>&lt; Functor, <a class="el" href="multidimensional__fit_8inl.html#a6bdffffea16f0dcaa4e4c96eb2c8838f">Integrator</a> &gt;, Iterator, Iterators... &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__fit.html#ga9a66809b24de0479eacf80a3fe269c91">make_loglikehood_fcn</a> (<a class="el" href="group__fit.html#classhydra_1_1Pdf">Pdf</a>&lt; Functor, <a class="el" href="multidimensional__fit_8inl.html#a6bdffffea16f0dcaa4e4c96eb2c8838f">Integrator</a> &gt; const  &amp;pdf, Iterator first, Iterator last, Iterators... weights)</td></tr>
<tr class="memdesc:ga9a66809b24de0479eacf80a3fe269c91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conveniency function to build up loglikehood fcns.  <a href="group__fit.html#ga9a66809b24de0479eacf80a3fe269c91">More...</a><br /></td></tr>
<tr class="separator:ga9a66809b24de0479eacf80a3fe269c91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e01056ba9de1f6dfb8bed2f332a92d1"><td class="memTemplParams" colspan="2">template&lt;typename... Pdfs, typename Iterator , typename ... Iterators&gt; </td></tr>
<tr class="memitem:ga7e01056ba9de1f6dfb8bed2f332a92d1"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterator.html">hydra::detail::is_iterator</a>&lt; Iterator &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1are__iterators.html">detail::are_iterators</a>&lt; Iterators... &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1LogLikelihoodFCN">LogLikelihoodFCN</a>&lt; <a class="el" href="group__fit.html#classhydra_1_1PDFSumNonExtendable">PDFSumNonExtendable</a>&lt; Pdfs... &gt;, Iterator, Iterators... &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__fit.html#ga7e01056ba9de1f6dfb8bed2f332a92d1">make_loglikehood_fcn</a> (<a class="el" href="group__fit.html#classhydra_1_1PDFSumNonExtendable">PDFSumNonExtendable</a>&lt; Pdfs... &gt;const  &amp;pdf, Iterator first, Iterator last, Iterators... weights)</td></tr>
<tr class="memdesc:ga7e01056ba9de1f6dfb8bed2f332a92d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conveniency function to build up loglikehood fcns.  <a href="group__fit.html#ga7e01056ba9de1f6dfb8bed2f332a92d1">More...</a><br /></td></tr>
<tr class="separator:ga7e01056ba9de1f6dfb8bed2f332a92d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad95e718c107a9b491fd272dfd4cd3623"><td class="memTemplParams" colspan="2">template&lt;typename ... Pdfs, typename Iterable , typename ... Iterables&gt; </td></tr>
<tr class="memitem:gad95e718c107a9b491fd272dfd4cd3623"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;(!<a class="el" href="structhydra_1_1detail_1_1is__iterator.html">detail::is_iterator</a>&lt; Iterable &gt;::value) &amp;&amp;((sizeof...(Iterables)==0)||!<a class="el" href="structhydra_1_1detail_1_1are__iterators.html">detail::are_iterators</a>&lt; Iterables... &gt;::value) &amp;&amp;(!<a class="el" href="structhydra_1_1detail_1_1is__hydra__dense__histogram.html">hydra::detail::is_hydra_dense_histogram</a>&lt; typename std::remove_reference&lt; Iterable &gt;::type &gt;::value) &amp;&amp;(!<a class="el" href="structhydra_1_1detail_1_1is__hydra__sparse__histogram.html">hydra::detail::is_hydra_sparse_histogram</a>&lt; typename std::remove_reference&lt; Iterable &gt;::type &gt;::value) &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1is__iterable.html">detail::is_iterable</a>&lt; Iterable &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1are__iterables.html">detail::are_iterables</a>&lt; Iterables... &gt;::value,<a class="el" href="namespacehydra.html#classhydra_1_1LogLikelihoodFCN">LogLikelihoodFCN</a>&lt; <a class="el" href="group__fit.html#classhydra_1_1PDFSumExtendable">PDFSumExtendable</a>&lt; Pdfs... &gt;, decltype(std::declval&lt; Iterable &gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()), decltype(std::declval&lt; Iterables &gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>())... &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__fit.html#gad95e718c107a9b491fd272dfd4cd3623">make_loglikehood_fcn</a> (<a class="el" href="group__fit.html#classhydra_1_1PDFSumExtendable">PDFSumExtendable</a>&lt; Pdfs... &gt; const &amp;functor, Iterable &amp;&amp;points, Iterables &amp;&amp;... weights)</td></tr>
<tr class="memdesc:gad95e718c107a9b491fd272dfd4cd3623"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conveniency function to build up loglikehood fcns.  <a href="group__fit.html#gad95e718c107a9b491fd272dfd4cd3623">More...</a><br /></td></tr>
<tr class="separator:gad95e718c107a9b491fd272dfd4cd3623"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad95e718c107a9b491fd272dfd4cd3623"><td class="memTemplParams" colspan="2">template&lt;typename ... Pdfs, typename Iterable , typename... Iterables&gt; </td></tr>
<tr class="memitem:gad95e718c107a9b491fd272dfd4cd3623"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;(!<a class="el" href="structhydra_1_1detail_1_1is__iterator.html">detail::is_iterator</a>&lt; Iterable &gt;::value) &amp;&amp;((sizeof...(Iterables)==0)||!<a class="el" href="structhydra_1_1detail_1_1are__iterators.html">detail::are_iterators</a>&lt; Iterables... &gt;::value) &amp;&amp;(!<a class="el" href="structhydra_1_1detail_1_1is__hydra__dense__histogram.html">hydra::detail::is_hydra_dense_histogram</a>&lt; typename std::remove_reference&lt; Iterable &gt;::type &gt;::value) &amp;&amp;(!<a class="el" href="structhydra_1_1detail_1_1is__hydra__sparse__histogram.html">hydra::detail::is_hydra_sparse_histogram</a>&lt; typename std::remove_reference&lt; Iterable &gt;::type &gt;::value) &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1is__iterable.html">detail::is_iterable</a>&lt; Iterable &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1are__iterables.html">detail::are_iterables</a>&lt; Iterables... &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1LogLikelihoodFCN">LogLikelihoodFCN</a>&lt; <a class="el" href="group__fit.html#classhydra_1_1PDFSumExtendable">PDFSumExtendable</a>&lt; Pdfs... &gt;, decltype(std::declval&lt; Iterable &gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()), decltype(std::declval&lt; Iterables &gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>())... &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__fit.html#gad95e718c107a9b491fd272dfd4cd3623">make_loglikehood_fcn</a> (<a class="el" href="group__fit.html#classhydra_1_1PDFSumExtendable">PDFSumExtendable</a>&lt; Pdfs... &gt; const &amp;functor, Iterable &amp;&amp;points, Iterables &amp;&amp;...weights)</td></tr>
<tr class="memdesc:gad95e718c107a9b491fd272dfd4cd3623"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conveniency function to build up loglikehood fcns.  <a href="group__fit.html#gad95e718c107a9b491fd272dfd4cd3623">More...</a><br /></td></tr>
<tr class="separator:gad95e718c107a9b491fd272dfd4cd3623"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5da2d6085352cf67cc5d6116fdcf60be"><td class="memTemplParams" colspan="2">template&lt;typename Functor , typename Integrator , typename Iterable , typename ... Iterables&gt; </td></tr>
<tr class="memitem:ga5da2d6085352cf67cc5d6116fdcf60be"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;(!<a class="el" href="structhydra_1_1detail_1_1is__iterator.html">detail::is_iterator</a>&lt; Iterable &gt;::value) &amp;&amp;((sizeof...(Iterables)==0)||!<a class="el" href="structhydra_1_1detail_1_1are__iterators.html">detail::are_iterators</a>&lt; Iterables... &gt;::value) &amp;&amp;(!<a class="el" href="structhydra_1_1detail_1_1is__hydra__dense__histogram.html">hydra::detail::is_hydra_dense_histogram</a>&lt; typename std::remove_reference&lt; Iterable &gt;::type &gt;::value) &amp;&amp;(!<a class="el" href="structhydra_1_1detail_1_1is__hydra__sparse__histogram.html">hydra::detail::is_hydra_sparse_histogram</a>&lt; typename std::remove_reference&lt; Iterable &gt;::type &gt;::value) &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1is__iterable.html">detail::is_iterable</a>&lt; Iterable &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1are__iterables.html">detail::are_iterables</a>&lt; Iterables... &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1LogLikelihoodFCN">LogLikelihoodFCN</a>&lt; <a class="el" href="group__fit.html#classhydra_1_1Pdf">Pdf</a>&lt; Functor, <a class="el" href="multidimensional__fit_8inl.html#a6bdffffea16f0dcaa4e4c96eb2c8838f">Integrator</a> &gt;, decltype(std::declval&lt; Iterable &gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()), decltype(std::declval&lt; Iterables &gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>())... &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__fit.html#ga5da2d6085352cf67cc5d6116fdcf60be">make_loglikehood_fcn</a> (<a class="el" href="group__fit.html#classhydra_1_1Pdf">Pdf</a>&lt; Functor, <a class="el" href="multidimensional__fit_8inl.html#a6bdffffea16f0dcaa4e4c96eb2c8838f">Integrator</a> &gt; const  &amp;pdf, Iterable &amp;&amp;points, Iterables &amp;&amp;... weights)</td></tr>
<tr class="memdesc:ga5da2d6085352cf67cc5d6116fdcf60be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conveniency function to build up loglikehood fcns.  <a href="group__fit.html#ga5da2d6085352cf67cc5d6116fdcf60be">More...</a><br /></td></tr>
<tr class="separator:ga5da2d6085352cf67cc5d6116fdcf60be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab40d1c176811fa708505bbb08326c97d"><td class="memTemplParams" colspan="2">template&lt;typename ... Pdfs, typename Iterable , typename ... Iterables&gt; </td></tr>
<tr class="memitem:gab40d1c176811fa708505bbb08326c97d"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;(!<a class="el" href="structhydra_1_1detail_1_1is__iterator.html">detail::is_iterator</a>&lt; Iterable &gt;::value) &amp;&amp;((sizeof...(Iterables)==0)||!<a class="el" href="structhydra_1_1detail_1_1are__iterators.html">detail::are_iterators</a>&lt; Iterables... &gt;::value) &amp;&amp;(!<a class="el" href="structhydra_1_1detail_1_1is__hydra__dense__histogram.html">hydra::detail::is_hydra_dense_histogram</a>&lt; typename std::remove_reference&lt; Iterable &gt;::type &gt;::value) &amp;&amp;(!<a class="el" href="structhydra_1_1detail_1_1is__hydra__sparse__histogram.html">hydra::detail::is_hydra_sparse_histogram</a>&lt; typename std::remove_reference&lt; Iterable &gt;::type &gt;::value) &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; Iterable &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1are__iterables.html">detail::are_iterables</a>&lt; Iterables... &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1LogLikelihoodFCN">LogLikelihoodFCN</a>&lt; <a class="el" href="group__fit.html#classhydra_1_1PDFSumNonExtendable">PDFSumNonExtendable</a>&lt; Pdfs... &gt;, decltype(std::declval&lt; Iterable &gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()), decltype(std::declval&lt; Iterables &gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>())... &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__fit.html#gab40d1c176811fa708505bbb08326c97d">make_loglikehood_fcn</a> (<a class="el" href="group__fit.html#classhydra_1_1PDFSumNonExtendable">PDFSumNonExtendable</a>&lt; Pdfs... &gt; const  &amp;functor, Iterable &amp;&amp;points, Iterables &amp;&amp;... weights)</td></tr>
<tr class="memdesc:gab40d1c176811fa708505bbb08326c97d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conveniency function to build up loglikehood fcns.  <a href="group__fit.html#gab40d1c176811fa708505bbb08326c97d">More...</a><br /></td></tr>
<tr class="separator:gab40d1c176811fa708505bbb08326c97d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a820a933e48fa338a812a9f88bfb18e56"><td class="memTemplParams" colspan="2">template&lt;typename ... Pdfs, typename Histogram &gt; </td></tr>
<tr class="memitem:a820a933e48fa338a812a9f88bfb18e56"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__hydra__dense__histogram.html">detail::is_hydra_dense_histogram</a>&lt; Histogram &gt;::value||<a class="el" href="structhydra_1_1detail_1_1is__hydra__sparse__histogram.html">detail::is_hydra_sparse_histogram</a>&lt; Histogram &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1LogLikelihoodFCN">LogLikelihoodFCN</a>&lt; <a class="el" href="group__fit.html#classhydra_1_1PDFSumExtendable">PDFSumExtendable</a>&lt; Pdfs... &gt;, decltype(std::declval&lt; const Histogram &amp; &gt;).GetBinsCenters().<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()), decltype(std::declval&lt; const Histogram &amp; &gt;).GetBinsContents().<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()) &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a820a933e48fa338a812a9f88bfb18e56">make_loglikehood_fcn</a> (<a class="el" href="group__fit.html#classhydra_1_1PDFSumExtendable">PDFSumExtendable</a>&lt; Pdfs... &gt; const &amp;functor, Histogram const &amp;points)</td></tr>
<tr class="separator:a820a933e48fa338a812a9f88bfb18e56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga013d425d98994f7a1288f69915d30381"><td class="memTemplParams" colspan="2">template&lt;typename ... Pdfs, typename Histogram &gt; </td></tr>
<tr class="memitem:ga013d425d98994f7a1288f69915d30381"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__hydra__dense__histogram.html">detail::is_hydra_dense_histogram</a>&lt; Histogram &gt;::value||<a class="el" href="structhydra_1_1detail_1_1is__hydra__sparse__histogram.html">detail::is_hydra_sparse_histogram</a>&lt; Histogram &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1LogLikelihoodFCN">LogLikelihoodFCN</a>&lt; <a class="el" href="group__fit.html#classhydra_1_1PDFSumNonExtendable">PDFSumNonExtendable</a>&lt; Pdfs... &gt;, decltype(std::declval&lt; const Histogram &amp; &gt;).GetBinsCenters().<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()), decltype(std::declval&lt; const Histogram &amp; &gt;).GetBinsContents().<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()) &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__fit.html#ga013d425d98994f7a1288f69915d30381">make_loglikehood_fcn</a> (<a class="el" href="group__fit.html#classhydra_1_1PDFSumNonExtendable">PDFSumNonExtendable</a>&lt; Pdfs... &gt; const &amp;functor, Histogram const &amp;points)</td></tr>
<tr class="memdesc:ga013d425d98994f7a1288f69915d30381"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function to build up loglikehood fcns for densely and sparsely binned datasets.  <a href="group__fit.html#ga013d425d98994f7a1288f69915d30381">More...</a><br /></td></tr>
<tr class="separator:ga013d425d98994f7a1288f69915d30381"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabec44b969b69228eb8f17fa82ec96df0"><td class="memTemplParams" colspan="2">template&lt;typename Functor , typename Integrator , typename Histogram &gt; </td></tr>
<tr class="memitem:gabec44b969b69228eb8f17fa82ec96df0"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__hydra__dense__histogram.html">detail::is_hydra_dense_histogram</a>&lt; Histogram &gt;::value||<a class="el" href="structhydra_1_1detail_1_1is__hydra__sparse__histogram.html">detail::is_hydra_sparse_histogram</a>&lt; Histogram &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1LogLikelihoodFCN">LogLikelihoodFCN</a>&lt; <a class="el" href="group__fit.html#classhydra_1_1Pdf">Pdf</a>&lt; Functor, <a class="el" href="multidimensional__fit_8inl.html#a6bdffffea16f0dcaa4e4c96eb2c8838f">Integrator</a> &gt;, decltype(std::declval&lt; const Histogram &amp; &gt;).GetBinsCenters().<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()), decltype(std::declval&lt; const Histogram &amp; &gt;).GetBinsContents().<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>())&gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__fit.html#gabec44b969b69228eb8f17fa82ec96df0">make_loglikehood_fcn</a> (<a class="el" href="group__fit.html#classhydra_1_1Pdf">Pdf</a>&lt; Functor, <a class="el" href="multidimensional__fit_8inl.html#a6bdffffea16f0dcaa4e4c96eb2c8838f">Integrator</a> &gt; const &amp;pdf, Histogram const &amp;points)</td></tr>
<tr class="memdesc:gabec44b969b69228eb8f17fa82ec96df0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function to build up loglikehood fcns for densely and sparsely binned datasets.  <a href="group__fit.html#gabec44b969b69228eb8f17fa82ec96df0">More...</a><br /></td></tr>
<tr class="separator:gabec44b969b69228eb8f17fa82ec96df0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabec44b969b69228eb8f17fa82ec96df0"><td class="memTemplParams" colspan="2">template&lt;typename Functor , typename Integrator , typename Histogram &gt; </td></tr>
<tr class="memitem:gabec44b969b69228eb8f17fa82ec96df0"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__hydra__dense__histogram.html">detail::is_hydra_dense_histogram</a>&lt; Histogram &gt;::value||<a class="el" href="structhydra_1_1detail_1_1is__hydra__sparse__histogram.html">detail::is_hydra_sparse_histogram</a>&lt; Histogram &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1LogLikelihoodFCN">LogLikelihoodFCN</a>&lt; <a class="el" href="group__fit.html#classhydra_1_1Pdf">Pdf</a>&lt; Functor, <a class="el" href="multidimensional__fit_8inl.html#a6bdffffea16f0dcaa4e4c96eb2c8838f">Integrator</a> &gt;, decltype(std::declval&lt; const Histogram &gt;).GetBinsCenters().<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()), decltype(std::declval&lt; const Histogram &gt;).GetBinsContents().<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>())&gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__fit.html#gabec44b969b69228eb8f17fa82ec96df0">make_loglikehood_fcn</a> (<a class="el" href="group__fit.html#classhydra_1_1Pdf">Pdf</a>&lt; Functor, <a class="el" href="multidimensional__fit_8inl.html#a6bdffffea16f0dcaa4e4c96eb2c8838f">Integrator</a> &gt; const &amp;pdf, Histogram const &amp;points)</td></tr>
<tr class="memdesc:gabec44b969b69228eb8f17fa82ec96df0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function to build up loglikehood fcns for densely and sparsely binned datasets.  <a href="group__fit.html#gabec44b969b69228eb8f17fa82ec96df0">More...</a><br /></td></tr>
<tr class="separator:gabec44b969b69228eb8f17fa82ec96df0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b1f7cf97347cb7e8ab8db38f9ed466e"><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 &gt; </td></tr>
<tr class="memitem:a2b1f7cf97347cb7e8ab8db38f9ed466e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a2b1f7cf97347cb7e8ab8db38f9ed466e">make_pair</a> (T1 &amp;&amp;t1, T2 &amp;&amp;t2) -&gt; decltype(hydra::thrust::make_pair(std::forward&lt; T1 &gt;(t1), std::forward&lt; T2 &gt;(t2)))</td></tr>
<tr class="memdesc:a2b1f7cf97347cb7e8ab8db38f9ed466e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This version of <code>make_pair</code> creates a new <code>pair</code> object from a list of objects.  <a href="#a2b1f7cf97347cb7e8ab8db38f9ed466e">More...</a><br /></td></tr>
<tr class="separator:a2b1f7cf97347cb7e8ab8db38f9ed466e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d468a0d98a74f41479f8ccb95f5533e"><td class="memTemplParams" colspan="2">template&lt;typename FUNCTOR , typename INTEGRATOR &gt; </td></tr>
<tr class="memitem:ga2d468a0d98a74f41479f8ccb95f5533e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__fit.html#classhydra_1_1Pdf">Pdf</a>&lt; FUNCTOR, INTEGRATOR &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__fit.html#ga2d468a0d98a74f41479f8ccb95f5533e">make_pdf</a> (FUNCTOR const &amp;functor, INTEGRATOR integrator)</td></tr>
<tr class="memdesc:ga2d468a0d98a74f41479f8ccb95f5533e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a <a class="el" href="group__fit.html#classhydra_1_1Pdf" title="Class representing probability density functions. ">hydra::Pdf</a> given a shape described by a functor and a integrator (algorithm or functor).  <a href="group__fit.html#ga2d468a0d98a74f41479f8ccb95f5533e">More...</a><br /></td></tr>
<tr class="separator:ga2d468a0d98a74f41479f8ccb95f5533e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc45ae5691f187be7c57c28d1154454f"><td class="memTemplParams" colspan="2">template&lt;typename Iterator , typename Functor &gt; </td></tr>
<tr class="memitem:afc45ae5691f187be7c57c28d1154454f"><td class="memTemplItemLeft" align="right" valign="top">hydra::thrust::detail::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt; Functor &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; Iterator, Functor &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#afc45ae5691f187be7c57c28d1154454f">make_range</a> (Iterator <a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>, Iterator <a class="el" href="namespacehydra.html#a4274268d147e9a988f379326b73682b0">end</a>, Functor const &amp;functor)</td></tr>
<tr class="separator:afc45ae5691f187be7c57c28d1154454f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed731c061feb7b22667628e351da610b"><td class="memTemplParams" colspan="2">template&lt;typename Iterator &gt; </td></tr>
<tr class="memitem:aed731c061feb7b22667628e351da610b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; Iterator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#aed731c061feb7b22667628e351da610b">make_range</a> (Iterator <a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>, Iterator <a class="el" href="namespacehydra.html#a4274268d147e9a988f379326b73682b0">end</a>)</td></tr>
<tr class="separator:aed731c061feb7b22667628e351da610b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb94a482290a0c2c1764865e7d16dcf8"><td class="memTemplParams" colspan="2">template&lt;typename Iterable &gt; </td></tr>
<tr class="memitem:aeb94a482290a0c2c1764865e7d16dcf8"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; Iterable &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; decltype(std::declval&lt; Iterable &gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>())&gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#aeb94a482290a0c2c1764865e7d16dcf8">make_range</a> (Iterable const &amp;container)</td></tr>
<tr class="separator:aeb94a482290a0c2c1764865e7d16dcf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad02081b2cc9c583c06df766e293556c1"><td class="memTemplParams" colspan="2">template&lt;typename Iterable , typename Functor &gt; </td></tr>
<tr class="memitem:ad02081b2cc9c583c06df766e293556c1"><td class="memTemplItemLeft" align="right" valign="top">hydra::thrust::detail::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">detail::is_iterable</a>&lt; Iterable &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt; Functor &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; decltype(std::declval&lt; Iterable &gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()), Functor &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ad02081b2cc9c583c06df766e293556c1">make_range</a> (Iterable const &amp;iterable, Functor const &amp;functor)</td></tr>
<tr class="separator:ad02081b2cc9c583c06df766e293556c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a997423cc7da26ee78b795e07a6910c29"><td class="memTemplParams" colspan="2">template&lt;typename Iterable &gt; </td></tr>
<tr class="memitem:a997423cc7da26ee78b795e07a6910c29"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; Iterable &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; decltype(std::declval&lt; Iterable &gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>())&gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a997423cc7da26ee78b795e07a6910c29">make_range</a> (Iterable &amp;&amp;container)</td></tr>
<tr class="separator:a997423cc7da26ee78b795e07a6910c29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea37e8b4846fce4e9e41f6adc0950bdd"><td class="memTemplParams" colspan="2">template&lt;typename Iterable , typename Functor &gt; </td></tr>
<tr class="memitem:aea37e8b4846fce4e9e41f6adc0950bdd"><td class="memTemplItemLeft" align="right" valign="top">hydra::thrust::detail::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">detail::is_iterable</a>&lt; Iterable &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt; Functor &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; decltype(std::declval&lt; Iterable &gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()), Functor &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#aea37e8b4846fce4e9e41f6adc0950bdd">make_range</a> (Iterable &amp;&amp;iterable, Functor const &amp;functor)</td></tr>
<tr class="separator:aea37e8b4846fce4e9e41f6adc0950bdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c5faeca1a5496aa680259e8d17085ee"><td class="memTemplParams" colspan="2">template&lt;typename Iterator , typename Functor &gt; </td></tr>
<tr class="memitem:a7c5faeca1a5496aa680259e8d17085ee"><td class="memTemplItemLeft" align="right" valign="top">hydra::thrust::detail::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt; Functor &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; hydra::thrust::reverse_iterator&lt; Iterator &gt;, Functor &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a7c5faeca1a5496aa680259e8d17085ee">make_reverse_range</a> (Iterator <a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>, Iterator <a class="el" href="namespacehydra.html#a4274268d147e9a988f379326b73682b0">end</a>, Functor const &amp;functor)</td></tr>
<tr class="separator:a7c5faeca1a5496aa680259e8d17085ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaca36384918d1107af74932bac7bde4a"><td class="memTemplParams" colspan="2">template&lt;typename Iterator &gt; </td></tr>
<tr class="memitem:aaca36384918d1107af74932bac7bde4a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; hydra::thrust::reverse_iterator&lt; Iterator &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#aaca36384918d1107af74932bac7bde4a">make_reverse_range</a> (Iterator <a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>, Iterator <a class="el" href="namespacehydra.html#a4274268d147e9a988f379326b73682b0">end</a>)</td></tr>
<tr class="separator:aaca36384918d1107af74932bac7bde4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8be66889f53db6bbae8365d509c13cd1"><td class="memTemplParams" colspan="2">template&lt;typename Iterable &gt; </td></tr>
<tr class="memitem:a8be66889f53db6bbae8365d509c13cd1"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__reverse__iterable.html">hydra::detail::is_reverse_iterable</a>&lt; Iterable &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; decltype(std::declval&lt; Iterable &gt;).<a class="el" href="namespacehydra.html#aadcca49207bf7ab79088f28cddb8f21d">rbegin</a>())&gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a8be66889f53db6bbae8365d509c13cd1">make_reverse_range</a> (Iterable const &amp;container)</td></tr>
<tr class="separator:a8be66889f53db6bbae8365d509c13cd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdb731a7ec634ab03b448a6cc6230d68"><td class="memTemplParams" colspan="2">template&lt;typename Iterable &gt; </td></tr>
<tr class="memitem:abdb731a7ec634ab03b448a6cc6230d68"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__reverse__iterable.html">hydra::detail::is_reverse_iterable</a>&lt; Iterable &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; decltype(std::declval&lt; Iterable &gt;).<a class="el" href="namespacehydra.html#aadcca49207bf7ab79088f28cddb8f21d">rbegin</a>())&gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#abdb731a7ec634ab03b448a6cc6230d68">make_reverse_range</a> (Iterable &amp;&amp;container)</td></tr>
<tr class="separator:abdb731a7ec634ab03b448a6cc6230d68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0538a7838b4c8a1395dcc2fffe6f4dc"><td class="memTemplParams" colspan="2">template&lt;typename Iterable , typename Functor &gt; </td></tr>
<tr class="memitem:ab0538a7838b4c8a1395dcc2fffe6f4dc"><td class="memTemplItemLeft" align="right" valign="top">hydra::thrust::detail::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__reverse__iterable.html">detail::is_reverse_iterable</a>&lt; Iterable &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt; Functor &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; decltype(std::declval&lt; Iterable &gt;).<a class="el" href="namespacehydra.html#aadcca49207bf7ab79088f28cddb8f21d">rbegin</a>()), Functor &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ab0538a7838b4c8a1395dcc2fffe6f4dc">make_reverse_range</a> (Iterable const &amp;iterable, Functor const &amp;functor)</td></tr>
<tr class="separator:ab0538a7838b4c8a1395dcc2fffe6f4dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41597c1949b55f024cfb5856e753e8be"><td class="memTemplParams" colspan="2">template&lt;typename Iterable , typename Functor &gt; </td></tr>
<tr class="memitem:a41597c1949b55f024cfb5856e753e8be"><td class="memTemplItemLeft" align="right" valign="top">hydra::thrust::detail::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__reverse__iterable.html">detail::is_reverse_iterable</a>&lt; Iterable &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt; Functor &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; decltype(std::declval&lt; Iterable &gt;).<a class="el" href="namespacehydra.html#aadcca49207bf7ab79088f28cddb8f21d">rbegin</a>()), Functor &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a41597c1949b55f024cfb5856e753e8be">make_reverse_range</a> (Iterable &amp;&amp;iterable, Functor const &amp;functor)</td></tr>
<tr class="separator:a41597c1949b55f024cfb5856e753e8be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3fbb751ad47ceb011f5bd0bb30664aa"><td class="memTemplParams" colspan="2">template&lt;typename ... ESTIMATORS&gt; </td></tr>
<tr class="memitem:gae3fbb751ad47ceb011f5bd0bb30664aa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__fit.html#classhydra_1_1FCN">FCN</a>&lt; hydra::thrust::tuple&lt; <a class="el" href="group__fit.html#classhydra_1_1FCN">FCN</a>&lt; ESTIMATORS &gt;... &gt;, false &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__fit.html#gae3fbb751ad47ceb011f5bd0bb30664aa">make_simultaneous_fcn</a> (<a class="el" href="group__fit.html#classhydra_1_1FCN">FCN</a>&lt; ESTIMATORS &gt;const  &amp;... fcns)</td></tr>
<tr class="memdesc:gae3fbb751ad47ceb011f5bd0bb30664aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function to build up simultaneous fcn simultaneous.  <a href="group__fit.html#gae3fbb751ad47ceb011f5bd0bb30664aa">More...</a><br /></td></tr>
<tr class="separator:gae3fbb751ad47ceb011f5bd0bb30664aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga419ee6032f86ed4acfe3c0c1644d548e"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Iterator , size_t N, hydra::detail::Backend BACKEND&gt; </td></tr>
<tr class="memitem:ga419ee6032f86ed4acfe3c0c1644d548e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__histogram.html#classhydra_1_1SparseHistogram">SparseHistogram</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1multidimensional">detail::multidimensional</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__histogram.html#ga419ee6032f86ed4acfe3c0c1644d548e">make_sparse_histogram</a> (<a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt; backend, std::array&lt; size_t, N &gt; grid, std::array&lt; <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>, N &gt; const  &amp;lowerlimits, std::array&lt; <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>, N &gt; const  &amp;upperlimits, Iterator first, Iterator <a class="el" href="namespacehydra.html#a4274268d147e9a988f379326b73682b0">end</a>)</td></tr>
<tr class="memdesc:ga419ee6032f86ed4acfe3c0c1644d548e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to make a N-dimensional sparse histogram.  <a href="group__histogram.html#ga419ee6032f86ed4acfe3c0c1644d548e">More...</a><br /></td></tr>
<tr class="separator:ga419ee6032f86ed4acfe3c0c1644d548e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf67b0ac7cd251adcc5a4b04921bb07ee"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Iterator1 , typename Iterator2 , size_t N, hydra::detail::Backend BACKEND&gt; </td></tr>
<tr class="memitem:gaf67b0ac7cd251adcc5a4b04921bb07ee"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__histogram.html#classhydra_1_1SparseHistogram">SparseHistogram</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1multidimensional">detail::multidimensional</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__histogram.html#gaf67b0ac7cd251adcc5a4b04921bb07ee">make_sparse_histogram</a> (<a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;, std::array&lt; size_t, N &gt; grid, std::array&lt; <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>, N &gt; const  &amp;lowerlimits, std::array&lt; <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>, N &gt; const  &amp;upperlimits, Iterator1 first, Iterator1 <a class="el" href="namespacehydra.html#a4274268d147e9a988f379326b73682b0">end</a>, Iterator2 wfirst)</td></tr>
<tr class="memdesc:gaf67b0ac7cd251adcc5a4b04921bb07ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to make a N-dimensional sparse histogram.  <a href="group__histogram.html#gaf67b0ac7cd251adcc5a4b04921bb07ee">More...</a><br /></td></tr>
<tr class="separator:gaf67b0ac7cd251adcc5a4b04921bb07ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4feb340b294e9362e3b125dfcf0bb40"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N, hydra::detail::Backend BACKEND, typename Iterable &gt; </td></tr>
<tr class="memitem:ae4feb340b294e9362e3b125dfcf0bb40"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; Iterable &gt;::value, <a class="el" href="group__histogram.html#classhydra_1_1SparseHistogram">SparseHistogram</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1multidimensional">detail::multidimensional</a> &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ae4feb340b294e9362e3b125dfcf0bb40">make_sparse_histogram</a> (<a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt; backend, std::array&lt; size_t, N &gt; grid, std::array&lt; <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>, N &gt;lowerlimits, std::array&lt; <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>, N &gt; upperlimits, Iterable &amp;&amp;<a class="el" href="basic__distributions_8inl.html#a248ea98483ce90baaf65a7682438d72d">data</a>)</td></tr>
<tr class="separator:ae4feb340b294e9362e3b125dfcf0bb40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ad4ad0aab0d7f908337b4d2544e1233"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N, hydra::detail::Backend BACKEND, typename Iterable1 , typename Iterable2 &gt; </td></tr>
<tr class="memitem:a4ad4ad0aab0d7f908337b4d2544e1233"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; Iterable1 &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; Iterable2 &gt;::value, <a class="el" href="group__histogram.html#classhydra_1_1SparseHistogram">SparseHistogram</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1multidimensional">detail::multidimensional</a> &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a4ad4ad0aab0d7f908337b4d2544e1233">make_sparse_histogram</a> (<a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt; backend, std::array&lt; size_t, N &gt; grid, std::array&lt; <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>, N &gt;lowerlimits, std::array&lt; <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>, N &gt; upperlimits, Iterable1 &amp;&amp;<a class="el" href="basic__distributions_8inl.html#a248ea98483ce90baaf65a7682438d72d">data</a>, Iterable2 &amp;&amp;weights)</td></tr>
<tr class="separator:a4ad4ad0aab0d7f908337b4d2544e1233"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga23b63e6a525a040fcf4d1ec9f3335b92"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Iterator , hydra::detail::Backend BACKEND&gt; </td></tr>
<tr class="memitem:ga23b63e6a525a040fcf4d1ec9f3335b92"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__histogram.html#classhydra_1_1SparseHistogram">SparseHistogram</a>&lt; T, 1, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1unidimensional">detail::unidimensional</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__histogram.html#ga23b63e6a525a040fcf4d1ec9f3335b92">make_sparse_histogram</a> (<a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;, size_t grid, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> lowerlimits, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> upperlimits, Iterator first, Iterator <a class="el" href="namespacehydra.html#a4274268d147e9a988f379326b73682b0">end</a>)</td></tr>
<tr class="memdesc:ga23b63e6a525a040fcf4d1ec9f3335b92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to make a 1-dimensional sparse histogram.  <a href="group__histogram.html#ga23b63e6a525a040fcf4d1ec9f3335b92">More...</a><br /></td></tr>
<tr class="separator:ga23b63e6a525a040fcf4d1ec9f3335b92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c396d8629e1982552d740a5524c63de"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Iterator1 , typename Iterator2 , hydra::detail::Backend BACKEND&gt; </td></tr>
<tr class="memitem:ga4c396d8629e1982552d740a5524c63de"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__histogram.html#classhydra_1_1SparseHistogram">SparseHistogram</a>&lt; T, 1, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1unidimensional">detail::unidimensional</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__histogram.html#ga4c396d8629e1982552d740a5524c63de">make_sparse_histogram</a> (<a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;, size_t nbins, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> lowerlimit, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> upperlimit, Iterator1 first, Iterator1 <a class="el" href="namespacehydra.html#a4274268d147e9a988f379326b73682b0">end</a>, Iterator2 wfirst)</td></tr>
<tr class="memdesc:ga4c396d8629e1982552d740a5524c63de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to make a 1-dimensional sparse histogram.  <a href="group__histogram.html#ga4c396d8629e1982552d740a5524c63de">More...</a><br /></td></tr>
<tr class="separator:ga4c396d8629e1982552d740a5524c63de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78a0f873d98142f0c26c5ad261d05cba"><td class="memTemplParams" colspan="2">template&lt;typename T , hydra::detail::Backend BACKEND, typename Iterable &gt; </td></tr>
<tr class="memitem:ga78a0f873d98142f0c26c5ad261d05cba"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; Iterable &gt;::value, <a class="el" href="group__histogram.html#classhydra_1_1SparseHistogram">SparseHistogram</a>&lt; T, 1, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1unidimensional">detail::unidimensional</a> &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__histogram.html#ga78a0f873d98142f0c26c5ad261d05cba">make_sparse_histogram</a> (<a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt; backend, size_t nbins, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> lowerlimit, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> upperlimit, Iterable &amp;&amp;<a class="el" href="basic__distributions_8inl.html#a248ea98483ce90baaf65a7682438d72d">data</a>)</td></tr>
<tr class="memdesc:ga78a0f873d98142f0c26c5ad261d05cba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to make a 1-dimensional sparse histogram.  <a href="group__histogram.html#ga78a0f873d98142f0c26c5ad261d05cba">More...</a><br /></td></tr>
<tr class="separator:ga78a0f873d98142f0c26c5ad261d05cba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6fdfe0a2e5a4a27cf6b16923f0411e0"><td class="memTemplParams" colspan="2">template&lt;typename T , hydra::detail::Backend BACKEND, typename Iterable1 , typename Iterable2 &gt; </td></tr>
<tr class="memitem:gaf6fdfe0a2e5a4a27cf6b16923f0411e0"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; Iterable1 &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; Iterable2 &gt;::value, <a class="el" href="group__histogram.html#classhydra_1_1SparseHistogram">SparseHistogram</a>&lt; T, 1, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1unidimensional">detail::unidimensional</a> &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__histogram.html#gaf6fdfe0a2e5a4a27cf6b16923f0411e0">make_sparse_histogram</a> (<a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt; backend, size_t nbins, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> lowerlimit, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> upperlimit, Iterable1 &amp;&amp;<a class="el" href="basic__distributions_8inl.html#a248ea98483ce90baaf65a7682438d72d">data</a>, Iterable2 &amp;&amp;weights)</td></tr>
<tr class="memdesc:gaf6fdfe0a2e5a4a27cf6b16923f0411e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to make a 1-dimensional sparse histogram.  <a href="group__histogram.html#gaf6fdfe0a2e5a4a27cf6b16923f0411e0">More...</a><br /></td></tr>
<tr class="separator:gaf6fdfe0a2e5a4a27cf6b16923f0411e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa016aeeffc6f380d7b2b285bd05047fd"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N, hydra::detail::Backend BACKEND, typename Iterable &gt; </td></tr>
<tr class="memitem:gaa016aeeffc6f380d7b2b285bd05047fd"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; Iterable &gt;::value, <a class="el" href="group__histogram.html#classhydra_1_1SparseHistogram">SparseHistogram</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1multidimensional">detail::multidimensional</a> &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__histogram.html#gaa016aeeffc6f380d7b2b285bd05047fd">make_sparse_histogram</a> (<a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt; backend, std::array&lt; size_t, N &gt;const &amp;grid, std::array&lt; <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>, N &gt;const &amp;lowerlimits, std::array&lt; <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>, N &gt;const &amp;upperlimits, Iterable &amp;&amp;<a class="el" href="basic__distributions_8inl.html#a248ea98483ce90baaf65a7682438d72d">data</a>)</td></tr>
<tr class="memdesc:gaa016aeeffc6f380d7b2b285bd05047fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to make a N-dimensional sparse histogram.  <a href="group__histogram.html#gaa016aeeffc6f380d7b2b285bd05047fd">More...</a><br /></td></tr>
<tr class="separator:gaa016aeeffc6f380d7b2b285bd05047fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e1c4d518f6b5ea220d59f730ada13ef"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N, hydra::detail::Backend BACKEND, typename Iterable1 , typename Iterable2 &gt; </td></tr>
<tr class="memitem:ga7e1c4d518f6b5ea220d59f730ada13ef"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; Iterable1 &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; Iterable2 &gt;::value, <a class="el" href="group__histogram.html#classhydra_1_1SparseHistogram">SparseHistogram</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1multidimensional">detail::multidimensional</a> &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__histogram.html#ga7e1c4d518f6b5ea220d59f730ada13ef">make_sparse_histogram</a> (<a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt; backend, std::array&lt; size_t, N &gt;const &amp;grid, std::array&lt; <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>, N &gt;const &amp;lowerlimits, std::array&lt; <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>, N &gt;const &amp;upperlimits, Iterable1 &amp;&amp;<a class="el" href="basic__distributions_8inl.html#a248ea98483ce90baaf65a7682438d72d">data</a>, Iterable2 &amp;&amp;weights)</td></tr>
<tr class="memdesc:ga7e1c4d518f6b5ea220d59f730ada13ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to make a N-dimensional sparse histogram.  <a href="group__histogram.html#ga7e1c4d518f6b5ea220d59f730ada13ef">More...</a><br /></td></tr>
<tr class="separator:ga7e1c4d518f6b5ea220d59f730ada13ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga23b63e6a525a040fcf4d1ec9f3335b92"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Iterator , hydra::detail::Backend BACKEND&gt; </td></tr>
<tr class="memitem:ga23b63e6a525a040fcf4d1ec9f3335b92"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__histogram.html#classhydra_1_1SparseHistogram">SparseHistogram</a>&lt; T, 1, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1multidimensional">detail::multidimensional</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__histogram.html#ga23b63e6a525a040fcf4d1ec9f3335b92">make_sparse_histogram</a> (<a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt; backend, size_t nbins, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> lowerlimit, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> upperlimit, Iterator first, Iterator <a class="el" href="namespacehydra.html#a4274268d147e9a988f379326b73682b0">end</a>)</td></tr>
<tr class="memdesc:ga23b63e6a525a040fcf4d1ec9f3335b92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to make a 1-dimensional sparse histogram.  <a href="group__histogram.html#ga23b63e6a525a040fcf4d1ec9f3335b92">More...</a><br /></td></tr>
<tr class="separator:ga23b63e6a525a040fcf4d1ec9f3335b92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca4da59a7dea5b04288b2d8ffc070bd9"><td class="memTemplParams" colspan="2">template&lt;typename ArgType , typename Iterator1 , typename Iterator2 &gt; </td></tr>
<tr class="memitem:aca4da59a7dea5b04288b2d8ffc070bd9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classhydra_1_1SplineFunctor.html">SplineFunctor</a>&lt; Iterator1, Iterator2, ArgType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#aca4da59a7dea5b04288b2d8ffc070bd9">make_spline</a> (Iterator1 firstX, Iterator1 lastX, Iterator2 firstY)</td></tr>
<tr class="separator:aca4da59a7dea5b04288b2d8ffc070bd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5d935ff11788a556de78fb586b908c4"><td class="memTemplParams" colspan="2">template&lt;typename ArgType , typename Iterable1 , typename Iterable2 &gt; </td></tr>
<tr class="memitem:ac5d935ff11788a556de78fb586b908c4"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; Iterable1 &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; Iterable2 &gt;::value, <a class="el" href="classhydra_1_1SplineFunctor.html">SplineFunctor</a>&lt; decltype(std::declval&lt; Iterable1 &gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()), decltype(std::declval&lt; Iterable2 &gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()), ArgType &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ac5d935ff11788a556de78fb586b908c4">make_spline</a> (Iterable1 &amp;&amp;x, Iterable2 &amp;&amp;y)</td></tr>
<tr class="separator:ac5d935ff11788a556de78fb586b908c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b09185a07939b47374a5caa7b163217"><td class="memTemplParams" colspan="2">template&lt;typename T , hydra::detail::Backend BACKEND&gt; </td></tr>
<tr class="memitem:a7b09185a07939b47374a5caa7b163217"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classhydra_1_1SplineFunctor.html">SplineFunctor</a>&lt; decltype(std::declval&lt; <a class="el" href="group__histogram.html#classhydra_1_1DenseHistogram">DenseHistogram</a>&lt; T, 1, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1unidimensional">detail::unidimensional</a> &gt; &gt;).GetBinsCenters().<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()), decltype(std::declval&lt; <a class="el" href="group__histogram.html#classhydra_1_1DenseHistogram">DenseHistogram</a>&lt; T, 1, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1unidimensional">detail::unidimensional</a> &gt; &gt;).GetBinsContents().<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()), T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a7b09185a07939b47374a5caa7b163217">make_spline</a> (<a class="el" href="group__histogram.html#classhydra_1_1DenseHistogram">DenseHistogram</a>&lt; T, 1, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1unidimensional">detail::unidimensional</a> &gt; const &amp;histogram)</td></tr>
<tr class="separator:a7b09185a07939b47374a5caa7b163217"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd5c4e348e70a6846b9a3ab62d4e4f26"><td class="memTemplParams" colspan="2">template&lt;typename T , hydra::detail::Backend BACKEND&gt; </td></tr>
<tr class="memitem:abd5c4e348e70a6846b9a3ab62d4e4f26"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_convertible&lt; T, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt;::value, <a class="el" href="classhydra_1_1Spline2DFunctor.html">Spline2DFunctor</a>&lt; decltype(std::declval&lt; <a class="el" href="group__histogram.html#classhydra_1_1DenseHistogram">DenseHistogram</a>&lt; T, 2, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1multidimensional">detail::multidimensional</a> &gt; &gt;).GetBinsCenters(<a class="el" href="namespacehydra_1_1placeholders.html#ac0d56a89cc015c8579b7933cc78552e7">placeholders::_0</a>).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()), decltype(std::declval&lt; <a class="el" href="group__histogram.html#classhydra_1_1DenseHistogram">DenseHistogram</a>&lt; T, 2, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1multidimensional">detail::multidimensional</a> &gt; &gt;).GetBinsCenters(<a class="el" href="namespacehydra_1_1placeholders.html#aeeeb42f8f504622ab1fbb117da05fcab">placeholders::_1</a>).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()), decltype(std::declval&lt; <a class="el" href="group__histogram.html#classhydra_1_1DenseHistogram">DenseHistogram</a>&lt; T, 2, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1multidimensional">detail::multidimensional</a> &gt; &gt;).GetBinsContents().<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()), <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#abd5c4e348e70a6846b9a3ab62d4e4f26">make_spline</a> (<a class="el" href="group__histogram.html#classhydra_1_1DenseHistogram">DenseHistogram</a>&lt; T, 2, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1multidimensional">detail::multidimensional</a> &gt; const &amp;histogram)</td></tr>
<tr class="separator:abd5c4e348e70a6846b9a3ab62d4e4f26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11f75d22cd39a0978df79fb629cf1a18"><td class="memTemplParams" colspan="2">template&lt;typename T , hydra::detail::Backend BACKEND&gt; </td></tr>
<tr class="memitem:a11f75d22cd39a0978df79fb629cf1a18"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classhydra_1_1SplineFunctor.html">SplineFunctor</a>&lt; decltype(std::declval&lt; <a class="el" href="group__histogram.html#classhydra_1_1SparseHistogram">SparseHistogram</a>&lt; T, 1, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1unidimensional">detail::unidimensional</a> &gt; &gt;).GetBinsCenters().<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()), decltype(std::declval&lt; <a class="el" href="group__histogram.html#classhydra_1_1SparseHistogram">SparseHistogram</a>&lt; T, 1, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1unidimensional">detail::unidimensional</a> &gt; &gt;).GetBinsContents().<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()), T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a11f75d22cd39a0978df79fb629cf1a18">make_spline</a> (<a class="el" href="group__histogram.html#classhydra_1_1SparseHistogram">SparseHistogram</a>&lt; T, 1, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1unidimensional">detail::unidimensional</a> &gt; const &amp;histogram)</td></tr>
<tr class="separator:a11f75d22cd39a0978df79fb629cf1a18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cb4f712fa5d988db7135da360347f15"><td class="memTemplParams" colspan="2">template&lt;typename T , hydra::detail::Backend BACKEND&gt; </td></tr>
<tr class="memitem:a8cb4f712fa5d988db7135da360347f15"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_convertible&lt; T, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt;::value, <a class="el" href="classhydra_1_1Spline2DFunctor.html">Spline2DFunctor</a>&lt; decltype(std::declval&lt; <a class="el" href="group__histogram.html#classhydra_1_1SparseHistogram">SparseHistogram</a>&lt; T, 2, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1multidimensional">detail::multidimensional</a> &gt; &gt;).GetBinsCenters(<a class="el" href="namespacehydra_1_1placeholders.html#ac0d56a89cc015c8579b7933cc78552e7">placeholders::_0</a>).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()), decltype(std::declval&lt; <a class="el" href="group__histogram.html#classhydra_1_1SparseHistogram">SparseHistogram</a>&lt; T, 2, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1multidimensional">detail::multidimensional</a> &gt; &gt;).GetBinsCenters(<a class="el" href="namespacehydra_1_1placeholders.html#aeeeb42f8f504622ab1fbb117da05fcab">placeholders::_1</a>).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()), decltype(std::declval&lt; <a class="el" href="group__histogram.html#classhydra_1_1SparseHistogram">SparseHistogram</a>&lt; T, 2, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1multidimensional">detail::multidimensional</a> &gt; &gt;).GetBinsContents().<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()), <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a8cb4f712fa5d988db7135da360347f15">make_spline</a> (<a class="el" href="group__histogram.html#classhydra_1_1SparseHistogram">SparseHistogram</a>&lt; T, 2, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1multidimensional">detail::multidimensional</a> &gt; const &amp;histogram)</td></tr>
<tr class="separator:a8cb4f712fa5d988db7135da360347f15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c65353b69cb026bf01fb3e3e0710d57"><td class="memTemplParams" colspan="2">template&lt;typename T , hydra::detail::Backend BACKEND&gt; </td></tr>
<tr class="memitem:a0c65353b69cb026bf01fb3e3e0710d57"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_convertible&lt; T, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt;::value, <a class="el" href="classhydra_1_1Spline3DFunctor.html">Spline3DFunctor</a>&lt; decltype(std::declval&lt; <a class="el" href="group__histogram.html#classhydra_1_1DenseHistogram">DenseHistogram</a>&lt; T, 3, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1multidimensional">detail::multidimensional</a> &gt; &gt;).GetBinsCenters(<a class="el" href="namespacehydra_1_1placeholders.html#ac0d56a89cc015c8579b7933cc78552e7">placeholders::_0</a>).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()), decltype(std::declval&lt; <a class="el" href="group__histogram.html#classhydra_1_1DenseHistogram">DenseHistogram</a>&lt; T, 3, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1multidimensional">detail::multidimensional</a> &gt; &gt;).GetBinsCenters(<a class="el" href="namespacehydra_1_1placeholders.html#aeeeb42f8f504622ab1fbb117da05fcab">placeholders::_1</a>).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()), decltype(std::declval&lt; <a class="el" href="group__histogram.html#classhydra_1_1DenseHistogram">DenseHistogram</a>&lt; T, 3, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1multidimensional">detail::multidimensional</a> &gt; &gt;).GetBinsCenters(<a class="el" href="namespacehydra_1_1placeholders.html#adfba0f80c06fadc6694f3f3ad8ed68bc">placeholders::_2</a>).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()), decltype(std::declval&lt; <a class="el" href="group__histogram.html#classhydra_1_1DenseHistogram">DenseHistogram</a>&lt; T, 3, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1multidimensional">detail::multidimensional</a> &gt; &gt;).GetBinsContents().<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()), <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a0c65353b69cb026bf01fb3e3e0710d57">make_spline</a> (<a class="el" href="group__histogram.html#classhydra_1_1DenseHistogram">DenseHistogram</a>&lt; T, 3, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1multidimensional">detail::multidimensional</a> &gt; const &amp;histogram)</td></tr>
<tr class="separator:a0c65353b69cb026bf01fb3e3e0710d57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36434857108a16306e46b6bef7e925b0"><td class="memTemplParams" colspan="2">template&lt;typename T , hydra::detail::Backend BACKEND&gt; </td></tr>
<tr class="memitem:a36434857108a16306e46b6bef7e925b0"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_convertible&lt; T, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt;::value, <a class="el" href="classhydra_1_1Spline3DFunctor.html">Spline3DFunctor</a>&lt; decltype(std::declval&lt; <a class="el" href="group__histogram.html#classhydra_1_1SparseHistogram">SparseHistogram</a>&lt; T, 3, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1multidimensional">detail::multidimensional</a> &gt; &gt;).GetBinsCenters(<a class="el" href="namespacehydra_1_1placeholders.html#ac0d56a89cc015c8579b7933cc78552e7">placeholders::_0</a>).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()), decltype(std::declval&lt; <a class="el" href="group__histogram.html#classhydra_1_1SparseHistogram">SparseHistogram</a>&lt; T, 3, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1multidimensional">detail::multidimensional</a> &gt; &gt;).GetBinsCenters(<a class="el" href="namespacehydra_1_1placeholders.html#aeeeb42f8f504622ab1fbb117da05fcab">placeholders::_1</a>).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()), decltype(std::declval&lt; <a class="el" href="group__histogram.html#classhydra_1_1SparseHistogram">SparseHistogram</a>&lt; T, 3, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1multidimensional">detail::multidimensional</a> &gt; &gt;).GetBinsCenters(<a class="el" href="namespacehydra_1_1placeholders.html#adfba0f80c06fadc6694f3f3ad8ed68bc">placeholders::_2</a>).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()), decltype(std::declval&lt; <a class="el" href="group__histogram.html#classhydra_1_1SparseHistogram">SparseHistogram</a>&lt; T, 3, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1multidimensional">detail::multidimensional</a> &gt; &gt;).GetBinsContents().<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()), <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a36434857108a16306e46b6bef7e925b0">make_spline</a> (<a class="el" href="group__histogram.html#classhydra_1_1SparseHistogram">SparseHistogram</a>&lt; T, 3, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1multidimensional">detail::multidimensional</a> &gt; const &amp;histogram)</td></tr>
<tr class="separator:a36434857108a16306e46b6bef7e925b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d1d020b412e5a0bf9b62c42cb5f92f6"><td class="memTemplParams" colspan="2">template&lt;typename T , hydra::detail::Backend BACKEND&gt; </td></tr>
<tr class="memitem:a3d1d020b412e5a0bf9b62c42cb5f92f6"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_convertible&lt; T, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt;::value, <a class="el" href="classhydra_1_1Spline4DFunctor.html">Spline4DFunctor</a>&lt; decltype(std::declval&lt; <a class="el" href="group__histogram.html#classhydra_1_1DenseHistogram">DenseHistogram</a>&lt; T, 4, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1multidimensional">detail::multidimensional</a> &gt; &gt;).GetBinsCenters(<a class="el" href="namespacehydra_1_1placeholders.html#ac0d56a89cc015c8579b7933cc78552e7">placeholders::_0</a>).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()), decltype(std::declval&lt; <a class="el" href="group__histogram.html#classhydra_1_1DenseHistogram">DenseHistogram</a>&lt; T, 4, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1multidimensional">detail::multidimensional</a> &gt; &gt;).GetBinsCenters(<a class="el" href="namespacehydra_1_1placeholders.html#aeeeb42f8f504622ab1fbb117da05fcab">placeholders::_1</a>).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()), decltype(std::declval&lt; <a class="el" href="group__histogram.html#classhydra_1_1DenseHistogram">DenseHistogram</a>&lt; T, 4, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1multidimensional">detail::multidimensional</a> &gt; &gt;).GetBinsCenters(<a class="el" href="namespacehydra_1_1placeholders.html#adfba0f80c06fadc6694f3f3ad8ed68bc">placeholders::_2</a>).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()), decltype(std::declval&lt; <a class="el" href="group__histogram.html#classhydra_1_1DenseHistogram">DenseHistogram</a>&lt; T, 4, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1multidimensional">detail::multidimensional</a> &gt; &gt;).GetBinsCenters(<a class="el" href="namespacehydra_1_1placeholders.html#a09db94b16cc11622963193aaff7d90f1">placeholders::_3</a>).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()), decltype(std::declval&lt; <a class="el" href="group__histogram.html#classhydra_1_1DenseHistogram">DenseHistogram</a>&lt; T, 4, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1multidimensional">detail::multidimensional</a> &gt; &gt;).GetBinsContents().<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()), <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a3d1d020b412e5a0bf9b62c42cb5f92f6">make_spline</a> (<a class="el" href="group__histogram.html#classhydra_1_1DenseHistogram">DenseHistogram</a>&lt; T, 4, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1multidimensional">detail::multidimensional</a> &gt; const &amp;histogram)</td></tr>
<tr class="separator:a3d1d020b412e5a0bf9b62c42cb5f92f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb4419d4fc7b7bdcb9ac9b93af8dc6c4"><td class="memTemplParams" colspan="2">template&lt;typename T , hydra::detail::Backend BACKEND&gt; </td></tr>
<tr class="memitem:adb4419d4fc7b7bdcb9ac9b93af8dc6c4"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_convertible&lt; T, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt;::value, <a class="el" href="classhydra_1_1Spline4DFunctor.html">Spline4DFunctor</a>&lt; decltype(std::declval&lt; <a class="el" href="group__histogram.html#classhydra_1_1SparseHistogram">SparseHistogram</a>&lt; T, 4, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1multidimensional">detail::multidimensional</a> &gt; &gt;).GetBinsCenters(<a class="el" href="namespacehydra_1_1placeholders.html#ac0d56a89cc015c8579b7933cc78552e7">placeholders::_0</a>).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()), decltype(std::declval&lt; <a class="el" href="group__histogram.html#classhydra_1_1SparseHistogram">SparseHistogram</a>&lt; T, 4, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1multidimensional">detail::multidimensional</a> &gt; &gt;).GetBinsCenters(<a class="el" href="namespacehydra_1_1placeholders.html#aeeeb42f8f504622ab1fbb117da05fcab">placeholders::_1</a>).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()), decltype(std::declval&lt; <a class="el" href="group__histogram.html#classhydra_1_1SparseHistogram">SparseHistogram</a>&lt; T, 4, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1multidimensional">detail::multidimensional</a> &gt; &gt;).GetBinsCenters(<a class="el" href="namespacehydra_1_1placeholders.html#adfba0f80c06fadc6694f3f3ad8ed68bc">placeholders::_2</a>).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()), decltype(std::declval&lt; <a class="el" href="group__histogram.html#classhydra_1_1SparseHistogram">SparseHistogram</a>&lt; T, 4, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1multidimensional">detail::multidimensional</a> &gt; &gt;).GetBinsCenters(<a class="el" href="namespacehydra_1_1placeholders.html#a09db94b16cc11622963193aaff7d90f1">placeholders::_3</a>).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()), decltype(std::declval&lt; <a class="el" href="group__histogram.html#classhydra_1_1SparseHistogram">SparseHistogram</a>&lt; T, 4, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1multidimensional">detail::multidimensional</a> &gt; &gt;).GetBinsContents().<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()), <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#adb4419d4fc7b7bdcb9ac9b93af8dc6c4">make_spline</a> (<a class="el" href="group__histogram.html#classhydra_1_1SparseHistogram">SparseHistogram</a>&lt; T, 4, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1multidimensional">detail::multidimensional</a> &gt; const &amp;histogram)</td></tr>
<tr class="separator:adb4419d4fc7b7bdcb9ac9b93af8dc6c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe57f02443c2a34dc68590831917fb19"><td class="memTemplParams" colspan="2">template&lt;typename ArgTypeX , typename ArgTypeY , typename IteratorX , typename IteratorY , typename IteratorZ &gt; </td></tr>
<tr class="memitem:abe57f02443c2a34dc68590831917fb19"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classhydra_1_1Spline2DFunctor.html">Spline2DFunctor</a>&lt; IteratorX, IteratorY, IteratorZ, ArgTypeX, ArgTypeY &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#abe57f02443c2a34dc68590831917fb19">make_spline2D</a> (IteratorX firstX, IteratorX lastX, IteratorY firstY, IteratorY lastY, IteratorZ firstZ)</td></tr>
<tr class="separator:abe57f02443c2a34dc68590831917fb19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae86e584b24ad42a95a80c77bc2234ed0"><td class="memTemplParams" colspan="2">template&lt;typename ArgTypeX , typename ArgTypeY , typename IterableX , typename IterableY , typename IterableZ &gt; </td></tr>
<tr class="memitem:ae86e584b24ad42a95a80c77bc2234ed0"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; IterableX &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; IterableY &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; IterableZ &gt;::value, <a class="el" href="classhydra_1_1Spline2DFunctor.html">Spline2DFunctor</a>&lt; decltype(std::declval&lt; IterableX &gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()),decltype(std::declval&lt; IterableY &gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()), decltype(std::declval&lt; IterableZ &gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()), ArgTypeX, ArgTypeY &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ae86e584b24ad42a95a80c77bc2234ed0">make_spline2D</a> (IterableX &amp;&amp;x, IterableY &amp;&amp;y, IterableZ &amp;&amp;z)</td></tr>
<tr class="separator:ae86e584b24ad42a95a80c77bc2234ed0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a147cb991452c985fd3827012cb8b6e49"><td class="memTemplParams" colspan="2">template&lt;typename ArgTypeX , typename ArgTypeY , typename ArgTypeZ , typename IteratorX , typename IteratorY , typename IteratorZ , typename IteratorM &gt; </td></tr>
<tr class="memitem:a147cb991452c985fd3827012cb8b6e49"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classhydra_1_1Spline3DFunctor.html">Spline3DFunctor</a>&lt; IteratorX, IteratorY, IteratorZ, IteratorM, ArgTypeX, ArgTypeY, ArgTypeZ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a147cb991452c985fd3827012cb8b6e49">make_spline3D</a> (IteratorX firstX, IteratorX lastX, IteratorY firstY, IteratorY lastY, IteratorZ firstZ, IteratorZ lastZ, IteratorM measurements_first)</td></tr>
<tr class="separator:a147cb991452c985fd3827012cb8b6e49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba5a69ae43d621252bd72c7a86b8a428"><td class="memTemplParams" colspan="2">template&lt;typename ArgTypeX , typename ArgTypeY , typename ArgTypeZ , typename IterableX , typename IterableY , typename IterableZ , typename IterableM &gt; </td></tr>
<tr class="memitem:aba5a69ae43d621252bd72c7a86b8a428"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; IterableX &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; IterableY &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; IterableZ &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; IterableM &gt;::value, <a class="el" href="classhydra_1_1Spline3DFunctor.html">Spline3DFunctor</a>&lt; decltype(std::declval&lt; IterableX &gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()),decltype(std::declval&lt; IterableY &gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()), decltype(std::declval&lt; IterableZ &gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()), decltype(std::declval&lt; IterableM &gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()), ArgTypeX, ArgTypeY, ArgTypeZ &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#aba5a69ae43d621252bd72c7a86b8a428">make_spline3D</a> (IterableX &amp;&amp;x, IterableY &amp;&amp;y, IterableZ &amp;&amp;z, IterableM &amp;&amp;measurements)</td></tr>
<tr class="separator:aba5a69ae43d621252bd72c7a86b8a428"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1db1991c330a4252eca5e6f54d817144"><td class="memTemplParams" colspan="2">template&lt;typename ArgTypeX , typename ArgTypeY , typename ArgTypeW , typename ArgTypeZ , typename IteratorX , typename IteratorY , typename IteratorW , typename IteratorZ , typename IteratorM &gt; </td></tr>
<tr class="memitem:a1db1991c330a4252eca5e6f54d817144"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classhydra_1_1Spline4DFunctor.html">Spline4DFunctor</a>&lt; IteratorX, IteratorY, IteratorW, IteratorZ, IteratorM, ArgTypeX, ArgTypeY, ArgTypeW, ArgTypeZ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a1db1991c330a4252eca5e6f54d817144">make_spline4D</a> (IteratorX firstX, IteratorX lastX, IteratorY firstY, IteratorY lastY, IteratorW firstW, IteratorW lastW, IteratorZ firstZ, IteratorZ lastZ, IteratorM measurements_first)</td></tr>
<tr class="separator:a1db1991c330a4252eca5e6f54d817144"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64fcd2ab64d8c4cca3ec8d1f349c75da"><td class="memTemplParams" colspan="2">template&lt;typename ArgTypeX , typename ArgTypeY , typename ArgTypeW , typename ArgTypeZ , typename IterableX , typename IterableY , typename IterableW , typename IterableZ , typename IterableM &gt; </td></tr>
<tr class="memitem:a64fcd2ab64d8c4cca3ec8d1f349c75da"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; IterableX &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; IterableY &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; IterableW &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; IterableZ &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; IterableM &gt;::value, <a class="el" href="classhydra_1_1Spline4DFunctor.html">Spline4DFunctor</a>&lt; decltype(std::declval&lt; IterableX &gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()), decltype(std::declval&lt; IterableY &gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()), decltype(std::declval&lt; IterableW &gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()), decltype(std::declval&lt; IterableZ &gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()), decltype(std::declval&lt; IterableM &gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()), ArgTypeX, ArgTypeY, ArgTypeW, ArgTypeZ &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a64fcd2ab64d8c4cca3ec8d1f349c75da">make_spline4D</a> (IterableX &amp;&amp;x, IterableY &amp;&amp;y, IterableW &amp;&amp;w, IterableZ &amp;&amp;z, IterableM &amp;&amp;measurements)</td></tr>
<tr class="separator:a64fcd2ab64d8c4cca3ec8d1f349c75da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f74fb09a286265393fbce752c0c32cb"><td class="memTemplParams" colspan="2">template&lt;typename Iterator , typename PDF1 , typename PDF2 , typename ... PDFs&gt; </td></tr>
<tr class="memitem:a7f74fb09a286265393fbce752c0c32cb"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterator.html">detail::is_iterator</a>&lt; Iterator &gt;::value, <a class="el" href="group__fit.html#classhydra_1_1SPlot">SPlot</a>&lt; Iterator, PDF1, PDF2, PDFs... &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a7f74fb09a286265393fbce752c0c32cb">make_splot</a> (<a class="el" href="group__fit.html#classhydra_1_1PDFSumExtendable">PDFSumExtendable</a>&lt; PDF1, PDF2, PDFs... &gt; const &amp;pdf, Iterator first, Iterator last)</td></tr>
<tr class="memdesc:a7f74fb09a286265393fbce752c0c32cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function for instantiating <a class="el" href="group__fit.html#classhydra_1_1SPlot" title="Implementation of {s}_{Plot} technique for statistical unfolding of sample containing events from dif...">SPlot</a> objects using type deduction.  <a href="#a7f74fb09a286265393fbce752c0c32cb">More...</a><br /></td></tr>
<tr class="separator:a7f74fb09a286265393fbce752c0c32cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5ead3609a0334574dba725caebf656b"><td class="memTemplParams" colspan="2">template&lt;typename Iterable , typename PDF1 , typename PDF2 , typename ... PDFs&gt; </td></tr>
<tr class="memitem:ac5ead3609a0334574dba725caebf656b"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">detail::is_iterable</a>&lt; Iterable &gt;::value, <a class="el" href="group__fit.html#classhydra_1_1SPlot">SPlot</a>&lt; decltype(std::declval&lt; Iterable &gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()), PDF1, PDF2, PDFs... &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ac5ead3609a0334574dba725caebf656b">make_splot</a> (<a class="el" href="group__fit.html#classhydra_1_1PDFSumExtendable">PDFSumExtendable</a>&lt; PDF1, PDF2, PDFs... &gt; const &amp;pdf, Iterable &amp;&amp;<a class="el" href="basic__distributions_8inl.html#a248ea98483ce90baaf65a7682438d72d">data</a>)</td></tr>
<tr class="memdesc:ac5ead3609a0334574dba725caebf656b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function for instantiating <a class="el" href="group__fit.html#classhydra_1_1SPlot" title="Implementation of {s}_{Plot} technique for statistical unfolding of sample containing events from dif...">SPlot</a> objects using type deduction.  <a href="#ac5ead3609a0334574dba725caebf656b">More...</a><br /></td></tr>
<tr class="separator:ac5ead3609a0334574dba725caebf656b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9e1c8df3eaea2b9e4646c5dcdeaf322"><td class="memTemplParams" colspan="2">template&lt;class ... T&gt; </td></tr>
<tr class="memitem:ae9e1c8df3eaea2b9e4646c5dcdeaf322"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ae9e1c8df3eaea2b9e4646c5dcdeaf322">make_tuple</a> (T &amp;&amp;... t) -&gt; decltype(hydra::thrust::make_tuple(std::forward&lt; T &gt;(t)...))</td></tr>
<tr class="memdesc:ae9e1c8df3eaea2b9e4646c5dcdeaf322"><td class="mdescLeft">&#160;</td><td class="mdescRight">This version of <code>make_tuple</code> creates a new <code>tuple</code> object from a list of objects.  <a href="#ae9e1c8df3eaea2b9e4646c5dcdeaf322">More...</a><br /></td></tr>
<tr class="separator:ae9e1c8df3eaea2b9e4646c5dcdeaf322"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a390592daf1ffc898bb26a468c09c17f8"><td class="memTemplParams" colspan="2">template&lt;hydra::detail::Backend BACKEND, typename ... T, typename ... U&gt; </td></tr>
<tr class="memitem:a390592daf1ffc898bb26a468c09c17f8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacehydra.html#classhydra_1_1Range">hydra::Range</a>&lt; hydra::thrust::zip_iterator&lt; typename <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1tuple__cat__type">detail::tuple_cat_type</a>&lt; typename <a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; hydra::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::iterator_tuple, typename <a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; hydra::thrust::tuple&lt; U... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::iterator_tuple &gt;::type &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a390592daf1ffc898bb26a468c09c17f8">meld</a> (<a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; hydra::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; &amp;left, <a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; hydra::thrust::tuple&lt; U... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; &amp;right)</td></tr>
<tr class="separator:a390592daf1ffc898bb26a468c09c17f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80fad279987242786b27065cd239f604"><td class="memTemplParams" colspan="2">template&lt;typename F1 , typename F2 &gt; </td></tr>
<tr class="memitem:a80fad279987242786b27065cd239f604"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;(<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt; F1 &gt;::value||<a class="el" href="structhydra_1_1detail_1_1is__hydra__lambda.html">detail::is_hydra_lambda</a>&lt; F1 &gt;::value) &amp;&amp;(<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt; F2 &gt;::value||<a class="el" href="structhydra_1_1detail_1_1is__hydra__lambda.html">detail::is_hydra_lambda</a>&lt; F2 &gt;::value), <a class="el" href="classhydra_1_1Minus.html">Minus</a>&lt; F1, F2 &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a80fad279987242786b27065cd239f604">minus</a> (F1 const &amp;f1, F2 const &amp;f2)</td></tr>
<tr class="separator:a80fad279987242786b27065cd239f604"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0b00e7787e93fe0624bb0422409b482"><td class="memTemplParams" colspan="2">template&lt;typename F1 , typename F2 , typename ... Fs&gt; </td></tr>
<tr class="memitem:ad0b00e7787e93fe0624bb0422409b482"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;(<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt; F1 &gt;::value||<a class="el" href="structhydra_1_1detail_1_1is__hydra__lambda.html">detail::is_hydra_lambda</a>&lt; F1 &gt;::value) &amp;&amp;(<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt; F2 &gt;::value||<a class="el" href="structhydra_1_1detail_1_1is__hydra__lambda.html">detail::is_hydra_lambda</a>&lt; F2 &gt;::value) &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1all__true.html">detail::all_true</a>&lt;(<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt; Fs &gt;::value||<a class="el" href="structhydra_1_1detail_1_1is__hydra__lambda.html">detail::is_hydra_lambda</a>&lt; Fs &gt;::value)... &gt;::value, <a class="el" href="classhydra_1_1Multiply.html">Multiply</a>&lt; F1, F2, Fs... &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ad0b00e7787e93fe0624bb0422409b482">multiply</a> (F1 const &amp;f1, F2 const &amp;f2, Fs const &amp;... functors)</td></tr>
<tr class="separator:ad0b00e7787e93fe0624bb0422409b482"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f06ee4cd16c4cd697a380053748bf67"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2f06ee4cd16c4cd697a380053748bf67"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespace_3globalScope_4.html#classint">int</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a2f06ee4cd16c4cd697a380053748bf67">nint</a> (const T x)</td></tr>
<tr class="memdesc:a2f06ee4cd16c4cd697a380053748bf67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Round to nearest integer.  <a href="#a2f06ee4cd16c4cd697a380053748bf67">More...</a><br /></td></tr>
<tr class="separator:a2f06ee4cd16c4cd697a380053748bf67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5fd2d8f62c3075ccdd36241e8dc6881"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab5fd2d8f62c3075ccdd36241e8dc6881"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ab5fd2d8f62c3075ccdd36241e8dc6881">norm</a> (const <a class="el" href="namespacehydra.html#a9d2c06cb9672fe86dbeaa65e8f35a2bf">complex</a>&lt; T &gt; &amp;z)</td></tr>
<tr class="separator:ab5fd2d8f62c3075ccdd36241e8dc6881"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24943c0d2419a40a68f0fb61e0a1b05f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a24943c0d2419a40a68f0fb61e0a1b05f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a24943c0d2419a40a68f0fb61e0a1b05f">operator!=</a> (const <a class="el" href="namespacehydra.html#a9d2c06cb9672fe86dbeaa65e8f35a2bf">complex</a>&lt; T &gt; &amp;lhs, const <a class="el" href="namespacehydra.html#a9d2c06cb9672fe86dbeaa65e8f35a2bf">complex</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="separator:a24943c0d2419a40a68f0fb61e0a1b05f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a716c80436ab96c757325cae3cd517960"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a716c80436ab96c757325cae3cd517960"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a716c80436ab96c757325cae3cd517960">operator!=</a> (const T &amp;lhs, const <a class="el" href="namespacehydra.html#a9d2c06cb9672fe86dbeaa65e8f35a2bf">complex</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="separator:a716c80436ab96c757325cae3cd517960"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91d952f42e31697e4b457b1a58424cb5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a91d952f42e31697e4b457b1a58424cb5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a91d952f42e31697e4b457b1a58424cb5">operator!=</a> (const <a class="el" href="namespacehydra.html#a9d2c06cb9672fe86dbeaa65e8f35a2bf">complex</a>&lt; T &gt; &amp;lhs, const T &amp;rhs)</td></tr>
<tr class="separator:a91d952f42e31697e4b457b1a58424cb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa51499fa04d39681eb6244313d32a16c"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N, hydra::detail::Backend BACKEND1, hydra::detail::Backend BACKEND2&gt; </td></tr>
<tr class="memitem:aa51499fa04d39681eb6244313d32a16c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#aa51499fa04d39681eb6244313d32a16c">operator!=</a> (const <a class="el" href="namespacehydra.html#classhydra_1_1multiarray">multiarray</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND1 &gt;&gt; &amp;lhs, const <a class="el" href="namespacehydra.html#classhydra_1_1multiarray">multiarray</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND2 &gt;&gt; &amp;rhs)</td></tr>
<tr class="separator:aa51499fa04d39681eb6244313d32a16c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a295dd80678d0052fd65fa6cf68d67faf"><td class="memTemplParams" colspan="2">template&lt;typename ... T, hydra::detail::Backend BACKEND1, hydra::detail::Backend BACKEND2&gt; </td></tr>
<tr class="memitem:a295dd80678d0052fd65fa6cf68d67faf"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a295dd80678d0052fd65fa6cf68d67faf">operator!=</a> (const <a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; hydra::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND1 &gt;&gt; &amp;lhs, const <a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; hydra::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND2 &gt;&gt; &amp;rhs)</td></tr>
<tr class="separator:a295dd80678d0052fd65fa6cf68d67faf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad01febd59c4dfebc87b5d363955d65db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> Vector3R&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ad01febd59c4dfebc87b5d363955d65db">operator*</a> (<a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> c, const Vector3R &amp;v2)</td></tr>
<tr class="separator:ad01febd59c4dfebc87b5d363955d65db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dce6130507b07eaac142c1815ade3f2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> Vector3R&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a0dce6130507b07eaac142c1815ade3f2">operator*</a> (const Vector3R &amp;v1, <a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> c)</td></tr>
<tr class="separator:a0dce6130507b07eaac142c1815ade3f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd42c2a636a5bfb4e605ddd9f1ea069a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#afd42c2a636a5bfb4e605ddd9f1ea069a">operator*</a> (const Vector3R &amp;v1, const Vector3R &amp;v2)</td></tr>
<tr class="separator:afd42c2a636a5bfb4e605ddd9f1ea069a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7578f3dee6f04171d8ebb4316b59cbd0"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a7578f3dee6f04171d8ebb4316b59cbd0"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;(<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt; T1 &gt;::value||<a class="el" href="structhydra_1_1detail_1_1is__hydra__lambda.html">detail::is_hydra_lambda</a>&lt; T1 &gt;::value) &amp;&amp;(<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt; T2 &gt;::value||<a class="el" href="structhydra_1_1detail_1_1is__hydra__lambda.html">detail::is_hydra_lambda</a>&lt; T2 &gt;::value), <a class="el" href="classhydra_1_1Multiply.html">Multiply</a>&lt; T1, T2 &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a7578f3dee6f04171d8ebb4316b59cbd0">operator*</a> (T1 const &amp;F1, T2 const &amp;F2)</td></tr>
<tr class="separator:a7578f3dee6f04171d8ebb4316b59cbd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5bae5caa4d9b5c0190220e55f650859"><td class="memItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> Vector4R&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ae5bae5caa4d9b5c0190220e55f650859">operator*</a> (<a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> c, const Vector4R &amp;v2)</td></tr>
<tr class="separator:ae5bae5caa4d9b5c0190220e55f650859"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6888146476615c2854543f7a087ba39e"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a6888146476615c2854543f7a087ba39e"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;(<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt; T &gt;::value||<a class="el" href="structhydra_1_1detail_1_1is__hydra__lambda.html">detail::is_hydra_lambda</a>&lt; T &gt;::value) &amp;&amp;(std::is_arithmetic&lt; U &gt;::value), <a class="el" href="classhydra_1_1Multiply.html">Multiply</a>&lt; <a class="el" href="structhydra_1_1Constant.html">Constant</a>&lt; U &gt;, T &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a6888146476615c2854543f7a087ba39e">operator*</a> (U const cte, T const &amp;F)</td></tr>
<tr class="separator:a6888146476615c2854543f7a087ba39e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2b0be1f22ac4914bd6ce0bc97411bff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> Vector4R&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ae2b0be1f22ac4914bd6ce0bc97411bff">operator*</a> (const Vector4R &amp;v2, <a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> c)</td></tr>
<tr class="separator:ae2b0be1f22ac4914bd6ce0bc97411bff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2721dd323f0709db66d4883bc4b1d72"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:aa2721dd323f0709db66d4883bc4b1d72"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;(<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt; T &gt;::value||<a class="el" href="structhydra_1_1detail_1_1is__hydra__lambda.html">detail::is_hydra_lambda</a>&lt; T &gt;::value) &amp;&amp;(std::is_arithmetic&lt; U &gt;::value), <a class="el" href="classhydra_1_1Multiply.html">Multiply</a>&lt; <a class="el" href="structhydra_1_1Constant.html">Constant</a>&lt; U &gt;, T &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#aa2721dd323f0709db66d4883bc4b1d72">operator*</a> (T const &amp;F, U cte)</td></tr>
<tr class="separator:aa2721dd323f0709db66d4883bc4b1d72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb096b020e55914fe7a1e885dd66b17e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#adb096b020e55914fe7a1e885dd66b17e">operator*</a> (const Vector4R &amp;v1, const Vector4R &amp;v2)</td></tr>
<tr class="separator:adb096b020e55914fe7a1e885dd66b17e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a269f7c2fafb8f0c9bd28b5104c6c3ea1"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a269f7c2fafb8f0c9bd28b5104c6c3ea1"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;(<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt; T &gt;::value||<a class="el" href="structhydra_1_1detail_1_1is__hydra__lambda.html">detail::is_hydra_lambda</a>&lt; T &gt;::value) &amp;&amp;(std::is_arithmetic&lt; U &gt;::value), <a class="el" href="classhydra_1_1Multiply.html">Multiply</a>&lt; <a class="el" href="structhydra_1_1Constant.html">Constant</a>&lt; <a class="el" href="namespacehydra.html#a9d2c06cb9672fe86dbeaa65e8f35a2bf">hydra::complex</a>&lt; U &gt; &gt;, T &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a269f7c2fafb8f0c9bd28b5104c6c3ea1">operator*</a> (<a class="el" href="namespacehydra.html#a9d2c06cb9672fe86dbeaa65e8f35a2bf">hydra::complex</a>&lt; U &gt; const &amp;cte, T const &amp;F)</td></tr>
<tr class="separator:a269f7c2fafb8f0c9bd28b5104c6c3ea1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31922e38da8d20b98cf9f5e3f0270621"><td class="memTemplParams" colspan="2">template&lt;typename ... T&gt; </td></tr>
<tr class="memitem:a31922e38da8d20b98cf9f5e3f0270621"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::tuple&lt; T... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a31922e38da8d20b98cf9f5e3f0270621">operator*</a> (const hydra::thrust::tuple&lt; T... &gt; &amp;a, const hydra::thrust::tuple&lt; T... &gt; &amp;b)</td></tr>
<tr class="separator:a31922e38da8d20b98cf9f5e3f0270621"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f5602c01e2c9d618b5461201c93e2db"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a4f5602c01e2c9d618b5461201c93e2db"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;(<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt; T &gt;::value||<a class="el" href="structhydra_1_1detail_1_1is__hydra__lambda.html">detail::is_hydra_lambda</a>&lt; T &gt;::value) &amp;&amp;(std::is_arithmetic&lt; U &gt;::value), <a class="el" href="classhydra_1_1Multiply.html">Multiply</a>&lt; <a class="el" href="structhydra_1_1Constant.html">Constant</a>&lt; U &gt;, T &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a4f5602c01e2c9d618b5461201c93e2db">operator*</a> (T const &amp;F, <a class="el" href="namespacehydra.html#a9d2c06cb9672fe86dbeaa65e8f35a2bf">hydra::complex</a>&lt; U &gt; const &amp;cte)</td></tr>
<tr class="separator:a4f5602c01e2c9d618b5461201c93e2db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b98f3604eca3a6023551cd4ce98020a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a0b98f3604eca3a6023551cd4ce98020a">operator*</a> (<a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a> par1, <a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a> const &amp;par2)</td></tr>
<tr class="separator:a0b98f3604eca3a6023551cd4ce98020a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac480ecaec81a0040f3b466ca5904ed5b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ac480ecaec81a0040f3b466ca5904ed5b">operator*</a> (<a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a> par1, <a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> par2)</td></tr>
<tr class="separator:ac480ecaec81a0040f3b466ca5904ed5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0bc15a0070c95cad2a9b6e300b430cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#aa0bc15a0070c95cad2a9b6e300b430cc">operator*</a> (<a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> par1, <a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a> const &amp;par2)</td></tr>
<tr class="separator:aa0bc15a0070c95cad2a9b6e300b430cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c1fc13eb2a4a440f72991b4347a472c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> Vector3R&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a1c1fc13eb2a4a440f72991b4347a472c">operator+</a> (const Vector3R &amp;v1, const Vector3R &amp;v2)</td></tr>
<tr class="separator:a1c1fc13eb2a4a440f72991b4347a472c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab86f27679e7fe8ecdc8e541844be6d4e"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ab86f27679e7fe8ecdc8e541844be6d4e"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;(<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt; T1 &gt;::value||<a class="el" href="structhydra_1_1detail_1_1is__hydra__lambda.html">detail::is_hydra_lambda</a>&lt; T1 &gt;::value) &amp;&amp;(<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt; T2 &gt;::value||<a class="el" href="structhydra_1_1detail_1_1is__hydra__lambda.html">detail::is_hydra_lambda</a>&lt; T2 &gt;::value), <a class="el" href="classhydra_1_1Sum.html">Sum</a>&lt; T1, T2 &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ab86f27679e7fe8ecdc8e541844be6d4e">operator+</a> (T1 const &amp;F1, T2 const &amp;F2)</td></tr>
<tr class="memdesc:ab86f27679e7fe8ecdc8e541844be6d4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">operator+ for two functors.  <a href="#ab86f27679e7fe8ecdc8e541844be6d4e">More...</a><br /></td></tr>
<tr class="separator:ab86f27679e7fe8ecdc8e541844be6d4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abee85dffaf46da1811e0cd22acd275f4"><td class="memTemplParams" colspan="2">template&lt;typename ... T&gt; </td></tr>
<tr class="memitem:abee85dffaf46da1811e0cd22acd275f4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::tuple&lt; T... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#abee85dffaf46da1811e0cd22acd275f4">operator+</a> (const hydra::thrust::tuple&lt; T... &gt; a, const hydra::thrust::tuple&lt; T... &gt; &amp;b)</td></tr>
<tr class="separator:abee85dffaf46da1811e0cd22acd275f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af211604c6cf6319359dd12f375b35b4d"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:af211604c6cf6319359dd12f375b35b4d"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;(<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt; T &gt;::value||<a class="el" href="structhydra_1_1detail_1_1is__hydra__lambda.html">detail::is_hydra_lambda</a>&lt; T &gt;::value) &amp;&amp;(std::is_arithmetic&lt; U &gt;::value), <a class="el" href="classhydra_1_1Sum.html">Sum</a>&lt; <a class="el" href="structhydra_1_1Constant.html">Constant</a>&lt; U &gt;, T &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#af211604c6cf6319359dd12f375b35b4d">operator+</a> (U const cte, T const &amp;F)</td></tr>
<tr class="memdesc:af211604c6cf6319359dd12f375b35b4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">operator+ for a value and a functor.  <a href="#af211604c6cf6319359dd12f375b35b4d">More...</a><br /></td></tr>
<tr class="separator:af211604c6cf6319359dd12f375b35b4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae714861f3eacb01ee0d377c4cba58f17"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ae714861f3eacb01ee0d377c4cba58f17"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;(<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt; T &gt;::value||<a class="el" href="structhydra_1_1detail_1_1is__hydra__lambda.html">detail::is_hydra_lambda</a>&lt; T &gt;::value) &amp;&amp;(std::is_arithmetic&lt; U &gt;::value), <a class="el" href="classhydra_1_1Sum.html">Sum</a>&lt; <a class="el" href="structhydra_1_1Constant.html">Constant</a>&lt; U &gt;, T &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ae714861f3eacb01ee0d377c4cba58f17">operator+</a> (T const &amp;F, U cte)</td></tr>
<tr class="memdesc:ae714861f3eacb01ee0d377c4cba58f17"><td class="mdescLeft">&#160;</td><td class="mdescRight">operator+ for a value and a functor.  <a href="#ae714861f3eacb01ee0d377c4cba58f17">More...</a><br /></td></tr>
<tr class="separator:ae714861f3eacb01ee0d377c4cba58f17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf71333237dfa78b46ecee56661beccb"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:acf71333237dfa78b46ecee56661beccb"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;(<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt; T &gt;::value||<a class="el" href="structhydra_1_1detail_1_1is__hydra__lambda.html">detail::is_hydra_lambda</a>&lt; T &gt;::value) &amp;&amp;(std::is_arithmetic&lt; U &gt;::value), <a class="el" href="classhydra_1_1Sum.html">Sum</a>&lt; <a class="el" href="structhydra_1_1Constant.html">Constant</a>&lt; <a class="el" href="namespacehydra.html#a9d2c06cb9672fe86dbeaa65e8f35a2bf">hydra::complex</a>&lt; U &gt; &gt;, T &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#acf71333237dfa78b46ecee56661beccb">operator+</a> (<a class="el" href="namespacehydra.html#a9d2c06cb9672fe86dbeaa65e8f35a2bf">hydra::complex</a>&lt; U &gt; const &amp;cte, T const &amp;F)</td></tr>
<tr class="memdesc:acf71333237dfa78b46ecee56661beccb"><td class="mdescLeft">&#160;</td><td class="mdescRight">operator+ for a complex value and a functor.  <a href="#acf71333237dfa78b46ecee56661beccb">More...</a><br /></td></tr>
<tr class="separator:acf71333237dfa78b46ecee56661beccb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a08ed0df33d16aa922ba9a4fe3874b6"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a5a08ed0df33d16aa922ba9a4fe3874b6"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;(<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt; T &gt;::value||<a class="el" href="structhydra_1_1detail_1_1is__hydra__lambda.html">detail::is_hydra_lambda</a>&lt; T &gt;::value) &amp;&amp;(std::is_arithmetic&lt; U &gt;::value), <a class="el" href="classhydra_1_1Sum.html">Sum</a>&lt; <a class="el" href="structhydra_1_1Constant.html">Constant</a>&lt; U &gt;, T &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a5a08ed0df33d16aa922ba9a4fe3874b6">operator+</a> (T const &amp;F, <a class="el" href="namespacehydra.html#a9d2c06cb9672fe86dbeaa65e8f35a2bf">hydra::complex</a>&lt; U &gt; const &amp;cte)</td></tr>
<tr class="memdesc:a5a08ed0df33d16aa922ba9a4fe3874b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">operator+ for a complex value and a functor.  <a href="#a5a08ed0df33d16aa922ba9a4fe3874b6">More...</a><br /></td></tr>
<tr class="separator:a5a08ed0df33d16aa922ba9a4fe3874b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af68a4c9bed0e1a2cf2ed9ba9ab057dd0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> Vector4R&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#af68a4c9bed0e1a2cf2ed9ba9ab057dd0">operator+</a> (const Vector4R &amp;v1, const Vector4R &amp;v2)</td></tr>
<tr class="separator:af68a4c9bed0e1a2cf2ed9ba9ab057dd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26e3492eb046c39e1b578738cd5ad7b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a26e3492eb046c39e1b578738cd5ad7b7">operator+</a> (<a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a> par1, <a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a> const &amp;par2)</td></tr>
<tr class="separator:a26e3492eb046c39e1b578738cd5ad7b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a357a28a5ec78cd838e8e90face792425"><td class="memItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a357a28a5ec78cd838e8e90face792425">operator+</a> (<a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a> par1, <a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> par2)</td></tr>
<tr class="separator:a357a28a5ec78cd838e8e90face792425"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af69233e29f096db5c17391b64a4ad0c2"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:af69233e29f096db5c17391b64a4ad0c2"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;(<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt; T1 &gt;::value||<a class="el" href="structhydra_1_1detail_1_1is__hydra__lambda.html">detail::is_hydra_lambda</a>&lt; T1 &gt;::value) &amp;&amp;(<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt; T2 &gt;::value||<a class="el" href="structhydra_1_1detail_1_1is__hydra__lambda.html">detail::is_hydra_lambda</a>&lt; T2 &gt;::value), <a class="el" href="classhydra_1_1Minus.html">Minus</a>&lt; T1, T2 &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#af69233e29f096db5c17391b64a4ad0c2">operator-</a> (T1 const &amp;F1, T2 const &amp;F2)</td></tr>
<tr class="separator:af69233e29f096db5c17391b64a4ad0c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71916daad41dcd1b16ba317699b32da9"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a71916daad41dcd1b16ba317699b32da9"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;(<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt; T &gt;::value||<a class="el" href="structhydra_1_1detail_1_1is__hydra__lambda.html">detail::is_hydra_lambda</a>&lt; T &gt;::value) &amp;&amp;(std::is_arithmetic&lt; U &gt;::value), <a class="el" href="classhydra_1_1Minus.html">Minus</a>&lt; <a class="el" href="structhydra_1_1Constant.html">Constant</a>&lt; U &gt;, T &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a71916daad41dcd1b16ba317699b32da9">operator-</a> (U const cte, T const &amp;F)</td></tr>
<tr class="separator:a71916daad41dcd1b16ba317699b32da9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1113b35a5588af8a55453fbd5e1b2651"><td class="memItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> Vector3R&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a1113b35a5588af8a55453fbd5e1b2651">operator-</a> (const Vector3R &amp;v1, const Vector3R &amp;v2)</td></tr>
<tr class="separator:a1113b35a5588af8a55453fbd5e1b2651"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a130d9256bfd5704541edabcf0908f204"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a130d9256bfd5704541edabcf0908f204"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;(<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt; T &gt;::value||<a class="el" href="structhydra_1_1detail_1_1is__hydra__lambda.html">detail::is_hydra_lambda</a>&lt; T &gt;::value) &amp;&amp;(std::is_arithmetic&lt; U &gt;::value), <a class="el" href="classhydra_1_1Minus.html">Minus</a>&lt; <a class="el" href="structhydra_1_1Constant.html">Constant</a>&lt; U &gt;, T &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a130d9256bfd5704541edabcf0908f204">operator-</a> (T const &amp;F, U cte)</td></tr>
<tr class="separator:a130d9256bfd5704541edabcf0908f204"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8ff276fd53d98090384b19ce18863f1"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ad8ff276fd53d98090384b19ce18863f1"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;(<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt; T &gt;::value||<a class="el" href="structhydra_1_1detail_1_1is__hydra__lambda.html">detail::is_hydra_lambda</a>&lt; T &gt;::value) &amp;&amp;(std::is_arithmetic&lt; U &gt;::value), <a class="el" href="classhydra_1_1Minus.html">Minus</a>&lt; <a class="el" href="structhydra_1_1Constant.html">Constant</a>&lt; <a class="el" href="namespacehydra.html#a9d2c06cb9672fe86dbeaa65e8f35a2bf">hydra::complex</a>&lt; U &gt; &gt;, T &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ad8ff276fd53d98090384b19ce18863f1">operator-</a> (<a class="el" href="namespacehydra.html#a9d2c06cb9672fe86dbeaa65e8f35a2bf">hydra::complex</a>&lt; U &gt; const &amp;cte, T const &amp;F)</td></tr>
<tr class="separator:ad8ff276fd53d98090384b19ce18863f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49d56f7e522b7ce37781b28b79620b54"><td class="memTemplParams" colspan="2">template&lt;typename ... T&gt; </td></tr>
<tr class="memitem:a49d56f7e522b7ce37781b28b79620b54"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::tuple&lt; T... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a49d56f7e522b7ce37781b28b79620b54">operator-</a> (const hydra::thrust::tuple&lt; T... &gt; &amp;a, const hydra::thrust::tuple&lt; T... &gt; &amp;b)</td></tr>
<tr class="separator:a49d56f7e522b7ce37781b28b79620b54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a330909b1bc1e1189c88bd560a7217a0d"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a330909b1bc1e1189c88bd560a7217a0d"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;(<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt; T &gt;::value||<a class="el" href="structhydra_1_1detail_1_1is__hydra__lambda.html">detail::is_hydra_lambda</a>&lt; T &gt;::value) &amp;&amp;(std::is_arithmetic&lt; U &gt;::value), <a class="el" href="classhydra_1_1Minus.html">Minus</a>&lt; <a class="el" href="structhydra_1_1Constant.html">Constant</a>&lt; U &gt;, T &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a330909b1bc1e1189c88bd560a7217a0d">operator-</a> (T const &amp;F, <a class="el" href="namespacehydra.html#a9d2c06cb9672fe86dbeaa65e8f35a2bf">hydra::complex</a>&lt; U &gt; const &amp;cte)</td></tr>
<tr class="separator:a330909b1bc1e1189c88bd560a7217a0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a950f2d5dc4356f6c6c13b9fc3bc7c0ef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> Vector4R&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a950f2d5dc4356f6c6c13b9fc3bc7c0ef">operator-</a> (const Vector4R &amp;v1, const Vector4R &amp;v2)</td></tr>
<tr class="separator:a950f2d5dc4356f6c6c13b9fc3bc7c0ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68375d62444cb2341ade99f0ac15972f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a68375d62444cb2341ade99f0ac15972f">operator-</a> (<a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a> par1, <a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a> const &amp;par2)</td></tr>
<tr class="separator:a68375d62444cb2341ade99f0ac15972f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07c46e4c59a5208f5d495b4ddaf3af75"><td class="memItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a07c46e4c59a5208f5d495b4ddaf3af75">operator-</a> (<a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a> par1, <a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> par2)</td></tr>
<tr class="separator:a07c46e4c59a5208f5d495b4ddaf3af75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a247f457807559c67d34c5b9d15c0b4b4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a247f457807559c67d34c5b9d15c0b4b4">operator-</a> (<a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> par1, <a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a> par2)</td></tr>
<tr class="separator:a247f457807559c67d34c5b9d15c0b4b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3b16aaa8206238e19f573a8b0f07730"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:aa3b16aaa8206238e19f573a8b0f07730"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;(<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt; T1 &gt;::value||<a class="el" href="structhydra_1_1detail_1_1is__hydra__lambda.html">detail::is_hydra_lambda</a>&lt; T1 &gt;::value) &amp;&amp;(<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt; T2 &gt;::value||<a class="el" href="structhydra_1_1detail_1_1is__hydra__lambda.html">detail::is_hydra_lambda</a>&lt; T2 &gt;::value), <a class="el" href="classhydra_1_1Divide.html">Divide</a>&lt; T1, T2 &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#aa3b16aaa8206238e19f573a8b0f07730">operator/</a> (T1 const &amp;F1, T2 const &amp;F2)</td></tr>
<tr class="separator:aa3b16aaa8206238e19f573a8b0f07730"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94cb4a79113148abd78aa8e4d6f7e41d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> Vector3R&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a94cb4a79113148abd78aa8e4d6f7e41d">operator/</a> (const Vector3R &amp;v1, <a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> c)</td></tr>
<tr class="separator:a94cb4a79113148abd78aa8e4d6f7e41d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac9b820e211bbd962531959dc1a78fb3"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:aac9b820e211bbd962531959dc1a78fb3"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;(<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt; T &gt;::value||<a class="el" href="structhydra_1_1detail_1_1is__hydra__lambda.html">detail::is_hydra_lambda</a>&lt; T &gt;::value) &amp;&amp;(std::is_arithmetic&lt; U &gt;::value), <a class="el" href="classhydra_1_1Divide.html">Divide</a>&lt; <a class="el" href="structhydra_1_1Constant.html">Constant</a>&lt; U &gt;, T &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#aac9b820e211bbd962531959dc1a78fb3">operator/</a> (U const cte, T const &amp;F)</td></tr>
<tr class="separator:aac9b820e211bbd962531959dc1a78fb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c3da5b1d54199b2e9af2b84ca58cb9c"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a1c3da5b1d54199b2e9af2b84ca58cb9c"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;(<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt; T &gt;::value||<a class="el" href="structhydra_1_1detail_1_1is__hydra__lambda.html">detail::is_hydra_lambda</a>&lt; T &gt;::value) &amp;&amp;(std::is_arithmetic&lt; U &gt;::value), <a class="el" href="classhydra_1_1Divide.html">Divide</a>&lt; <a class="el" href="structhydra_1_1Constant.html">Constant</a>&lt; U &gt;, T &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a1c3da5b1d54199b2e9af2b84ca58cb9c">operator/</a> (T const &amp;F, U cte)</td></tr>
<tr class="separator:a1c3da5b1d54199b2e9af2b84ca58cb9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a437843c59b2b049d7867bf08aa2ac121"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a437843c59b2b049d7867bf08aa2ac121"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;(<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt; T &gt;::value||<a class="el" href="structhydra_1_1detail_1_1is__hydra__lambda.html">detail::is_hydra_lambda</a>&lt; T &gt;::value) &amp;&amp;(std::is_arithmetic&lt; U &gt;::value), <a class="el" href="classhydra_1_1Divide.html">Divide</a>&lt; <a class="el" href="structhydra_1_1Constant.html">Constant</a>&lt; <a class="el" href="namespacehydra.html#a9d2c06cb9672fe86dbeaa65e8f35a2bf">hydra::complex</a>&lt; U &gt; &gt;, T &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a437843c59b2b049d7867bf08aa2ac121">operator/</a> (<a class="el" href="namespacehydra.html#a9d2c06cb9672fe86dbeaa65e8f35a2bf">hydra::complex</a>&lt; U &gt; const &amp;cte, T const &amp;F)</td></tr>
<tr class="separator:a437843c59b2b049d7867bf08aa2ac121"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c88c44916843fa91a8ecc8179640685"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a7c88c44916843fa91a8ecc8179640685"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;(<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt; T &gt;::value||<a class="el" href="structhydra_1_1detail_1_1is__hydra__lambda.html">detail::is_hydra_lambda</a>&lt; T &gt;::value) &amp;&amp;(std::is_arithmetic&lt; U &gt;::value), <a class="el" href="classhydra_1_1Divide.html">Divide</a>&lt; <a class="el" href="structhydra_1_1Constant.html">Constant</a>&lt; <a class="el" href="namespacehydra.html#a9d2c06cb9672fe86dbeaa65e8f35a2bf">hydra::complex</a>&lt; U &gt; &gt;, T &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a7c88c44916843fa91a8ecc8179640685">operator/</a> (T const &amp;F, <a class="el" href="namespacehydra.html#a9d2c06cb9672fe86dbeaa65e8f35a2bf">hydra::complex</a>&lt; U &gt; const &amp;cte)</td></tr>
<tr class="separator:a7c88c44916843fa91a8ecc8179640685"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4db4d6d0e3fe03dccf661b7ac0751fe7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> Vector4R&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a4db4d6d0e3fe03dccf661b7ac0751fe7">operator/</a> (const Vector4R &amp;v2, <a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> c)</td></tr>
<tr class="separator:a4db4d6d0e3fe03dccf661b7ac0751fe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c87c4ccd857a5c017a3657b29db4df8"><td class="memTemplParams" colspan="2">template&lt;typename ... T&gt; </td></tr>
<tr class="memitem:a8c87c4ccd857a5c017a3657b29db4df8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::tuple&lt; T... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a8c87c4ccd857a5c017a3657b29db4df8">operator/</a> (const hydra::thrust::tuple&lt; T... &gt; &amp;a, const hydra::thrust::tuple&lt; T... &gt; &amp;b)</td></tr>
<tr class="separator:a8c87c4ccd857a5c017a3657b29db4df8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9b1664e58d41d5f8e7ec6d1c20bf9c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ac9b1664e58d41d5f8e7ec6d1c20bf9c0">operator/</a> (<a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a> par1, <a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a> const par2)</td></tr>
<tr class="separator:ac9b1664e58d41d5f8e7ec6d1c20bf9c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a4133d480d7e9f3f5e85286e47a3709"><td class="memItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a0a4133d480d7e9f3f5e85286e47a3709">operator/</a> (<a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a> par1, <a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> par2)</td></tr>
<tr class="separator:a0a4133d480d7e9f3f5e85286e47a3709"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af29cde1e70c62bec6f1fa1ee52940887"><td class="memItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#af29cde1e70c62bec6f1fa1ee52940887">operator/</a> (<a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> par1, <a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a> par2)</td></tr>
<tr class="separator:af29cde1e70c62bec6f1fa1ee52940887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15cdb083719133399edb77f5ef3eb547"><td class="memTemplParams" colspan="2">template&lt;size_t N, typename T &gt; </td></tr>
<tr class="memitem:a15cdb083719133399edb77f5ef3eb547"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a15cdb083719133399edb77f5ef3eb547">operator&lt;&lt;</a> (std::ostream &amp;os, std::array&lt; T, N &gt; const &amp;obj)</td></tr>
<tr class="separator:a15cdb083719133399edb77f5ef3eb547"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fab8d226ee701c0755c60202fc30f6c"><td class="memTemplParams" colspan="2">template&lt;typename ... T&gt; </td></tr>
<tr class="memitem:a6fab8d226ee701c0755c60202fc30f6c"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a6fab8d226ee701c0755c60202fc30f6c">operator&lt;&lt;</a> (std::ostream &amp;os, std::tuple&lt; T... &gt; const &amp;obj)</td></tr>
<tr class="separator:a6fab8d226ee701c0755c60202fc30f6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4d7f13d811f0d63d4ce49d31b6cfbe0"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ad4d7f13d811f0d63d4ce49d31b6cfbe0"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ad4d7f13d811f0d63d4ce49d31b6cfbe0">operator&lt;&lt;</a> (std::ostream &amp;os, std::pair&lt; T1, T2 &gt; const &amp;obj)</td></tr>
<tr class="separator:ad4d7f13d811f0d63d4ce49d31b6cfbe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fa8037907332bf633dfc1bc3b40865c"><td class="memItemLeft" align="right" valign="top">ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a3fa8037907332bf633dfc1bc3b40865c">operator&lt;&lt;</a> (ostream &amp;s, const Vector3R &amp;v)</td></tr>
<tr class="separator:a3fa8037907332bf633dfc1bc3b40865c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaacce78528c9499de97312cbe606ece4"><td class="memItemLeft" align="right" valign="top">ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#aaacce78528c9499de97312cbe606ece4">operator&lt;&lt;</a> (ostream &amp;s, const Vector4R &amp;v)</td></tr>
<tr class="separator:aaacce78528c9499de97312cbe606ece4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3be8e63c60c604b927f9638600a598b"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ad3be8e63c60c604b927f9638600a598b">operator&lt;&lt;</a> (std::ostream &amp;os, <a class="el" href="group__fit.html#classhydra_1_1UserParameters">UserParameters</a> const &amp;par)</td></tr>
<tr class="memdesc:ad3be8e63c60c604b927f9638600a598b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classhydra_1_1Print.html">Print</a> the ROOT::Minuit2 state to stream.  <a href="#ad3be8e63c60c604b927f9638600a598b">More...</a><br /></td></tr>
<tr class="separator:ad3be8e63c60c604b927f9638600a598b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21d7262b80d73f956ed1a477607b9053"><td class="memTemplParams" colspan="2">template&lt;typename ValueType , class charT , class traits &gt; </td></tr>
<tr class="memitem:a21d7262b80d73f956ed1a477607b9053"><td class="memTemplItemLeft" align="right" valign="top">std::basic_ostream&lt; charT, traits &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a21d7262b80d73f956ed1a477607b9053">operator&lt;&lt;</a> (std::basic_ostream&lt; charT, traits &gt; &amp;os, const <a class="el" href="namespacehydra.html#a9d2c06cb9672fe86dbeaa65e8f35a2bf">complex</a>&lt; ValueType &gt; &amp;z)</td></tr>
<tr class="separator:a21d7262b80d73f956ed1a477607b9053"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb57654e359a17e312e9aef986f956a8"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#adb57654e359a17e312e9aef986f956a8">operator&lt;&lt;</a> (std::ostream &amp;os, <a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a> const &amp;var)</td></tr>
<tr class="separator:adb57654e359a17e312e9aef986f956a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea70aec01321527f54717a004a3df99d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aea70aec01321527f54717a004a3df99d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#aea70aec01321527f54717a004a3df99d">operator==</a> (const <a class="el" href="namespacehydra.html#a9d2c06cb9672fe86dbeaa65e8f35a2bf">complex</a>&lt; T &gt; &amp;lhs, const <a class="el" href="namespacehydra.html#a9d2c06cb9672fe86dbeaa65e8f35a2bf">complex</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="separator:aea70aec01321527f54717a004a3df99d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a227370a3dddcea864f09490bc65b93ad"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a227370a3dddcea864f09490bc65b93ad"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a227370a3dddcea864f09490bc65b93ad">operator==</a> (const T &amp;lhs, const <a class="el" href="namespacehydra.html#a9d2c06cb9672fe86dbeaa65e8f35a2bf">complex</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="separator:a227370a3dddcea864f09490bc65b93ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99bf5390aa3ab39e8ac0cd109ef6b7c9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a99bf5390aa3ab39e8ac0cd109ef6b7c9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a99bf5390aa3ab39e8ac0cd109ef6b7c9">operator==</a> (const <a class="el" href="namespacehydra.html#a9d2c06cb9672fe86dbeaa65e8f35a2bf">complex</a>&lt; T &gt; &amp;lhs, const T &amp;rhs)</td></tr>
<tr class="separator:a99bf5390aa3ab39e8ac0cd109ef6b7c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3bafbf7fa6e97bc40b02d74d7d596ea"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N, hydra::detail::Backend BACKEND1, hydra::detail::Backend BACKEND2&gt; </td></tr>
<tr class="memitem:ab3bafbf7fa6e97bc40b02d74d7d596ea"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ab3bafbf7fa6e97bc40b02d74d7d596ea">operator==</a> (const <a class="el" href="namespacehydra.html#classhydra_1_1multiarray">multiarray</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND1 &gt;&gt; &amp;lhs, const <a class="el" href="namespacehydra.html#classhydra_1_1multiarray">multiarray</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND2 &gt;&gt; &amp;rhs)</td></tr>
<tr class="separator:ab3bafbf7fa6e97bc40b02d74d7d596ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a859dbfadafdb7de2fe58343b80555a6b"><td class="memTemplParams" colspan="2">template&lt;typename ... T, hydra::detail::Backend BACKEND1, hydra::detail::Backend BACKEND2&gt; </td></tr>
<tr class="memitem:a859dbfadafdb7de2fe58343b80555a6b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a859dbfadafdb7de2fe58343b80555a6b">operator==</a> (const <a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; hydra::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND1 &gt;&gt; &amp;lhs, const <a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; hydra::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND2 &gt;&gt; &amp;rhs)</td></tr>
<tr class="separator:a859dbfadafdb7de2fe58343b80555a6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63ad8f84031200c3161c889507d3a9c0"><td class="memTemplParams" colspan="2">template&lt;typename ValueType , typename charT , class traits &gt; </td></tr>
<tr class="memitem:a63ad8f84031200c3161c889507d3a9c0"><td class="memTemplItemLeft" align="right" valign="top">std::basic_istream&lt; charT, traits &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a63ad8f84031200c3161c889507d3a9c0">operator&gt;&gt;</a> (std::basic_istream&lt; charT, traits &gt; &amp;is, <a class="el" href="namespacehydra.html#a9d2c06cb9672fe86dbeaa65e8f35a2bf">complex</a>&lt; ValueType &gt; &amp;z)</td></tr>
<tr class="separator:a63ad8f84031200c3161c889507d3a9c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e1791730fd6db81f61c76881fa37a75"><td class="memTemplParams" colspan="2">template&lt;typename Iterable , typename Functor &gt; </td></tr>
<tr class="memitem:a4e1791730fd6db81f61c76881fa37a75"><td class="memTemplItemLeft" align="right" valign="top">hydra::thrust::detail::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">detail::is_iterable</a>&lt; Iterable &gt;::value &amp;&amp;(<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt; Functor &gt;::value||<a class="el" href="structhydra_1_1detail_1_1is__hydra__lambda.html">detail::is_hydra_lambda</a>&lt; Functor &gt;::value), <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; decltype(std::declval&lt; const Iterable &gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()), Functor &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a4e1791730fd6db81f61c76881fa37a75">operator|</a> (Iterable const &amp;iterable, Functor const &amp;functor)</td></tr>
<tr class="separator:a4e1791730fd6db81f61c76881fa37a75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ee022f8e7ac910d13bdda4d79415652"><td class="memTemplParams" colspan="2">template&lt;typename Iterable , typename Functor &gt; </td></tr>
<tr class="memitem:a0ee022f8e7ac910d13bdda4d79415652"><td class="memTemplItemLeft" align="right" valign="top">hydra::thrust::detail::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">detail::is_iterable</a>&lt; Iterable &gt;::value &amp;&amp;(<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt; Functor &gt;::value||<a class="el" href="structhydra_1_1detail_1_1is__hydra__lambda.html">detail::is_hydra_lambda</a>&lt; Functor &gt;::value), <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; decltype(std::declval&lt; Iterable &gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()), Functor &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a0ee022f8e7ac910d13bdda4d79415652">operator|</a> (Iterable &amp;&amp;iterable, Functor const &amp;functor)</td></tr>
<tr class="separator:a0ee022f8e7ac910d13bdda4d79415652"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d01c3dc710d6d9c8950f67d03cdb14c"><td class="memTemplParams" colspan="2">template&lt;size_t N&gt; </td></tr>
<tr class="memitem:a8d01c3dc710d6d9c8950f67d03cdb14c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; hydra::thrust::transform_iterator&lt; <a class="el" href="structhydra_1_1detail_1_1GenerateDecay.html">detail::GenerateDecay</a>&lt; N, hydra::thrust::random::default_random_engine &gt;, hydra::thrust::counting_iterator&lt; size_t &gt;, typename <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1tuple__cat__type">hydra::detail::tuple_cat_type</a>&lt; hydra::thrust::tuple&lt; <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt;, typename <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1tuple__type">hydra::detail::tuple_type</a>&lt; N, Vector4R &gt;::type &gt;::type &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a8d01c3dc710d6d9c8950f67d03cdb14c">phase_space_range</a> (Vector4R const &amp;mother, std::array&lt; <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>, N &gt; <a class="el" href="phsp__unweighting_8inl.html#ad507bdbe1cd7219fead6e9dcd287d908">masses</a>, size_t seed, size_t length=0)</td></tr>
<tr class="separator:a8d01c3dc710d6d9c8950f67d03cdb14c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae85d86e6980bcf24de91a003711b3224"><td class="memItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ae85d86e6980bcf24de91a003711b3224">pmf</a> (const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> mother_mass, const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> daughter1_mass, const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> daughter2_mass)</td></tr>
<tr class="memdesc:ae85d86e6980bcf24de91a003711b3224"><td class="mdescLeft">&#160;</td><td class="mdescRight">Momentum in mother frame of daughter particle in two-body-decay.  <a href="#ae85d86e6980bcf24de91a003711b3224">More...</a><br /></td></tr>
<tr class="separator:ae85d86e6980bcf24de91a003711b3224"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3cc52fabc8882be13d9a6ca92fc648e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae3cc52fabc8882be13d9a6ca92fc648e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespacehydra.html#a9d2c06cb9672fe86dbeaa65e8f35a2bf">complex</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ae3cc52fabc8882be13d9a6ca92fc648e">polar</a> (const T &amp;m, const T &amp;theta=0)</td></tr>
<tr class="separator:ae3cc52fabc8882be13d9a6ca92fc648e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95aad7e7e244a3cb3c71a4d57e695511"><td class="memTemplParams" colspan="2">template&lt;typename T , unsigned int N&gt; </td></tr>
<tr class="memitem:a95aad7e7e244a3cb3c71a4d57e695511"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a95aad7e7e244a3cb3c71a4d57e695511">pow</a> (T x)</td></tr>
<tr class="memdesc:a95aad7e7e244a3cb3c71a4d57e695511"><td class="mdescLeft">&#160;</td><td class="mdescRight">Power with integer exponent.  <a href="#a95aad7e7e244a3cb3c71a4d57e695511">More...</a><br /></td></tr>
<tr class="separator:a95aad7e7e244a3cb3c71a4d57e695511"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2256bff965f5a7359591579a97114ec"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac2256bff965f5a7359591579a97114ec"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespacehydra.html#a9d2c06cb9672fe86dbeaa65e8f35a2bf">complex</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ac2256bff965f5a7359591579a97114ec">pow</a> (const <a class="el" href="namespacehydra.html#a9d2c06cb9672fe86dbeaa65e8f35a2bf">complex</a>&lt; T &gt; &amp;x, const <a class="el" href="namespacehydra.html#a9d2c06cb9672fe86dbeaa65e8f35a2bf">complex</a>&lt; T &gt; &amp;y)</td></tr>
<tr class="separator:ac2256bff965f5a7359591579a97114ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cf806d100f53f6d281b8b826697e10f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4cf806d100f53f6d281b8b826697e10f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespacehydra.html#a9d2c06cb9672fe86dbeaa65e8f35a2bf">complex</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a4cf806d100f53f6d281b8b826697e10f">pow</a> (const <a class="el" href="namespacehydra.html#a9d2c06cb9672fe86dbeaa65e8f35a2bf">complex</a>&lt; T &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:a4cf806d100f53f6d281b8b826697e10f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e9146d77dfa5b6c0fcbcb31557f6854"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2e9146d77dfa5b6c0fcbcb31557f6854"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespacehydra.html#a9d2c06cb9672fe86dbeaa65e8f35a2bf">complex</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a2e9146d77dfa5b6c0fcbcb31557f6854">pow</a> (const T &amp;x, const <a class="el" href="namespacehydra.html#a9d2c06cb9672fe86dbeaa65e8f35a2bf">complex</a>&lt; T &gt; &amp;y)</td></tr>
<tr class="separator:a2e9146d77dfa5b6c0fcbcb31557f6854"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee265139cfc0f8d933bae711850feb4a"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:aee265139cfc0f8d933bae711850feb4a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespacehydra.html#a9d2c06cb9672fe86dbeaa65e8f35a2bf">complex</a>&lt; typename hydra::thrust::detail::promoted_numerical_type&lt; T, U &gt;::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#aee265139cfc0f8d933bae711850feb4a">pow</a> (const <a class="el" href="namespacehydra.html#a9d2c06cb9672fe86dbeaa65e8f35a2bf">complex</a>&lt; T &gt; &amp;x, const <a class="el" href="namespacehydra.html#a9d2c06cb9672fe86dbeaa65e8f35a2bf">complex</a>&lt; U &gt; &amp;y)</td></tr>
<tr class="separator:aee265139cfc0f8d933bae711850feb4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60f026a6918ec1392c7d9e7bb0a48f90"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a60f026a6918ec1392c7d9e7bb0a48f90"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespacehydra.html#a9d2c06cb9672fe86dbeaa65e8f35a2bf">complex</a>&lt; typename hydra::thrust::detail::promoted_numerical_type&lt; T, U &gt;::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a60f026a6918ec1392c7d9e7bb0a48f90">pow</a> (const <a class="el" href="namespacehydra.html#a9d2c06cb9672fe86dbeaa65e8f35a2bf">complex</a>&lt; T &gt; &amp;x, const U &amp;y)</td></tr>
<tr class="separator:a60f026a6918ec1392c7d9e7bb0a48f90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d616da905f7096cf297aad08b2c23e3"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a7d616da905f7096cf297aad08b2c23e3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespacehydra.html#a9d2c06cb9672fe86dbeaa65e8f35a2bf">complex</a>&lt; typename hydra::thrust::detail::promoted_numerical_type&lt; T, U &gt;::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a7d616da905f7096cf297aad08b2c23e3">pow</a> (const T &amp;x, const <a class="el" href="namespacehydra.html#a9d2c06cb9672fe86dbeaa65e8f35a2bf">complex</a>&lt; U &gt; &amp;y)</td></tr>
<tr class="separator:a7d616da905f7096cf297aad08b2c23e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb0c9817024c69efe44c2d9653928519"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:acb0c9817024c69efe44c2d9653928519"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#acb0c9817024c69efe44c2d9653928519">PrintToStream</a> (std::ostream &amp;ostream, const char *format, Args... args)</td></tr>
<tr class="separator:acb0c9817024c69efe44c2d9653928519"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace0454750e3561d390ee18b96824227c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ace0454750e3561d390ee18b96824227c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespacehydra.html#a9d2c06cb9672fe86dbeaa65e8f35a2bf">complex</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ace0454750e3561d390ee18b96824227c">proj</a> (const T &amp;z)</td></tr>
<tr class="separator:ace0454750e3561d390ee18b96824227c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae624fce02dd351435098431f13679919"><td class="memTemplParams" colspan="2">template&lt;typename Engine  = hydra::default_random_engine, typename Functor &gt; </td></tr>
<tr class="memitem:ae624fce02dd351435098431f13679919"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; hydra::thrust::transform_iterator&lt; <a class="el" href="structhydra_1_1detail_1_1Sampler.html">detail::Sampler</a>&lt; Functor, Engine &gt;, hydra::thrust::counting_iterator&lt; size_t &gt;, typename <a class="el" href="structhydra_1_1detail_1_1Sampler.html">detail::Sampler</a>&lt; Functor, Engine &gt;::value_type &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ae624fce02dd351435098431f13679919">random_range</a> (Functor const &amp;functor, size_t seed=0x8ec74d321e6b5a27, size_t length=0, size_t rng_jump=0)</td></tr>
<tr class="separator:ae624fce02dd351435098431f13679919"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57a8dad11538cee5058cf0f6755f26a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; hydra::thrust::counting_iterator&lt; long <a class="el" href="namespace_3globalScope_4.html#classint">int</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a57a8dad11538cee5058cf0f6755f26a3">range</a> (long <a class="el" href="namespace_3globalScope_4.html#classint">int</a> first, long <a class="el" href="namespace_3globalScope_4.html#classint">int</a> last)</td></tr>
<tr class="separator:a57a8dad11538cee5058cf0f6755f26a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3208533344bd3938c87afbfd7d4d01b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab3208533344bd3938c87afbfd7d4d01b"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_floating_point&lt; T &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; hydra::thrust::counting_iterator&lt; <a class="el" href="namespace_3globalScope_4.html#classunsigned">unsigned</a> &gt;, <a class="el" href="structhydra_1_1detail_1_1range_1_1Shift.html">detail::range::Shift</a>&lt; T &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ab3208533344bd3938c87afbfd7d4d01b">range</a> (T <a class="el" href="particle__mass_8inl.html#aad36546e8175d2922bee165fe028fedc">min</a>, T <a class="el" href="particle__mass_8inl.html#a0b0ede69e8156eb97acc579b88e883de">max</a>, <a class="el" href="namespace_3globalScope_4.html#classunsigned">unsigned</a> nbins)</td></tr>
<tr class="separator:ab3208533344bd3938c87afbfd7d4d01b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a589e3fc7f3e94613126a8198bf90dd59"><td class="memItemLeft" align="right" valign="top"><a class="el" href="basic__distributions_8inl.html#a9717e7bbecb906637e86cef6da3d83c2">return</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a589e3fc7f3e94613126a8198bf90dd59">Range&lt; iterator_type &gt;</a> (other.begin(cls...), <a class="el" href="phsp__unweighting_8inl.html#a6be7d98960df33edf9f3998a9e8b2407">other.end</a>(cls...))</td></tr>
<tr class="separator:a589e3fc7f3e94613126a8198bf90dd59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf9723fecdbba95ef0e6ccfd8b30994a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="basic__distributions_8inl.html#a9717e7bbecb906637e86cef6da3d83c2">return</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#abf9723fecdbba95ef0e6ccfd8b30994a">Range&lt; iterator_type &gt;</a> (other.begin(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;{}), <a class="el" href="phsp__unweighting_8inl.html#a6be7d98960df33edf9f3998a9e8b2407">other.end</a>(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;{}))</td></tr>
<tr class="separator:abf9723fecdbba95ef0e6ccfd8b30994a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadcca49207bf7ab79088f28cddb8f21d"><td class="memTemplParams" colspan="2">template&lt;class C &gt; </td></tr>
<tr class="memitem:aadcca49207bf7ab79088f28cddb8f21d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#aadcca49207bf7ab79088f28cddb8f21d">rbegin</a> (<a class="el" href="basic__distributions_8inl.html#a4900ef306eb9271438791f1a98b8ccba">C</a> &amp;&amp;c) -&gt; decltype(std::forward&lt; <a class="el" href="basic__distributions_8inl.html#a4900ef306eb9271438791f1a98b8ccba">C</a> &gt;(c).rbegin())</td></tr>
<tr class="separator:aadcca49207bf7ab79088f28cddb8f21d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a434c6a6c1a24dbd8ca880af38694803d"><td class="memTemplParams" colspan="2">template&lt;class C &gt; </td></tr>
<tr class="memitem:a434c6a6c1a24dbd8ca880af38694803d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a434c6a6c1a24dbd8ca880af38694803d">rbegin</a> (const <a class="el" href="basic__distributions_8inl.html#a4900ef306eb9271438791f1a98b8ccba">C</a> &amp;c) -&gt; decltype(c.rbegin())</td></tr>
<tr class="separator:a434c6a6c1a24dbd8ca880af38694803d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d87c9638b5f275d1fbbef560a3c0197"><td class="memTemplParams" colspan="2">template&lt;class T , size_t N&gt; </td></tr>
<tr class="memitem:a0d87c9638b5f275d1fbbef560a3c0197"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a0d87c9638b5f275d1fbbef560a3c0197">rbegin</a> (T(&amp;array)[N])</td></tr>
<tr class="separator:a0d87c9638b5f275d1fbbef560a3c0197"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69daea4927958e8a666ee6ed3a795cbd"><td class="memTemplParams" colspan="2">template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename T , size_t N&gt; </td></tr>
<tr class="memitem:a69daea4927958e8a666ee6ed3a795cbd"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a69daea4927958e8a666ee6ed3a795cbd">rbegin</a> (<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;, <a class="el" href="namespacehydra.html#classhydra_1_1multiarray">multiarray</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; const &amp;other) -&gt; decltype(other.rbegin(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;</td></tr>
<tr class="separator:a69daea4927958e8a666ee6ed3a795cbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a932ef4185794129e04c9a4220db464eb"><td class="memTemplParams" colspan="2">template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename T , size_t N&gt; </td></tr>
<tr class="memitem:a932ef4185794129e04c9a4220db464eb"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a932ef4185794129e04c9a4220db464eb">rbegin</a> (<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;, <a class="el" href="namespacehydra.html#classhydra_1_1multiarray">multiarray</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; &amp;other) -&gt; decltype(other.rbegin(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;</td></tr>
<tr class="separator:a932ef4185794129e04c9a4220db464eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f0fb8d425a7340b07a03c08f4f3e73b"><td class="memTemplParams" colspan="2">template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename ... T&gt; </td></tr>
<tr class="memitem:a2f0fb8d425a7340b07a03c08f4f3e73b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a2f0fb8d425a7340b07a03c08f4f3e73b">rbegin</a> (<a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; hydra::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; const &amp;other) -&gt; decltype(other.rbegin(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;</td></tr>
<tr class="separator:a2f0fb8d425a7340b07a03c08f4f3e73b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af274ce4fee4b9c77c3f992939f29d8af"><td class="memTemplParams" colspan="2">template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename ... T&gt; </td></tr>
<tr class="memitem:af274ce4fee4b9c77c3f992939f29d8af"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#af274ce4fee4b9c77c3f992939f29d8af">rbegin</a> (<a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; hydra::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; &amp;other) -&gt; decltype(other.rbegin(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;</td></tr>
<tr class="separator:af274ce4fee4b9c77c3f992939f29d8af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81e867dc81c5f6665b28b83f873e4d7c"><td class="memTemplParams" colspan="2">template&lt;typename Iterable &gt; </td></tr>
<tr class="memitem:a81e867dc81c5f6665b28b83f873e4d7c"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; Iterable &gt;::value, typename hydra::thrust::iterator_traits&lt; decltype(std::declval&lt; Iterable &gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>())&gt;::value_type &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a81e867dc81c5f6665b28b83f873e4d7c">reduce</a> (Iterable &amp;&amp;iterable)</td></tr>
<tr class="separator:a81e867dc81c5f6665b28b83f873e4d7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63b9d5a2744d5acc0852b40f5262eb17"><td class="memTemplParams" colspan="2">template&lt;typename Iterable , typename Functor , typename T  = typename hydra::thrust::iterator_traits&lt;		     decltype(std::declval&lt;Iterable&gt;().begin())&gt;::value_type&gt; </td></tr>
<tr class="memitem:a63b9d5a2744d5acc0852b40f5262eb17"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; Iterable &gt;::value, T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a63b9d5a2744d5acc0852b40f5262eb17">reduce</a> (Iterable &amp;&amp;iterable, T const &amp;init, Functor const &amp;binary_functor)</td></tr>
<tr class="separator:a63b9d5a2744d5acc0852b40f5262eb17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58e00797465282d00eeaf0cd82d1c076"><td class="memTemplParams" colspan="2">template&lt;class C &gt; </td></tr>
<tr class="memitem:a58e00797465282d00eeaf0cd82d1c076"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a58e00797465282d00eeaf0cd82d1c076">rend</a> (<a class="el" href="basic__distributions_8inl.html#a4900ef306eb9271438791f1a98b8ccba">C</a> &amp;&amp;c) -&gt; decltype(std::forward&lt; <a class="el" href="basic__distributions_8inl.html#a4900ef306eb9271438791f1a98b8ccba">C</a> &gt;(c).rend())</td></tr>
<tr class="separator:a58e00797465282d00eeaf0cd82d1c076"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48be0e2a44047208c68e2c096683db35"><td class="memTemplParams" colspan="2">template&lt;class C &gt; </td></tr>
<tr class="memitem:a48be0e2a44047208c68e2c096683db35"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a48be0e2a44047208c68e2c096683db35">rend</a> (const <a class="el" href="basic__distributions_8inl.html#a4900ef306eb9271438791f1a98b8ccba">C</a> &amp;c) -&gt; decltype(c.rend())</td></tr>
<tr class="separator:a48be0e2a44047208c68e2c096683db35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f3625ffa0bf89a7d056a0d2b226e882"><td class="memTemplParams" colspan="2">template&lt;class T , size_t N&gt; </td></tr>
<tr class="memitem:a7f3625ffa0bf89a7d056a0d2b226e882"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a7f3625ffa0bf89a7d056a0d2b226e882">rend</a> (T(&amp;array)[N])</td></tr>
<tr class="separator:a7f3625ffa0bf89a7d056a0d2b226e882"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad79366fdc5ac96950ef240f03e0321b5"><td class="memTemplParams" colspan="2">template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename T , size_t N&gt; </td></tr>
<tr class="memitem:ad79366fdc5ac96950ef240f03e0321b5"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ad79366fdc5ac96950ef240f03e0321b5">rend</a> (<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;, <a class="el" href="namespacehydra.html#classhydra_1_1multiarray">multiarray</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; const &amp;other) -&gt; decltype(other.rend(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;</td></tr>
<tr class="separator:ad79366fdc5ac96950ef240f03e0321b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a175fc3749a8859251e455ea11b8739f8"><td class="memTemplParams" colspan="2">template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename T , size_t N&gt; </td></tr>
<tr class="memitem:a175fc3749a8859251e455ea11b8739f8"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a175fc3749a8859251e455ea11b8739f8">rend</a> (<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;, <a class="el" href="namespacehydra.html#classhydra_1_1multiarray">multiarray</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; &amp;other) -&gt; decltype(other.rend(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;</td></tr>
<tr class="separator:a175fc3749a8859251e455ea11b8739f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1872dcef050553663eec1f029a5a1449"><td class="memTemplParams" colspan="2">template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename ... T&gt; </td></tr>
<tr class="memitem:a1872dcef050553663eec1f029a5a1449"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a1872dcef050553663eec1f029a5a1449">rend</a> (<a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; hydra::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; const &amp;other) -&gt; decltype(other.rend(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;</td></tr>
<tr class="separator:a1872dcef050553663eec1f029a5a1449"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b966d2403c1766f3b6ce6f97c4bd3fa"><td class="memTemplParams" colspan="2">template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename ... T&gt; </td></tr>
<tr class="memitem:a3b966d2403c1766f3b6ce6f97c4bd3fa"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a3b966d2403c1766f3b6ce6f97c4bd3fa">rend</a> (<a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; hydra::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; &amp;other) -&gt; decltype(other.rend(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;</td></tr>
<tr class="separator:a3b966d2403c1766f3b6ce6f97c4bd3fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95552751864e14c366dd5ea7186d2ff4"><td class="memTemplParams" colspan="2">template&lt;typename Iterable &gt; </td></tr>
<tr class="memitem:a95552751864e14c366dd5ea7186d2ff4"><td class="memTemplItemLeft" align="right" valign="top">hydra::thrust::detail::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">detail::is_iterable</a>&lt; Iterable &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; hydra::thrust::reverse_iterator&lt; decltype(std::declval&lt; Iterable &gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()) &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a95552751864e14c366dd5ea7186d2ff4">reverse</a> (Iterable &amp;&amp;iterable)</td></tr>
<tr class="separator:a95552751864e14c366dd5ea7186d2ff4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad27ce158f82bfcf3ba0855a224a3f626"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad27ce158f82bfcf3ba0855a224a3f626"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ad27ce158f82bfcf3ba0855a224a3f626">rint</a> (T x)</td></tr>
<tr class="separator:ad27ce158f82bfcf3ba0855a224a3f626"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a9e21c7083ea65e58667297a801f0c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> Vector4R&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a4a9e21c7083ea65e58667297a801f0c0">rotateEuler</a> (const Vector4R &amp;rs, <a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> <a class="el" href="crystal__ball__plus__exponential_8inl.html#a143fa1ae6e83f554763008ef6fc4829b">alpha</a>, <a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> <a class="el" href="particle__mass_8inl.html#a7033d85826bd54896b58da524b818474">beta</a>, <a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> <a class="el" href="basic__distributions_8inl.html#acdd95f533acd83442ce3dec24fa4e49b">gamma</a>)</td></tr>
<tr class="separator:a4a9e21c7083ea65e58667297a801f0c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9637ed446b2f89c3514f57bac1fd1be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> Vector3R&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ab9637ed446b2f89c3514f57bac1fd1be">rotateEuler</a> (const Vector3R &amp;v, <a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> phi, <a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> theta, <a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> ksi)</td></tr>
<tr class="separator:ab9637ed446b2f89c3514f57bac1fd1be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeefa8e6c3af06dd76fce7b15bfeb3d8d"><td class="memTemplParams" colspan="2">template&lt;typename RNG , typename DerivedPolicy , typename Functor , typename Iterator &gt; </td></tr>
<tr class="memitem:aeefa8e6c3af06dd76fce7b15bfeb3d8d"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1random_1_1is__callable.html">detail::random::is_callable</a>&lt; Functor &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1random_1_1is__iterator.html">detail::random::is_iterator</a>&lt; Iterator &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; Iterator &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#aeefa8e6c3af06dd76fce7b15bfeb3d8d">sample</a> (hydra::thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; const  &amp;policy, Iterator <a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>, Iterator <a class="el" href="namespacehydra.html#a4274268d147e9a988f379326b73682b0">end</a>, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> <a class="el" href="particle__mass_8inl.html#aad36546e8175d2922bee165fe028fedc">min</a>, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> <a class="el" href="particle__mass_8inl.html#a0b0ede69e8156eb97acc579b88e883de">max</a>, Functor const  &amp;functor, size_t seed=0xb56c4feeef1b, size_t rng_jump=0)</td></tr>
<tr class="memdesc:aeefa8e6c3af06dd76fce7b15bfeb3d8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill a range with numbers distributed according a user defined distribution.  <a href="#aeefa8e6c3af06dd76fce7b15bfeb3d8d">More...</a><br /></td></tr>
<tr class="separator:aeefa8e6c3af06dd76fce7b15bfeb3d8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdbd3d61d9788560832b988d7f091d94"><td class="memTemplParams" colspan="2">template&lt;typename RNG , typename Functor , typename Iterator , hydra::detail::Backend BACKEND&gt; </td></tr>
<tr class="memitem:abdbd3d61d9788560832b988d7f091d94"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1random_1_1is__callable.html">detail::random::is_callable</a>&lt; Functor &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1random_1_1is__iterator.html">detail::random::is_iterator</a>&lt; Iterator &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; Iterator &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#abdbd3d61d9788560832b988d7f091d94">sample</a> (<a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; const  &amp;policy, Iterator <a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>, Iterator <a class="el" href="namespacehydra.html#a4274268d147e9a988f379326b73682b0">end</a>, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> <a class="el" href="particle__mass_8inl.html#aad36546e8175d2922bee165fe028fedc">min</a>, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> <a class="el" href="particle__mass_8inl.html#a0b0ede69e8156eb97acc579b88e883de">max</a>, Functor const  &amp;functor, size_t seed=0xb56c4feeef1b, size_t rng_jump=0)</td></tr>
<tr class="memdesc:abdbd3d61d9788560832b988d7f091d94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill a range with numbers distributed according a user defined distribution.  <a href="#abdbd3d61d9788560832b988d7f091d94">More...</a><br /></td></tr>
<tr class="separator:abdbd3d61d9788560832b988d7f091d94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94f8c5c248211faf04726d832275af49"><td class="memTemplParams" colspan="2">template&lt;typename RNG , typename Functor , typename Iterator &gt; </td></tr>
<tr class="memitem:a94f8c5c248211faf04726d832275af49"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1random_1_1is__callable.html">detail::random::is_callable</a>&lt; Functor &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1random_1_1is__iterator.html">detail::random::is_iterator</a>&lt; Iterator &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; Iterator &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a94f8c5c248211faf04726d832275af49">sample</a> (Iterator <a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>, Iterator <a class="el" href="namespacehydra.html#a4274268d147e9a988f379326b73682b0">end</a>, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> <a class="el" href="particle__mass_8inl.html#aad36546e8175d2922bee165fe028fedc">min</a>, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> <a class="el" href="particle__mass_8inl.html#a0b0ede69e8156eb97acc579b88e883de">max</a>, Functor const  &amp;functor, size_t seed=0xb56c4feeef1b, size_t rng_jump=0)</td></tr>
<tr class="memdesc:a94f8c5c248211faf04726d832275af49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill a range with numbers distributed according a user defined distribution.  <a href="#a94f8c5c248211faf04726d832275af49">More...</a><br /></td></tr>
<tr class="separator:a94f8c5c248211faf04726d832275af49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad56d9801d61654d7fd47841afa712ebd"><td class="memTemplParams" colspan="2">template&lt;typename RNG , typename Functor , typename Iterable &gt; </td></tr>
<tr class="memitem:ad56d9801d61654d7fd47841afa712ebd"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1random_1_1is__callable.html">detail::random::is_callable</a>&lt; Functor &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1random_1_1is__iterable.html">detail::random::is_iterable</a>&lt; Iterable &gt;::value,<a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; decltype(std::declval&lt; Iterable &gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>())&gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ad56d9801d61654d7fd47841afa712ebd">sample</a> (Iterable &amp;&amp;output, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> <a class="el" href="particle__mass_8inl.html#aad36546e8175d2922bee165fe028fedc">min</a>, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> <a class="el" href="particle__mass_8inl.html#a0b0ede69e8156eb97acc579b88e883de">max</a>, Functor const  &amp;functor, size_t seed=0xb56c4feeef1b, size_t rng_jump=0)</td></tr>
<tr class="memdesc:ad56d9801d61654d7fd47841afa712ebd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill a range with numbers distributed according a user defined distribution.  <a href="#ad56d9801d61654d7fd47841afa712ebd">More...</a><br /></td></tr>
<tr class="separator:ad56d9801d61654d7fd47841afa712ebd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accd7b2510c1c22431252d15d956b9c1b"><td class="memTemplParams" colspan="2">template&lt;typename RNG , typename DerivedPolicy , typename Functor , typename Iterator , size_t N&gt; </td></tr>
<tr class="memitem:accd7b2510c1c22431252d15d956b9c1b"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1random_1_1is__callable.html">detail::random::is_callable</a>&lt; Functor &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1random_1_1is__iterator.html">detail::random::is_iterator</a>&lt; Iterator &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; Iterator &gt;&gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#accd7b2510c1c22431252d15d956b9c1b">sample</a> (hydra::thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; const &amp;policy, Iterator <a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>, Iterator <a class="el" href="namespacehydra.html#a4274268d147e9a988f379326b73682b0">end</a>, std::array&lt; <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>, N &gt; const &amp;<a class="el" href="particle__mass_8inl.html#aad36546e8175d2922bee165fe028fedc">min</a>, std::array&lt; <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>, N &gt; const &amp;<a class="el" href="particle__mass_8inl.html#a0b0ede69e8156eb97acc579b88e883de">max</a>, Functor const &amp;functor, size_t seed, size_t rng_jump)</td></tr>
<tr class="memdesc:accd7b2510c1c22431252d15d956b9c1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill a range with numbers distributed according a user defined distribution.  <a href="#accd7b2510c1c22431252d15d956b9c1b">More...</a><br /></td></tr>
<tr class="separator:accd7b2510c1c22431252d15d956b9c1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74d72b60139be864da3acc8dee2b3cd2"><td class="memTemplParams" colspan="2">template&lt;typename RNG , typename Functor , typename Iterator , hydra::detail::Backend BACKEND, size_t N&gt; </td></tr>
<tr class="memitem:a74d72b60139be864da3acc8dee2b3cd2"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1random_1_1is__callable.html">detail::random::is_callable</a>&lt; Functor &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1random_1_1is__iterator.html">detail::random::is_iterator</a>&lt; Iterator &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; Iterator &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a74d72b60139be864da3acc8dee2b3cd2">sample</a> (<a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; const  &amp;policy, Iterator <a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>, Iterator <a class="el" href="namespacehydra.html#a4274268d147e9a988f379326b73682b0">end</a>, std::array&lt; <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>, N &gt;const  &amp;<a class="el" href="particle__mass_8inl.html#aad36546e8175d2922bee165fe028fedc">min</a>, std::array&lt; <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>, N &gt;const  &amp;<a class="el" href="particle__mass_8inl.html#a0b0ede69e8156eb97acc579b88e883de">max</a>, Functor const  &amp;functor, size_t seed=0xb56c4feeef1b, size_t rng_jump=0)</td></tr>
<tr class="memdesc:a74d72b60139be864da3acc8dee2b3cd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill a range with numbers distributed according a user defined distribution.  <a href="#a74d72b60139be864da3acc8dee2b3cd2">More...</a><br /></td></tr>
<tr class="separator:a74d72b60139be864da3acc8dee2b3cd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ced8bd2c8181d3d6f2d07b1513fc265"><td class="memTemplParams" colspan="2">template&lt;typename RNG , typename Functor , typename Iterator , size_t N&gt; </td></tr>
<tr class="memitem:a1ced8bd2c8181d3d6f2d07b1513fc265"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1random_1_1is__callable.html">detail::random::is_callable</a>&lt; Functor &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1random_1_1is__iterator.html">detail::random::is_iterator</a>&lt; Iterator &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; Iterator &gt;&gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a1ced8bd2c8181d3d6f2d07b1513fc265">sample</a> (Iterator <a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>, Iterator <a class="el" href="namespacehydra.html#a4274268d147e9a988f379326b73682b0">end</a>, std::array&lt; <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>, N &gt;const &amp;<a class="el" href="particle__mass_8inl.html#aad36546e8175d2922bee165fe028fedc">min</a>, std::array&lt; <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>, N &gt;const &amp;<a class="el" href="particle__mass_8inl.html#a0b0ede69e8156eb97acc579b88e883de">max</a>, Functor const &amp;functor, size_t seed, size_t rng_jump)</td></tr>
<tr class="memdesc:a1ced8bd2c8181d3d6f2d07b1513fc265"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill a range with numbers distributed according a user defined distribution.  <a href="#a1ced8bd2c8181d3d6f2d07b1513fc265">More...</a><br /></td></tr>
<tr class="separator:a1ced8bd2c8181d3d6f2d07b1513fc265"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a412b8c1fc9904852adebe877474f739a"><td class="memTemplParams" colspan="2">template&lt;typename RNG , typename Functor , typename Iterator &gt; </td></tr>
<tr class="memitem:a412b8c1fc9904852adebe877474f739a"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1random_1_1is__callable.html">detail::random::is_callable</a>&lt; Functor &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1random_1_1is__iterator.html">detail::random::is_iterator</a>&lt; Iterator &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1is__tuple__type.html">detail::is_tuple_type</a>&lt; decltype(*std::declval&lt; Iterator &gt;))&gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; Iterator &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a412b8c1fc9904852adebe877474f739a">sample</a> (Iterator <a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>, Iterator <a class="el" href="namespacehydra.html#a4274268d147e9a988f379326b73682b0">end</a>, typename Functor::argument_type const &amp;<a class="el" href="particle__mass_8inl.html#aad36546e8175d2922bee165fe028fedc">min</a>, typename Functor::argument_type const &amp;<a class="el" href="particle__mass_8inl.html#a0b0ede69e8156eb97acc579b88e883de">max</a>, Functor const &amp;functor, size_t seed, size_t rng_jump)</td></tr>
<tr class="separator:a412b8c1fc9904852adebe877474f739a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c41cef4b543ccd17e24018e36b758ad"><td class="memTemplParams" colspan="2">template&lt;typename RNG , typename Functor , typename Iterable , size_t N&gt; </td></tr>
<tr class="memitem:a4c41cef4b543ccd17e24018e36b758ad"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1random_1_1is__callable.html">detail::random::is_callable</a>&lt; Functor &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1random_1_1is__iterable.html">detail::random::is_iterable</a>&lt; Iterable &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; decltype(std::declval&lt; Iterable &gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>())&gt;&gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a4c41cef4b543ccd17e24018e36b758ad">sample</a> (Iterable &amp;&amp;output, std::array&lt; <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>, N &gt;const &amp;<a class="el" href="particle__mass_8inl.html#aad36546e8175d2922bee165fe028fedc">min</a>, std::array&lt; <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>, N &gt;const &amp;<a class="el" href="particle__mass_8inl.html#a0b0ede69e8156eb97acc579b88e883de">max</a>, Functor const &amp;functor, size_t seed, size_t rng_jump)</td></tr>
<tr class="memdesc:a4c41cef4b543ccd17e24018e36b758ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill a range with numbers distributed according a user defined distribution.  <a href="#a4c41cef4b543ccd17e24018e36b758ad">More...</a><br /></td></tr>
<tr class="separator:a4c41cef4b543ccd17e24018e36b758ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3f7e6110746692937a4925af19f3476"><td class="memTemplParams" colspan="2">template&lt;typename RNG , typename Functor , typename Iterable &gt; </td></tr>
<tr class="memitem:ad3f7e6110746692937a4925af19f3476"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1random_1_1is__callable.html">detail::random::is_callable</a>&lt; Functor &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1random_1_1is__iterable.html">detail::random::is_iterable</a>&lt; Iterable &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1is__tuple__type.html">detail::is_tuple_type</a>&lt; decltype(*std::declval&lt; Iterable &gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>())&gt;::value,<a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; decltype(std::declval&lt; Iterable &gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>())&gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ad3f7e6110746692937a4925af19f3476">sample</a> (Iterable &amp;&amp;output, typename Functor::argument_type const &amp;<a class="el" href="particle__mass_8inl.html#aad36546e8175d2922bee165fe028fedc">min</a>, typename Functor::argument_type const &amp;<a class="el" href="particle__mass_8inl.html#a0b0ede69e8156eb97acc579b88e883de">max</a>, Functor const &amp;functor, size_t seed, size_t rng_jump)</td></tr>
<tr class="memdesc:ad3f7e6110746692937a4925af19f3476"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill a range with numbers distributed according a user defined distribution.  <a href="#ad3f7e6110746692937a4925af19f3476">More...</a><br /></td></tr>
<tr class="separator:ad3f7e6110746692937a4925af19f3476"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc25aa814da94f10c50c8d5c0e6b23db"><td class="memTemplParams" colspan="2">template&lt;typename RNG  = default_random_engine, typename Functor , typename Iterator , size_t N&gt; </td></tr>
<tr class="memitem:adc25aa814da94f10c50c8d5c0e6b23db"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1random_1_1is__callable.html">detail::random::is_callable</a>&lt; Functor &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1random_1_1is__iterator.html">detail::random::is_iterator</a>&lt; Iterator &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; Iterator &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#adc25aa814da94f10c50c8d5c0e6b23db">sample</a> (Iterator <a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>, Iterator <a class="el" href="namespacehydra.html#a4274268d147e9a988f379326b73682b0">end</a>, std::array&lt; <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>, N &gt;const &amp;<a class="el" href="particle__mass_8inl.html#aad36546e8175d2922bee165fe028fedc">min</a>, std::array&lt; <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>, N &gt;const &amp;<a class="el" href="particle__mass_8inl.html#a0b0ede69e8156eb97acc579b88e883de">max</a>, Functor const &amp;functor, size_t seed=0xb56c4feeef1b, size_t rng_jump=0)</td></tr>
<tr class="memdesc:adc25aa814da94f10c50c8d5c0e6b23db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill a range with numbers distributed according a user defined distribution.  <a href="#adc25aa814da94f10c50c8d5c0e6b23db">More...</a><br /></td></tr>
<tr class="separator:adc25aa814da94f10c50c8d5c0e6b23db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18d244688e1a333fb925e222eeeb17d9"><td class="memTemplParams" colspan="2">template&lt;typename RNG  = default_random_engine, typename DerivedPolicy , typename Functor , typename Iterator , size_t N&gt; </td></tr>
<tr class="memitem:a18d244688e1a333fb925e222eeeb17d9"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1random_1_1is__callable.html">detail::random::is_callable</a>&lt; Functor &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1random_1_1is__iterator.html">detail::random::is_iterator</a>&lt; Iterator &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; Iterator &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a18d244688e1a333fb925e222eeeb17d9">sample</a> (hydra::thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; const &amp;policy, Iterator <a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>, Iterator <a class="el" href="namespacehydra.html#a4274268d147e9a988f379326b73682b0">end</a>, std::array&lt; <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>, N &gt;const &amp;<a class="el" href="particle__mass_8inl.html#aad36546e8175d2922bee165fe028fedc">min</a>, std::array&lt; <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>, N &gt;const &amp;<a class="el" href="particle__mass_8inl.html#a0b0ede69e8156eb97acc579b88e883de">max</a>, Functor const &amp;functor, size_t seed=0xb56c4feeef1b, size_t rng_jump=0)</td></tr>
<tr class="memdesc:a18d244688e1a333fb925e222eeeb17d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill a range with numbers distributed according a user defined distribution.  <a href="#a18d244688e1a333fb925e222eeeb17d9">More...</a><br /></td></tr>
<tr class="separator:a18d244688e1a333fb925e222eeeb17d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a296508ea7f57df138f13db7cdb95abc2"><td class="memTemplParams" colspan="2">template&lt;typename RNG  = default_random_engine, typename Functor , typename Iterable , size_t N&gt; </td></tr>
<tr class="memitem:a296508ea7f57df138f13db7cdb95abc2"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1random_1_1is__callable.html">detail::random::is_callable</a>&lt; Functor &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1random_1_1is__iterable.html">detail::random::is_iterable</a>&lt; Iterable &gt;::value,<a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; decltype(std::declval&lt; Iterable &gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>())&gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a296508ea7f57df138f13db7cdb95abc2">sample</a> (Iterable &amp;&amp;output, std::array&lt; <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>, N &gt;const &amp;<a class="el" href="particle__mass_8inl.html#aad36546e8175d2922bee165fe028fedc">min</a>, std::array&lt; <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>, N &gt;const &amp;<a class="el" href="particle__mass_8inl.html#a0b0ede69e8156eb97acc579b88e883de">max</a>, Functor const &amp;functor, size_t seed=0xb56c4feeef1b, size_t rng_jump=0)</td></tr>
<tr class="memdesc:a296508ea7f57df138f13db7cdb95abc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill a range with numbers distributed according a user defined distribution.  <a href="#a296508ea7f57df138f13db7cdb95abc2">More...</a><br /></td></tr>
<tr class="separator:a296508ea7f57df138f13db7cdb95abc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b62f11052cf4a8e258b21b9f64f0c6d"><td class="memTemplParams" colspan="2">template&lt;typename Iterable_Source , typename Iterable_Target , typename Iterable_Map &gt; </td></tr>
<tr class="memitem:a7b62f11052cf4a8e258b21b9f64f0c6d"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; Iterable_Source &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; Iterable_Target &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; Iterable_Map &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; decltype(std::declval&lt; Iterable_Target &amp; &gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>())&gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a7b62f11052cf4a8e258b21b9f64f0c6d">scatter</a> (Iterable_Source &amp;&amp;source, Iterable_Map &amp;&amp;map, Iterable_Target &amp;&amp;target)</td></tr>
<tr class="separator:a7b62f11052cf4a8e258b21b9f64f0c6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8056e4374a5e077e4ecb940851166b51"><td class="memTemplParams" colspan="2">template&lt;typename Iterable , typename Functor &gt; </td></tr>
<tr class="memitem:a8056e4374a5e077e4ecb940851166b51"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; Iterable &gt;::value, std::pair&lt; <a class="el" href="namespacehydra.html#classhydra_1_1Range">hydra::Range</a>&lt; decltype(std::declval&lt; Iterable &gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>())&gt;, <a class="el" href="namespacehydra.html#classhydra_1_1Range">hydra::Range</a>&lt; decltype(std::declval&lt; Iterable &gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>())&gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a8056e4374a5e077e4ecb940851166b51">segregate</a> (Iterable &amp;&amp;container, Functor &amp;&amp;<a class="el" href="namespacehydra.html#aab0cc380e55d7f4d02106a74165f7162">filter</a>)</td></tr>
<tr class="separator:a8056e4374a5e077e4ecb940851166b51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5337fca35f17ea6b1001e76ce351f9e"><td class="memTemplParams" colspan="2">template&lt;typename Iterable , typename Functor &gt; </td></tr>
<tr class="memitem:ae5337fca35f17ea6b1001e76ce351f9e"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; Iterable &gt;::value, std::pair&lt; <a class="el" href="namespacehydra.html#classhydra_1_1Range">hydra::Range</a>&lt; decltype(std::declval&lt; Iterable &gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>())&gt;, <a class="el" href="namespacehydra.html#classhydra_1_1Range">hydra::Range</a>&lt; decltype(std::declval&lt; Iterable &gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>())&gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ae5337fca35f17ea6b1001e76ce351f9e">segregate</a> (Iterable &amp;&amp;container, Functor const &amp;<a class="el" href="namespacehydra.html#aab0cc380e55d7f4d02106a74165f7162">filter</a>)</td></tr>
<tr class="separator:ae5337fca35f17ea6b1001e76ce351f9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb7d0e5da38544692eb3545e81617e19"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:acb7d0e5da38544692eb3545e81617e19"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespacehydra.html#a9d2c06cb9672fe86dbeaa65e8f35a2bf">complex</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#acb7d0e5da38544692eb3545e81617e19">sin</a> (const <a class="el" href="namespacehydra.html#a9d2c06cb9672fe86dbeaa65e8f35a2bf">complex</a>&lt; T &gt; &amp;z)</td></tr>
<tr class="separator:acb7d0e5da38544692eb3545e81617e19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af59c474655ecd14c6748391d80e2e4c2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af59c474655ecd14c6748391d80e2e4c2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespacehydra.html#a9d2c06cb9672fe86dbeaa65e8f35a2bf">complex</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#af59c474655ecd14c6748391d80e2e4c2">sinh</a> (const <a class="el" href="namespacehydra.html#a9d2c06cb9672fe86dbeaa65e8f35a2bf">complex</a>&lt; T &gt; &amp;z)</td></tr>
<tr class="separator:af59c474655ecd14c6748391d80e2e4c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b6b3a330b6d16d3221bb7b994b9329b"><td class="memTemplParams" colspan="2">template&lt;typename Iterable , typename Iterator  = decltype(std::declval&lt;Iterable&gt;().begin())&gt; </td></tr>
<tr class="memitem:a5b6b3a330b6d16d3221bb7b994b9329b"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; Iterable &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; decltype(std::declval&lt; Iterable &amp; &gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>())&gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a5b6b3a330b6d16d3221bb7b994b9329b">sort</a> (Iterable &amp;iterable)</td></tr>
<tr class="separator:a5b6b3a330b6d16d3221bb7b994b9329b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac64c757c35da63a927af0ad5147ac7c5"><td class="memTemplParams" colspan="2">template&lt;typename Iterable , typename Functor , typename Iterator  = decltype(std::declval&lt;Iterable&gt;().begin())&gt; </td></tr>
<tr class="memitem:ac64c757c35da63a927af0ad5147ac7c5"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; Iterable &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; decltype(std::declval&lt; Iterable &amp; &gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>())&gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ac64c757c35da63a927af0ad5147ac7c5">sort</a> (Iterable &amp;iterable, Functor const &amp;comparator)</td></tr>
<tr class="separator:ac64c757c35da63a927af0ad5147ac7c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34662231e9292fda55e3a182ea5d342a"><td class="memTemplParams" colspan="2">template&lt;typename Iterable , typename Iterable_Key , typename Iterator  = decltype(std::declval&lt;Iterable&gt;().begin()), typename Iterator_Key  = decltype(std::declval&lt;Iterable_Key&gt;().begin()), typename Value_Key  = decltype(*std::declval&lt;Iterator_Key&gt;().begin())&gt; </td></tr>
<tr class="memitem:a34662231e9292fda55e3a182ea5d342a"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; Iterable &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; decltype(std::declval&lt; Iterable &amp; &gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>())&gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a34662231e9292fda55e3a182ea5d342a">sort_by_key</a> (Iterable &amp;iterable, Iterable_Key &amp;keys)</td></tr>
<tr class="separator:a34662231e9292fda55e3a182ea5d342a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5d13834b7141cdaba43ad83ca671e7a"><td class="memTemplParams" colspan="2">template&lt;typename Iterable , typename Iterator_Key , typename Functor , typename Iterator  = decltype(std::declval&lt;Iterable&gt;().begin()), typename Value_Key  = decltype(*std::declval&lt;Range&lt;Iterator_Key,Functor&gt;&gt;().begin())&gt; </td></tr>
<tr class="memitem:ae5d13834b7141cdaba43ad83ca671e7a"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; Iterable &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; decltype(std::declval&lt; Iterable &amp; &gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>())&gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ae5d13834b7141cdaba43ad83ca671e7a">sort_by_key</a> (Iterable &amp;iterable, <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; Iterator_Key, Functor &gt; keys)</td></tr>
<tr class="separator:ae5d13834b7141cdaba43ad83ca671e7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfe40eab613a0a770c25a46e661ba808"><td class="memTemplParams" colspan="2">template&lt;typename IterableX , typename IterableY , typename IterableM , typename TypeX , typename TypeY &gt; </td></tr>
<tr class="memitem:abfe40eab613a0a770c25a46e661ba808"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; IterableX &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; IterableY &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; IterableM &gt;::value &amp;&amp;std::is_convertible&lt; typename IterableX::value_type, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt;::value &amp;&amp;std::is_convertible&lt; typename IterableY::value_type, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt;::value &amp;&amp;std::is_convertible&lt; typename IterableM::value_type, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt;::value &amp;&amp;std::is_convertible&lt; TypeX, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt;::value &amp;&amp;std::is_convertible&lt; TypeY, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt;::value, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#abfe40eab613a0a770c25a46e661ba808">spline</a> (IterableX &amp;&amp;abcissa_x, IterableY &amp;&amp;abcissa_y, IterableM measurements, TypeX x, TypeX y)</td></tr>
<tr class="separator:abfe40eab613a0a770c25a46e661ba808"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3cd7470ec536773f1107ff6af7c028b"><td class="memTemplParams" colspan="2">template&lt;typename Iterator1 , typename Iterator2 , typename Type &gt; </td></tr>
<tr class="memitem:ad3cd7470ec536773f1107ff6af7c028b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> std::enable_if&lt; std::is_convertible&lt; typename hydra::thrust::iterator_traits&lt; Iterator1 &gt;::value_type, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt;::value &amp;&amp;std::is_convertible&lt; typename hydra::thrust::iterator_traits&lt; Iterator2 &gt;::value_type, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt;::value &amp;&amp;std::is_convertible&lt; Type, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt;::value, Type &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ad3cd7470ec536773f1107ff6af7c028b">spline</a> (Iterator1 first, Iterator1 last, Iterator2 measurements, Type value)</td></tr>
<tr class="memdesc:ad3cd7470ec536773f1107ff6af7c028b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cubic monotone spline interpolation.  <a href="#ad3cd7470ec536773f1107ff6af7c028b">More...</a><br /></td></tr>
<tr class="separator:ad3cd7470ec536773f1107ff6af7c028b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75c9f64381a091df5fc576d74114c1eb"><td class="memTemplParams" colspan="2">template&lt;typename Iterable1 , typename Iterable2 , typename Type &gt; </td></tr>
<tr class="memitem:a75c9f64381a091df5fc576d74114c1eb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; Iterable1 &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; Iterable2 &gt;::value &amp;&amp;std::is_convertible&lt; typename Iterable1::value_type, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt;::value &amp;&amp;std::is_convertible&lt; typename Iterable2::value_type, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt;::value &amp;&amp;std::is_convertible&lt; Type, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt;::value, Type &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a75c9f64381a091df5fc576d74114c1eb">spline</a> (Iterable1 &amp;&amp;abscissae, Iterable2 &amp;&amp;ordinate, Type value)</td></tr>
<tr class="separator:a75c9f64381a091df5fc576d74114c1eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab21df89c98da4cb935e4801272aadf3a"><td class="memTemplParams" colspan="2">template&lt;typename IteratorX , typename IteratorY , typename IteratorM , typename TypeX , typename TypeY &gt; </td></tr>
<tr class="memitem:ab21df89c98da4cb935e4801272aadf3a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> std::enable_if&lt; std::is_convertible&lt; typename hydra::thrust::iterator_traits&lt; IteratorX &gt;::value_type, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt;::value &amp;&amp;std::is_convertible&lt; typename hydra::thrust::iterator_traits&lt; IteratorY &gt;::value_type, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt;::value &amp;&amp;std::is_convertible&lt; typename hydra::thrust::iterator_traits&lt; IteratorM &gt;::value_type, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt;::value &amp;&amp;std::is_convertible&lt; TypeX, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt;::value &amp;&amp;std::is_convertible&lt; TypeY, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt;::value, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ab21df89c98da4cb935e4801272aadf3a">spline2D</a> (IteratorX firstx, IteratorX lastx, IteratorY firsty, IteratorY lasty, IteratorM measurements, TypeX x, TypeY y)</td></tr>
<tr class="separator:ab21df89c98da4cb935e4801272aadf3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c56eae6c288b029507ba62c90f1429c"><td class="memTemplParams" colspan="2">template&lt;typename IterableX , typename IterableY , typename IterableM , typename TypeX , typename TypeY &gt; </td></tr>
<tr class="memitem:a1c56eae6c288b029507ba62c90f1429c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; IterableX &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; IterableY &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; IterableM &gt;::value &amp;&amp;std::is_convertible&lt; typename IterableX::value_type, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt;::value &amp;&amp;std::is_convertible&lt; typename IterableY::value_type, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt;::value &amp;&amp;std::is_convertible&lt; typename IterableM::value_type, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt;::value &amp;&amp;std::is_convertible&lt; TypeX, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt;::value &amp;&amp;std::is_convertible&lt; TypeY, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt;::value, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a1c56eae6c288b029507ba62c90f1429c">spline2D</a> (IterableX &amp;&amp;abscissa_x, IterableY &amp;&amp;abscissa_y, IterableM measurements, TypeX x, TypeX y)</td></tr>
<tr class="separator:a1c56eae6c288b029507ba62c90f1429c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6962b0587db951690d13d7883d7088ee"><td class="memTemplParams" colspan="2">template&lt;typename IteratorX , typename IteratorY , typename IteratorZ , typename IteratorM , typename TypeX , typename TypeY , typename TypeZ &gt; </td></tr>
<tr class="memitem:a6962b0587db951690d13d7883d7088ee"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> std::enable_if&lt; std::is_convertible&lt; typename hydra::thrust::iterator_traits&lt; IteratorX &gt;::value_type, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt;::value &amp;&amp;std::is_convertible&lt; typename hydra::thrust::iterator_traits&lt; IteratorY &gt;::value_type, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt;::value &amp;&amp;std::is_convertible&lt; typename hydra::thrust::iterator_traits&lt; IteratorZ &gt;::value_type, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt;::value &amp;&amp;std::is_convertible&lt; typename hydra::thrust::iterator_traits&lt; IteratorM &gt;::value_type, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt;::value &amp;&amp;std::is_convertible&lt; TypeX, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt;::value &amp;&amp;std::is_convertible&lt; TypeY, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt;::value &amp;&amp;std::is_convertible&lt; TypeZ, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt;::value, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a6962b0587db951690d13d7883d7088ee">spline3D</a> (IteratorX firstx, IteratorX lastx, IteratorY firsty, IteratorY lasty, IteratorZ firstz, IteratorZ lastz, IteratorM measurements, TypeX x, TypeY y, TypeZ z)</td></tr>
<tr class="separator:a6962b0587db951690d13d7883d7088ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac42536655f18622458ca9e69a055f4a4"><td class="memTemplParams" colspan="2">template&lt;typename IterableX , typename IterableY , typename IterableZ , typename IterableM , typename TypeX , typename TypeY , typename TypeZ &gt; </td></tr>
<tr class="memitem:ac42536655f18622458ca9e69a055f4a4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; IterableX &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; IterableY &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; IterableZ &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; IterableM &gt;::value &amp;&amp;std::is_convertible&lt; typename IterableX::value_type, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt;::value &amp;&amp;std::is_convertible&lt; typename IterableY::value_type, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt;::value &amp;&amp;std::is_convertible&lt; typename IterableZ::value_type, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt;::value &amp;&amp;std::is_convertible&lt; typename IterableM::value_type, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt;::value &amp;&amp;std::is_convertible&lt; TypeX, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt;::value &amp;&amp;std::is_convertible&lt; TypeY, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt;::value &amp;&amp;std::is_convertible&lt; TypeZ, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt;::value, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ac42536655f18622458ca9e69a055f4a4">spline3D</a> (IterableX &amp;&amp;abscissa_x, IterableY &amp;&amp;abscissa_y, IterableZ &amp;&amp;abscissa_z, IterableM measurements, TypeX x, TypeX y, TypeZ z)</td></tr>
<tr class="separator:ac42536655f18622458ca9e69a055f4a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a920dfa188c2124bedd5ff97e17581752"><td class="memTemplParams" colspan="2">template&lt;typename IteratorX , typename IteratorY , typename IteratorZ , typename IteratorM , typename TypeX , typename TypeY , typename TypeZ &gt; </td></tr>
<tr class="memitem:a920dfa188c2124bedd5ff97e17581752"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> std::enable_if&lt; std::is_convertible&lt; typename hydra::thrust::iterator_traits&lt; IteratorX &gt;::value_type, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt;::value &amp;&amp;std::is_convertible&lt; typename hydra::thrust::iterator_traits&lt; IteratorY &gt;::value_type, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt;::value &amp;&amp;std::is_convertible&lt; typename hydra::thrust::iterator_traits&lt; IteratorZ &gt;::value_type, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt;::value &amp;&amp;std::is_convertible&lt; typename hydra::thrust::iterator_traits&lt; IteratorM &gt;::value_type, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt;::value &amp;&amp;std::is_convertible&lt; TypeX, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt;::value &amp;&amp;std::is_convertible&lt; TypeY, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt;::value &amp;&amp;std::is_convertible&lt; TypeZ, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt;::value, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a920dfa188c2124bedd5ff97e17581752">spline3D</a> (IteratorX firstx, IteratorX lastx, IteratorY firsty, IteratorY lasty, IteratorY firstz, IteratorY lastz, IteratorM measurements, TypeX x, TypeY y, TypeZ z)</td></tr>
<tr class="separator:a920dfa188c2124bedd5ff97e17581752"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf75877945a3556c21b5f4e512c20fc7"><td class="memTemplParams" colspan="2">template&lt;typename IterableX , typename IterableY , typename IterableW , typename IterableZ , typename IterableM , typename TypeX , typename TypeY , typename TypeW , typename TypeZ &gt; </td></tr>
<tr class="memitem:adf75877945a3556c21b5f4e512c20fc7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; IterableX &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; IterableY &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; IterableW &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; IterableZ &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; IterableM &gt;::value &amp;&amp;std::is_convertible&lt; typename IterableX::value_type, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt;::value &amp;&amp;std::is_convertible&lt; typename IterableY::value_type, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt;::value &amp;&amp;std::is_convertible&lt; typename IterableW::value_type, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt;::value &amp;&amp;std::is_convertible&lt; typename IterableZ::value_type, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt;::value &amp;&amp;std::is_convertible&lt; typename IterableM::value_type, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt;::value &amp;&amp;std::is_convertible&lt; TypeX, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt;::value &amp;&amp;std::is_convertible&lt; TypeY, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt;::value &amp;&amp;std::is_convertible&lt; TypeW, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt;::value &amp;&amp;std::is_convertible&lt; TypeZ, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt;::value, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#adf75877945a3556c21b5f4e512c20fc7">spline3D</a> (IterableX &amp;&amp;abscissa_x, IterableY &amp;&amp;abscissa_y, IterableW &amp;&amp;abscissa_w, IterableZ &amp;&amp;abscissa_z, IterableM measurements, TypeX x, TypeX y, TypeW w, TypeZ z)</td></tr>
<tr class="separator:adf75877945a3556c21b5f4e512c20fc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f6ea1c8ee93dd574ab6f3fc9068f238"><td class="memTemplParams" colspan="2">template&lt;typename IteratorX , typename IteratorY , typename IteratorW , typename IteratorZ , typename IteratorM , typename TypeX , typename TypeY , typename TypeW , typename TypeZ &gt; </td></tr>
<tr class="memitem:a7f6ea1c8ee93dd574ab6f3fc9068f238"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> std::enable_if&lt; std::is_convertible&lt; typename hydra::thrust::iterator_traits&lt; IteratorX &gt;::value_type, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt;::value &amp;&amp;std::is_convertible&lt; typename hydra::thrust::iterator_traits&lt; IteratorY &gt;::value_type, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt;::value &amp;&amp;std::is_convertible&lt; typename hydra::thrust::iterator_traits&lt; IteratorW &gt;::value_type, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt;::value &amp;&amp;std::is_convertible&lt; typename hydra::thrust::iterator_traits&lt; IteratorZ &gt;::value_type, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt;::value &amp;&amp;std::is_convertible&lt; typename hydra::thrust::iterator_traits&lt; IteratorM &gt;::value_type, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt;::value &amp;&amp;std::is_convertible&lt; TypeX, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt;::value &amp;&amp;std::is_convertible&lt; TypeY, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt;::value &amp;&amp;std::is_convertible&lt; TypeW, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt;::value &amp;&amp;std::is_convertible&lt; TypeZ, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt;::value, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a7f6ea1c8ee93dd574ab6f3fc9068f238">spline4D</a> (IteratorX firstx, IteratorX lastx, IteratorY firsty, IteratorY lasty, IteratorW firstw, IteratorW lastw, IteratorZ firstz, IteratorZ lastz, IteratorM measurements, TypeX x, TypeY y, TypeW w, TypeZ z)</td></tr>
<tr class="separator:a7f6ea1c8ee93dd574ab6f3fc9068f238"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74988a829019bf111e7f51d81b33eec7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a74988a829019bf111e7f51d81b33eec7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespacehydra.html#a9d2c06cb9672fe86dbeaa65e8f35a2bf">complex</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a74988a829019bf111e7f51d81b33eec7">sqrt</a> (const <a class="el" href="namespacehydra.html#a9d2c06cb9672fe86dbeaa65e8f35a2bf">complex</a>&lt; T &gt; &amp;z)</td></tr>
<tr class="separator:a74988a829019bf111e7f51d81b33eec7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa792627bbf68dd5d3c3d969c3462808f"><td class="memTemplParams" colspan="2">template&lt;size_t N, typename T , size_t I&gt; </td></tr>
<tr class="memitem:aa792627bbf68dd5d3c3d969c3462808f"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;(I==N), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#aa792627bbf68dd5d3c3d969c3462808f">stream_array_helper</a> (std::ostream &amp;, std::array&lt; T, N &gt; const &amp;)</td></tr>
<tr class="memdesc:aa792627bbf68dd5d3c3d969c3462808f"><td class="mdescLeft">&#160;</td><td class="mdescRight">array streamer helper  <a href="#aa792627bbf68dd5d3c3d969c3462808f">More...</a><br /></td></tr>
<tr class="separator:aa792627bbf68dd5d3c3d969c3462808f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b2446e6e58a2466b66c1277d67075ad"><td class="memTemplParams" colspan="2">template&lt;size_t N, typename T , size_t I = 0&gt; </td></tr>
<tr class="memitem:a6b2446e6e58a2466b66c1277d67075ad"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;(I&lt; N), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a6b2446e6e58a2466b66c1277d67075ad">stream_array_helper</a> (std::ostream &amp;os, std::array&lt; T, N &gt; const &amp;obj)</td></tr>
<tr class="separator:a6b2446e6e58a2466b66c1277d67075ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa8b42796ae70a6c34b6871a8755b382"><td class="memTemplParams" colspan="2">template&lt;size_t I, typename ... T&gt; </td></tr>
<tr class="memitem:afa8b42796ae70a6c34b6871a8755b382"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;(I==sizeof ...(T)), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#afa8b42796ae70a6c34b6871a8755b382">stream_tuple_helper</a> (std::ostream &amp;, std::tuple&lt; T... &gt; const &amp;)</td></tr>
<tr class="memdesc:afa8b42796ae70a6c34b6871a8755b382"><td class="mdescLeft">&#160;</td><td class="mdescRight">tuple streamer helper  <a href="#afa8b42796ae70a6c34b6871a8755b382">More...</a><br /></td></tr>
<tr class="separator:afa8b42796ae70a6c34b6871a8755b382"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0ba407638beac5920ac997d3021b413"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename ... T&gt; </td></tr>
<tr class="memitem:af0ba407638beac5920ac997d3021b413"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;(I&lt; sizeof ...(T)), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#af0ba407638beac5920ac997d3021b413">stream_tuple_helper</a> (std::ostream &amp;os, std::tuple&lt; T... &gt; const &amp;obj)</td></tr>
<tr class="separator:af0ba407638beac5920ac997d3021b413"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e699b8e46110a6a9df156affb6d3308"><td class="memTemplParams" colspan="2">template&lt;typename F1 , typename F2 , typename ... Fs&gt; </td></tr>
<tr class="memitem:a3e699b8e46110a6a9df156affb6d3308"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;(<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt; F1 &gt;::value||<a class="el" href="structhydra_1_1detail_1_1is__hydra__lambda.html">detail::is_hydra_lambda</a>&lt; F1 &gt;::value) &amp;&amp;(<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt; F2 &gt;::value||<a class="el" href="structhydra_1_1detail_1_1is__hydra__lambda.html">detail::is_hydra_lambda</a>&lt; F2 &gt;::value) &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1all__true.html">detail::all_true</a>&lt;(<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt; Fs &gt;::value||<a class="el" href="structhydra_1_1detail_1_1is__hydra__lambda.html">detail::is_hydra_lambda</a>&lt; Fs &gt;::value)... &gt;::value, <a class="el" href="classhydra_1_1Sum.html">Sum</a>&lt; F1, F2, Fs... &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a3e699b8e46110a6a9df156affb6d3308">sum</a> (F1 const &amp;f1, F2 const &amp;f2, Fs const &amp;... functors)</td></tr>
<tr class="separator:a3e699b8e46110a6a9df156affb6d3308"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7d619f99868f45f5e06b9040bcc68b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#aa7d619f99868f45f5e06b9040bcc68b7">swap</a> (Vector3R &amp;v1, Vector3R &amp;v2)</td></tr>
<tr class="separator:aa7d619f99868f45f5e06b9040bcc68b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67385a5afc562279b4419a11ab79e3d6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a67385a5afc562279b4419a11ab79e3d6">swap</a> (Vector4R &amp;v1, Vector4R &amp;v2)</td></tr>
<tr class="separator:a67385a5afc562279b4419a11ab79e3d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a110443bb149efe88b6713bc5aca89b7c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a110443bb149efe88b6713bc5aca89b7c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespacehydra.html#a9d2c06cb9672fe86dbeaa65e8f35a2bf">complex</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a110443bb149efe88b6713bc5aca89b7c">tan</a> (const <a class="el" href="namespacehydra.html#a9d2c06cb9672fe86dbeaa65e8f35a2bf">complex</a>&lt; T &gt; &amp;z)</td></tr>
<tr class="separator:a110443bb149efe88b6713bc5aca89b7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c39f4b7fa2b8b0c1e4066e9d059b435"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5c39f4b7fa2b8b0c1e4066e9d059b435"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespacehydra.html#a9d2c06cb9672fe86dbeaa65e8f35a2bf">complex</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a5c39f4b7fa2b8b0c1e4066e9d059b435">tanh</a> (const <a class="el" href="namespacehydra.html#a9d2c06cb9672fe86dbeaa65e8f35a2bf">complex</a>&lt; T &gt; &amp;z)</td></tr>
<tr class="separator:a5c39f4b7fa2b8b0c1e4066e9d059b435"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9654f2c52c92ba7219bfc4e6edb9ef58"><td class="memTemplParams" colspan="2">template&lt;class ... T&gt; </td></tr>
<tr class="memitem:a9654f2c52c92ba7219bfc4e6edb9ef58"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a9654f2c52c92ba7219bfc4e6edb9ef58">tie</a> (T &amp;...t) -&gt; decltype(hydra::thrust::tie(t...))</td></tr>
<tr class="memdesc:a9654f2c52c92ba7219bfc4e6edb9ef58"><td class="mdescLeft">&#160;</td><td class="mdescRight">This version of <code>tie</code> creates a new <code>tuple</code> whose elements are references which refers to this function's arguments.  <a href="#a9654f2c52c92ba7219bfc4e6edb9ef58">More...</a><br /></td></tr>
<tr class="separator:a9654f2c52c92ba7219bfc4e6edb9ef58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66e3f95285aed29c7f62df05eecf2f00"><td class="memTemplParams" colspan="2">template&lt;typename Iterable_Input , typename Iterable_Output , typename Functor , typename Iterator  = decltype(std::declval&lt;Iterable_Output&gt;().begin())&gt; </td></tr>
<tr class="memitem:a66e3f95285aed29c7f62df05eecf2f00"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; Iterable_Output &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; decltype(std::declval&lt; Iterable_Output &amp; &gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>())&gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a66e3f95285aed29c7f62df05eecf2f00">transform</a> (Iterable_Input &amp;&amp;iterable_input, Iterable_Output &amp;&amp;iterable_output, Functor const &amp;unary_functor)</td></tr>
<tr class="separator:a66e3f95285aed29c7f62df05eecf2f00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae23442b36fe3fb907689e3150f77c12"><td class="memTemplParams" colspan="2">template&lt;typename RNG , typename DerivedPolicy , typename IteratorData , typename IteratorWeight &gt; </td></tr>
<tr class="memitem:gaae23442b36fe3fb907689e3150f77c12"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1random_1_1is__iterator.html">detail::random::is_iterator</a>&lt; IteratorData &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1random_1_1is__iterator.html">detail::random::is_iterator</a>&lt; IteratorWeight &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; IteratorData &gt;&gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__random.html#gaae23442b36fe3fb907689e3150f77c12">unweight</a> (hydra::thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; const &amp;policy, IteratorData data_begin, IteratorData data_end, IteratorWeight weights_begin, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> max_pdf, size_t rng_seed, size_t rng_jump)</td></tr>
<tr class="memdesc:gaae23442b36fe3fb907689e3150f77c12"><td class="mdescLeft">&#160;</td><td class="mdescRight">This functions reorder a dataset to produce a unweighted sample according to the weights [wbegin, wend].  <a href="group__random.html#gaae23442b36fe3fb907689e3150f77c12">More...</a><br /></td></tr>
<tr class="separator:gaae23442b36fe3fb907689e3150f77c12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae8c064cc002534c30896c7b14480dfb9"><td class="memTemplParams" colspan="2">template&lt;typename RNG , typename IteratorData , typename IteratorWeight , hydra::detail::Backend BACKEND&gt; </td></tr>
<tr class="memitem:gae8c064cc002534c30896c7b14480dfb9"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1random_1_1is__iterator.html">detail::random::is_iterator</a>&lt; IteratorData &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1random_1_1is__iterator.html">detail::random::is_iterator</a>&lt; IteratorWeight &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; IteratorData &gt;&gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__random.html#gae8c064cc002534c30896c7b14480dfb9">unweight</a> (<a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt; const &amp;policy, IteratorData data_begin, IteratorData data_end, IteratorWeight weights_begin, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> max_pdf, size_t rng_seed, size_t rng_jump)</td></tr>
<tr class="memdesc:gae8c064cc002534c30896c7b14480dfb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This functions reorder a dataset to produce a unweighted sample according to the weights [wbegin, wend].  <a href="group__random.html#gae8c064cc002534c30896c7b14480dfb9">More...</a><br /></td></tr>
<tr class="separator:gae8c064cc002534c30896c7b14480dfb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a695d916ac439e7a655586ca4e52395c8"><td class="memTemplParams" colspan="2">template&lt;typename RNG , typename IteratorData , typename IteratorWeight &gt; </td></tr>
<tr class="memitem:a695d916ac439e7a655586ca4e52395c8"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1random_1_1is__iterator.html">detail::random::is_iterator</a>&lt; IteratorData &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1random_1_1is__iterator.html">detail::random::is_iterator</a>&lt; IteratorWeight &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; IteratorData &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a695d916ac439e7a655586ca4e52395c8">unweight</a> (IteratorData data_begin, IteratorData data_end, IteratorWeight weights_begin, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> max_pdf, size_t rng_seed, size_t rng_jump)</td></tr>
<tr class="separator:a695d916ac439e7a655586ca4e52395c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga932e096b6854bbad2b35cdc46d42a08c"><td class="memTemplParams" colspan="2">template&lt;typename RNG , typename IterableData , typename IterableWeight , hydra::detail::Backend BACKEND&gt; </td></tr>
<tr class="memitem:ga932e096b6854bbad2b35cdc46d42a08c"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1random_1_1is__iterable.html">detail::random::is_iterable</a>&lt; IterableData &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1random_1_1is__iterable.html">detail::random::is_iterable</a>&lt; IterableWeight &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; decltype(std::declval&lt; IterableData &gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>())&gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__random.html#ga932e096b6854bbad2b35cdc46d42a08c">unweight</a> (<a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; const  &amp;policy, IterableData &amp;&amp;<a class="el" href="basic__distributions_8inl.html#a248ea98483ce90baaf65a7682438d72d">data</a>, IterableWeight &amp;&amp;weights, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> max_pdf=-1.0, size_t rng_seed=0x8ec74d321e6b5a27, size_t rng_jump=0)</td></tr>
<tr class="memdesc:ga932e096b6854bbad2b35cdc46d42a08c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This functions reorder a dataset to produce a unweighted sample according to a weights.  <a href="group__random.html#ga932e096b6854bbad2b35cdc46d42a08c">More...</a><br /></td></tr>
<tr class="separator:ga932e096b6854bbad2b35cdc46d42a08c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2775fa2909173fb09d8ffb19c5a8b4df"><td class="memTemplParams" colspan="2">template&lt;typename RNG , typename IterableData , typename IterableWeight &gt; </td></tr>
<tr class="memitem:a2775fa2909173fb09d8ffb19c5a8b4df"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1random_1_1is__iterable.html">detail::random::is_iterable</a>&lt; IterableData &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1random_1_1is__iterable.html">detail::random::is_iterable</a>&lt; IterableWeight &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; decltype(std::declval&lt; IterableData &gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>())&gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a2775fa2909173fb09d8ffb19c5a8b4df">unweight</a> (IterableData &amp;&amp;<a class="el" href="basic__distributions_8inl.html#a248ea98483ce90baaf65a7682438d72d">data</a>, IterableWeight &amp;&amp;weights, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> max_pdf, size_t rng_seed, size_t rng_jump)</td></tr>
<tr class="separator:a2775fa2909173fb09d8ffb19c5a8b4df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae23442b36fe3fb907689e3150f77c12"><td class="memTemplParams" colspan="2">template&lt;typename RNG  = default_random_engine, typename DerivedPolicy , typename IteratorData , typename IteratorWeight &gt; </td></tr>
<tr class="memitem:gaae23442b36fe3fb907689e3150f77c12"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1random_1_1is__iterator.html">detail::random::is_iterator</a>&lt; IteratorData &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1random_1_1is__iterator.html">detail::random::is_iterator</a>&lt; IteratorWeight &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; IteratorData &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__random.html#gaae23442b36fe3fb907689e3150f77c12">unweight</a> (hydra::thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; const &amp;policy, IteratorData data_begin, IteratorData data_end, IteratorWeight weights_begin, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> max_pdf=-1.0, size_t rng_seed=0x8ec74d321e6b5a27, size_t rng_jump=0)</td></tr>
<tr class="memdesc:gaae23442b36fe3fb907689e3150f77c12"><td class="mdescLeft">&#160;</td><td class="mdescRight">This functions reorder a dataset to produce a unweighted sample according to the weights [wbegin, wend].  <a href="group__random.html#gaae23442b36fe3fb907689e3150f77c12">More...</a><br /></td></tr>
<tr class="separator:gaae23442b36fe3fb907689e3150f77c12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga880b569319bd1c53db05a7b4779a47f8"><td class="memTemplParams" colspan="2">template&lt;typename RNG , typename Functor , typename Iterator , typename DerivedPolicy &gt; </td></tr>
<tr class="memitem:ga880b569319bd1c53db05a7b4779a47f8"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1random_1_1is__callable.html">detail::random::is_callable</a>&lt; Functor &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1random_1_1is__iterator.html">detail::random::is_iterator</a>&lt; Iterator &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; Iterator &gt;&gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__random.html#ga880b569319bd1c53db05a7b4779a47f8">unweight</a> (hydra::thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; const  &amp;policy, Iterator <a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>, Iterator <a class="el" href="namespacehydra.html#a4274268d147e9a988f379326b73682b0">end</a>, Functor const  &amp;functor, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> max_pdf=-1.0, size_t rng_seed=0x8ec74d321e6b5a27, size_t rng_jump=0)</td></tr>
<tr class="memdesc:ga880b569319bd1c53db05a7b4779a47f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This functions reorder a dataset to produce an unweighted sample according to.  <a href="group__random.html#ga880b569319bd1c53db05a7b4779a47f8">More...</a><br /></td></tr>
<tr class="separator:ga880b569319bd1c53db05a7b4779a47f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae8c064cc002534c30896c7b14480dfb9"><td class="memTemplParams" colspan="2">template&lt;typename RNG  = default_random_engine, typename IteratorData , typename IteratorWeight , hydra::detail::Backend BACKEND&gt; </td></tr>
<tr class="memitem:gae8c064cc002534c30896c7b14480dfb9"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1random_1_1is__iterator.html">detail::random::is_iterator</a>&lt; IteratorData &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1random_1_1is__iterator.html">detail::random::is_iterator</a>&lt; IteratorWeight &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; IteratorData &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__random.html#gae8c064cc002534c30896c7b14480dfb9">unweight</a> (<a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt; const &amp;policy, IteratorData data_begin, IteratorData data_end, IteratorWeight weights_begin, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> max_pdf=-1.0, size_t rng_seed=0x8ec74d321e6b5a27, size_t rng_jump=0)</td></tr>
<tr class="memdesc:gae8c064cc002534c30896c7b14480dfb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This functions reorder a dataset to produce a unweighted sample according to the weights [wbegin, wend].  <a href="group__random.html#gae8c064cc002534c30896c7b14480dfb9">More...</a><br /></td></tr>
<tr class="separator:gae8c064cc002534c30896c7b14480dfb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga523a7ddb8f50e2d91e19ef3123f455ff"><td class="memTemplParams" colspan="2">template&lt;typename RNG , typename Functor , typename Iterator , hydra::detail::Backend BACKEND&gt; </td></tr>
<tr class="memitem:ga523a7ddb8f50e2d91e19ef3123f455ff"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1random_1_1is__callable.html">detail::random::is_callable</a>&lt; Functor &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1random_1_1is__iterator.html">detail::random::is_iterator</a>&lt; Iterator &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; Iterator &gt;&gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__random.html#ga523a7ddb8f50e2d91e19ef3123f455ff">unweight</a> (<a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; const  &amp;policy, Iterator <a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>, Iterator <a class="el" href="namespacehydra.html#a4274268d147e9a988f379326b73682b0">end</a>, Functor const  &amp;functor, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> max_pdf=-1.0, size_t rng_seed=0x8ec74d321e6b5a27, size_t rng_jump=0)</td></tr>
<tr class="memdesc:ga523a7ddb8f50e2d91e19ef3123f455ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">This functions reorder a dataset to produce an unweighted sample according to.  <a href="group__random.html#ga523a7ddb8f50e2d91e19ef3123f455ff">More...</a><br /></td></tr>
<tr class="separator:ga523a7ddb8f50e2d91e19ef3123f455ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga450b674f56a2c27ed4c0d37d9a9e92de"><td class="memTemplParams" colspan="2">template&lt;typename RNG  = default_random_engine, typename IteratorData , typename IteratorWeight &gt; </td></tr>
<tr class="memitem:ga450b674f56a2c27ed4c0d37d9a9e92de"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1random_1_1is__iterator.html">detail::random::is_iterator</a>&lt; IteratorData &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1random_1_1is__iterator.html">detail::random::is_iterator</a>&lt; IteratorWeight &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; IteratorData &gt;&gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__random.html#ga450b674f56a2c27ed4c0d37d9a9e92de">unweight</a> (IteratorData data_begin, IteratorData data_end, IteratorData weights_begin, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> max_pdf=-1.0, size_t rng_seed=0x8ec74d321e6b5a27, size_t rng_jump=0)</td></tr>
<tr class="memdesc:ga450b674f56a2c27ed4c0d37d9a9e92de"><td class="mdescLeft">&#160;</td><td class="mdescRight">This functions reorder a dataset to produce a unweighted sample according to the weights [wbegin, wend].  <a href="group__random.html#ga450b674f56a2c27ed4c0d37d9a9e92de">More...</a><br /></td></tr>
<tr class="separator:ga450b674f56a2c27ed4c0d37d9a9e92de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad15cc3b2599bbe6cde09ce6826dd67ad"><td class="memTemplParams" colspan="2">template&lt;typename RNG , typename Functor , typename Iterator &gt; </td></tr>
<tr class="memitem:gad15cc3b2599bbe6cde09ce6826dd67ad"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1random_1_1is__callable.html">detail::random::is_callable</a>&lt; Functor &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1random_1_1is__iterator.html">detail::random::is_iterator</a>&lt; Iterator &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; Iterator &gt;&gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__random.html#gad15cc3b2599bbe6cde09ce6826dd67ad">unweight</a> (Iterator <a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>, Iterator <a class="el" href="namespacehydra.html#a4274268d147e9a988f379326b73682b0">end</a>, Functor const  &amp;functor, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> max_pdf=-1.0, size_t rng_seed=0x8ec74d321e6b5a27, size_t rng_jump=0)</td></tr>
<tr class="memdesc:gad15cc3b2599bbe6cde09ce6826dd67ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">This functions reorder a dataset to produce an unweighted sample according to.  <a href="group__random.html#gad15cc3b2599bbe6cde09ce6826dd67ad">More...</a><br /></td></tr>
<tr class="separator:gad15cc3b2599bbe6cde09ce6826dd67ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb3c70f084c7e21be32f72eb2979247e"><td class="memTemplParams" colspan="2">template&lt;typename RNG , typename Functor , typename Iterable , hydra::detail::Backend BACKEND&gt; </td></tr>
<tr class="memitem:gacb3c70f084c7e21be32f72eb2979247e"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1random_1_1is__callable.html">detail::random::is_callable</a>&lt; Functor &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1random_1_1is__iterable.html">detail::random::is_iterable</a>&lt; Iterable &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; decltype(std::declval&lt; Iterable &gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>())&gt;&gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__random.html#gacb3c70f084c7e21be32f72eb2979247e">unweight</a> (<a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; const  &amp;policy, Iterable &amp;&amp;iterable, Functor const  &amp;functor, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> max_pdf=-1.0, size_t rng_seed=0x8ec74d321e6b5a27, size_t rng_jump=0)</td></tr>
<tr class="memdesc:gacb3c70f084c7e21be32f72eb2979247e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This functions reorder a dataset to produce an unweighted sample according to.  <a href="group__random.html#gacb3c70f084c7e21be32f72eb2979247e">More...</a><br /></td></tr>
<tr class="separator:gacb3c70f084c7e21be32f72eb2979247e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga94b72c0a1e58267b650befa0d3d2a991"><td class="memTemplParams" colspan="2">template&lt;typename RNG , typename Functor , typename Iterable &gt; </td></tr>
<tr class="memitem:ga94b72c0a1e58267b650befa0d3d2a991"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1random_1_1is__callable.html">detail::random::is_callable</a>&lt; Functor &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1random_1_1is__iterable.html">detail::random::is_iterable</a>&lt; Iterable &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; decltype(std::declval&lt; Iterable &gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>())&gt;&gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__random.html#ga94b72c0a1e58267b650befa0d3d2a991">unweight</a> (Iterable &amp;&amp;iterable, Functor const &amp;functor, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> max_pdf, size_t rng_seed, size_t rng_jump)</td></tr>
<tr class="memdesc:ga94b72c0a1e58267b650befa0d3d2a991"><td class="mdescLeft">&#160;</td><td class="mdescRight">This functions reorder a dataset to produce an unweighted sample according to.  <a href="group__random.html#ga94b72c0a1e58267b650befa0d3d2a991">More...</a><br /></td></tr>
<tr class="separator:ga94b72c0a1e58267b650befa0d3d2a991"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3cdb91f1ad44de272a40071be5c5668"><td class="memTemplParams" colspan="2">template&lt;typename RNG  = default_random_engine, typename IterableData , typename IterableWeight &gt; </td></tr>
<tr class="memitem:gae3cdb91f1ad44de272a40071be5c5668"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1random_1_1is__iterable.html">detail::random::is_iterable</a>&lt; IterableData &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1random_1_1is__iterable.html">detail::random::is_iterable</a>&lt; IterableWeight &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; decltype(std::declval&lt; IterableData &gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>())&gt;&gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__random.html#gae3cdb91f1ad44de272a40071be5c5668">unweight</a> (IterableData <a class="el" href="basic__distributions_8inl.html#a248ea98483ce90baaf65a7682438d72d">data</a>, IterableWeight weights, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> max_pdf=-1.0, size_t rng_seed=0x8ec74d321e6b5a27, size_t rng_jump=0)</td></tr>
<tr class="memdesc:gae3cdb91f1ad44de272a40071be5c5668"><td class="mdescLeft">&#160;</td><td class="mdescRight">This functions reorder a dataset to produce an unweighted sample according to a weights.  <a href="group__random.html#gae3cdb91f1ad44de272a40071be5c5668">More...</a><br /></td></tr>
<tr class="separator:gae3cdb91f1ad44de272a40071be5c5668"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga94b72c0a1e58267b650befa0d3d2a991"><td class="memTemplParams" colspan="2">template&lt;typename RNG  = default_random_engine, typename Functor , typename Iterable &gt; </td></tr>
<tr class="memitem:ga94b72c0a1e58267b650befa0d3d2a991"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1random_1_1is__callable.html">detail::random::is_callable</a>&lt; Functor &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1random_1_1is__iterable.html">detail::random::is_iterable</a>&lt; Iterable &gt;::value,<a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; decltype(std::declval&lt; Iterable &gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>())&gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__random.html#ga94b72c0a1e58267b650befa0d3d2a991">unweight</a> (Iterable &amp;&amp;iterable, Functor const &amp;functor, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> max_pdf=-1.0, size_t rng_seed=0x8ec74d321e6b5a27, size_t rng_jump=0)</td></tr>
<tr class="memdesc:ga94b72c0a1e58267b650befa0d3d2a991"><td class="mdescLeft">&#160;</td><td class="mdescRight">This functions reorder a dataset to produce an unweighted sample according to.  <a href="group__random.html#ga94b72c0a1e58267b650befa0d3d2a991">More...</a><br /></td></tr>
<tr class="separator:ga94b72c0a1e58267b650befa0d3d2a991"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16cc58cf433d121a37c54f965023d49a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a16cc58cf433d121a37c54f965023d49a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a16cc58cf433d121a37c54f965023d49a">wigner_d_matrix</a> (<a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> j, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> m, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> <a class="el" href="crystal__ball__plus__exponential_8inl.html#a21f77208d6bc667560ff8aaf8f943b6a">n</a>, const T theta)</td></tr>
<tr class="separator:a16cc58cf433d121a37c54f965023d49a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba159f9fe4df851059cae3f4ad676088"><td class="memItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#aba159f9fe4df851059cae3f4ad676088">wigner_d_matrix</a> (<a class="el" href="namespace_3globalScope_4.html#classunsigned">unsigned</a> j, <a class="el" href="namespace_3globalScope_4.html#classunsigned">unsigned</a> m, <a class="el" href="namespace_3globalScope_4.html#classunsigned">unsigned</a> <a class="el" href="crystal__ball__plus__exponential_8inl.html#a21f77208d6bc667560ff8aaf8f943b6a">n</a>, const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> theta)</td></tr>
<tr class="separator:aba159f9fe4df851059cae3f4ad676088"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a094f4a025290ae35ad9eb8c553c7fc61"><td class="memTemplParams" colspan="2">template&lt;typename LambdaType &gt; </td></tr>
<tr class="memitem:a094f4a025290ae35ad9eb8c553c7fc61"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classhydra_1_1Lambda.html">hydra::Lambda</a>&lt; LambdaType, 0 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a094f4a025290ae35ad9eb8c553c7fc61">wrap_lambda</a> (LambdaType const &amp;<a class="el" href="basic__distributions_8inl.html#a226b5ae55983130a9a1e82e0ecdd8c1b">lambda</a>)</td></tr>
<tr class="separator:a094f4a025290ae35ad9eb8c553c7fc61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d026eb3807e3f2358feb9a7890b4598"><td class="memTemplParams" colspan="2">template&lt;typename LambdaType , typename ... T&gt; </td></tr>
<tr class="memitem:a5d026eb3807e3f2358feb9a7890b4598"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1all__true.html">detail::all_true</a>&lt; std::is_same&lt; T, <a class="el" href="group__fit.html#structhydra_1_1Parameter">hydra::Parameter</a> &gt;::value... &gt;::value, <a class="el" href="classhydra_1_1Lambda.html">hydra::Lambda</a>&lt; LambdaType, sizeof...(T)&gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a5d026eb3807e3f2358feb9a7890b4598">wrap_lambda</a> (LambdaType const &amp;<a class="el" href="basic__distributions_8inl.html#a226b5ae55983130a9a1e82e0ecdd8c1b">lambda</a>, T const &amp;...parameters)</td></tr>
<tr class="separator:a5d026eb3807e3f2358feb9a7890b4598"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25948c700f3cfb8ebc1752cfe765fc31"><td class="memTemplParams" colspan="2">template&lt;typename ... Iterables&gt; </td></tr>
<tr class="memitem:a25948c700f3cfb8ebc1752cfe765fc31"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1all__true.html">detail::all_true</a>&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">detail::is_iterable</a>&lt; Iterables &gt;::value... &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; hydra::thrust::zip_iterator&lt; decltype(hydra::thrust::make_tuple(std::declval&lt; Iterables &amp; &gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()...))&gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a25948c700f3cfb8ebc1752cfe765fc31">zip</a> (Iterables &amp;&amp;... iterables)</td></tr>
<tr class="separator:a25948c700f3cfb8ebc1752cfe765fc31"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga65a1b65421aa4aa59946679a3950f902"><td class="memTemplParams" colspan="2">template&lt;typename Engine  = hydra::default_random_engine, hydra::detail::Backend BACKEND, typename Iterator , typename FUNCTOR &gt; </td></tr>
<tr class="memitem:ga65a1b65421aa4aa59946679a3950f902"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1has__rng__formula.html">hydra::detail::has_rng_formula</a>&lt; FUNCTOR &gt;::value &amp;&amp;std::is_convertible&lt; decltype(std::declval&lt; <a class="el" href="classhydra_1_1RngFormula.html">RngFormula</a>&lt; FUNCTOR &gt; &gt;).<a class="el" href="phsp__unweighting_8inl.html#aae0754269ece74173f4afd72643b7e3e">Generate</a>(std::declval&lt; Engine &amp; &gt;), std::declval&lt; FUNCTOR const  &amp; &gt;))), typename hydra::thrust::iterator_traits&lt; Iterator &gt;::value_type &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__random.html#ga65a1b65421aa4aa59946679a3950f902">fill_random</a> (<a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; const &amp;policy, Iterator <a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>, Iterator <a class="el" href="namespacehydra.html#a4274268d147e9a988f379326b73682b0">end</a>, FUNCTOR const &amp;functor, size_t seed=0x254a0afcf7da74a2, size_t rng_jump=0)</td></tr>
<tr class="memdesc:ga65a1b65421aa4aa59946679a3950f902"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill a range with numbers distributed according a user defined distribution using a RNG analytical formula.  <a href="group__random.html#ga65a1b65421aa4aa59946679a3950f902">More...</a><br /></td></tr>
<tr class="separator:ga65a1b65421aa4aa59946679a3950f902"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89686ff2116120de2d9e2ad6889a47de"><td class="memItemLeft" align="right" valign="top">decltype(other.begin(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;{})) typedef&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a89686ff2116120de2d9e2ad6889a47de">iterator_type</a></td></tr>
<tr class="separator:a89686ff2116120de2d9e2ad6889a47de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab14adaa26f703b8c130df530167ebd23"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacehydra.html#aa8c251ed5017d0638da929130062bcad">GBool_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ab14adaa26f703b8c130df530167ebd23">kFalse</a> = false</td></tr>
<tr class="separator:ab14adaa26f703b8c130df530167ebd23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1556536d7a73fa95e5a9c9610f76a3c1"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacehydra.html#aa8c251ed5017d0638da929130062bcad">GBool_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a1556536d7a73fa95e5a9c9610f76a3c1">kTrue</a> = true</td></tr>
<tr class="separator:a1556536d7a73fa95e5a9c9610f76a3c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7cb37dfdb2198202b4cb3f0b79f94080"><td class="memTemplParams" colspan="2">template&lt;typename ... Pdfs, typename Histogram &gt; </td></tr>
<tr class="memitem:ga7cb37dfdb2198202b4cb3f0b79f94080"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__hydra__dense__histogram.html">detail::is_hydra_dense_histogram</a>&lt; Histogram &gt;::value||<a class="el" href="structhydra_1_1detail_1_1is__hydra__sparse__histogram.html">detail::is_hydra_sparse_histogram</a>&lt; Histogram &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1LogLikelihoodFCN">LogLikelihoodFCN</a>&lt; <a class="el" href="group__fit.html#classhydra_1_1PDFSumExtendable">PDFSumExtendable</a>&lt; Pdfs... &gt;, decltype(std::declval&lt; const Histogram &amp; &gt;).GetBinsCenters().<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()), decltype(std::declval&lt; const Histogram &amp; &gt;).GetBinsContents().<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()) &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__fit.html#ga7cb37dfdb2198202b4cb3f0b79f94080">make_loglikehood_fcn</a> (<a class="el" href="group__fit.html#classhydra_1_1PDFSumExtendable">PDFSumExtendable</a>&lt; Pdfs... &gt; const &amp;pdf, Histogram const &amp;<a class="el" href="basic__distributions_8inl.html#a248ea98483ce90baaf65a7682438d72d">data</a>)</td></tr>
<tr class="memdesc:ga7cb37dfdb2198202b4cb3f0b79f94080"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function to build up loglikehood fcns for densely and sparsely binned datasets.  <a href="group__fit.html#ga7cb37dfdb2198202b4cb3f0b79f94080">More...</a><br /></td></tr>
<tr class="separator:ga7cb37dfdb2198202b4cb3f0b79f94080"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5afb8f1b6ea1ba2b8fc79444e5d20f20"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_3globalScope_4.html#classint">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a5afb8f1b6ea1ba2b8fc79444e5d20f20">PrintLevel</a> = <a class="el" href="namespacehydra.html#a1107488f838687e73b39ddd8245f40d0a1bf857a06d5b8463494a6fcac6f4ea26">WARNING</a></td></tr>
<tr class="separator:a5afb8f1b6ea1ba2b8fc79444e5d20f20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b5278e8bbc808a52856865a2a39dba7"><td class="memTemplParams" colspan="2">template&lt;typename RNG  = default_random_engine, typename Functor , typename Iterator &gt; </td></tr>
<tr class="memitem:a5b5278e8bbc808a52856865a2a39dba7"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1random_1_1is__callable.html">detail::random::is_callable</a>&lt; Functor &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1random_1_1is__iterator.html">detail::random::is_iterator</a>&lt; Iterator &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1is__tuple__type.html">detail::is_tuple_type</a>&lt; decltype(*std::declval&lt; Iterator &gt;))&gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; Iterator &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a5b5278e8bbc808a52856865a2a39dba7">sample</a> (Iterator <a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>, Iterator <a class="el" href="namespacehydra.html#a4274268d147e9a988f379326b73682b0">end</a>, typename Functor::argument_type const &amp;<a class="el" href="particle__mass_8inl.html#aad36546e8175d2922bee165fe028fedc">min</a>, typename Functor::argument_type const &amp;<a class="el" href="particle__mass_8inl.html#a0b0ede69e8156eb97acc579b88e883de">max</a>, Functor const &amp;functor, size_t seed=0xb56c4feeef1b, size_t rng_jump=0)</td></tr>
<tr class="memdesc:a5b5278e8bbc808a52856865a2a39dba7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill a range with numbers distributed according a user defined distribution.  <a href="#a5b5278e8bbc808a52856865a2a39dba7">More...</a><br /></td></tr>
<tr class="separator:a5b5278e8bbc808a52856865a2a39dba7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Generic policies definition. </p>
<p>namespace thrust</p>
<p><code>thrust</code> is the top-level namespace which contains all Hydra functions and types.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000002">Todo:</a></b></dt><dd>: fix compile error in nvcc adding variants to vectors</dd></dl>
</div><hr/><h2 class="groupheader">Data Structure Documentation</h2>
<a name="classhydra_1_1BaseCompositeFunctor" id="classhydra_1_1BaseCompositeFunctor"></a>
<h2 class="memtitle"><span class="permalink"><a href="#classhydra_1_1BaseCompositeFunctor">&#9670;&nbsp;</a></span>hydra::BaseCompositeFunctor</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class hydra::BaseCompositeFunctor</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename Composite, typename FunctorList, typename Signature&gt;<br />
class hydra::BaseCompositeFunctor&lt; Composite, FunctorList, Signature &gt;</h3>

</div><div class="dynheader">
Inheritance diagram for hydra::BaseCompositeFunctor&lt; Composite, FunctorList, Signature &gt;:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="classhydra_1_1BaseCompositeFunctor__inherit__graph.svg" width="100%" height="600"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</div>
<div class="dynheader">
Collaboration diagram for hydra::BaseCompositeFunctor&lt; Composite, FunctorList, Signature &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classhydra_1_1BaseCompositeFunctor__coll__graph.svg" width="210" height="118"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a name="classhydra_1_1ConvolutionFunctor" id="classhydra_1_1ConvolutionFunctor"></a>
<h2 class="memtitle"><span class="permalink"><a href="#classhydra_1_1ConvolutionFunctor">&#9670;&nbsp;</a></span>hydra::ConvolutionFunctor</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class hydra::ConvolutionFunctor</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename Functor, typename Kernel, typename Backend, typename FFT, typename ArgType&gt;<br />
class hydra::ConvolutionFunctor&lt; Functor, Kernel, Backend, FFT, ArgType &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::ConvolutionFunctor&lt; Functor, Kernel, Backend, FFT, ArgType &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classhydra_1_1ConvolutionFunctor__coll__graph.svg" width="196" height="118"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a name="classhydra_1_1Distribution" id="classhydra_1_1Distribution"></a>
<h2 class="memtitle"><span class="permalink"><a href="#classhydra_1_1Distribution">&#9670;&nbsp;</a></span>hydra::Distribution</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class hydra::Distribution</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename Functor, bool Implemented = detail::has_rng_formula&lt;Functor&gt;::value&gt;<br />
class hydra::Distribution&lt; Functor, Implemented &gt;</h3>

<dl><dt><b>Examples: </b></dt><dd><a class="el" href="basic_distributions_8inl-example.html#_a47">basic_distributions.inl</a>.</dd>
</dl></div><div class="dynheader">
Collaboration diagram for hydra::Distribution&lt; Functor, Implemented &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classhydra_1_1Distribution__coll__graph.svg" width="183" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a name="structhydra_1_1Distribution_3_01Class_00_01false_01_4" id="structhydra_1_1Distribution_3_01Class_00_01false_01_4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1Distribution_3_01Class_00_01false_01_4">&#9670;&nbsp;</a></span>hydra::Distribution&lt; Class, false &gt;</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::Distribution&lt; Class, false &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename Class&gt;<br />
struct hydra::Distribution&lt; Class, false &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::Distribution&lt; Class, false &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1Distribution_3_01Class_00_01false_01_4__coll__graph.svg" width="139" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a name="classhydra_1_1GaussKronrodAdaptiveQuadrature" id="classhydra_1_1GaussKronrodAdaptiveQuadrature"></a>
<h2 class="memtitle"><span class="permalink"><a href="#classhydra_1_1GaussKronrodAdaptiveQuadrature">&#9670;&nbsp;</a></span>hydra::GaussKronrodAdaptiveQuadrature</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class hydra::GaussKronrodAdaptiveQuadrature</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;size_t NRULE, size_t NBIN, typename BACKEND&gt;<br />
class hydra::GaussKronrodAdaptiveQuadrature&lt; NRULE, NBIN, BACKEND &gt;</h3>

<dl><dt><b>Examples: </b></dt><dd><a class="el" href="adaptive_gauss_kronrod_8inl-example.html#_a12">adaptive_gauss_kronrod.inl</a>.</dd>
</dl></div><div class="dynheader">
Collaboration diagram for hydra::GaussKronrodAdaptiveQuadrature&lt; NRULE, NBIN, BACKEND &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classhydra_1_1GaussKronrodAdaptiveQuadrature__coll__graph.svg" width="207" height="118"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a name="classhydra_1_1GaussKronrodQuadrature" id="classhydra_1_1GaussKronrodQuadrature"></a>
<h2 class="memtitle"><span class="permalink"><a href="#classhydra_1_1GaussKronrodQuadrature">&#9670;&nbsp;</a></span>hydra::GaussKronrodQuadrature</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class hydra::GaussKronrodQuadrature</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;size_t NRULE, size_t NBIN, typename BACKEND&gt;<br />
class hydra::GaussKronrodQuadrature&lt; NRULE, NBIN, BACKEND &gt;</h3>

<dl><dt><b>Examples: </b></dt><dd><a class="el" href="convolute_functions_8inl-example.html#_a22">convolute_functions.inl</a>, <a class="el" href="fit_convoluted_pdfs_8inl-example.html#_a25">fit_convoluted_pdfs.inl</a>, and <a class="el" href="gauss_kronrod_8inl-example.html#_a13">gauss_kronrod.inl</a>.</dd>
</dl></div><div class="dynheader">
Collaboration diagram for hydra::GaussKronrodQuadrature&lt; NRULE, NBIN, BACKEND &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classhydra_1_1GaussKronrodQuadrature__coll__graph.svg" width="220" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a name="structhydra_1_1GaussKronrodRuleSelector" id="structhydra_1_1GaussKronrodRuleSelector"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1GaussKronrodRuleSelector">&#9670;&nbsp;</a></span>hydra::GaussKronrodRuleSelector</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::GaussKronrodRuleSelector</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;size_t N&gt;<br />
struct hydra::GaussKronrodRuleSelector&lt; N &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::GaussKronrodRuleSelector&lt; N &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1GaussKronrodRuleSelector__coll__graph.svg" width="266" height="88"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a name="classhydra_1_1GenzMalikQuadrature" id="classhydra_1_1GenzMalikQuadrature"></a>
<h2 class="memtitle"><span class="permalink"><a href="#classhydra_1_1GenzMalikQuadrature">&#9670;&nbsp;</a></span>hydra::GenzMalikQuadrature</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class hydra::GenzMalikQuadrature</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;size_t N, typename BACKEND&gt;<br />
class hydra::GenzMalikQuadrature&lt; N, BACKEND &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::GenzMalikQuadrature&lt; N, BACKEND &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classhydra_1_1GenzMalikQuadrature__coll__graph.svg" width="199" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a name="classhydra_1_1GenzMalikRule" id="classhydra_1_1GenzMalikRule"></a>
<h2 class="memtitle"><span class="permalink"><a href="#classhydra_1_1GenzMalikRule">&#9670;&nbsp;</a></span>hydra::GenzMalikRule</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class hydra::GenzMalikRule</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;size_t DIM, typename BACKEND&gt;<br />
class hydra::GenzMalikRule&lt; DIM, BACKEND &gt;</h3>

</div><div class="dynheader">
Inheritance diagram for hydra::GenzMalikRule&lt; DIM, BACKEND &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classhydra_1_1GenzMalikRule__inherit__graph.svg" width="300" height="287"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Collaboration diagram for hydra::GenzMalikRule&lt; DIM, BACKEND &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classhydra_1_1GenzMalikRule__coll__graph.svg" width="162" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a name="classhydra_1_1LogLikelihoodFCN" id="classhydra_1_1LogLikelihoodFCN"></a>
<h2 class="memtitle"><span class="permalink"><a href="#classhydra_1_1LogLikelihoodFCN">&#9670;&nbsp;</a></span>hydra::LogLikelihoodFCN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class hydra::LogLikelihoodFCN</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename PDF, typename Iterator, typename... Extensions&gt;<br />
class hydra::LogLikelihoodFCN&lt; PDF, Iterator, Extensions &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::LogLikelihoodFCN&lt; PDF, Iterator, Extensions &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classhydra_1_1LogLikelihoodFCN__coll__graph.svg" width="203" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a name="classhydra_1_1multiarray" id="classhydra_1_1multiarray"></a>
<h2 class="memtitle"><span class="permalink"><a href="#classhydra_1_1multiarray">&#9670;&nbsp;</a></span>hydra::multiarray</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class hydra::multiarray</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename T, size_t N, typename BACKEND&gt;<br />
class hydra::multiarray&lt; T, N, BACKEND &gt;</h3>

<dl><dt><b>Examples: </b></dt><dd><a class="el" href="multiarray_container_8inl-example.html#_a6">multiarray_container.inl</a>, <a class="el" href="pseudo_experiment_8inl-example.html#_a31">pseudo_experiment.inl</a>, <a class="el" href="sample_distribution_8inl-example.html#_a13">sample_distribution.inl</a>, and <a class="el" href="splot_8inl-example.html#_a42">splot.inl</a>.</dd>
</dl></div><div class="dynheader">
Inheritance diagram for hydra::multiarray&lt; T, N, BACKEND &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classhydra_1_1multiarray__inherit__graph.svg" width="246" height="287"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Collaboration diagram for hydra::multiarray&lt; T, N, BACKEND &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classhydra_1_1multiarray__coll__graph.svg" width="147" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a name="classhydra_1_1multivector" id="classhydra_1_1multivector"></a>
<h2 class="memtitle"><span class="permalink"><a href="#classhydra_1_1multivector">&#9670;&nbsp;</a></span>hydra::multivector</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class hydra::multivector</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename T, typename BACKEND&gt;<br />
class hydra::multivector&lt; T, BACKEND &gt;</h3>

<dl><dt><b>Examples: </b></dt><dd><a class="el" href="dense_histogram_8inl-example.html#_a12">dense_histogram.inl</a>, <a class="el" href="multidimensional_fit_8inl-example.html#_a38">multidimensional_fit.inl</a>, <a class="el" href="multivector_container_8inl-example.html#_a6">multivector_container.inl</a>, <a class="el" href="phsp_chain_8inl-example.html#_a24">phsp_chain.inl</a>, <a class="el" href="pseudo_experiment_8inl-example.html#_a24">pseudo_experiment.inl</a>, <a class="el" href="range_semantics_8inl-example.html#_a8">range_semantics.inl</a>, and <a class="el" href="splot_8inl-example.html#_a26">splot.inl</a>.</dd>
</dl></div><div class="dynheader">
Inheritance diagram for hydra::multivector&lt; T, BACKEND &gt;:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="classhydra_1_1multivector__inherit__graph.svg" width="100%" height="537"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</div>
<div class="dynheader">
Collaboration diagram for hydra::multivector&lt; T, BACKEND &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classhydra_1_1multivector__coll__graph.svg" width="138" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a name="structhydra_1_1null__type" id="structhydra_1_1null__type"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1null__type">&#9670;&nbsp;</a></span>hydra::null_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::null_type</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"></div><div class="dynheader">
Collaboration diagram for hydra::null_type:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1null__type__coll__graph.svg" width="126" height="88"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a name="structhydra_1_1Plain" id="structhydra_1_1Plain"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1Plain">&#9670;&nbsp;</a></span>hydra::Plain</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::Plain</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;size_t N, typename BACKEND, typename GRND = hydra::default_random_engine&gt;<br />
struct hydra::Plain&lt; N, BACKEND, GRND &gt;</h3>

<dl><dt><b>Examples: </b></dt><dd><a class="el" href="multidimensional_fit_8inl-example.html#_a34">multidimensional_fit.inl</a>, and <a class="el" href="plain_mc_8inl-example.html#_a13">plain_mc.inl</a>.</dd>
</dl></div><div class="dynheader">
Collaboration diagram for hydra::Plain&lt; N, BACKEND, GRND &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1Plain__coll__graph.svg" width="202" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a name="classhydra_1_1Range" id="classhydra_1_1Range"></a>
<h2 class="memtitle"><span class="permalink"><a href="#classhydra_1_1Range">&#9670;&nbsp;</a></span>hydra::Range</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class hydra::Range</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename ... T&gt;<br />
class hydra::Range&lt; T &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::Range&lt; T &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classhydra_1_1Range__coll__graph.svg" width="143" height="88"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a name="classhydra_1_1ScopedBuffer" id="classhydra_1_1ScopedBuffer"></a>
<h2 class="memtitle"><span class="permalink"><a href="#classhydra_1_1ScopedBuffer">&#9670;&nbsp;</a></span>hydra::ScopedBuffer</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class hydra::ScopedBuffer</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename T, typename BACKEND&gt;<br />
class hydra::ScopedBuffer&lt; T, BACKEND &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::ScopedBuffer&lt; T, BACKEND &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classhydra_1_1ScopedBuffer__coll__graph.svg" width="152" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a name="classhydra_1_1Vegas" id="classhydra_1_1Vegas"></a>
<h2 class="memtitle"><span class="permalink"><a href="#classhydra_1_1Vegas">&#9670;&nbsp;</a></span>hydra::Vegas</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class hydra::Vegas</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;size_t N, typename BACKEND, typename GRND = hydra::default_random_engine&gt;<br />
class hydra::Vegas&lt; N, BACKEND, GRND &gt;</h3>

<dl><dt><b>Examples: </b></dt><dd><a class="el" href="vegas_8inl-example.html#_a13">vegas.inl</a>.</dd>
</dl></div><div class="dynheader">
Collaboration diagram for hydra::Vegas&lt; N, BACKEND, GRND &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classhydra_1_1Vegas__coll__graph.svg" width="210" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a2d2c6b5545615d4ad77efa8cd3d190f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d2c6b5545615d4ad77efa8cd3d190f8">&#9670;&nbsp;</a></span>ars</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacehydra.html#a2d2c6b5545615d4ad77efa8cd3d190f8">hydra::ars</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ars uses the crypotgraphic AES round function, but a <b>non-cryptographc</b> key schedule to save time and space. </p>

</div>
</div>
<a id="a9d2c06cb9672fe86dbeaa65e8f35a2bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d2c06cb9672fe86dbeaa65e8f35a2bf">&#9670;&nbsp;</a></span>complex</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacehydra.html#a9d2c06cb9672fe86dbeaa65e8f35a2bf">hydra::complex</a> = typedef hydra::thrust::complex&lt;T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1e747e9ec41024e3efe0349f8ac10062"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e747e9ec41024e3efe0349f8ac10062">&#9670;&nbsp;</a></span>default_random_engine</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacehydra.html#a1e747e9ec41024e3efe0349f8ac10062">hydra::default_random_engine</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An implementation-defined "default" random number engine. </p>
<dl class="section note"><dt>Note</dt><dd><code>default_random_engine</code> is currently an alias for <code><a class="el" href="classhydra_1_1random_1_1squares3.html">hydra::random::squares3</a></code>, and may change in a future version. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="basic_distributions_8inl-example.html#a45">basic_distributions.inl</a>, and <a class="el" href="fill_basic_distributions_8inl-example.html#a44">fill_basic_distributions.inl</a>.</dd>
</dl>
</div>
</div>
<a id="ad614c0d4d1799d691f39110ece55090c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad614c0d4d1799d691f39110ece55090c">&#9670;&nbsp;</a></span>default_sobol_table</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structhydra_1_1detail_1_1SobolTable.html">detail::SobolTable</a> <a class="el" href="namespacehydra.html#ad614c0d4d1799d691f39110ece55090c">hydra::default_sobol_table</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa8c251ed5017d0638da929130062bcad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8c251ed5017d0638da929130062bcad">&#9670;&nbsp;</a></span>GBool_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef bool <a class="el" href="namespacehydra.html#aa8c251ed5017d0638da929130062bcad">hydra::GBool_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Boolean (0=false, 1=true) (bool) </p>

</div>
</div>
<a id="ae2da2ab0037e6bca3cb7c15adc5c4125"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2da2ab0037e6bca3cb7c15adc5c4125">&#9670;&nbsp;</a></span>GByte_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="namespace_3globalScope_4.html#classunsigned">unsigned</a> char <a class="el" href="namespacehydra.html#ae2da2ab0037e6bca3cb7c15adc5c4125">hydra::GByte_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Byte (8 bits) (unsigned char) </p>

</div>
</div>
<a id="a7ab04a199389c4989174dc115507fa89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ab04a199389c4989174dc115507fa89">&#9670;&nbsp;</a></span>GChar_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef char <a class="el" href="namespacehydra.html#a7ab04a199389c4989174dc115507fa89">hydra::GChar_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signed Character 1 byte (char) </p>

</div>
</div>
<a id="af986267d40d932c5cbf0ae874a506f83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af986267d40d932c5cbf0ae874a506f83">&#9670;&nbsp;</a></span>GDouble_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> <a class="el" href="namespacehydra.html#af986267d40d932c5cbf0ae874a506f83">hydra::GDouble_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Double 8 bytes. </p>

</div>
</div>
<a id="a71bab7b854d7b3c3042fe47201b765eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71bab7b854d7b3c3042fe47201b765eb">&#9670;&nbsp;</a></span>GFloat_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef float <a class="el" href="namespacehydra.html#a71bab7b854d7b3c3042fe47201b765eb">hydra::GFloat_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Float 4 bytes (float) </p>

</div>
</div>
<a id="a0c9fb4d7195ab952da10a82d5c4ad30e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c9fb4d7195ab952da10a82d5c4ad30e">&#9670;&nbsp;</a></span>GInt_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="namespace_3globalScope_4.html#classint">int</a> <a class="el" href="namespacehydra.html#a0c9fb4d7195ab952da10a82d5c4ad30e">hydra::GInt_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signed integer 4 bytes (int) </p>

</div>
</div>
<a id="a9d68c21fb715bbfb1edc5b1933b173e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d68c21fb715bbfb1edc5b1933b173e9">&#9670;&nbsp;</a></span>GLong64_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef long long <a class="el" href="namespacehydra.html#a9d68c21fb715bbfb1edc5b1933b173e9">hydra::GLong64_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Portable signed long integer 8 bytes. </p>

</div>
</div>
<a id="a5f57a4025b40929c2708cd544c3a1ccd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f57a4025b40929c2708cd544c3a1ccd">&#9670;&nbsp;</a></span>GLong_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef long <a class="el" href="namespacehydra.html#a5f57a4025b40929c2708cd544c3a1ccd">hydra::GLong_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signed long integer 4 bytes (long) </p>

</div>
</div>
<a id="a751abe69b482cde879c718fd4775733f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a751abe69b482cde879c718fd4775733f">&#9670;&nbsp;</a></span>GLongDouble_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef long <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> <a class="el" href="namespacehydra.html#a751abe69b482cde879c718fd4775733f">hydra::GLongDouble_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Long Double. </p>

</div>
</div>
<a id="a971e94bcb8c43741d11f9d8eb98f5fab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a971e94bcb8c43741d11f9d8eb98f5fab">&#9670;&nbsp;</a></span>GReal_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> <a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">hydra::GReal_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Double 16 bytes or float 4 bytes. </p>

</div>
</div>
<a id="a589c60d92ba893c28d814edd6e149a9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a589c60d92ba893c28d814edd6e149a9c">&#9670;&nbsp;</a></span>GShort_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef short <a class="el" href="namespacehydra.html#a589c60d92ba893c28d814edd6e149a9c">hydra::GShort_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signed Short integer 2 bytes (short) </p>

</div>
</div>
<a id="abc842c1ec8321e9637dee714dcdaebff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc842c1ec8321e9637dee714dcdaebff">&#9670;&nbsp;</a></span>GText_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef char <a class="el" href="namespacehydra.html#abc842c1ec8321e9637dee714dcdaebff">hydra::GText_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>General string (char) </p>

</div>
</div>
<a id="a51ef97faee95aa79f3839eb7abdf5238"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51ef97faee95aa79f3839eb7abdf5238">&#9670;&nbsp;</a></span>GUChar_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="namespace_3globalScope_4.html#classunsigned">unsigned</a> char <a class="el" href="namespacehydra.html#a51ef97faee95aa79f3839eb7abdf5238">hydra::GUChar_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unsigned Character 1 byte (unsigned char) </p>

</div>
</div>
<a id="a251a7b1f515ac1ed9409afd67252a32b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a251a7b1f515ac1ed9409afd67252a32b">&#9670;&nbsp;</a></span>GUInt_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="namespace_3globalScope_4.html#classunsigned">unsigned</a> <a class="el" href="namespace_3globalScope_4.html#classint">int</a> <a class="el" href="namespacehydra.html#a251a7b1f515ac1ed9409afd67252a32b">hydra::GUInt_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unsigned integer 4 bytes (unsigned int) </p>

</div>
</div>
<a id="a55e8443cd746900da90cb1f77807e7c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55e8443cd746900da90cb1f77807e7c0">&#9670;&nbsp;</a></span>GULong64_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="namespace_3globalScope_4.html#classunsigned">unsigned</a> long long <a class="el" href="namespacehydra.html#a55e8443cd746900da90cb1f77807e7c0">hydra::GULong64_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Portable unsigned long integer 8 bytes. </p>

</div>
</div>
<a id="abf9a0d54fd4ed46052939549edd086c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf9a0d54fd4ed46052939549edd086c5">&#9670;&nbsp;</a></span>GULong_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="namespace_3globalScope_4.html#classunsigned">unsigned</a> long <a class="el" href="namespacehydra.html#abf9a0d54fd4ed46052939549edd086c5">hydra::GULong_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a911a3042526fac189d0c87a089f52955"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a911a3042526fac189d0c87a089f52955">&#9670;&nbsp;</a></span>GUShort_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="namespace_3globalScope_4.html#classunsigned">unsigned</a> short <a class="el" href="namespacehydra.html#a911a3042526fac189d0c87a089f52955">hydra::GUShort_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unsigned Short integer 2 bytes (unsigned short) </p>

</div>
</div>
<a id="adaf935e1b294f95c8bde7769a0e60468"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adaf935e1b294f95c8bde7769a0e60468">&#9670;&nbsp;</a></span>mc_device_vector</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacehydra.html#adaf935e1b294f95c8bde7769a0e60468">hydra::mc_device_vector</a> = typedef hydra::thrust::device_vector&lt;T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generic template typedef for hydra::thrust::host_vector. </p>
<p>Use it instead of Thrust implementation in order to avoid problems to compile OpenMP based applications using gcc and without a cuda runtime installation. </p>

</div>
</div>
<a id="a7f1cb44a968c99a7fae4678eff452b12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f1cb44a968c99a7fae4678eff452b12">&#9670;&nbsp;</a></span>mc_host_vector</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacehydra.html#a7f1cb44a968c99a7fae4678eff452b12">hydra::mc_host_vector</a> = typedef hydra::thrust::host_vector&lt;T, hydra::thrust::system::cuda::experimental::pinned_allocator&lt;T&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generic template typedef for hydra::thrust::host_vector. </p>
<p>Use it instead of Thrust implementation in order to avoid problems to compile OpenMP based applications using gcc and without a cuda runtime installation. mc_host_vectot will always allocate page locked memory on CUDA backends in order to maximize speed in memory transfers to the device. </p>

</div>
</div>
<a id="aeccdd58e3a4c27246dadd0930e3fb569"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeccdd58e3a4c27246dadd0930e3fb569">&#9670;&nbsp;</a></span>minstd_rand</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacehydra.html#aeccdd58e3a4c27246dadd0930e3fb569">hydra::minstd_rand</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A random number engine with predefined parameters which implements a version of the Minimal Standard random number generation algorithm. </p>
<dl class="section note"><dt>Note</dt><dd>The 10000th consecutive invocation of a default-constructed object of type <code>minstd_rand</code> shall produce the value <code>399268537</code> . </dd></dl>

</div>
</div>
<a id="ab7c3603cf7a6c467176d8be9dd2c82fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7c3603cf7a6c467176d8be9dd2c82fd">&#9670;&nbsp;</a></span>minstd_rand0</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacehydra.html#ab7c3603cf7a6c467176d8be9dd2c82fd">hydra::minstd_rand0</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A random number engine with predefined parameters which implements a version of the Minimal Standard random number generation algorithm. </p>
<dl class="section note"><dt>Note</dt><dd>The 10000th consecutive invocation of a default-constructed object of type <code>minstd_rand0</code> shall produce the value <code>1043618065</code> . </dd></dl>

</div>
</div>
<a id="a1f40581ef3c81ef08844d3beb59842f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f40581ef3c81ef08844d3beb59842f7">&#9670;&nbsp;</a></span>pair</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacehydra.html#a1f40581ef3c81ef08844d3beb59842f7">hydra::pair</a> = typedef hydra::thrust::pair&lt;T1,T2&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>pair</code> template is an alias to the hydra::thrust::pair structure. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>The type of <code>pair's</code> first object type. There are no requirements on the type of <code>T1</code>. <code>T1</code>'s type is provided by <code>pair::first_type</code>.</td></tr>
    <tr><td class="paramname">T2</td><td>The type of <code>pair's</code> second object type. There are no requirements on the type of <code>T2</code>. <code>T2</code>'s type is provided by <code>pair::second_type</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad1501ab96b6a1b76d1f6a1bdd63efd5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1501ab96b6a1b76d1f6a1bdd63efd5d">&#9670;&nbsp;</a></span>philox</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacehydra.html#ad1501ab96b6a1b76d1f6a1bdd63efd5d">hydra::philox</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The Philox family of counter-based RNGs use integer multiplication, xor and permutation of W-bit words to scramble its N-word input key. </p>
<p>Philox is a mnemonic for Product HI LO Xor). This generator has a period of 2^128</p>
<p>Philox is a mnemonic for Product HI LO Xor). This generator has a period of 2^256 </p>

</div>
</div>
<a id="a45b538d4a1c53d043ba20318da7bbcff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45b538d4a1c53d043ba20318da7bbcff">&#9670;&nbsp;</a></span>philox_long</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="namespacehydra_1_1random.html#a983737b2c7216258a407aec6a65705c6">hydra::random::philox_long</a> <a class="el" href="namespacehydra.html#a45b538d4a1c53d043ba20318da7bbcff">hydra::philox_long</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a943a0571fdadbbb4bc9b17ba7ae4b59b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a943a0571fdadbbb4bc9b17ba7ae4b59b">&#9670;&nbsp;</a></span>ranlux24</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacehydra.html#a943a0571fdadbbb4bc9b17ba7ae4b59b">hydra::ranlux24</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A random number engine with predefined parameters which implements the RANLUX level-3 random number generation algorithm. </p>
<dl class="section note"><dt>Note</dt><dd>The 10000th consecutive invocation of a default-constructed object of type <code>ranlux24</code> shall produce the value <code>9901578</code> . </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="pseudo_experiment_8inl-example.html#a27">pseudo_experiment.inl</a>.</dd>
</dl>
</div>
</div>
<a id="a6950c5abef4e2015f833501684940b5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6950c5abef4e2015f833501684940b5d">&#9670;&nbsp;</a></span>ranlux48</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacehydra.html#a6950c5abef4e2015f833501684940b5d">hydra::ranlux48</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A random number engine with predefined parameters which implements the RANLUX level-4 random number generation algorithm. </p>
<dl class="section note"><dt>Note</dt><dd>The 10000th consecutive invocation of a default-constructed object of type <code>ranlux48</code> shall produce the value <code>88229545517833</code> . </dd></dl>

</div>
</div>
<a id="a27378ecbb012326012d334cf11431549"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27378ecbb012326012d334cf11431549">&#9670;&nbsp;</a></span>sobol</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned D&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacehydra.html#a27378ecbb012326012d334cf11431549">hydra::sobol</a> = typedef <a class="el" href="classhydra_1_1sobol__engine.html">sobol_engine</a>&lt;uint_least64_t, <a class="el" href="basic__distributions_8inl.html#a6f9cfa21f3993da1ed1a77acbc9bd9be">D</a>, 64u, default_sobol_table&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section attention"><dt>Attention</dt><dd>This specialization of  supports up to 3667 dimensions.</dd></dl>
<p>Data on the primitive binary polynomials <code>a</code> and the corresponding starting values <code>m</code> for Sobol sequences in up to 21201 dimensions was taken from</p>
<p>S. Joe and F. Y. Kuo, Constructing Sobol sequences with better two-dimensional projections, SIAM J. Sci. Comput. 30, 2635-2654 (2008). </p>
<p>See the original tables up to dimension 21201: <a href="https://web.archive.org/web/20170802022909/http://web.maths.unsw.edu.au/~fkuo/sobol/new-joe-kuo-6.21201">https://web.archive.org/web/20170802022909/http://web.maths.unsw.edu.au/~fkuo/sobol/new-joe-kuo-6.21201</a></p>
<p>For practical reasons the default table uses only the subset of binary polynomials <code>a</code> &lt; 2<sup>16</sup>.</p>
<p>However, it is possible to provide your own table to  should the default one be insufficient. </p>

</div>
</div>
<a id="aa0465592a7919d064d2cdb934f6eedce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0465592a7919d064d2cdb934f6eedce">&#9670;&nbsp;</a></span>squares3</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacehydra.html#aa0465592a7919d064d2cdb934f6eedce">hydra::squares3</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ars uses the crypotgraphic AES round function, but a <b>non-cryptographc</b> key schedule to save time and space. </p>

</div>
</div>
<a id="aa99a8402f27d47792099e50efce10c6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa99a8402f27d47792099e50efce10c6a">&#9670;&nbsp;</a></span>squares4</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacehydra.html#aa99a8402f27d47792099e50efce10c6a">hydra::squares4</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ars uses the crypotgraphic AES round function, but a <b>non-cryptographc</b> key schedule to save time and space. </p>

</div>
</div>
<a id="a2633cfe1492c02cfb2aef6a79804f191"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2633cfe1492c02cfb2aef6a79804f191">&#9670;&nbsp;</a></span>taus88</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacehydra.html#a2633cfe1492c02cfb2aef6a79804f191">hydra::taus88</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A random number engine with predefined parameters which implements L'Ecuyer's 1996 three-component Tausworthe random number generator. </p>
<dl class="section note"><dt>Note</dt><dd>The 10000th consecutive invocation of a default-constructed object of type <code>taus88</code> shall produce the value <code>3535848941</code> . </dd></dl>

</div>
</div>
<a id="a211bb34d13be9d9796acd4b9c3303dae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a211bb34d13be9d9796acd4b9c3303dae">&#9670;&nbsp;</a></span>threefry</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacehydra.html#a211bb34d13be9d9796acd4b9c3303dae">hydra::threefry</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Threefry uses integer addition, bitwise rotation, xor and permutation of words to randomize its output. </p>
<p>This generator has a period of 2^128 </p>

</div>
</div>
<a id="ad1cbf60d1726087cc7968bab8aabf7a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1cbf60d1726087cc7968bab8aabf7a4">&#9670;&nbsp;</a></span>threefry_long</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacehydra.html#ad1cbf60d1726087cc7968bab8aabf7a4">hydra::threefry_long</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Threefry uses integer addition, bitwise rotation, xor and permutation of words to randomize its output. </p>
<p>This generator has a period of 2^256 </p>

</div>
</div>
<a id="ac3486502b2db72187626125cea971683"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3486502b2db72187626125cea971683">&#9670;&nbsp;</a></span>tuple</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacehydra.html#ac3486502b2db72187626125cea971683">hydra::tuple</a> = typedef hydra::thrust::tuple&lt;T...&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>tuple</code> template is an alias to the variadic version of hydra::thrust::tuple and that can be instantiated with a indefinite number of arguments. </p>
<p>Each template argument specifies the type of element in the <code>tuple</code>. Consequently, tuples are heterogeneous, fixed-size collections of values. An instantiation of <code>tuple</code> with two arguments is similar to an instantiation of <code>pair</code> with the same two arguments. Individual elements of a <code>tuple</code> may be accessed with the <code>get</code> function.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TN</td><td>The type of the <code>N</code> <code>tuple</code> element.</td></tr>
  </table>
  </dd>
</dl>
<p>The following code snippet demonstrates how to create a new <code>tuple</code> object and inspect and modify the value of its elements.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;hydra/tuple.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line">...</div><div class="line"><span class="comment">// create a tuple containing an int, a float, and a string</span></div><div class="line">hydra::tuple&lt;<a class="code" href="namespace_3globalScope_4.html#classint">int</a>, float, <span class="keyword">const</span> <span class="keywordtype">char</span>*&gt; t(13, 0.1f, <span class="stringliteral">&quot;hydra&quot;</span>);</div><div class="line"></div><div class="line"><span class="comment">// individual members are accessed with the free function get</span></div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;The first element&#39;s value is &quot;</span> &lt;&lt; hydra::get&lt;0&gt;(t) &lt;&lt; std::endl;</div><div class="line"></div><div class="line"><span class="comment">// or the member function get</span></div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;The second element&#39;s value is &quot;</span> &lt;&lt; t.get&lt;1&gt;() &lt;&lt; std::endl;</div><div class="line"></div><div class="line"><span class="comment">// we can also modify elements with the same function</span></div><div class="line">hydra::get&lt;0&gt;(t) += 10;</div></div><!-- fragment --> 
</div>
</div>
<a id="ab09551bcd98d1cd273b2001cdcc33b9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab09551bcd98d1cd273b2001cdcc33b9c">&#9670;&nbsp;</a></span>tuple_element</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N, class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacehydra.html#ab09551bcd98d1cd273b2001cdcc33b9c">hydra::tuple_element</a> = typedef hydra::thrust::tuple_element&lt;N,T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The <code>get</code> function returns a <code>const</code> reference to a <code>tuple</code> element of interest. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>A reference to a <code>tuple</code> of interest. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>const</code> reference to <code>t's</code> <code>N</code>th element.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">N</td><td>The index of the element of interest.</td></tr>
  </table>
  </dd>
</dl>
<p>The following code snippet demonstrates how to use <code>get</code> to print the value of a <code>tuple</code> element.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="Tuple_8h.html">hydra/Tuple.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line">...</div><div class="line">hydra::tuple&lt;<a class="code" href="namespace_3globalScope_4.html#classint">int</a>, <span class="keyword">const</span> <span class="keywordtype">char</span> *&gt; t(13, <span class="stringliteral">&quot;hydra&quot;</span>);</div><div class="line"></div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;The 1st value of t is &quot;</span> &lt;&lt; hydra::get&lt;0&gt;(t) &lt;&lt; std::endl;</div></div><!-- fragment --><p>This metafunction returns the type of a <code>tuple's</code> <code>N</code>th element.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">N</td><td>This parameter selects the element of interest. </td></tr>
    <tr><td class="paramname">T</td><td>A <code>tuple</code> type of interest. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a58298133d4826dc6f35253762a7d6788"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58298133d4826dc6f35253762a7d6788">&#9670;&nbsp;</a></span>tuple_size</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacehydra.html#a58298133d4826dc6f35253762a7d6788">hydra::tuple_size</a> = typedef hydra::thrust::tuple_size&lt;T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This metafunction returns the number of elements of a <code>tuple</code> type of interest. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>A <code>tuple</code> type of interest. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a798d2fe7cacd6711fb3c975052992398"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a798d2fe7cacd6711fb3c975052992398">&#9670;&nbsp;</a></span>anonymous enum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a798d2fe7cacd6711fb3c975052992398aae772e8b4c5ada0e1e4c65495702176a"></a>MODE_IMPORTANCE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a798d2fe7cacd6711fb3c975052992398a28550661921a3af1306fa74a26b8569c"></a>MODE_IMPORTANCE_ONLY&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a798d2fe7cacd6711fb3c975052992398acb2c0124fecbf6c1182f1cf7cd9bc37a"></a>MODE_STRATIFIED&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a798d2fe7cacd6711fb3c975052992398aba2629d0445cc7ef401fd6793f047da0"></a>BINS_MAX&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a1107488f838687e73b39ddd8245f40d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1107488f838687e73b39ddd8245f40d0">&#9670;&nbsp;</a></span>anonymous enum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a1107488f838687e73b39ddd8245f40d0a4517ec382985cb7a39393c0da09e58d5"></a>INFO&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1107488f838687e73b39ddd8245f40d0a1bf857a06d5b8463494a6fcac6f4ea26"></a>WARNING&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1107488f838687e73b39ddd8245f40d0adbc96f88184ea3a51f68df95e2b44851"></a>ERROR&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a5e095cca28f6bec603156fd48914aefe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e095cca28f6bec603156fd48914aefe">&#9670;&nbsp;</a></span>abs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> T hydra::abs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#a9d2c06cb9672fe86dbeaa65e8f35a2bf">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a256097a85b1ce0eafa6e497f46d87383"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a256097a85b1ce0eafa6e497f46d87383">&#9670;&nbsp;</a></span>acos()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespacehydra.html#a9d2c06cb9672fe86dbeaa65e8f35a2bf">complex</a>&lt;T&gt; hydra::acos </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#a9d2c06cb9672fe86dbeaa65e8f35a2bf">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aec91f5ec5ff214023b38f72ec4ac1e76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec91f5ec5ff214023b38f72ec4ac1e76">&#9670;&nbsp;</a></span>acosh()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespacehydra.html#a9d2c06cb9672fe86dbeaa65e8f35a2bf">complex</a>&lt;T&gt; hydra::acosh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#a9d2c06cb9672fe86dbeaa65e8f35a2bf">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae96191cbaa62c58f63b7e58924362c24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae96191cbaa62c58f63b7e58924362c24">&#9670;&nbsp;</a></span>arg()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> T hydra::arg </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#a9d2c06cb9672fe86dbeaa65e8f35a2bf">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9a7e65b9bb4aca1f24356f2d43f91bda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a7e65b9bb4aca1f24356f2d43f91bda">&#9670;&nbsp;</a></span>asin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespacehydra.html#a9d2c06cb9672fe86dbeaa65e8f35a2bf">complex</a>&lt;T&gt; hydra::asin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#a9d2c06cb9672fe86dbeaa65e8f35a2bf">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abd779382ac3242158686664a9a3ca3a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd779382ac3242158686664a9a3ca3a0">&#9670;&nbsp;</a></span>asinh()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespacehydra.html#a9d2c06cb9672fe86dbeaa65e8f35a2bf">complex</a>&lt;T&gt; hydra::asinh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#a9d2c06cb9672fe86dbeaa65e8f35a2bf">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9772b7e92ecdf60524cde428c1670bd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9772b7e92ecdf60524cde428c1670bd4">&#9670;&nbsp;</a></span>atan()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespacehydra.html#a9d2c06cb9672fe86dbeaa65e8f35a2bf">complex</a>&lt;T&gt; hydra::atan </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#a9d2c06cb9672fe86dbeaa65e8f35a2bf">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a24b7bc13880335fdf6964df5034ade29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24b7bc13880335fdf6964df5034ade29">&#9670;&nbsp;</a></span>atanh()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespacehydra.html#a9d2c06cb9672fe86dbeaa65e8f35a2bf">complex</a>&lt;T&gt; hydra::atanh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#a9d2c06cb9672fe86dbeaa65e8f35a2bf">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a03f4e98f986e55037e1a01fe4d9b8fc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03f4e98f986e55037e1a01fe4d9b8fc8">&#9670;&nbsp;</a></span>BarrierFactor&lt; hydra::DWave &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> <a class="el" href="group__common__functions.html#gacd995d684b15024c891571fe47518404">hydra::BarrierFactor</a>&lt; <a class="el" href="group__common__functions.html#gga0dc858c0fb14ade1e8abc19cdd0959e2a74097dfe50b93307e587c23f9180b6b3">hydra::DWave</a> &gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td>
          <td class="paramname"><em>radi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td>
          <td class="paramname"><em>p0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac5a1e302e48427c947ab2084811df1df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5a1e302e48427c947ab2084811df1df">&#9670;&nbsp;</a></span>BarrierFactor&lt; hydra::FWave &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> <a class="el" href="group__common__functions.html#gacd995d684b15024c891571fe47518404">hydra::BarrierFactor</a>&lt; <a class="el" href="group__common__functions.html#gga0dc858c0fb14ade1e8abc19cdd0959e2a82415de987820fb86ab995f1dee87db1">hydra::FWave</a> &gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td>
          <td class="paramname"><em>radi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td>
          <td class="paramname"><em>p0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac0e0a9c294368d8d5b74fb919e261bef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0e0a9c294368d8d5b74fb919e261bef">&#9670;&nbsp;</a></span>BarrierFactor&lt; hydra::GWave &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> <a class="el" href="group__common__functions.html#gacd995d684b15024c891571fe47518404">hydra::BarrierFactor</a>&lt; <a class="el" href="group__common__functions.html#gga0dc858c0fb14ade1e8abc19cdd0959e2a113622b6b528bfd4a76d68e9a99ac032">hydra::GWave</a> &gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td>
          <td class="paramname"><em>radi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td>
          <td class="paramname"><em>p0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae223d417259cf7e660fd89a54438d45b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae223d417259cf7e660fd89a54438d45b">&#9670;&nbsp;</a></span>BarrierFactor&lt; hydra::HWave &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> <a class="el" href="group__common__functions.html#gacd995d684b15024c891571fe47518404">hydra::BarrierFactor</a>&lt; <a class="el" href="group__common__functions.html#gga0dc858c0fb14ade1e8abc19cdd0959e2af168d5a7a174aa70e881f13fdeaf4426">hydra::HWave</a> &gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td>
          <td class="paramname"><em>radi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td>
          <td class="paramname"><em>p0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa78649879f76b3b52249830df2482980"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa78649879f76b3b52249830df2482980">&#9670;&nbsp;</a></span>BarrierFactor&lt; hydra::PWave &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> <a class="el" href="group__common__functions.html#gacd995d684b15024c891571fe47518404">hydra::BarrierFactor</a>&lt; <a class="el" href="group__common__functions.html#gga0dc858c0fb14ade1e8abc19cdd0959e2ae382eaafad7afe6dee68693249ff8a45">hydra::PWave</a> &gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td>
          <td class="paramname"><em>radi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td>
          <td class="paramname"><em>p0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aab59597f876fc220d388f5911bb9822c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab59597f876fc220d388f5911bb9822c">&#9670;&nbsp;</a></span>BarrierFactor&lt; hydra::SWave &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> <a class="el" href="group__common__functions.html#gacd995d684b15024c891571fe47518404">hydra::BarrierFactor</a>&lt; <a class="el" href="group__common__functions.html#gga0dc858c0fb14ade1e8abc19cdd0959e2a4f4fc5545002d4eada7e2a14c27c5dfd">hydra::SWave</a> &gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab9d562f964ef193664077363da8859e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9d562f964ef193664077363da8859e2">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::begin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="basic__distributions_8inl.html#a4900ef306eb9271438791f1a98b8ccba">C</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td> -&gt;  decltype(c.begin())</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="multiarray_container_8inl-example.html#a7">multiarray_container.inl</a>.</dd>
</dl>
</div>
</div>
<a id="a7e149bee61e4ddabca7fa0aafa121fe1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e149bee61e4ddabca7fa0aafa121fe1">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::begin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="basic__distributions_8inl.html#a4900ef306eb9271438791f1a98b8ccba">C</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td> -&gt;  decltype(std::forward&lt; <a class="el" href="basic__distributions_8inl.html#a4900ef306eb9271438791f1a98b8ccba">C</a> &gt;(c).begin())</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6c64031cbdf1765fdf74577297ddb758"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c64031cbdf1765fdf74577297ddb758">&#9670;&nbsp;</a></span>begin() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T * hydra::begin </td>
          <td>(</td>
          <td class="paramtype">T(&amp;)&#160;</td>
          <td class="paramname"><em>array</em>[N]</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afd4f46840c85ee014f1d237601913ae1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd4f46840c85ee014f1d237601913ae1">&#9670;&nbsp;</a></span>begin() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename T , size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::begin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#classhydra_1_1multiarray">multiarray</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(other.begin(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt;I&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6483cec578e17112f07ba012a4dc50ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6483cec578e17112f07ba012a4dc50ed">&#9670;&nbsp;</a></span>begin() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename T , size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::begin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#classhydra_1_1multiarray">multiarray</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(other.begin(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt;I&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8f9aebde030525eb216e14815d87a16f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f9aebde030525eb216e14815d87a16f">&#9670;&nbsp;</a></span>begin() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::begin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; hydra::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> -&gt; decltype(other.begin(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt;I&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a13db31ab59bd6f8c2dc4bfcb0ce4fc1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13db31ab59bd6f8c2dc4bfcb0ce4fc1d">&#9670;&nbsp;</a></span>begin() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::begin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; hydra::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> -&gt; decltype(other.begin(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt;I&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0da471ad7818c9c8aa4c743360952240"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0da471ad7818c9c8aa4c743360952240">&#9670;&nbsp;</a></span>bessel_i()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> hydra::bessel_i </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_3globalScope_4.html#classint">int</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Modified Bessel function of first kind and order n. </p>

</div>
</div>
<a id="a863ac23066d7b53623db033ee1ac3ca8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a863ac23066d7b53623db033ee1ac3ca8">&#9670;&nbsp;</a></span>bessel_i0()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> hydra::bessel_i0 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Modified Bessel function of first kind and order 0. </p>

</div>
</div>
<a id="abd0944fc0cf328edf5747e1401144172"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd0944fc0cf328edf5747e1401144172">&#9670;&nbsp;</a></span>bessel_i1()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> hydra::bessel_i1 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Modified Bessel function of first kind and order 1. </p>

</div>
</div>
<a id="a28212504a23a89b5dd376831503d5b4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28212504a23a89b5dd376831503d5b4b">&#9670;&nbsp;</a></span>bessel_j()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> hydra::bessel_j </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_3globalScope_4.html#classint">int</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bessel function of first kind and order n. </p>

</div>
</div>
<a id="aa4de83802cdb05bd73882b760a777000"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4de83802cdb05bd73882b760a777000">&#9670;&nbsp;</a></span>bessel_j0()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> hydra::bessel_j0 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bessel function of first kind and order 0. </p>

</div>
</div>
<a id="aa49ac19ea37c518db0592dbaf9e6f9b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa49ac19ea37c518db0592dbaf9e6f9b2">&#9670;&nbsp;</a></span>bessel_j1()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> hydra::bessel_j1 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bessel function of first kind and order 1. </p>

</div>
</div>
<a id="a99c82254ed81e63682342ebb3b8a0a39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99c82254ed81e63682342ebb3b8a0a39">&#9670;&nbsp;</a></span>bessel_k()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> hydra::bessel_k </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_3globalScope_4.html#classint">int</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Modified Bessel function of second kind and order n. </p>

</div>
</div>
<a id="ae823549b0cbc2c65b52c780568d6149f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae823549b0cbc2c65b52c780568d6149f">&#9670;&nbsp;</a></span>bessel_k0()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> hydra::bessel_k0 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Modified Bessel function of second kind and order 0. </p>

</div>
</div>
<a id="aad12f1f40a1a2ea2d50b6fdc3630a60e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad12f1f40a1a2ea2d50b6fdc3630a60e">&#9670;&nbsp;</a></span>bessel_k1()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> hydra::bessel_k1 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Modified Bessel function of second kind and order 1. </p>

</div>
</div>
<a id="a050d42bcab45eeac4f9258ea328feb9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a050d42bcab45eeac4f9258ea328feb9e">&#9670;&nbsp;</a></span>bessel_y()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> hydra::bessel_y </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_3globalScope_4.html#classint">int</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bessel function of second kind and order n. </p>

</div>
</div>
<a id="a607169f1794b7262c178c13637daceae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a607169f1794b7262c178c13637daceae">&#9670;&nbsp;</a></span>bessel_y0()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> hydra::bessel_y0 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bessel function of second kind and order 0. </p>

</div>
</div>
<a id="a191a30b1209e25f34f98584dee43e067"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a191a30b1209e25f34f98584dee43e067">&#9670;&nbsp;</a></span>bessel_y1()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> hydra::bessel_y1 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bessel function of second kind and order 1. </p>

</div>
</div>
<a id="aabecf2c4fcb00adefa79bd93786ec18b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabecf2c4fcb00adefa79bd93786ec18b">&#9670;&nbsp;</a></span>boost_strapped_range()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterable &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;<a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt;Iterable&gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; hydra::thrust::permutation_iterator&lt;decltype(std::declval&lt;Iterable&amp;&gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()), hydra::thrust::transform_iterator&lt; <a class="el" href="structhydra_1_1detail_1_1RndUniform.html">detail::RndUniform</a>&lt;size_t, hydra::thrust::random::default_random_engine&gt; ,hydra::thrust::counting_iterator&lt;size_t&gt;,size_t &gt; &gt; &gt; &gt;::type hydra::boost_strapped_range </td>
          <td>(</td>
          <td class="paramtype">Iterable &amp;&amp;&#160;</td>
          <td class="paramname"><em>iterable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>seed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="booststrapping_8inl-example.html#a5">booststrapping.inl</a>, and <a class="el" href="pseudo_experiment_8inl-example.html#a32">pseudo_experiment.inl</a>.</dd>
</dl>
</div>
</div>
<a id="a39ca77c714b3e8b913c37d323cfd5640"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39ca77c714b3e8b913c37d323cfd5640">&#9670;&nbsp;</a></span>boostTo() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> Vector4R hydra::boostTo </td>
          <td>(</td>
          <td class="paramtype">const Vector4R &amp;&#160;</td>
          <td class="paramname"><em>rs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector4R &amp;&#160;</td>
          <td class="paramname"><em>p4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>inverse</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1c1de9e4fabdb747b9e3352ef6298476"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c1de9e4fabdb747b9e3352ef6298476">&#9670;&nbsp;</a></span>boostTo() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> Vector4R hydra::boostTo </td>
          <td>(</td>
          <td class="paramtype">const Vector4R &amp;&#160;</td>
          <td class="paramname"><em>rs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector3R &amp;&#160;</td>
          <td class="paramname"><em>boost</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>inverse</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa60325f68cb5ff194182e0fb67ce11d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa60325f68cb5ff194182e0fb67ce11d6">&#9670;&nbsp;</a></span>chebychev_1st_kind()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> hydra::chebychev_1st_kind </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_3globalScope_4.html#classunsigned">unsigned</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implementation of <a class="el" href="group__common__functions.html#classhydra_1_1Chebychev" title="The Chebyshev polynomials  (first kind) are polynomials with the largest possible leading coefficient...">Chebychev</a> polynomials of first kind \( P_n(n) \) using the recursive relation. </p>
<p class="formulaDsp">
\[P_{n+1}(x) = 2xP_n(x)-P_{n-1}(x) \]
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>order of the polynomial </td></tr>
    <tr><td class="paramname">x</td><td>argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a89c5073655dc6f793f63d7364e490fde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89c5073655dc6f793f63d7364e490fde">&#9670;&nbsp;</a></span>chebychev_2nd_kind()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> hydra::chebychev_2nd_kind </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_3globalScope_4.html#classunsigned">unsigned</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implementation of <a class="el" href="group__common__functions.html#classhydra_1_1Chebychev" title="The Chebyshev polynomials  (first kind) are polynomials with the largest possible leading coefficient...">Chebychev</a> polynomials of second kind \( P_n(n) \) using the recursive relation. </p>
<p class="formulaDsp">
\[ P_{n+1}(x) = 2xP_n(x) - P_{n-1}(x) \]
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>order of the polynomial </td></tr>
    <tr><td class="paramname">x</td><td>argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a58e3aa55839abeda676e6a8ede0902a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58e3aa55839abeda676e6a8ede0902a7">&#9670;&nbsp;</a></span>collect()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterable_Index , typename Iterable_Values &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::collect </td>
          <td>(</td>
          <td class="paramtype">Iterable_Index &amp;&#160;</td>
          <td class="paramname"><em>indexing_scheme</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterable_Values &amp;&#160;</td>
          <td class="paramname"><em>collected_values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; typename std::enable_if&lt;<a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt;Iterable_Index&gt;::value
					    &amp;&amp; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt;Iterable_Values&gt;::value,
<a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt;hydra::thrust::permutation_iterator&lt;
		decltype(std::declval&lt;Iterable_Values&amp;&gt;().<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()),
		decltype(std::declval&lt;Iterable_Index&amp;&gt;().<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>())&gt;
&gt;::type
</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aec19ef09aa95bbdb2230bd31d879b94d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec19ef09aa95bbdb2230bd31d879b94d">&#9670;&nbsp;</a></span>columns() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;hydra::detail::Backend BACKEND, typename T , size_t N, unsigned int... I&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::columns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#classhydra_1_1multiarray">multiarray</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt;const &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;...&#160;</td>
          <td class="paramname"><em>cls</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt;decltype(std::declval&lt;	<a class="el" href="namespacehydra.html#classhydra_1_1multiarray">multiarray</a>&lt;T,N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt;BACKEND&gt;&gt;const&amp;&gt;().<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt;I&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="pseudo_experiment_8inl-example.html#a35">pseudo_experiment.inl</a>, and <a class="el" href="range_semantics_8inl-example.html#a14">range_semantics.inl</a>.</dd>
</dl>
</div>
</div>
<a id="ac897e7fcbfbb068d5d29122253491201"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac897e7fcbfbb068d5d29122253491201">&#9670;&nbsp;</a></span>columns() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;hydra::detail::Backend BACKEND, typename T , size_t N, unsigned int... I&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::columns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#classhydra_1_1multiarray">multiarray</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;...&#160;</td>
          <td class="paramname"><em>cls</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt;decltype(std::declval&lt;<a class="el" href="namespacehydra.html#classhydra_1_1multiarray">multiarray</a>&lt;T,N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt;BACKEND&gt;&gt;&amp;&amp;&gt;().<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt;I&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5f66637e61ac9f1a4254b43131f3d450"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f66637e61ac9f1a4254b43131f3d450">&#9670;&nbsp;</a></span>columns() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;hydra::detail::Backend BACKEND, typename ... T, unsigned int... I&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::columns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; hydra::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt;&gt;const &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;...&#160;</td>
          <td class="paramname"><em>cls</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt;decltype(std::declval&lt;<a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt;hydra::thrust::tuple&lt;T...&gt;,
		<a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt;BACKEND&gt;&gt; const&amp;&gt;().<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt;I&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2f3ece26d764846bc2f62db61a01cc49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f3ece26d764846bc2f62db61a01cc49">&#9670;&nbsp;</a></span>columns() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;hydra::detail::Backend BACKEND, typename ... T, unsigned int... I&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::columns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; hydra::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;...&#160;</td>
          <td class="paramname"><em>cls</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt;decltype(std::declval&lt;<a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt;hydra::thrust::tuple&lt;T...&gt;,
		<a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt;BACKEND&gt;&gt;&amp;&gt;().<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt;I&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abb0c6c5638e245ee1fdb17b516b0a455"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb0c6c5638e245ee1fdb17b516b0a455">&#9670;&nbsp;</a></span>columns() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , hydra::detail::Backend BACKEND, typename ... T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::columns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; hydra::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> -&gt; <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt;decltype(
std::declval&lt;<a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt;hydra::thrust::tuple&lt;T...&gt;,
<a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt;BACKEND&gt;&gt;&amp;&gt;().<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>(
		<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt;<a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1index__in__tuple">detail::index_in_tuple</a>&lt;Type, hydra::thrust::tuple&lt;T...&gt; &gt;::value&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a86c018d960aacf7e0b79a20946aff059"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86c018d960aacf7e0b79a20946aff059">&#9670;&nbsp;</a></span>compose()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T0 , typename T1 , typename ... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;(<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt;T0&gt;::value || <a class="el" href="structhydra_1_1detail_1_1is__hydra__lambda.html">detail::is_hydra_lambda</a>&lt;T0&gt;::value ) &amp;&amp;(<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt;T1&gt;::value || <a class="el" href="structhydra_1_1detail_1_1is__hydra__lambda.html">detail::is_hydra_lambda</a>&lt;T1&gt;::value ) &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1all__true.html">detail::all_true</a>&lt;(<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt;Ts&gt;::value || <a class="el" href="structhydra_1_1detail_1_1is__hydra__lambda.html">detail::is_hydra_lambda</a>&lt;Ts&gt;::value )...&gt;::value,<a class="el" href="classhydra_1_1Compose.html">Compose</a>&lt;T0,T1,Ts...&gt; &gt;::type hydra::compose </td>
          <td>(</td>
          <td class="paramtype">T0 const &amp;&#160;</td>
          <td class="paramname"><em>F0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T1 const &amp;&#160;</td>
          <td class="paramname"><em>F1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ts const &amp;...&#160;</td>
          <td class="paramname"><em>Fs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="dalitz_plot_8C-example.html#a20">dalitz_plot.C</a>, and <a class="el" href="dalitz_plot_8inl-example.html#a21">dalitz_plot.inl</a>.</dd>
</dl>
</div>
</div>
<a id="ad2ffe3ace108474a31b8cb84ceae7f14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2ffe3ace108474a31b8cb84ceae7f14">&#9670;&nbsp;</a></span>conj()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespacehydra.html#a9d2c06cb9672fe86dbeaa65e8f35a2bf">complex</a>&lt;T&gt; hydra::conj </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#a9d2c06cb9672fe86dbeaa65e8f35a2bf">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4de27927128c4f574aa5d2d8715ab58c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4de27927128c4f574aa5d2d8715ab58c">&#9670;&nbsp;</a></span>constant_range()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt;hydra::thrust::constant_iterator&lt;Value_Type&gt; &gt; hydra::constant_range </td>
          <td>(</td>
          <td class="paramtype">const Value_Type &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ade5b435c4a37bbda1d67cd8fe18b526f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade5b435c4a37bbda1d67cd8fe18b526f">&#9670;&nbsp;</a></span>convolute()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;detail::Backend BACKEND, detail::FFTCalculator FFTBackend, typename Functor , typename Kernel , typename Iterable , typename T  = typename detail::stripped_type&lt;typename hydra::thrust::iterator_traits&lt;decltype(std::declval&lt;Iterable&gt;().begin())&gt;::value_type&gt;::type, typename USING_CUDA_BACKEND  = typename std::conditional&lt; std::is_convertible&lt;detail::BackendPolicy&lt;BACKEND&gt;,hydra::thrust::system::cuda::tag &gt;::value, std::integral_constant&lt;int, 1&gt;,std::integral_constant&lt;int, 0&gt;&gt;::type, typename USING_CUFFT  = typename std::conditional&lt; FFTBackend==detail::CuFFT, std::integral_constant&lt;int, 1&gt;,std::integral_constant&lt;int, 0&gt;&gt;::type, typename GPU_DATA  = typename std::conditional&lt; std::is_convertible&lt;typename hydra::thrust::iterator_system&lt; decltype(std::declval&lt;Iterable&gt;().begin())&gt;::type, hydra::thrust::system::cuda::tag&gt;::value , std::integral_constant&lt;int, 1&gt;, std::integral_constant&lt;int, 0&gt; &gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;std::is_floating_point&lt;T&gt;::value &amp;&amp; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt;Iterable&gt;::value ,void&gt;::type hydra::convolute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&#160;</td>
          <td class="paramname"><em>policy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1FFTPolicy">detail::FFTPolicy</a>&lt; T, FFTBackend &gt;&#160;</td>
          <td class="paramname"><em>fft_policy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Functor const &amp;&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Kernel const &amp;&#160;</td>
          <td class="paramname"><em>kernel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterable &amp;&amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>power_up</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="convolute_functions_8inl-example.html#a19">convolute_functions.inl</a>.</dd>
</dl>
</div>
</div>
<a id="a0b928198a46f83eb9d2793e8e079ba5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b928198a46f83eb9d2793e8e079ba5a">&#9670;&nbsp;</a></span>copy() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterable_Source , typename Iterable_Target &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;<a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt;Iterable_Source&gt;::value&amp;&amp; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt;Iterable_Target&gt;::value,<a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt;decltype(std::declval&lt;Iterable_Target&amp;&gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>())&gt; &gt;::type hydra::copy </td>
          <td>(</td>
          <td class="paramtype">Iterable_Source &amp;&amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterable_Target &amp;&amp;&#160;</td>
          <td class="paramname"><em>destination</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="basic_fit_8inl-example.html#a18">basic_fit.inl</a>, <a class="el" href="fill_basic_distributions_8inl-example.html#a47">fill_basic_distributions.inl</a>, <a class="el" href="fit_gaussian_8C-example.html#a15">fit_gaussian.C</a>, <a class="el" href="fit_johnson_8C-example.html#a12">fit_johnson.C</a>, <a class="el" href="phsp_chain_8inl-example.html#a25">phsp_chain.inl</a>, <a class="el" href="simultaneous_fit_8inl-example.html#a20">simultaneous_fit.inl</a>, and <a class="el" href="splot_8inl-example.html#a29">splot.inl</a>.</dd>
</dl>
</div>
</div>
<a id="a28aa8ffeea73bf98ccab0fb7cd1c8116"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28aa8ffeea73bf98ccab0fb7cd1c8116">&#9670;&nbsp;</a></span>copy() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator , typename OutputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator hydra::copy </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a98b97d9c4a1b0350ef7c2d646c8c504a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98b97d9c4a1b0350ef7c2d646c8c504a">&#9670;&nbsp;</a></span>copy() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;detail::Backend Backend, typename InputIterator , typename OutputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator hydra::copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; Backend &gt; const &amp;&#160;</td>
          <td class="paramname"><em>policy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a82497912f037617b630d048bfcc515c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82497912f037617b630d048bfcc515c0">&#9670;&nbsp;</a></span>cos()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespacehydra.html#a9d2c06cb9672fe86dbeaa65e8f35a2bf">complex</a>&lt;T&gt; hydra::cos </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#a9d2c06cb9672fe86dbeaa65e8f35a2bf">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="dalitz_plot_8C-example.html#a29">dalitz_plot.C</a>, and <a class="el" href="dalitz_plot_8inl-example.html#a32">dalitz_plot.inl</a>.</dd>
</dl>
</div>
</div>
<a id="ac9aa7456a15f61cd1ed2b5ef7227409e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9aa7456a15f61cd1ed2b5ef7227409e">&#9670;&nbsp;</a></span>cosh()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespacehydra.html#a9d2c06cb9672fe86dbeaa65e8f35a2bf">complex</a>&lt;T&gt; hydra::cosh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#a9d2c06cb9672fe86dbeaa65e8f35a2bf">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6d55d71b4eca1da2fac83a615ea4b990"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d55d71b4eca1da2fac83a615ea4b990">&#9670;&nbsp;</a></span>cross()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> Vector3R hydra::cross </td>
          <td>(</td>
          <td class="paramtype">const Vector3R &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector3R &amp;&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6f97451ec9f21c866bbe94c68c4b985e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f97451ec9f21c866bbe94c68c4b985e">&#9670;&nbsp;</a></span>distance()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> auto hydra::distance </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype( hydra::thrust::distance&lt;Iterator&gt;(first,last))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6afbe062f479abb939d72e60c387ff05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6afbe062f479abb939d72e60c387ff05">&#9670;&nbsp;</a></span>divide()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F1 , typename F2 , typename ... Fs&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;(<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt;F1&gt;::value || <a class="el" href="structhydra_1_1detail_1_1is__hydra__lambda.html">detail::is_hydra_lambda</a>&lt;F1&gt;::value ) &amp;&amp;(<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt;F2&gt;::value || <a class="el" href="structhydra_1_1detail_1_1is__hydra__lambda.html">detail::is_hydra_lambda</a>&lt;F2&gt;::value ),<a class="el" href="classhydra_1_1Divide.html">Divide</a>&lt;F1, F2&gt; &gt;::type hydra::divide </td>
          <td>(</td>
          <td class="paramtype">F1 const &amp;&#160;</td>
          <td class="paramname"><em>f1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F2 const &amp;&#160;</td>
          <td class="paramname"><em>f2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4274268d147e9a988f379326b73682b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4274268d147e9a988f379326b73682b0">&#9670;&nbsp;</a></span>end() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::end </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="basic__distributions_8inl.html#a4900ef306eb9271438791f1a98b8ccba">C</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td> -&gt;  decltype(c.end())</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="multiarray_container_8inl-example.html#a9">multiarray_container.inl</a>, <a class="el" href="phsp_averaging_functor_8inl-example.html#a21">phsp_averaging_functor.inl</a>, <a class="el" href="phsp_basic_8inl-example.html#a24">phsp_basic.inl</a>, <a class="el" href="phsp_chain_8inl-example.html#a22">phsp_chain.inl</a>, <a class="el" href="phsp_reweighting_8inl-example.html#a29">phsp_reweighting.inl</a>, <a class="el" href="phsp_unweighting_8inl-example.html#a24">phsp_unweighting.inl</a>, <a class="el" href="phsp_unweighting_functor_8inl-example.html#a29">phsp_unweighting_functor.inl</a>, <a class="el" href="plain_mc_8inl-example.html#a15">plain_mc.inl</a>, and <a class="el" href="pseudo_experiment_8inl-example.html#a42">pseudo_experiment.inl</a>.</dd>
</dl>
</div>
</div>
<a id="a1d1cd86c2f2c422730b87a5890dbaee3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d1cd86c2f2c422730b87a5890dbaee3">&#9670;&nbsp;</a></span>end() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="basic__distributions_8inl.html#a4900ef306eb9271438791f1a98b8ccba">C</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td> -&gt;  decltype(std::forward&lt; <a class="el" href="basic__distributions_8inl.html#a4900ef306eb9271438791f1a98b8ccba">C</a> &gt;(c).end())</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3e7ed93e81eae920f0c85fea012dc23c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e7ed93e81eae920f0c85fea012dc23c">&#9670;&nbsp;</a></span>end() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T * hydra::end </td>
          <td>(</td>
          <td class="paramtype">T(&amp;)&#160;</td>
          <td class="paramname"><em>array</em>[N]</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a03f64a7db637f2f1865093311d69f0bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03f64a7db637f2f1865093311d69f0bc">&#9670;&nbsp;</a></span>end() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename T , size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#classhydra_1_1multiarray">multiarray</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(other.end(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt;I&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab07ef1a981144fec2ec0227a346bedf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab07ef1a981144fec2ec0227a346bedf8">&#9670;&nbsp;</a></span>end() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename T , size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#classhydra_1_1multiarray">multiarray</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(other.end(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt;I&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a149ddb5e1cfb584bb8f0c680f6413917"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a149ddb5e1cfb584bb8f0c680f6413917">&#9670;&nbsp;</a></span>end() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; hydra::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> -&gt; decltype(other.end(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt;I&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3e410df30c5ed179d15ebab858960584"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e410df30c5ed179d15ebab858960584">&#9670;&nbsp;</a></span>end() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; hydra::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> -&gt; decltype(other.end(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt;I&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5a9d4c5b0ed8b81a1ddc80ac67189b6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a9d4c5b0ed8b81a1ddc80ac67189b6f">&#9670;&nbsp;</a></span>erfinv()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> long <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> hydra::erfinv </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5acb87c4eb594ddbf0c4322a11cf4d8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5acb87c4eb594ddbf0c4322a11cf4d8a">&#9670;&nbsp;</a></span>exp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespacehydra.html#a9d2c06cb9672fe86dbeaa65e8f35a2bf">complex</a>&lt;T&gt; hydra::exp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#a9d2c06cb9672fe86dbeaa65e8f35a2bf">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="basic_distributions_8inl-example.html#a19">basic_distributions.inl</a>, <a class="el" href="dense_histogram_8inl-example.html#a7">dense_histogram.inl</a>, <a class="el" href="fill_basic_distributions_8inl-example.html#a18">fill_basic_distributions.inl</a>, and <a class="el" href="plain_mc_8inl-example.html#a8">plain_mc.inl</a>.</dd>
</dl>
</div>
</div>
<a id="a9d88d9e0baa81e633c5eb3f455a57221"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d88d9e0baa81e633c5eb3f455a57221">&#9670;&nbsp;</a></span>fill_random() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Engine , hydra::detail::Backend BACKEND, typename Iterator , typename FUNCTOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1has__rng__formula.html">hydra::detail::has_rng_formula</a>&lt;FUNCTOR&gt;::value &amp;&amp; std::is_convertible&lt; decltype(std::declval&lt;<a class="el" href="classhydra_1_1RngFormula.html">RngFormula</a>&lt;FUNCTOR&gt; &gt;).<a class="el" href="phsp__unweighting_8inl.html#aae0754269ece74173f4afd72643b7e3e">Generate</a>( std::declval&lt;Engine&amp;&gt;), std::declval&lt;FUNCTOR const&amp;&gt;))), typename hydra::thrust::iterator_traits&lt;Iterator&gt;::value_type &gt;::value, void&gt;::type hydra::fill_random </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; const &amp;&#160;</td>
          <td class="paramname"><em>policy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FUNCTOR const &amp;&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>rng_jump</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fill a range with numbers distributed according a user defined distribution using a RNG analytical formula. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">policy</td><td>backend to perform the calculation. </td></tr>
    <tr><td class="paramname">begin</td><td>beginning of the range storing the generated values </td></tr>
    <tr><td class="paramname">end</td><td>ending of the range storing the generated values </td></tr>
    <tr><td class="paramname">functor</td><td>distribution to be sampled </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga64b2d1486052fdd0ecf8e48ef9cb89d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga64b2d1486052fdd0ecf8e48ef9cb89d6">&#9670;&nbsp;</a></span>fill_random() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Engine , typename Iterator , typename FUNCTOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1has__rng__formula.html">hydra::detail::has_rng_formula</a>&lt; FUNCTOR &gt;::value &amp;&amp;std::is_convertible&lt; decltype(std::declval&lt; <a class="el" href="classhydra_1_1RngFormula.html">RngFormula</a>&lt; FUNCTOR &gt; &gt;).<a class="el" href="phsp__unweighting_8inl.html#aae0754269ece74173f4afd72643b7e3e">Generate</a>(std::declval&lt; Engine &amp; &gt;), std::declval&lt; FUNCTOR const  &amp; &gt;))), typename hydra::thrust::iterator_traits&lt; Iterator &gt;::value_type &gt;::value, void &gt;::type hydra::fill_random </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FUNCTOR const &amp;&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>seed</em> = <code>0x254a0afcf7da74a2</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>rng_jump</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fill a range with numbers distributed according a user defined distribution using a RNG analytical formula. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>beginning of the range storing the generated values </td></tr>
    <tr><td class="paramname">end</td><td>ending of the range storing the generated values </td></tr>
    <tr><td class="paramname">functor</td><td>distribution to be sampled</td></tr>
    <tr><td class="paramname">begin</td><td>beginning of the range storing the generated values </td></tr>
    <tr><td class="paramname">end</td><td>ending of the range storing the generated values </td></tr>
    <tr><td class="paramname">functor</td><td>distribution to be sampled </td></tr>
    <tr><td class="paramname">max_pdf</td><td>maximum pdf value for accept-reject method. If no value is set, the maximum value in the sample is used. </td></tr>
    <tr><td class="paramname">rng_seed</td><td>seed for the underlying pseudo-random number generator </td></tr>
    <tr><td class="paramname">rng_jump</td><td>sequence offset for the underlying pseudo-random number generator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga108c406782cf2d5b6b5c71aa876178ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga108c406782cf2d5b6b5c71aa876178ba">&#9670;&nbsp;</a></span>fill_random() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Engine , hydra::detail::Backend BACKEND, typename Iterator , typename FUNCTOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; !std::is_convertible&lt; decltype(std::declval&lt; <a class="el" href="classhydra_1_1RngFormula.html">RngFormula</a>&lt; FUNCTOR &gt; &gt;).<a class="el" href="phsp__unweighting_8inl.html#aae0754269ece74173f4afd72643b7e3e">Generate</a>(std::declval&lt; Engine &amp; &gt;), std::declval&lt; FUNCTOR const  &amp; &gt;))), typename std::iterator_traits&lt; Iterator &gt;::value_type &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1has__rng__formula.html">hydra::detail::has_rng_formula</a>&lt; FUNCTOR &gt;::value, void &gt;::type hydra::fill_random </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; const &amp;&#160;</td>
          <td class="paramname"><em>policy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FUNCTOR const &amp;&#160;</td>
          <td class="paramname"><em>funct</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>seed</em> = <code>0x254a0afcf7da74a2</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>rng_jump</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fall back function if RngFormula::Generate() return value is not convertible to functor return value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">policy</td><td>backend to perform the calculation. </td></tr>
    <tr><td class="paramname">begin</td><td>beginning of the range storing the generated values </td></tr>
    <tr><td class="paramname">end</td><td>ending of the range storing the generated values </td></tr>
    <tr><td class="paramname">functor</td><td>distribution to be sampled </td></tr>
    <tr><td class="paramname">max_pdf</td><td>maximum pdf value for accept-reject method. If no value is set, the maximum value in the sample is used. </td></tr>
    <tr><td class="paramname">rng_seed</td><td>seed for the underlying pseudo-random number generator </td></tr>
    <tr><td class="paramname">rng_jump</td><td>sequence offset for the underlying pseudo-random number generator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga64b2d1486052fdd0ecf8e48ef9cb89d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga64b2d1486052fdd0ecf8e48ef9cb89d6">&#9670;&nbsp;</a></span>fill_random() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Engine , typename Iterator , typename FUNCTOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; !std::is_convertible&lt; decltype(std::declval&lt; <a class="el" href="classhydra_1_1RngFormula.html">RngFormula</a>&lt; FUNCTOR &gt; &gt;).<a class="el" href="phsp__unweighting_8inl.html#aae0754269ece74173f4afd72643b7e3e">Generate</a>(std::declval&lt; Engine &amp; &gt;), std::declval&lt; FUNCTOR const  &amp; &gt;))), typename std::iterator_traits&lt; Iterator &gt;::value_type &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1has__rng__formula.html">hydra::detail::has_rng_formula</a>&lt; FUNCTOR &gt;::value, void &gt;::type hydra::fill_random </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FUNCTOR const &amp;&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>seed</em> = <code>0x254a0afcf7da74a2</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>rng_jump</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fall back function if RngFormula::Generate() return value is not convertible to functor return value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>beginning of the range storing the generated values </td></tr>
    <tr><td class="paramname">end</td><td>ending of the range storing the generated values </td></tr>
    <tr><td class="paramname">functor</td><td>distribution to be sampled </td></tr>
    <tr><td class="paramname">max_pdf</td><td>maximum pdf value for accept-reject method. If no value is set, the maximum value in the sample is used. </td></tr>
    <tr><td class="paramname">rng_seed</td><td>seed for the underlying pseudo-random number generator </td></tr>
    <tr><td class="paramname">rng_jump</td><td>sequence offset for the underlying pseudo-random number generator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga17ea099eedec5a25a96e3309b81f6a6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga17ea099eedec5a25a96e3309b81f6a6f">&#9670;&nbsp;</a></span>fill_random() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Engine , hydra::detail::Backend BACKEND, typename Iterable , typename FUNCTOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; !(<a class="el" href="structhydra_1_1detail_1_1random_1_1is__matching__iterable.html">detail::random::is_matching_iterable</a>&lt; Engine, FUNCTOR, Iterable &gt;::value), void &gt;::type hydra::fill_random </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; const &amp;&#160;</td>
          <td class="paramname"><em>policy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterable &amp;&amp;&#160;</td>
          <td class="paramname"><em>iterable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FUNCTOR const &amp;&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>seed</em> = <code>0x254a0afcf7da74a2</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>rng_jump</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fall back function if the argument is not an Iterable or if it is not convertible to the Functor return value. </p>
<p>Fall back function if the argument is not an Iterable or if itis not convertible to the Functor return value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">policy</td><td>backend to perform the calculation. </td></tr>
    <tr><td class="paramname">iterable</td><td>range storing the generated values </td></tr>
    <tr><td class="paramname">functor</td><td>distribution to be sampled </td></tr>
    <tr><td class="paramname">max_pdf</td><td>maximum pdf value for accept-reject method. If no value is set, the maximum value in the sample is used. </td></tr>
    <tr><td class="paramname">rng_seed</td><td>seed for the underlying pseudo-random number generator </td></tr>
    <tr><td class="paramname">rng_jump</td><td>sequence offset for the underlying pseudo-random number generator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aab0cc380e55d7f4d02106a74165f7162"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab0cc380e55d7f4d02106a74165f7162">&#9670;&nbsp;</a></span>filter() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterable , typename Functor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt;Iterable&gt;::value,<a class="el" href="namespacehydra.html#classhydra_1_1Range">hydra::Range</a>&lt;decltype(std::declval&lt;Iterable&gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>())&gt; &gt;::type hydra::filter </td>
          <td>(</td>
          <td class="paramtype">Iterable &amp;&amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Functor &amp;&amp;&#160;</td>
          <td class="paramname"><em>filter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="basic_fit_range_semantics_8inl-example.html#a24">basic_fit_range_semantics.inl</a>, <a class="el" href="extended_logLL_fit_8inl-example.html#a32">extended_logLL_fit.inl</a>, <a class="el" href="fit_johnson_8C-example.html#a14">fit_johnson.C</a>, <a class="el" href="fractional_logLL_fit_8inl-example.html#a30">fractional_logLL_fit.inl</a>, <a class="el" href="multidimensional_fit_8inl-example.html#a45">multidimensional_fit.inl</a>, <a class="el" href="simultaneous_fit_8inl-example.html#a21">simultaneous_fit.inl</a>, and <a class="el" href="splot_8inl-example.html#a31">splot.inl</a>.</dd>
</dl>
</div>
</div>
<a id="a10d99a671eb993b054706c645b533533"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10d99a671eb993b054706c645b533533">&#9670;&nbsp;</a></span>filter() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterable , typename Functor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt;Iterable&gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1Range">hydra::Range</a>&lt;decltype(std::declval&lt;Iterable&gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>())&gt; &gt;::type hydra::filter </td>
          <td>(</td>
          <td class="paramtype">Iterable &amp;&amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Functor const &amp;&#160;</td>
          <td class="paramname"><em>filter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply a filter to the range [first, last] and return a pair of iterators for the filtered events. </p>
<p>This function will not change the size of the original range, [first, last], but will reorder the entries to put together the accepted entries. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>Iterator pointing to the begin of the range to filter. </td></tr>
    <tr><td class="paramname">last</td><td>Iterator pointing to the end of the range to filter. </td></tr>
    <tr><td class="paramname">filter</td><td>Functor returning bool. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="ab056ed3df61b0755f67d96f8537c657f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab056ed3df61b0755f67d96f8537c657f">&#9670;&nbsp;</a></span>for_each()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterable , typename Functor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;<a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt;Iterable&gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt;decltype(std::declval&lt;Iterable&amp;&gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>())&gt; &gt;::type hydra::for_each </td>
          <td>(</td>
          <td class="paramtype">Iterable &amp;&amp;&#160;</td>
          <td class="paramname"><em>iterable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Functor const &amp;&#160;</td>
          <td class="paramname"><em>functor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="booststrapping_8inl-example.html#a7">booststrapping.inl</a>, <a class="el" href="cufft_8inl-example.html#a20">cufft.inl</a>, <a class="el" href="fft_8inl-example.html#a20">fft.inl</a>, and <a class="el" href="range_semantics_8inl-example.html#a17">range_semantics.inl</a>.</dd>
</dl>
</div>
</div>
<a id="ae76012f51e751385a4a326ab68c01caf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae76012f51e751385a4a326ab68c01caf">&#9670;&nbsp;</a></span>forward_as_tuple()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> auto hydra::forward_as_tuple </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;...&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td> -&gt; decltype(hydra::thrust::forward_as_tuple(std::forward&lt;T&gt;(t)...))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a tuple of references to the arguments in args suitable for forwarding as an argument to a function. </p>
<p>The tuple has rvalue reference data members when rvalues are used as arguments, and otherwise has lvalue reference data members. </p>

</div>
</div>
<a id="a75feeef216747fa3b7c90b590f2761e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75feeef216747fa3b7c90b590f2761e8">&#9670;&nbsp;</a></span>gather()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterable_Source , typename Iterable_Target , typename Iterable_Map &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;<a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt;Iterable_Source&gt;::value &amp;&amp; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt;Iterable_Target&gt;::value &amp;&amp; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt;Iterable_Map&gt;::value,<a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt;decltype(std::declval&lt;Iterable_Target&amp;&gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>())&gt; &gt;::type hydra::gather </td>
          <td>(</td>
          <td class="paramtype">Iterable_Source &amp;&amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterable_Map &amp;&amp;&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterable_Target &amp;&amp;&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac71b87e64d6dbb15c41c8f77e95a8072"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac71b87e64d6dbb15c41c8f77e95a8072">&#9670;&nbsp;</a></span>get() <span class="overload">[1/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int I, int N, typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> T hydra::get </td>
          <td>(</td>
          <td class="paramtype">T(&amp;)&#160;</td>
          <td class="paramname"><em>array</em>[N]</td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a048ae1166f9c2988a3d1933b0a3843d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a048ae1166f9c2988a3d1933b0a3843d7">&#9670;&nbsp;</a></span>get() <span class="overload">[2/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int I, typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> T hydra::get </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a814bb5809cacd8d37e09352725352022"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a814bb5809cacd8d37e09352725352022">&#9670;&nbsp;</a></span>get() <span class="overload">[3/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , typename ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> Type&amp; hydra::get </td>
          <td>(</td>
          <td class="paramtype">hydra::thrust::tuple&lt; T... &gt; const &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The <code>get</code> function returns a reference to a <code>tuple</code> element of interest. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>A reference to a <code>tuple</code> of interest. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to <code>t's</code> <code>N</code>th element.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">N</td><td>The index of the element of interest.</td></tr>
  </table>
  </dd>
</dl>
<p>The following code snippet demonstrates how to use <code>get</code> to print the value of a <code>tuple</code> element.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="Tuple_8h.html">hydra/Tuple.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line">...</div><div class="line">hydra::tuple&lt;<a class="code" href="namespace_3globalScope_4.html#classint">int</a>, <span class="keyword">const</span> <span class="keywordtype">char</span> *&gt; t(13, <span class="stringliteral">&quot;hydra&quot;</span>);</div><div class="line"></div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;The 1st value of t is &quot;</span> &lt;&lt; hydra::get&lt;0&gt;(t) &lt;&lt; std::endl;</div></div><!-- fragment --> 
</div>
</div>
<a id="afb26cae3e192ca17f5d682bfc8007fa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb26cae3e192ca17f5d682bfc8007fa9">&#9670;&nbsp;</a></span>get() <span class="overload">[4/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N, typename ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> const hydra::thrust::tuple_element&lt;N,hydra::thrust::tuple&lt;T...&gt; &gt;::type&amp; hydra::get </td>
          <td>(</td>
          <td class="paramtype">hydra::thrust::tuple&lt; T... &gt; const &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3a91b6f5a6e8ace5a456c5674c3bc648"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a91b6f5a6e8ace5a456c5674c3bc648">&#9670;&nbsp;</a></span>get() <span class="overload">[5/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , typename ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> Type&amp; hydra::get </td>
          <td>(</td>
          <td class="paramtype">hydra::thrust::tuple&lt; T... &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af73fcb34d196900b763588aa3e47fd63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af73fcb34d196900b763588aa3e47fd63">&#9670;&nbsp;</a></span>get() <span class="overload">[6/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N, typename ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::tuple_element&lt;N,hydra::thrust::tuple&lt;T...&gt; &gt;::type&amp; hydra::get </td>
          <td>(</td>
          <td class="paramtype">hydra::thrust::tuple&lt; T... &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aca9a5101a5abdfded954a3ccc77c0fb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca9a5101a5abdfded954a3ccc77c0fb0">&#9670;&nbsp;</a></span>get() <span class="overload">[7/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , typename ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> Type&amp;&amp; hydra::get </td>
          <td>(</td>
          <td class="paramtype">hydra::thrust::tuple&lt; T... &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab0b90037b5e239de92e89e0e6f8e04e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0b90037b5e239de92e89e0e6f8e04e9">&#9670;&nbsp;</a></span>get() <span class="overload">[8/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N, typename ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::tuple_element&lt;N,hydra::thrust::tuple&lt;T...&gt; &gt;::type&amp;&amp; hydra::get </td>
          <td>(</td>
          <td class="paramtype">hydra::thrust::tuple&lt; T... &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8ff947d6f9d1df1e747890d127bcb5c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ff947d6f9d1df1e747890d127bcb5c3">&#9670;&nbsp;</a></span>get() <span class="overload">[9/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N, typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::tuple_element&lt;N,hydra::thrust::pair&lt;T1,T2&gt; &gt;::type&amp; hydra::get </td>
          <td>(</td>
          <td class="paramtype">hydra::thrust::pair&lt; T1, T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="adec0d1c7056a5e7cd2a8c01a934bdfa7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adec0d1c7056a5e7cd2a8c01a934bdfa7">&#9670;&nbsp;</a></span>get() <span class="overload">[10/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N, typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> const hydra::thrust::tuple_element&lt;N,hydra::thrust::pair&lt;T1,T2&gt; &gt;::type&amp; hydra::get </td>
          <td>(</td>
          <td class="paramtype">hydra::thrust::pair&lt; T1, T2 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7a182f435e1010a0556c543f19feed6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a182f435e1010a0556c543f19feed6f">&#9670;&nbsp;</a></span>get() <span class="overload">[11/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N, typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::tuple_element&lt;N,hydra::thrust::pair&lt;T1,T2&gt; &gt;::type&amp;&amp; hydra::get </td>
          <td>(</td>
          <td class="paramtype">hydra::thrust::pair&lt; T1, T2 &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2658beb74af1f617373f6f640e2949e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2658beb74af1f617373f6f640e2949e4">&#9670;&nbsp;</a></span>get() <span class="overload">[12/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename T , size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#classhydra_1_1multiarray">multiarray</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(other.column(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt;I&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the column <code>_I</code> of the <a class="el" href="namespacehydra.html#classhydra_1_1multiarray">hydra::multiarray</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="af63079c411073c082f1099994bd539af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af63079c411073c082f1099994bd539af">&#9670;&nbsp;</a></span>get() <span class="overload">[13/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename T , size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#classhydra_1_1multiarray">multiarray</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(other.column(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt;I&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the column <code>_I</code> of the <a class="el" href="namespacehydra.html#classhydra_1_1multiarray">hydra::multiarray</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a9455f669c9c73c240ae096df0543c241"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9455f669c9c73c240ae096df0543c241">&#9670;&nbsp;</a></span>get() <span class="overload">[14/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; hydra::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> -&gt; decltype(other.column(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt;I&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac9c0317a250fbfc438fda2c5a41218f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9c0317a250fbfc438fda2c5a41218f9">&#9670;&nbsp;</a></span>get_flat_tuple()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="structhydra_1_1detail_1_1tuple__utility_1_1flat__tuple.html">detail::tuple_utility::flat_tuple</a>&lt;T...&gt;::type hydra::get_flat_tuple </td>
          <td>(</td>
          <td class="paramtype">T const &amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7582acf570b53c033d52c6ff0fecb43e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7582acf570b53c033d52c6ff0fecb43e">&#9670;&nbsp;</a></span>GetFormatedString()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string hydra::GetFormatedString </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2fcdf55250e5c7b839127b60ccc1bb08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fcdf55250e5c7b839127b60ccc1bb08">&#9670;&nbsp;</a></span>hermite()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> hydra::hermite </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_3globalScope_4.html#classunsigned">unsigned</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implementation of Hermite polynomials \( P_n(n) \) using the recursive relation. </p>
<p class="formulaDsp">
\[ P_{n + 1}(x) = 2xP_n(x) - 2nP_{n - 1}(x) \]
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>order of the polynomial </td></tr>
    <tr><td class="paramname">x</td><td>argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a80375f44c776f48ac47363edc4f21c49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80375f44c776f48ac47363edc4f21c49">&#9670;&nbsp;</a></span>jacobi()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> hydra::jacobi </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_3globalScope_4.html#classunsigned">unsigned</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>P_{n-1}^{(,)}(z) - 2 (n+ - 1) (n + -1) (2n+ + ) P_{n-2}^{(, )}(z), {align}&lt;/math&gt; </p>
<p>for ''n'' = 2, 3, .... </p>

</div>
</div>
<a id="ab528a52c914909be19583b377cf15dea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab528a52c914909be19583b377cf15dea">&#9670;&nbsp;</a></span>laguerre()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> hydra::laguerre </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_3globalScope_4.html#classunsigned">unsigned</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implementation of Laguerre polynomials \( P_n(n) \) using the recursive relation. </p>
<p class="formulaDsp">
\[ P_{n + 1}(x) = \frac{(2n + 1 - x)P_n(x) - n P_{n - 1}(x)}{n + 1} \]
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>order of the polynomial </td></tr>
    <tr><td class="paramname">x</td><td>argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="aa6f9d2e0f2fbfaf2119679f2ef60c213"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6f9d2e0f2fbfaf2119679f2ef60c213">&#9670;&nbsp;</a></span>legendre()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> hydra::legendre </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_3globalScope_4.html#classunsigned">unsigned</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implementation of Legendre polynomials \( P_n(n) \) using the recursive relation. </p>
<p class="formulaDsp">
\[ (n+1)P_{n+1}(x) = (2n+1)xP_{n}(x) - nP_{n-1}(x) \]
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>order of the polynomial </td></tr>
    <tr><td class="paramname">x</td><td>argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a2725e178af11595cbeba053c1f84dfa8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2725e178af11595cbeba053c1f84dfa8">&#9670;&nbsp;</a></span>log()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespacehydra.html#a9d2c06cb9672fe86dbeaa65e8f35a2bf">complex</a>&lt;T&gt; hydra::log </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#a9d2c06cb9672fe86dbeaa65e8f35a2bf">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a64d53a33e43032b9e482284fd1a38b08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64d53a33e43032b9e482284fd1a38b08">&#9670;&nbsp;</a></span>log10()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespacehydra.html#a9d2c06cb9672fe86dbeaa65e8f35a2bf">complex</a>&lt;T&gt; hydra::log10 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#a9d2c06cb9672fe86dbeaa65e8f35a2bf">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aec6434cd5d4090bff5bbac363febb2df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec6434cd5d4090bff5bbac363febb2df">&#9670;&nbsp;</a></span>make_convolution()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ArgType , typename Functor , typename Kernel , detail::Backend BACKEND, detail::FFTCalculator FFT, typename T  = typename detail::stripped_type&lt;typename std::common_type&lt;typename Functor::return_type, typename Kernel::return_type&gt;::type&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_floating_point&lt;T&gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1ConvolutionFunctor">ConvolutionFunctor</a>&lt;Functor, Kernel, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt;BACKEND&gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1FFTPolicy">detail::FFTPolicy</a>&lt;T, FFT&gt;, ArgType&gt; &gt;::type hydra::make_convolution </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt; const &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1FFTPolicy">detail::FFTPolicy</a>&lt; T, FFT &gt; const &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Functor const &amp;&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Kernel const &amp;&#160;</td>
          <td class="paramname"><em>kernel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>kmin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>kmax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_3globalScope_4.html#classunsigned">unsigned</a>&#160;</td>
          <td class="paramname"><em>nsamples</em> = <code>1024</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>interpolate</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>power_up</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5d38b20da8bf42cb19f79f82b80bbc3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d38b20da8bf42cb19f79f82b80bbc3e">&#9670;&nbsp;</a></span>make_dense_histogram()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Iterator1 , typename Iterator2 , size_t N, hydra::detail::Backend BACKEND&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__histogram.html#classhydra_1_1DenseHistogram">DenseHistogram</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt;BACKEND&gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1multidimensional">detail::multidimensional</a>&gt; hydra::make_dense_histogram </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; size_t, N &gt; const &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>, N &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lowerlimits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>, N &gt; const &amp;&#160;</td>
          <td class="paramname"><em>upperlimits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator1&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator1&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator2&#160;</td>
          <td class="paramname"><em>wfirst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a820a933e48fa338a812a9f88bfb18e56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a820a933e48fa338a812a9f88bfb18e56">&#9670;&nbsp;</a></span>make_loglikehood_fcn()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... Pdfs, typename Histogram &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;<a class="el" href="structhydra_1_1detail_1_1is__hydra__dense__histogram.html">detail::is_hydra_dense_histogram</a>&lt;Histogram&gt;::value || <a class="el" href="structhydra_1_1detail_1_1is__hydra__sparse__histogram.html">detail::is_hydra_sparse_histogram</a>&lt;Histogram&gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1LogLikelihoodFCN">LogLikelihoodFCN</a>&lt; <a class="el" href="group__fit.html#classhydra_1_1PDFSumExtendable">PDFSumExtendable</a>&lt;Pdfs...&gt;, decltype(std::declval&lt;const Histogram&amp;&gt;).GetBinsCenters().<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()), decltype(std::declval&lt;const Histogram&amp;&gt;).GetBinsContents().<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()) &gt; &gt;::type hydra::make_loglikehood_fcn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__fit.html#classhydra_1_1PDFSumExtendable">PDFSumExtendable</a>&lt; Pdfs... &gt; const &amp;&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Histogram const &amp;&#160;</td>
          <td class="paramname"><em>points</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2b1f7cf97347cb7e8ab8db38f9ed466e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b1f7cf97347cb7e8ab8db38f9ed466e">&#9670;&nbsp;</a></span>make_pair()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> auto hydra::make_pair </td>
          <td>(</td>
          <td class="paramtype">T1 &amp;&amp;&#160;</td>
          <td class="paramname"><em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2 &amp;&amp;&#160;</td>
          <td class="paramname"><em>t2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(hydra::thrust::make_pair( std::forward&lt;T1&gt;(t1), std::forward&lt;T2&gt;(t2) ))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This version of <code>make_pair</code> creates a new <code>pair</code> object from a list of objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">T1</td><td>The first object to copy from. </td></tr>
    <tr><td class="paramname">T2</td><td>The second object to copy from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>pair</code> object with members which are copies of <code>t</code>. </dd></dl>

</div>
</div>
<a id="afc45ae5691f187be7c57c28d1154454f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc45ae5691f187be7c57c28d1154454f">&#9670;&nbsp;</a></span>make_range() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator , typename Functor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">hydra::thrust::detail::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt;Functor&gt;::value , <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt;Iterator, Functor&gt; &gt;::type hydra::make_range </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Functor const &amp;&#160;</td>
          <td class="paramname"><em>functor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aed731c061feb7b22667628e351da610b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed731c061feb7b22667628e351da610b">&#9670;&nbsp;</a></span>make_range() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt;Iterator&gt; hydra::make_range </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="cufft_8inl-example.html#a16">cufft.inl</a>, <a class="el" href="fft_8inl-example.html#a16">fft.inl</a>, and <a class="el" href="pseudo_experiment_8inl-example.html#a28">pseudo_experiment.inl</a>.</dd>
</dl>
</div>
</div>
<a id="aeb94a482290a0c2c1764865e7d16dcf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb94a482290a0c2c1764865e7d16dcf8">&#9670;&nbsp;</a></span>make_range() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterable &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;<a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt;Iterable&gt;::value,<a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt;decltype(std::declval&lt;Iterable&gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>())&gt; &gt;::type hydra::make_range </td>
          <td>(</td>
          <td class="paramtype">Iterable const &amp;&#160;</td>
          <td class="paramname"><em>container</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad02081b2cc9c583c06df766e293556c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad02081b2cc9c583c06df766e293556c1">&#9670;&nbsp;</a></span>make_range() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterable , typename Functor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">hydra::thrust::detail::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">detail::is_iterable</a>&lt;Iterable&gt;::value &amp;&amp; <a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt;Functor&gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt;decltype(std::declval&lt;Iterable&gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()), Functor&gt; &gt;::type hydra::make_range </td>
          <td>(</td>
          <td class="paramtype">Iterable const &amp;&#160;</td>
          <td class="paramname"><em>iterable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Functor const &amp;&#160;</td>
          <td class="paramname"><em>functor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a997423cc7da26ee78b795e07a6910c29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a997423cc7da26ee78b795e07a6910c29">&#9670;&nbsp;</a></span>make_range() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterable &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;<a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt;Iterable&gt;::value,<a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt;decltype(std::declval&lt;Iterable&gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>())&gt; &gt;::type hydra::make_range </td>
          <td>(</td>
          <td class="paramtype">Iterable &amp;&amp;&#160;</td>
          <td class="paramname"><em>container</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aea37e8b4846fce4e9e41f6adc0950bdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea37e8b4846fce4e9e41f6adc0950bdd">&#9670;&nbsp;</a></span>make_range() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterable , typename Functor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">hydra::thrust::detail::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">detail::is_iterable</a>&lt;Iterable&gt;::value &amp;&amp; <a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt;Functor&gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt;decltype(std::declval&lt;Iterable&gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()), Functor&gt; &gt;::type hydra::make_range </td>
          <td>(</td>
          <td class="paramtype">Iterable &amp;&amp;&#160;</td>
          <td class="paramname"><em>iterable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Functor const &amp;&#160;</td>
          <td class="paramname"><em>functor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7c5faeca1a5496aa680259e8d17085ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c5faeca1a5496aa680259e8d17085ee">&#9670;&nbsp;</a></span>make_reverse_range() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator , typename Functor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">hydra::thrust::detail::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt;Functor&gt;::value , <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt;hydra::thrust::reverse_iterator&lt;Iterator&gt;, Functor&gt; &gt;::type hydra::make_reverse_range </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Functor const &amp;&#160;</td>
          <td class="paramname"><em>functor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aaca36384918d1107af74932bac7bde4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaca36384918d1107af74932bac7bde4a">&#9670;&nbsp;</a></span>make_reverse_range() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt;hydra::thrust::reverse_iterator&lt;Iterator&gt; &gt; hydra::make_reverse_range </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8be66889f53db6bbae8365d509c13cd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8be66889f53db6bbae8365d509c13cd1">&#9670;&nbsp;</a></span>make_reverse_range() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterable &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;<a class="el" href="structhydra_1_1detail_1_1is__reverse__iterable.html">hydra::detail::is_reverse_iterable</a>&lt;Iterable&gt;::value,<a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt;decltype(std::declval&lt;Iterable&gt;).<a class="el" href="namespacehydra.html#aadcca49207bf7ab79088f28cddb8f21d">rbegin</a>())&gt; &gt;::type hydra::make_reverse_range </td>
          <td>(</td>
          <td class="paramtype">Iterable const &amp;&#160;</td>
          <td class="paramname"><em>container</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abdb731a7ec634ab03b448a6cc6230d68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdb731a7ec634ab03b448a6cc6230d68">&#9670;&nbsp;</a></span>make_reverse_range() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterable &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;<a class="el" href="structhydra_1_1detail_1_1is__reverse__iterable.html">hydra::detail::is_reverse_iterable</a>&lt;Iterable&gt;::value,<a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt;decltype(std::declval&lt;Iterable&gt;).<a class="el" href="namespacehydra.html#aadcca49207bf7ab79088f28cddb8f21d">rbegin</a>())&gt; &gt;::type hydra::make_reverse_range </td>
          <td>(</td>
          <td class="paramtype">Iterable &amp;&amp;&#160;</td>
          <td class="paramname"><em>container</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab0538a7838b4c8a1395dcc2fffe6f4dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0538a7838b4c8a1395dcc2fffe6f4dc">&#9670;&nbsp;</a></span>make_reverse_range() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterable , typename Functor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">hydra::thrust::detail::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__reverse__iterable.html">detail::is_reverse_iterable</a>&lt;Iterable&gt;::value &amp;&amp; <a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt;Functor&gt;::value , <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt;decltype(std::declval&lt;Iterable&gt;).<a class="el" href="namespacehydra.html#aadcca49207bf7ab79088f28cddb8f21d">rbegin</a>()), Functor&gt; &gt;::type hydra::make_reverse_range </td>
          <td>(</td>
          <td class="paramtype">Iterable const &amp;&#160;</td>
          <td class="paramname"><em>iterable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Functor const &amp;&#160;</td>
          <td class="paramname"><em>functor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a41597c1949b55f024cfb5856e753e8be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41597c1949b55f024cfb5856e753e8be">&#9670;&nbsp;</a></span>make_reverse_range() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterable , typename Functor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">hydra::thrust::detail::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__reverse__iterable.html">detail::is_reverse_iterable</a>&lt;Iterable&gt;::value &amp;&amp; <a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt;Functor&gt;::value , <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt;decltype(std::declval&lt;Iterable&gt;).<a class="el" href="namespacehydra.html#aadcca49207bf7ab79088f28cddb8f21d">rbegin</a>()), Functor&gt; &gt;::type hydra::make_reverse_range </td>
          <td>(</td>
          <td class="paramtype">Iterable &amp;&amp;&#160;</td>
          <td class="paramname"><em>iterable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Functor const &amp;&#160;</td>
          <td class="paramname"><em>functor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae4feb340b294e9362e3b125dfcf0bb40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4feb340b294e9362e3b125dfcf0bb40">&#9670;&nbsp;</a></span>make_sparse_histogram() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t N, hydra::detail::Backend BACKEND, typename Iterable &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt;Iterable&gt;::value,<a class="el" href="group__histogram.html#classhydra_1_1SparseHistogram">SparseHistogram</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt;BACKEND&gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1multidimensional">detail::multidimensional</a>&gt; &gt;::type hydra::make_sparse_histogram </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&#160;</td>
          <td class="paramname"><em>backend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; size_t, N &gt;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>, N &gt;&#160;</td>
          <td class="paramname"><em>lowerlimits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>, N &gt;&#160;</td>
          <td class="paramname"><em>upperlimits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterable &amp;&amp;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4ad4ad0aab0d7f908337b4d2544e1233"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ad4ad0aab0d7f908337b4d2544e1233">&#9670;&nbsp;</a></span>make_sparse_histogram() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t N, hydra::detail::Backend BACKEND, typename Iterable1 , typename Iterable2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt;Iterable1&gt;::value&amp;&amp;<a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt;Iterable2&gt;::value,<a class="el" href="group__histogram.html#classhydra_1_1SparseHistogram">SparseHistogram</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt;BACKEND&gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1multidimensional">detail::multidimensional</a>&gt; &gt;::type hydra::make_sparse_histogram </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&#160;</td>
          <td class="paramname"><em>backend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; size_t, N &gt;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>, N &gt;&#160;</td>
          <td class="paramname"><em>lowerlimits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>, N &gt;&#160;</td>
          <td class="paramname"><em>upperlimits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterable1 &amp;&amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterable2 &amp;&amp;&#160;</td>
          <td class="paramname"><em>weights</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aca4da59a7dea5b04288b2d8ffc070bd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca4da59a7dea5b04288b2d8ffc070bd9">&#9670;&nbsp;</a></span>make_spline() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ArgType , typename Iterator1 , typename Iterator2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhydra_1_1SplineFunctor.html">SplineFunctor</a>&lt;Iterator1, Iterator2, ArgType&gt; hydra::make_spline </td>
          <td>(</td>
          <td class="paramtype">Iterator1&#160;</td>
          <td class="paramname"><em>firstX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator1&#160;</td>
          <td class="paramname"><em>lastX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator2&#160;</td>
          <td class="paramname"><em>firstY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac5d935ff11788a556de78fb586b908c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5d935ff11788a556de78fb586b908c4">&#9670;&nbsp;</a></span>make_spline() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ArgType , typename Iterable1 , typename Iterable2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt;Iterable1&gt;::value &amp;&amp; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt;Iterable2&gt;::value, <a class="el" href="classhydra_1_1SplineFunctor.html">SplineFunctor</a>&lt; decltype(std::declval&lt;Iterable1&gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()), decltype(std::declval&lt;Iterable2&gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()), ArgType&gt; &gt;::type hydra::make_spline </td>
          <td>(</td>
          <td class="paramtype">Iterable1 &amp;&amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterable2 &amp;&amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7b09185a07939b47374a5caa7b163217"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b09185a07939b47374a5caa7b163217">&#9670;&nbsp;</a></span>make_spline() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , hydra::detail::Backend BACKEND&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhydra_1_1SplineFunctor.html">SplineFunctor</a>&lt;decltype( std::declval&lt; <a class="el" href="group__histogram.html#classhydra_1_1DenseHistogram">DenseHistogram</a>&lt;T, 1, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt;BACKEND&gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1unidimensional">detail::unidimensional</a> &gt; &gt;).GetBinsCenters().<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()),decltype(std::declval&lt; <a class="el" href="group__histogram.html#classhydra_1_1DenseHistogram">DenseHistogram</a>&lt;T, 1, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt;BACKEND&gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1unidimensional">detail::unidimensional</a> &gt; &gt;).GetBinsContents().<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()), T&gt; hydra::make_spline </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__histogram.html#classhydra_1_1DenseHistogram">DenseHistogram</a>&lt; T, 1, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1unidimensional">detail::unidimensional</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>histogram</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abd5c4e348e70a6846b9a3ab62d4e4f26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd5c4e348e70a6846b9a3ab62d4e4f26">&#9670;&nbsp;</a></span>make_spline() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , hydra::detail::Backend BACKEND&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_convertible&lt;T, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&gt;::value,<a class="el" href="classhydra_1_1Spline2DFunctor.html">Spline2DFunctor</a>&lt;decltype(std::declval&lt;<a class="el" href="group__histogram.html#classhydra_1_1DenseHistogram">DenseHistogram</a>&lt;T, 2, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt;BACKEND&gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1multidimensional">detail::multidimensional</a>&gt; &gt;).GetBinsCenters(<a class="el" href="namespacehydra_1_1placeholders.html#ac0d56a89cc015c8579b7933cc78552e7">placeholders::_0</a>).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()),decltype(std::declval&lt;<a class="el" href="group__histogram.html#classhydra_1_1DenseHistogram">DenseHistogram</a>&lt;T, 2, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt;BACKEND&gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1multidimensional">detail::multidimensional</a>&gt; &gt;).GetBinsCenters(<a class="el" href="namespacehydra_1_1placeholders.html#aeeeb42f8f504622ab1fbb117da05fcab">placeholders::_1</a>).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()),decltype(std::declval&lt;<a class="el" href="group__histogram.html#classhydra_1_1DenseHistogram">DenseHistogram</a>&lt;T, 2, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt;BACKEND&gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1multidimensional">detail::multidimensional</a> &gt; &gt;).GetBinsContents().<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()), <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&gt; &gt;::type hydra::make_spline </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__histogram.html#classhydra_1_1DenseHistogram">DenseHistogram</a>&lt; T, 2, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1multidimensional">detail::multidimensional</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>histogram</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a11f75d22cd39a0978df79fb629cf1a18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11f75d22cd39a0978df79fb629cf1a18">&#9670;&nbsp;</a></span>make_spline() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , hydra::detail::Backend BACKEND&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhydra_1_1SplineFunctor.html">SplineFunctor</a>&lt; decltype(std::declval&lt;<a class="el" href="group__histogram.html#classhydra_1_1SparseHistogram">SparseHistogram</a>&lt;T, 1, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt;BACKEND&gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1unidimensional">detail::unidimensional</a> &gt; &gt;).GetBinsCenters().<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()), decltype(std::declval&lt;<a class="el" href="group__histogram.html#classhydra_1_1SparseHistogram">SparseHistogram</a>&lt;T, 1, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt;BACKEND&gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1unidimensional">detail::unidimensional</a> &gt; &gt;).GetBinsContents().<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()), T&gt; hydra::make_spline </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__histogram.html#classhydra_1_1SparseHistogram">SparseHistogram</a>&lt; T, 1, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1unidimensional">detail::unidimensional</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>histogram</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8cb4f712fa5d988db7135da360347f15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cb4f712fa5d988db7135da360347f15">&#9670;&nbsp;</a></span>make_spline() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , hydra::detail::Backend BACKEND&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_convertible&lt;T, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&gt;::value,<a class="el" href="classhydra_1_1Spline2DFunctor.html">Spline2DFunctor</a>&lt;decltype(std::declval&lt;<a class="el" href="group__histogram.html#classhydra_1_1SparseHistogram">SparseHistogram</a>&lt;T, 2, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt;BACKEND&gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1multidimensional">detail::multidimensional</a>&gt; &gt;).GetBinsCenters(<a class="el" href="namespacehydra_1_1placeholders.html#ac0d56a89cc015c8579b7933cc78552e7">placeholders::_0</a>).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()),decltype(std::declval&lt;<a class="el" href="group__histogram.html#classhydra_1_1SparseHistogram">SparseHistogram</a>&lt;T, 2, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt;BACKEND&gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1multidimensional">detail::multidimensional</a>&gt; &gt;).GetBinsCenters(<a class="el" href="namespacehydra_1_1placeholders.html#aeeeb42f8f504622ab1fbb117da05fcab">placeholders::_1</a>).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()),decltype(std::declval&lt;<a class="el" href="group__histogram.html#classhydra_1_1SparseHistogram">SparseHistogram</a>&lt;T, 2, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt;BACKEND&gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1multidimensional">detail::multidimensional</a> &gt; &gt;).GetBinsContents().<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()), <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&gt; &gt;::type hydra::make_spline </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__histogram.html#classhydra_1_1SparseHistogram">SparseHistogram</a>&lt; T, 2, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1multidimensional">detail::multidimensional</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>histogram</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0c65353b69cb026bf01fb3e3e0710d57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c65353b69cb026bf01fb3e3e0710d57">&#9670;&nbsp;</a></span>make_spline() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , hydra::detail::Backend BACKEND&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_convertible&lt;T, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&gt;::value,<a class="el" href="classhydra_1_1Spline3DFunctor.html">Spline3DFunctor</a>&lt;decltype(std::declval&lt;<a class="el" href="group__histogram.html#classhydra_1_1DenseHistogram">DenseHistogram</a>&lt;T, 3, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt;BACKEND&gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1multidimensional">detail::multidimensional</a>&gt; &gt;).GetBinsCenters(<a class="el" href="namespacehydra_1_1placeholders.html#ac0d56a89cc015c8579b7933cc78552e7">placeholders::_0</a>).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()),decltype(std::declval&lt;<a class="el" href="group__histogram.html#classhydra_1_1DenseHistogram">DenseHistogram</a>&lt;T, 3, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt;BACKEND&gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1multidimensional">detail::multidimensional</a>&gt; &gt;).GetBinsCenters(<a class="el" href="namespacehydra_1_1placeholders.html#aeeeb42f8f504622ab1fbb117da05fcab">placeholders::_1</a>).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()),decltype(std::declval&lt;<a class="el" href="group__histogram.html#classhydra_1_1DenseHistogram">DenseHistogram</a>&lt;T, 3, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt;BACKEND&gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1multidimensional">detail::multidimensional</a>&gt; &gt;).GetBinsCenters(<a class="el" href="namespacehydra_1_1placeholders.html#adfba0f80c06fadc6694f3f3ad8ed68bc">placeholders::_2</a>).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()),decltype(std::declval&lt;<a class="el" href="group__histogram.html#classhydra_1_1DenseHistogram">DenseHistogram</a>&lt;T, 3, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt;BACKEND&gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1multidimensional">detail::multidimensional</a> &gt; &gt;).GetBinsContents().<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()), <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&gt; &gt;::type hydra::make_spline </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__histogram.html#classhydra_1_1DenseHistogram">DenseHistogram</a>&lt; T, 3, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1multidimensional">detail::multidimensional</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>histogram</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a36434857108a16306e46b6bef7e925b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36434857108a16306e46b6bef7e925b0">&#9670;&nbsp;</a></span>make_spline() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , hydra::detail::Backend BACKEND&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_convertible&lt;T, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&gt;::value,<a class="el" href="classhydra_1_1Spline3DFunctor.html">Spline3DFunctor</a>&lt;decltype(std::declval&lt;<a class="el" href="group__histogram.html#classhydra_1_1SparseHistogram">SparseHistogram</a>&lt;T, 3, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt;BACKEND&gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1multidimensional">detail::multidimensional</a>&gt; &gt;).GetBinsCenters(<a class="el" href="namespacehydra_1_1placeholders.html#ac0d56a89cc015c8579b7933cc78552e7">placeholders::_0</a>).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()),decltype(std::declval&lt;<a class="el" href="group__histogram.html#classhydra_1_1SparseHistogram">SparseHistogram</a>&lt;T, 3, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt;BACKEND&gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1multidimensional">detail::multidimensional</a>&gt; &gt;).GetBinsCenters(<a class="el" href="namespacehydra_1_1placeholders.html#aeeeb42f8f504622ab1fbb117da05fcab">placeholders::_1</a>).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()),decltype(std::declval&lt;<a class="el" href="group__histogram.html#classhydra_1_1SparseHistogram">SparseHistogram</a>&lt;T, 3, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt;BACKEND&gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1multidimensional">detail::multidimensional</a>&gt; &gt;).GetBinsCenters(<a class="el" href="namespacehydra_1_1placeholders.html#adfba0f80c06fadc6694f3f3ad8ed68bc">placeholders::_2</a>).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()),decltype(std::declval&lt;<a class="el" href="group__histogram.html#classhydra_1_1SparseHistogram">SparseHistogram</a>&lt;T, 3, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt;BACKEND&gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1multidimensional">detail::multidimensional</a> &gt; &gt;).GetBinsContents().<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()), <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&gt; &gt;::type hydra::make_spline </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__histogram.html#classhydra_1_1SparseHistogram">SparseHistogram</a>&lt; T, 3, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1multidimensional">detail::multidimensional</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>histogram</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3d1d020b412e5a0bf9b62c42cb5f92f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d1d020b412e5a0bf9b62c42cb5f92f6">&#9670;&nbsp;</a></span>make_spline() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , hydra::detail::Backend BACKEND&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_convertible&lt;T, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&gt;::value,<a class="el" href="classhydra_1_1Spline4DFunctor.html">Spline4DFunctor</a>&lt;decltype(std::declval&lt;<a class="el" href="group__histogram.html#classhydra_1_1DenseHistogram">DenseHistogram</a>&lt;T, 4, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt;BACKEND&gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1multidimensional">detail::multidimensional</a>&gt; &gt;).GetBinsCenters(<a class="el" href="namespacehydra_1_1placeholders.html#ac0d56a89cc015c8579b7933cc78552e7">placeholders::_0</a>).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()),decltype(std::declval&lt;<a class="el" href="group__histogram.html#classhydra_1_1DenseHistogram">DenseHistogram</a>&lt;T, 4, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt;BACKEND&gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1multidimensional">detail::multidimensional</a>&gt; &gt;).GetBinsCenters(<a class="el" href="namespacehydra_1_1placeholders.html#aeeeb42f8f504622ab1fbb117da05fcab">placeholders::_1</a>).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()),decltype(std::declval&lt;<a class="el" href="group__histogram.html#classhydra_1_1DenseHistogram">DenseHistogram</a>&lt;T, 4, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt;BACKEND&gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1multidimensional">detail::multidimensional</a>&gt; &gt;).GetBinsCenters(<a class="el" href="namespacehydra_1_1placeholders.html#adfba0f80c06fadc6694f3f3ad8ed68bc">placeholders::_2</a>).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()),decltype(std::declval&lt;<a class="el" href="group__histogram.html#classhydra_1_1DenseHistogram">DenseHistogram</a>&lt;T, 4, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt;BACKEND&gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1multidimensional">detail::multidimensional</a>&gt; &gt;).GetBinsCenters(<a class="el" href="namespacehydra_1_1placeholders.html#a09db94b16cc11622963193aaff7d90f1">placeholders::_3</a>).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()),decltype(std::declval&lt;<a class="el" href="group__histogram.html#classhydra_1_1DenseHistogram">DenseHistogram</a>&lt;T, 4, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt;BACKEND&gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1multidimensional">detail::multidimensional</a> &gt; &gt;).GetBinsContents().<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()),<a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&gt; &gt;::type hydra::make_spline </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__histogram.html#classhydra_1_1DenseHistogram">DenseHistogram</a>&lt; T, 4, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1multidimensional">detail::multidimensional</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>histogram</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="adb4419d4fc7b7bdcb9ac9b93af8dc6c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb4419d4fc7b7bdcb9ac9b93af8dc6c4">&#9670;&nbsp;</a></span>make_spline() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , hydra::detail::Backend BACKEND&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_convertible&lt;T, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&gt;::value,<a class="el" href="classhydra_1_1Spline4DFunctor.html">Spline4DFunctor</a>&lt;decltype(std::declval&lt;<a class="el" href="group__histogram.html#classhydra_1_1SparseHistogram">SparseHistogram</a>&lt;T, 4, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt;BACKEND&gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1multidimensional">detail::multidimensional</a>&gt; &gt;).GetBinsCenters(<a class="el" href="namespacehydra_1_1placeholders.html#ac0d56a89cc015c8579b7933cc78552e7">placeholders::_0</a>).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()),decltype(std::declval&lt;<a class="el" href="group__histogram.html#classhydra_1_1SparseHistogram">SparseHistogram</a>&lt;T, 4, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt;BACKEND&gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1multidimensional">detail::multidimensional</a>&gt; &gt;).GetBinsCenters(<a class="el" href="namespacehydra_1_1placeholders.html#aeeeb42f8f504622ab1fbb117da05fcab">placeholders::_1</a>).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()),decltype(std::declval&lt;<a class="el" href="group__histogram.html#classhydra_1_1SparseHistogram">SparseHistogram</a>&lt;T, 4, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt;BACKEND&gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1multidimensional">detail::multidimensional</a>&gt; &gt;).GetBinsCenters(<a class="el" href="namespacehydra_1_1placeholders.html#adfba0f80c06fadc6694f3f3ad8ed68bc">placeholders::_2</a>).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()),decltype(std::declval&lt;<a class="el" href="group__histogram.html#classhydra_1_1SparseHistogram">SparseHistogram</a>&lt;T, 4, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt;BACKEND&gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1multidimensional">detail::multidimensional</a>&gt; &gt;).GetBinsCenters(<a class="el" href="namespacehydra_1_1placeholders.html#a09db94b16cc11622963193aaff7d90f1">placeholders::_3</a>).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()),decltype(std::declval&lt;<a class="el" href="group__histogram.html#classhydra_1_1SparseHistogram">SparseHistogram</a>&lt;T, 4, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt;BACKEND&gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1multidimensional">detail::multidimensional</a> &gt; &gt;).GetBinsContents().<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()),<a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&gt; &gt;::type hydra::make_spline </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__histogram.html#classhydra_1_1SparseHistogram">SparseHistogram</a>&lt; T, 4, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1multidimensional">detail::multidimensional</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>histogram</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abe57f02443c2a34dc68590831917fb19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe57f02443c2a34dc68590831917fb19">&#9670;&nbsp;</a></span>make_spline2D() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ArgTypeX , typename ArgTypeY , typename IteratorX , typename IteratorY , typename IteratorZ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhydra_1_1Spline2DFunctor.html">Spline2DFunctor</a>&lt; IteratorX, IteratorY, IteratorZ, ArgTypeX, ArgTypeY &gt; hydra::make_spline2D </td>
          <td>(</td>
          <td class="paramtype">IteratorX&#160;</td>
          <td class="paramname"><em>firstX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorX&#160;</td>
          <td class="paramname"><em>lastX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorY&#160;</td>
          <td class="paramname"><em>firstY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorY&#160;</td>
          <td class="paramname"><em>lastY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorZ&#160;</td>
          <td class="paramname"><em>firstZ</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae86e584b24ad42a95a80c77bc2234ed0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae86e584b24ad42a95a80c77bc2234ed0">&#9670;&nbsp;</a></span>make_spline2D() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ArgTypeX , typename ArgTypeY , typename IterableX , typename IterableY , typename IterableZ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt;IterableX&gt;::value &amp;&amp; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt;IterableY&gt;::value &amp;&amp; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt;IterableZ&gt;::value, <a class="el" href="classhydra_1_1Spline2DFunctor.html">Spline2DFunctor</a>&lt; decltype(std::declval&lt;IterableX&gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()) ,decltype(std::declval&lt;IterableY&gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()), decltype(std::declval&lt;IterableZ&gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()), ArgTypeX, ArgTypeY&gt; &gt;::type hydra::make_spline2D </td>
          <td>(</td>
          <td class="paramtype">IterableX &amp;&amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IterableY &amp;&amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IterableZ &amp;&amp;&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a147cb991452c985fd3827012cb8b6e49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a147cb991452c985fd3827012cb8b6e49">&#9670;&nbsp;</a></span>make_spline3D() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ArgTypeX , typename ArgTypeY , typename ArgTypeZ , typename IteratorX , typename IteratorY , typename IteratorZ , typename IteratorM &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhydra_1_1Spline3DFunctor.html">Spline3DFunctor</a>&lt; IteratorX, IteratorY, IteratorZ, IteratorM, ArgTypeX, ArgTypeY, ArgTypeZ &gt; hydra::make_spline3D </td>
          <td>(</td>
          <td class="paramtype">IteratorX&#160;</td>
          <td class="paramname"><em>firstX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorX&#160;</td>
          <td class="paramname"><em>lastX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorY&#160;</td>
          <td class="paramname"><em>firstY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorY&#160;</td>
          <td class="paramname"><em>lastY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorZ&#160;</td>
          <td class="paramname"><em>firstZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorZ&#160;</td>
          <td class="paramname"><em>lastZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorM&#160;</td>
          <td class="paramname"><em>measurements_first</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aba5a69ae43d621252bd72c7a86b8a428"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba5a69ae43d621252bd72c7a86b8a428">&#9670;&nbsp;</a></span>make_spline3D() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ArgTypeX , typename ArgTypeY , typename ArgTypeZ , typename IterableX , typename IterableY , typename IterableZ , typename IterableM &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt;IterableX&gt;::value &amp;&amp; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt;IterableY&gt;::value &amp;&amp; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt;IterableZ&gt;::value &amp;&amp; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt;IterableM&gt;::value, <a class="el" href="classhydra_1_1Spline3DFunctor.html">Spline3DFunctor</a>&lt; decltype(std::declval&lt;IterableX&gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()) ,decltype(std::declval&lt;IterableY&gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()), decltype(std::declval&lt;IterableZ&gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()), decltype(std::declval&lt;IterableM&gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()), ArgTypeX, ArgTypeY, ArgTypeZ&gt; &gt;::type hydra::make_spline3D </td>
          <td>(</td>
          <td class="paramtype">IterableX &amp;&amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IterableY &amp;&amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IterableZ &amp;&amp;&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IterableM &amp;&amp;&#160;</td>
          <td class="paramname"><em>measurements</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1db1991c330a4252eca5e6f54d817144"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1db1991c330a4252eca5e6f54d817144">&#9670;&nbsp;</a></span>make_spline4D() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ArgTypeX , typename ArgTypeY , typename ArgTypeW , typename ArgTypeZ , typename IteratorX , typename IteratorY , typename IteratorW , typename IteratorZ , typename IteratorM &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhydra_1_1Spline4DFunctor.html">Spline4DFunctor</a>&lt; IteratorX, IteratorY, IteratorW, IteratorZ, IteratorM, ArgTypeX, ArgTypeY, ArgTypeW, ArgTypeZ &gt; hydra::make_spline4D </td>
          <td>(</td>
          <td class="paramtype">IteratorX&#160;</td>
          <td class="paramname"><em>firstX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorX&#160;</td>
          <td class="paramname"><em>lastX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorY&#160;</td>
          <td class="paramname"><em>firstY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorY&#160;</td>
          <td class="paramname"><em>lastY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorW&#160;</td>
          <td class="paramname"><em>firstW</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorW&#160;</td>
          <td class="paramname"><em>lastW</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorZ&#160;</td>
          <td class="paramname"><em>firstZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorZ&#160;</td>
          <td class="paramname"><em>lastZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorM&#160;</td>
          <td class="paramname"><em>measurements_first</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a64fcd2ab64d8c4cca3ec8d1f349c75da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64fcd2ab64d8c4cca3ec8d1f349c75da">&#9670;&nbsp;</a></span>make_spline4D() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ArgTypeX , typename ArgTypeY , typename ArgTypeW , typename ArgTypeZ , typename IterableX , typename IterableY , typename IterableW , typename IterableZ , typename IterableM &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt;IterableX&gt;::value &amp;&amp; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt;IterableY&gt;::value &amp;&amp; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt;IterableW&gt;::value &amp;&amp; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt;IterableZ&gt;::value &amp;&amp; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt;IterableM&gt;::value, <a class="el" href="classhydra_1_1Spline4DFunctor.html">Spline4DFunctor</a>&lt; decltype(std::declval&lt;IterableX&gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()), decltype(std::declval&lt;IterableY&gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()), decltype(std::declval&lt;IterableW&gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()), decltype(std::declval&lt;IterableZ&gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()), decltype(std::declval&lt;IterableM&gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()), ArgTypeX, ArgTypeY, ArgTypeW, ArgTypeZ&gt; &gt;::type hydra::make_spline4D </td>
          <td>(</td>
          <td class="paramtype">IterableX &amp;&amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IterableY &amp;&amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IterableW &amp;&amp;&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IterableZ &amp;&amp;&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IterableM &amp;&amp;&#160;</td>
          <td class="paramname"><em>measurements</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7f74fb09a286265393fbce752c0c32cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f74fb09a286265393fbce752c0c32cb">&#9670;&nbsp;</a></span>make_splot() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator , typename PDF1 , typename PDF2 , typename ... PDFs&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterator.html">detail::is_iterator</a>&lt;Iterator&gt;::value, <a class="el" href="group__fit.html#classhydra_1_1SPlot">SPlot</a>&lt;Iterator, PDF1, PDF2, PDFs...&gt; &gt;::type hydra::make_splot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__fit.html#classhydra_1_1PDFSumExtendable">PDFSumExtendable</a>&lt; PDF1, PDF2, PDFs... &gt; const &amp;&#160;</td>
          <td class="paramname"><em>pdf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience function for instantiating <a class="el" href="group__fit.html#classhydra_1_1SPlot" title="Implementation of {s}_{Plot} technique for statistical unfolding of sample containing events from dif...">SPlot</a> objects using type deduction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pdf</td><td>PDFSumExtendable&lt;PDF1, PDF2, PDFs...&gt; optimized object </td></tr>
    <tr><td class="paramname">first</td><td>iterator pointing to beginning of the data range. </td></tr>
    <tr><td class="paramname">last</td><td>iterator pointing to end of the data range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="pseudo_experiment_8inl-example.html#a44">pseudo_experiment.inl</a>, and <a class="el" href="splot_8inl-example.html#a41">splot.inl</a>.</dd>
</dl>
</div>
</div>
<a id="ac5ead3609a0334574dba725caebf656b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5ead3609a0334574dba725caebf656b">&#9670;&nbsp;</a></span>make_splot() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterable , typename PDF1 , typename PDF2 , typename ... PDFs&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">detail::is_iterable</a>&lt;Iterable&gt;::value, <a class="el" href="group__fit.html#classhydra_1_1SPlot">SPlot</a>&lt; decltype(std::declval&lt;Iterable&gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()), PDF1, PDF2, PDFs...&gt; &gt;::type hydra::make_splot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__fit.html#classhydra_1_1PDFSumExtendable">PDFSumExtendable</a>&lt; PDF1, PDF2, PDFs... &gt; const &amp;&#160;</td>
          <td class="paramname"><em>pdf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterable &amp;&amp;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience function for instantiating <a class="el" href="group__fit.html#classhydra_1_1SPlot" title="Implementation of {s}_{Plot} technique for statistical unfolding of sample containing events from dif...">SPlot</a> objects using type deduction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pdf</td><td>PDFSumExtendable&lt;PDF1, PDF2, PDFs...&gt; optimized object </td></tr>
    <tr><td class="paramname">data</td><td>iterable representing the data-range </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="ae9e1c8df3eaea2b9e4646c5dcdeaf322"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9e1c8df3eaea2b9e4646c5dcdeaf322">&#9670;&nbsp;</a></span>make_tuple()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> auto hydra::make_tuple </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;...&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td> -&gt; decltype(hydra::thrust::make_tuple( std::forward&lt;T&gt;(t)...))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This version of <code>make_tuple</code> creates a new <code>tuple</code> object from a list of objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">T</td><td>The first object to copy from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>tuple</code> object with members which are copies of <code>t</code>. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="dalitz_plot_8C-example.html#a42">dalitz_plot.C</a>, <a class="el" href="dalitz_plot_8inl-example.html#a45">dalitz_plot.inl</a>, <a class="el" href="multiarray_container_8inl-example.html#a5">multiarray_container.inl</a>, <a class="el" href="multidimensional_fit_8inl-example.html#a56">multidimensional_fit.inl</a>, <a class="el" href="multivector_container_8inl-example.html#a5">multivector_container.inl</a>, <a class="el" href="phsp_basic_8inl-example.html#a20">phsp_basic.inl</a>, <a class="el" href="phsp_chain_8inl-example.html#a16">phsp_chain.inl</a>, <a class="el" href="phsp_reweighting_8inl-example.html#a20">phsp_reweighting.inl</a>, <a class="el" href="phsp_unweighting_8inl-example.html#a20">phsp_unweighting.inl</a>, <a class="el" href="phsp_unweighting_functor_8inl-example.html#a20">phsp_unweighting_functor.inl</a>, and <a class="el" href="pseudo_experiment_8inl-example.html#a47">pseudo_experiment.inl</a>.</dd>
</dl>
</div>
</div>
<a id="a390592daf1ffc898bb26a468c09c17f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a390592daf1ffc898bb26a468c09c17f8">&#9670;&nbsp;</a></span>meld()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;hydra::detail::Backend BACKEND, typename ... T, typename ... U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacehydra.html#classhydra_1_1Range">hydra::Range</a>&lt; hydra::thrust::zip_iterator&lt; typename <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1tuple__cat__type">detail::tuple_cat_type</a>&lt;typename <a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt;hydra::thrust::tuple&lt;T...&gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt;BACKEND&gt; &gt;::iterator_tuple,typename <a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt;hydra::thrust::tuple&lt;U...&gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt;BACKEND&gt; &gt;::iterator_tuple&gt;::type&gt; &gt; hydra::meld </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; hydra::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; hydra::thrust::tuple&lt; U... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a80fad279987242786b27065cd239f604"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80fad279987242786b27065cd239f604">&#9670;&nbsp;</a></span>minus()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F1 , typename F2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;(<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt;F1&gt;::value || <a class="el" href="structhydra_1_1detail_1_1is__hydra__lambda.html">detail::is_hydra_lambda</a>&lt;F1&gt;::value ) &amp;&amp;(<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt;F2&gt;::value || <a class="el" href="structhydra_1_1detail_1_1is__hydra__lambda.html">detail::is_hydra_lambda</a>&lt;F2&gt;::value ),<a class="el" href="classhydra_1_1Minus.html">Minus</a>&lt;F1, F2&gt; &gt;::type hydra::minus </td>
          <td>(</td>
          <td class="paramtype">F1 const &amp;&#160;</td>
          <td class="paramname"><em>f1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F2 const &amp;&#160;</td>
          <td class="paramname"><em>f2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad0b00e7787e93fe0624bb0422409b482"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0b00e7787e93fe0624bb0422409b482">&#9670;&nbsp;</a></span>multiply()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F1 , typename F2 , typename ... Fs&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;(<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt;F1&gt;::value || <a class="el" href="structhydra_1_1detail_1_1is__hydra__lambda.html">detail::is_hydra_lambda</a>&lt;F1&gt;::value ) &amp;&amp;(<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt;F2&gt;::value || <a class="el" href="structhydra_1_1detail_1_1is__hydra__lambda.html">detail::is_hydra_lambda</a>&lt;F2&gt;::value ) &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1all__true.html">detail::all_true</a>&lt;(<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt;Fs&gt;::value || <a class="el" href="structhydra_1_1detail_1_1is__hydra__lambda.html">detail::is_hydra_lambda</a>&lt;Fs&gt;::value )...&gt;::value,<a class="el" href="classhydra_1_1Multiply.html">Multiply</a>&lt;F1, F2,Fs...&gt; &gt;::type hydra::multiply </td>
          <td>(</td>
          <td class="paramtype">F1 const &amp;&#160;</td>
          <td class="paramname"><em>f1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F2 const &amp;&#160;</td>
          <td class="paramname"><em>f2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Fs const &amp;...&#160;</td>
          <td class="paramname"><em>functors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2f06ee4cd16c4cd697a380053748bf67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f06ee4cd16c4cd697a380053748bf67">&#9670;&nbsp;</a></span>nint()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespace_3globalScope_4.html#classint">int</a> hydra::nint </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Round to nearest integer. </p>
<p>Rounds half integers to the nearest even integer. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="ab5fd2d8f62c3075ccdd36241e8dc6881"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5fd2d8f62c3075ccdd36241e8dc6881">&#9670;&nbsp;</a></span>norm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> T hydra::norm </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#a9d2c06cb9672fe86dbeaa65e8f35a2bf">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="dalitz_plot_8C-example.html#a17">dalitz_plot.C</a>, and <a class="el" href="dalitz_plot_8inl-example.html#a18">dalitz_plot.inl</a>.</dd>
</dl>
</div>
</div>
<a id="a24943c0d2419a40a68f0fb61e0a1b05f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24943c0d2419a40a68f0fb61e0a1b05f">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> bool hydra::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#a9d2c06cb9672fe86dbeaa65e8f35a2bf">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#a9d2c06cb9672fe86dbeaa65e8f35a2bf">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a716c80436ab96c757325cae3cd517960"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a716c80436ab96c757325cae3cd517960">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> bool hydra::operator!= </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#a9d2c06cb9672fe86dbeaa65e8f35a2bf">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a91d952f42e31697e4b457b1a58424cb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91d952f42e31697e4b457b1a58424cb5">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> bool hydra::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#a9d2c06cb9672fe86dbeaa65e8f35a2bf">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa51499fa04d39681eb6244313d32a16c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa51499fa04d39681eb6244313d32a16c">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t N, hydra::detail::Backend BACKEND1, hydra::detail::Backend BACKEND2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool hydra::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#classhydra_1_1multiarray">multiarray</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND1 &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#classhydra_1_1multiarray">multiarray</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND2 &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a295dd80678d0052fd65fa6cf68d67faf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a295dd80678d0052fd65fa6cf68d67faf">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND1, hydra::detail::Backend BACKEND2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool hydra::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; hydra::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND1 &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; hydra::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND2 &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad01febd59c4dfebc87b5d363955d65db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad01febd59c4dfebc87b5d363955d65db">&#9670;&nbsp;</a></span>operator*() <span class="overload">[1/15]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> Vector3R hydra::operator* </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector3R &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0dce6130507b07eaac142c1815ade3f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dce6130507b07eaac142c1815ade3f2">&#9670;&nbsp;</a></span>operator*() <span class="overload">[2/15]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> Vector3R hydra::operator* </td>
          <td>(</td>
          <td class="paramtype">const Vector3R &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afd42c2a636a5bfb4e605ddd9f1ea069a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd42c2a636a5bfb4e605ddd9f1ea069a">&#9670;&nbsp;</a></span>operator*() <span class="overload">[3/15]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> hydra::operator* </td>
          <td>(</td>
          <td class="paramtype">const Vector3R &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector3R &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7578f3dee6f04171d8ebb4316b59cbd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7578f3dee6f04171d8ebb4316b59cbd0">&#9670;&nbsp;</a></span>operator*() <span class="overload">[4/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;(<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt;T1&gt;::value || <a class="el" href="structhydra_1_1detail_1_1is__hydra__lambda.html">detail::is_hydra_lambda</a>&lt;T1&gt;::value ) &amp;&amp;(<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt;T2&gt;::value || <a class="el" href="structhydra_1_1detail_1_1is__hydra__lambda.html">detail::is_hydra_lambda</a>&lt;T2&gt;::value ),<a class="el" href="classhydra_1_1Multiply.html">Multiply</a>&lt;T1, T2&gt; &gt;::type hydra::operator* </td>
          <td>(</td>
          <td class="paramtype">T1 const &amp;&#160;</td>
          <td class="paramname"><em>F1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2 const &amp;&#160;</td>
          <td class="paramname"><em>F2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae5bae5caa4d9b5c0190220e55f650859"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5bae5caa4d9b5c0190220e55f650859">&#9670;&nbsp;</a></span>operator*() <span class="overload">[5/15]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> Vector4R hydra::operator* </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector4R &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6888146476615c2854543f7a087ba39e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6888146476615c2854543f7a087ba39e">&#9670;&nbsp;</a></span>operator*() <span class="overload">[6/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;(<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt;T&gt;::value || <a class="el" href="structhydra_1_1detail_1_1is__hydra__lambda.html">detail::is_hydra_lambda</a>&lt;T&gt;::value ) &amp;&amp;(std::is_arithmetic&lt;U&gt;::value),<a class="el" href="classhydra_1_1Multiply.html">Multiply</a>&lt; <a class="el" href="structhydra_1_1Constant.html">Constant</a>&lt;U&gt;, T&gt; &gt;::type hydra::operator* </td>
          <td>(</td>
          <td class="paramtype">U const&#160;</td>
          <td class="paramname"><em>cte</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>F</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae2b0be1f22ac4914bd6ce0bc97411bff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2b0be1f22ac4914bd6ce0bc97411bff">&#9670;&nbsp;</a></span>operator*() <span class="overload">[7/15]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> Vector4R hydra::operator* </td>
          <td>(</td>
          <td class="paramtype">const Vector4R &amp;&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa2721dd323f0709db66d4883bc4b1d72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2721dd323f0709db66d4883bc4b1d72">&#9670;&nbsp;</a></span>operator*() <span class="overload">[8/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;(<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt;T&gt;::value || <a class="el" href="structhydra_1_1detail_1_1is__hydra__lambda.html">detail::is_hydra_lambda</a>&lt;T&gt;::value ) &amp;&amp;(std::is_arithmetic&lt;U&gt;::value),<a class="el" href="classhydra_1_1Multiply.html">Multiply</a>&lt; <a class="el" href="structhydra_1_1Constant.html">Constant</a>&lt;U&gt;, T&gt; &gt;::type hydra::operator* </td>
          <td>(</td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U&#160;</td>
          <td class="paramname"><em>cte</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="adb096b020e55914fe7a1e885dd66b17e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb096b020e55914fe7a1e885dd66b17e">&#9670;&nbsp;</a></span>operator*() <span class="overload">[9/15]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> hydra::operator* </td>
          <td>(</td>
          <td class="paramtype">const Vector4R &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector4R &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a269f7c2fafb8f0c9bd28b5104c6c3ea1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a269f7c2fafb8f0c9bd28b5104c6c3ea1">&#9670;&nbsp;</a></span>operator*() <span class="overload">[10/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;(<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt;T&gt;::value || <a class="el" href="structhydra_1_1detail_1_1is__hydra__lambda.html">detail::is_hydra_lambda</a>&lt;T&gt;::value ) &amp;&amp;(std::is_arithmetic&lt;U&gt;::value),<a class="el" href="classhydra_1_1Multiply.html">Multiply</a>&lt; <a class="el" href="structhydra_1_1Constant.html">Constant</a>&lt;<a class="el" href="namespacehydra.html#a9d2c06cb9672fe86dbeaa65e8f35a2bf">hydra::complex</a>&lt;U&gt; &gt;, T&gt; &gt;::type hydra::operator* </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#a9d2c06cb9672fe86dbeaa65e8f35a2bf">hydra::complex</a>&lt; U &gt; const &amp;&#160;</td>
          <td class="paramname"><em>cte</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>F</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a31922e38da8d20b98cf9f5e3f0270621"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31922e38da8d20b98cf9f5e3f0270621">&#9670;&nbsp;</a></span>operator*() <span class="overload">[11/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::tuple&lt;T...&gt; hydra::operator* </td>
          <td>(</td>
          <td class="paramtype">const hydra::thrust::tuple&lt; T... &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const hydra::thrust::tuple&lt; T... &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4f5602c01e2c9d618b5461201c93e2db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f5602c01e2c9d618b5461201c93e2db">&#9670;&nbsp;</a></span>operator*() <span class="overload">[12/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;(<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt;T&gt;::value || <a class="el" href="structhydra_1_1detail_1_1is__hydra__lambda.html">detail::is_hydra_lambda</a>&lt;T&gt;::value ) &amp;&amp;(std::is_arithmetic&lt;U&gt;::value),<a class="el" href="classhydra_1_1Multiply.html">Multiply</a>&lt; <a class="el" href="structhydra_1_1Constant.html">Constant</a>&lt;U&gt;, T&gt; &gt;::type hydra::operator* </td>
          <td>(</td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#a9d2c06cb9672fe86dbeaa65e8f35a2bf">hydra::complex</a>&lt; U &gt; const &amp;&#160;</td>
          <td class="paramname"><em>cte</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0b98f3604eca3a6023551cd4ce98020a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b98f3604eca3a6023551cd4ce98020a">&#9670;&nbsp;</a></span>operator*() <span class="overload">[13/15]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a> hydra::operator* </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a>&#160;</td>
          <td class="paramname"><em>par1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a> const &amp;&#160;</td>
          <td class="paramname"><em>par2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac480ecaec81a0040f3b466ca5904ed5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac480ecaec81a0040f3b466ca5904ed5b">&#9670;&nbsp;</a></span>operator*() <span class="overload">[14/15]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> hydra::operator* </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a>&#160;</td>
          <td class="paramname"><em>par1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>&#160;</td>
          <td class="paramname"><em>par2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa0bc15a0070c95cad2a9b6e300b430cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0bc15a0070c95cad2a9b6e300b430cc">&#9670;&nbsp;</a></span>operator*() <span class="overload">[15/15]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> hydra::operator* </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>&#160;</td>
          <td class="paramname"><em>par1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a> const &amp;&#160;</td>
          <td class="paramname"><em>par2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1c1fc13eb2a4a440f72991b4347a472c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c1fc13eb2a4a440f72991b4347a472c">&#9670;&nbsp;</a></span>operator+() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> Vector3R hydra::operator+ </td>
          <td>(</td>
          <td class="paramtype">const Vector3R &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector3R &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab86f27679e7fe8ecdc8e541844be6d4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab86f27679e7fe8ecdc8e541844be6d4e">&#9670;&nbsp;</a></span>operator+() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;(<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt;T1&gt;::value || <a class="el" href="structhydra_1_1detail_1_1is__hydra__lambda.html">detail::is_hydra_lambda</a>&lt;T1&gt;::value ) &amp;&amp;(<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt;T2&gt;::value || <a class="el" href="structhydra_1_1detail_1_1is__hydra__lambda.html">detail::is_hydra_lambda</a>&lt;T2&gt;::value ),<a class="el" href="classhydra_1_1Sum.html">Sum</a>&lt;T1, T2&gt; &gt;::type hydra::operator+ </td>
          <td>(</td>
          <td class="paramtype">T1 const &amp;&#160;</td>
          <td class="paramname"><em>F1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2 const &amp;&#160;</td>
          <td class="paramname"><em>F2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>operator+ for two functors. </p>

</div>
</div>
<a id="abee85dffaf46da1811e0cd22acd275f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abee85dffaf46da1811e0cd22acd275f4">&#9670;&nbsp;</a></span>operator+() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::tuple&lt;T...&gt; hydra::operator+ </td>
          <td>(</td>
          <td class="paramtype">const hydra::thrust::tuple&lt; T... &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const hydra::thrust::tuple&lt; T... &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af211604c6cf6319359dd12f375b35b4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af211604c6cf6319359dd12f375b35b4d">&#9670;&nbsp;</a></span>operator+() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;(<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt;T&gt;::value || <a class="el" href="structhydra_1_1detail_1_1is__hydra__lambda.html">detail::is_hydra_lambda</a>&lt;T&gt;::value ) &amp;&amp;(std::is_arithmetic&lt;U&gt;::value),<a class="el" href="classhydra_1_1Sum.html">Sum</a>&lt; <a class="el" href="structhydra_1_1Constant.html">Constant</a>&lt;U&gt;, T&gt; &gt;::type hydra::operator+ </td>
          <td>(</td>
          <td class="paramtype">U const&#160;</td>
          <td class="paramname"><em>cte</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>F</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>operator+ for a value and a functor. </p>

</div>
</div>
<a id="ae714861f3eacb01ee0d377c4cba58f17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae714861f3eacb01ee0d377c4cba58f17">&#9670;&nbsp;</a></span>operator+() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;(<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt;T&gt;::value || <a class="el" href="structhydra_1_1detail_1_1is__hydra__lambda.html">detail::is_hydra_lambda</a>&lt;T&gt;::value ) &amp;&amp;(std::is_arithmetic&lt;U&gt;::value),<a class="el" href="classhydra_1_1Sum.html">Sum</a>&lt; <a class="el" href="structhydra_1_1Constant.html">Constant</a>&lt;U&gt;, T&gt; &gt;::type hydra::operator+ </td>
          <td>(</td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U&#160;</td>
          <td class="paramname"><em>cte</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>operator+ for a value and a functor. </p>

</div>
</div>
<a id="acf71333237dfa78b46ecee56661beccb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf71333237dfa78b46ecee56661beccb">&#9670;&nbsp;</a></span>operator+() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;(<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt;T&gt;::value || <a class="el" href="structhydra_1_1detail_1_1is__hydra__lambda.html">detail::is_hydra_lambda</a>&lt;T&gt;::value ) &amp;&amp;(std::is_arithmetic&lt;U&gt;::value),<a class="el" href="classhydra_1_1Sum.html">Sum</a>&lt; <a class="el" href="structhydra_1_1Constant.html">Constant</a>&lt;<a class="el" href="namespacehydra.html#a9d2c06cb9672fe86dbeaa65e8f35a2bf">hydra::complex</a>&lt;U&gt; &gt;, T&gt; &gt;::type hydra::operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#a9d2c06cb9672fe86dbeaa65e8f35a2bf">hydra::complex</a>&lt; U &gt; const &amp;&#160;</td>
          <td class="paramname"><em>cte</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>F</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>operator+ for a complex value and a functor. </p>

</div>
</div>
<a id="a5a08ed0df33d16aa922ba9a4fe3874b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a08ed0df33d16aa922ba9a4fe3874b6">&#9670;&nbsp;</a></span>operator+() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;(<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt;T&gt;::value || <a class="el" href="structhydra_1_1detail_1_1is__hydra__lambda.html">detail::is_hydra_lambda</a>&lt;T&gt;::value ) &amp;&amp;(std::is_arithmetic&lt;U&gt;::value),<a class="el" href="classhydra_1_1Sum.html">Sum</a>&lt; <a class="el" href="structhydra_1_1Constant.html">Constant</a>&lt;U&gt;, T&gt; &gt;::type hydra::operator+ </td>
          <td>(</td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#a9d2c06cb9672fe86dbeaa65e8f35a2bf">hydra::complex</a>&lt; U &gt; const &amp;&#160;</td>
          <td class="paramname"><em>cte</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>operator+ for a complex value and a functor. </p>

</div>
</div>
<a id="af68a4c9bed0e1a2cf2ed9ba9ab057dd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af68a4c9bed0e1a2cf2ed9ba9ab057dd0">&#9670;&nbsp;</a></span>operator+() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> Vector4R hydra::operator+ </td>
          <td>(</td>
          <td class="paramtype">const Vector4R &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector4R &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a26e3492eb046c39e1b578738cd5ad7b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26e3492eb046c39e1b578738cd5ad7b7">&#9670;&nbsp;</a></span>operator+() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a> hydra::operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a>&#160;</td>
          <td class="paramname"><em>par1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a> const &amp;&#160;</td>
          <td class="paramname"><em>par2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a357a28a5ec78cd838e8e90face792425"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a357a28a5ec78cd838e8e90face792425">&#9670;&nbsp;</a></span>operator+() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> hydra::operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a>&#160;</td>
          <td class="paramname"><em>par1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>&#160;</td>
          <td class="paramname"><em>par2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af69233e29f096db5c17391b64a4ad0c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af69233e29f096db5c17391b64a4ad0c2">&#9670;&nbsp;</a></span>operator-() <span class="overload">[1/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;(<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt;T1&gt;::value || <a class="el" href="structhydra_1_1detail_1_1is__hydra__lambda.html">detail::is_hydra_lambda</a>&lt;T1&gt;::value ) &amp;&amp;(<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt;T2&gt;::value || <a class="el" href="structhydra_1_1detail_1_1is__hydra__lambda.html">detail::is_hydra_lambda</a>&lt;T2&gt;::value ),<a class="el" href="classhydra_1_1Minus.html">Minus</a>&lt;T1, T2&gt; &gt;::type hydra::operator- </td>
          <td>(</td>
          <td class="paramtype">T1 const &amp;&#160;</td>
          <td class="paramname"><em>F1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2 const &amp;&#160;</td>
          <td class="paramname"><em>F2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a71916daad41dcd1b16ba317699b32da9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71916daad41dcd1b16ba317699b32da9">&#9670;&nbsp;</a></span>operator-() <span class="overload">[2/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;(<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt;T&gt;::value || <a class="el" href="structhydra_1_1detail_1_1is__hydra__lambda.html">detail::is_hydra_lambda</a>&lt;T&gt;::value ) &amp;&amp;(std::is_arithmetic&lt;U&gt;::value),<a class="el" href="classhydra_1_1Minus.html">Minus</a>&lt; <a class="el" href="structhydra_1_1Constant.html">Constant</a>&lt;U&gt;, T&gt; &gt;::type hydra::operator- </td>
          <td>(</td>
          <td class="paramtype">U const&#160;</td>
          <td class="paramname"><em>cte</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>F</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1113b35a5588af8a55453fbd5e1b2651"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1113b35a5588af8a55453fbd5e1b2651">&#9670;&nbsp;</a></span>operator-() <span class="overload">[3/11]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> Vector3R hydra::operator- </td>
          <td>(</td>
          <td class="paramtype">const Vector3R &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector3R &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a130d9256bfd5704541edabcf0908f204"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a130d9256bfd5704541edabcf0908f204">&#9670;&nbsp;</a></span>operator-() <span class="overload">[4/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;(<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt;T&gt;::value || <a class="el" href="structhydra_1_1detail_1_1is__hydra__lambda.html">detail::is_hydra_lambda</a>&lt;T&gt;::value ) &amp;&amp;(std::is_arithmetic&lt;U&gt;::value),<a class="el" href="classhydra_1_1Minus.html">Minus</a>&lt; <a class="el" href="structhydra_1_1Constant.html">Constant</a>&lt;U&gt;, T&gt; &gt;::type hydra::operator- </td>
          <td>(</td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U&#160;</td>
          <td class="paramname"><em>cte</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad8ff276fd53d98090384b19ce18863f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8ff276fd53d98090384b19ce18863f1">&#9670;&nbsp;</a></span>operator-() <span class="overload">[5/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;(<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt;T&gt;::value || <a class="el" href="structhydra_1_1detail_1_1is__hydra__lambda.html">detail::is_hydra_lambda</a>&lt;T&gt;::value ) &amp;&amp;(std::is_arithmetic&lt;U&gt;::value),<a class="el" href="classhydra_1_1Minus.html">Minus</a>&lt; <a class="el" href="structhydra_1_1Constant.html">Constant</a>&lt;<a class="el" href="namespacehydra.html#a9d2c06cb9672fe86dbeaa65e8f35a2bf">hydra::complex</a>&lt;U&gt; &gt;, T&gt; &gt;::type hydra::operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#a9d2c06cb9672fe86dbeaa65e8f35a2bf">hydra::complex</a>&lt; U &gt; const &amp;&#160;</td>
          <td class="paramname"><em>cte</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>F</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a49d56f7e522b7ce37781b28b79620b54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49d56f7e522b7ce37781b28b79620b54">&#9670;&nbsp;</a></span>operator-() <span class="overload">[6/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::tuple&lt;T...&gt; hydra::operator- </td>
          <td>(</td>
          <td class="paramtype">const hydra::thrust::tuple&lt; T... &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const hydra::thrust::tuple&lt; T... &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a330909b1bc1e1189c88bd560a7217a0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a330909b1bc1e1189c88bd560a7217a0d">&#9670;&nbsp;</a></span>operator-() <span class="overload">[7/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;(<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt;T&gt;::value || <a class="el" href="structhydra_1_1detail_1_1is__hydra__lambda.html">detail::is_hydra_lambda</a>&lt;T&gt;::value ) &amp;&amp;(std::is_arithmetic&lt;U&gt;::value),<a class="el" href="classhydra_1_1Minus.html">Minus</a>&lt; <a class="el" href="structhydra_1_1Constant.html">Constant</a>&lt;U&gt;, T&gt; &gt;::type hydra::operator- </td>
          <td>(</td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#a9d2c06cb9672fe86dbeaa65e8f35a2bf">hydra::complex</a>&lt; U &gt; const &amp;&#160;</td>
          <td class="paramname"><em>cte</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a950f2d5dc4356f6c6c13b9fc3bc7c0ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a950f2d5dc4356f6c6c13b9fc3bc7c0ef">&#9670;&nbsp;</a></span>operator-() <span class="overload">[8/11]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> Vector4R hydra::operator- </td>
          <td>(</td>
          <td class="paramtype">const Vector4R &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector4R &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a68375d62444cb2341ade99f0ac15972f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68375d62444cb2341ade99f0ac15972f">&#9670;&nbsp;</a></span>operator-() <span class="overload">[9/11]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a> hydra::operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a>&#160;</td>
          <td class="paramname"><em>par1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a> const &amp;&#160;</td>
          <td class="paramname"><em>par2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a07c46e4c59a5208f5d495b4ddaf3af75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07c46e4c59a5208f5d495b4ddaf3af75">&#9670;&nbsp;</a></span>operator-() <span class="overload">[10/11]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> hydra::operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a>&#160;</td>
          <td class="paramname"><em>par1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>&#160;</td>
          <td class="paramname"><em>par2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a247f457807559c67d34c5b9d15c0b4b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a247f457807559c67d34c5b9d15c0b4b4">&#9670;&nbsp;</a></span>operator-() <span class="overload">[11/11]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> hydra::operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>&#160;</td>
          <td class="paramname"><em>par1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a>&#160;</td>
          <td class="paramname"><em>par2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa3b16aaa8206238e19f573a8b0f07730"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3b16aaa8206238e19f573a8b0f07730">&#9670;&nbsp;</a></span>operator/() <span class="overload">[1/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;(<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt;T1&gt;::value || <a class="el" href="structhydra_1_1detail_1_1is__hydra__lambda.html">detail::is_hydra_lambda</a>&lt;T1&gt;::value) &amp;&amp;(<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt;T2&gt;::value || <a class="el" href="structhydra_1_1detail_1_1is__hydra__lambda.html">detail::is_hydra_lambda</a>&lt;T2&gt;::value),<a class="el" href="classhydra_1_1Divide.html">Divide</a>&lt;T1, T2&gt; &gt;::type hydra::operator/ </td>
          <td>(</td>
          <td class="paramtype">T1 const &amp;&#160;</td>
          <td class="paramname"><em>F1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2 const &amp;&#160;</td>
          <td class="paramname"><em>F2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a94cb4a79113148abd78aa8e4d6f7e41d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94cb4a79113148abd78aa8e4d6f7e41d">&#9670;&nbsp;</a></span>operator/() <span class="overload">[2/11]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> Vector3R hydra::operator/ </td>
          <td>(</td>
          <td class="paramtype">const Vector3R &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aac9b820e211bbd962531959dc1a78fb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac9b820e211bbd962531959dc1a78fb3">&#9670;&nbsp;</a></span>operator/() <span class="overload">[3/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;(<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt;T&gt;::value || <a class="el" href="structhydra_1_1detail_1_1is__hydra__lambda.html">detail::is_hydra_lambda</a>&lt;T&gt;::value ) &amp;&amp;(std::is_arithmetic&lt;U&gt;::value),<a class="el" href="classhydra_1_1Divide.html">Divide</a>&lt; <a class="el" href="structhydra_1_1Constant.html">Constant</a>&lt;U&gt;, T&gt; &gt;::type hydra::operator/ </td>
          <td>(</td>
          <td class="paramtype">U const&#160;</td>
          <td class="paramname"><em>cte</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>F</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1c3da5b1d54199b2e9af2b84ca58cb9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c3da5b1d54199b2e9af2b84ca58cb9c">&#9670;&nbsp;</a></span>operator/() <span class="overload">[4/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;(<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt;T&gt;::value || <a class="el" href="structhydra_1_1detail_1_1is__hydra__lambda.html">detail::is_hydra_lambda</a>&lt;T&gt;::value ) &amp;&amp;(std::is_arithmetic&lt;U&gt;::value),<a class="el" href="classhydra_1_1Divide.html">Divide</a>&lt; <a class="el" href="structhydra_1_1Constant.html">Constant</a>&lt;U&gt;, T&gt; &gt;::type hydra::operator/ </td>
          <td>(</td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U&#160;</td>
          <td class="paramname"><em>cte</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a437843c59b2b049d7867bf08aa2ac121"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a437843c59b2b049d7867bf08aa2ac121">&#9670;&nbsp;</a></span>operator/() <span class="overload">[5/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;(<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt;T&gt;::value || <a class="el" href="structhydra_1_1detail_1_1is__hydra__lambda.html">detail::is_hydra_lambda</a>&lt;T&gt;::value ) &amp;&amp;(std::is_arithmetic&lt;U&gt;::value),<a class="el" href="classhydra_1_1Divide.html">Divide</a>&lt; <a class="el" href="structhydra_1_1Constant.html">Constant</a>&lt;<a class="el" href="namespacehydra.html#a9d2c06cb9672fe86dbeaa65e8f35a2bf">hydra::complex</a>&lt;U&gt; &gt;, T&gt; &gt;::type hydra::operator/ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#a9d2c06cb9672fe86dbeaa65e8f35a2bf">hydra::complex</a>&lt; U &gt; const &amp;&#160;</td>
          <td class="paramname"><em>cte</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>F</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7c88c44916843fa91a8ecc8179640685"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c88c44916843fa91a8ecc8179640685">&#9670;&nbsp;</a></span>operator/() <span class="overload">[6/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;(<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt;T&gt;::value || <a class="el" href="structhydra_1_1detail_1_1is__hydra__lambda.html">detail::is_hydra_lambda</a>&lt;T&gt;::value ) &amp;&amp;(std::is_arithmetic&lt;U&gt;::value),<a class="el" href="classhydra_1_1Divide.html">Divide</a>&lt; <a class="el" href="structhydra_1_1Constant.html">Constant</a>&lt;<a class="el" href="namespacehydra.html#a9d2c06cb9672fe86dbeaa65e8f35a2bf">hydra::complex</a>&lt;U&gt; &gt;, T&gt; &gt;::type hydra::operator/ </td>
          <td>(</td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#a9d2c06cb9672fe86dbeaa65e8f35a2bf">hydra::complex</a>&lt; U &gt; const &amp;&#160;</td>
          <td class="paramname"><em>cte</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4db4d6d0e3fe03dccf661b7ac0751fe7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4db4d6d0e3fe03dccf661b7ac0751fe7">&#9670;&nbsp;</a></span>operator/() <span class="overload">[7/11]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> Vector4R hydra::operator/ </td>
          <td>(</td>
          <td class="paramtype">const Vector4R &amp;&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8c87c4ccd857a5c017a3657b29db4df8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c87c4ccd857a5c017a3657b29db4df8">&#9670;&nbsp;</a></span>operator/() <span class="overload">[8/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::tuple&lt;T...&gt; hydra::operator/ </td>
          <td>(</td>
          <td class="paramtype">const hydra::thrust::tuple&lt; T... &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const hydra::thrust::tuple&lt; T... &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac9b1664e58d41d5f8e7ec6d1c20bf9c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9b1664e58d41d5f8e7ec6d1c20bf9c0">&#9670;&nbsp;</a></span>operator/() <span class="overload">[9/11]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a> hydra::operator/ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a>&#160;</td>
          <td class="paramname"><em>par1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a> const&#160;</td>
          <td class="paramname"><em>par2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0a4133d480d7e9f3f5e85286e47a3709"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a4133d480d7e9f3f5e85286e47a3709">&#9670;&nbsp;</a></span>operator/() <span class="overload">[10/11]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> hydra::operator/ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a>&#160;</td>
          <td class="paramname"><em>par1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>&#160;</td>
          <td class="paramname"><em>par2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af29cde1e70c62bec6f1fa1ee52940887"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af29cde1e70c62bec6f1fa1ee52940887">&#9670;&nbsp;</a></span>operator/() <span class="overload">[11/11]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> hydra::operator/ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>&#160;</td>
          <td class="paramname"><em>par1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a>&#160;</td>
          <td class="paramname"><em>par2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a15cdb083719133399edb77f5ef3eb547"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15cdb083719133399edb77f5ef3eb547">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t N, typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; hydra::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; T, N &gt; const &amp;&#160;</td>
          <td class="paramname"><em>obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6fab8d226ee701c0755c60202fc30f6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fab8d226ee701c0755c60202fc30f6c">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; hydra::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::tuple&lt; T... &gt; const &amp;&#160;</td>
          <td class="paramname"><em>obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad4d7f13d811f0d63d4ce49d31b6cfbe0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4d7f13d811f0d63d4ce49d31b6cfbe0">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; hydra::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::pair&lt; T1, T2 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3fa8037907332bf633dfc1bc3b40865c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fa8037907332bf633dfc1bc3b40865c">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ostream&amp; hydra::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector3R &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aaacce78528c9499de97312cbe606ece4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaacce78528c9499de97312cbe606ece4">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ostream&amp; hydra::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector4R &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad3be8e63c60c604b927f9638600a598b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3be8e63c60c604b927f9638600a598b">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; hydra::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__fit.html#classhydra_1_1UserParameters">UserParameters</a> const &amp;&#160;</td>
          <td class="paramname"><em>par</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classhydra_1_1Print.html">Print</a> the ROOT::Minuit2 state to stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>std::ostream </td></tr>
    <tr><td class="paramname">par</td><td><a class="el" href="group__fit.html#classhydra_1_1UserParameters" title="Class implementing a interface to ROOT::Minuit2::MnUserParameters. ">hydra::UserParameters</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a21d7262b80d73f956ed1a477607b9053"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21d7262b80d73f956ed1a477607b9053">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , class charT , class traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::basic_ostream&lt; charT,traits &gt;&amp; hydra::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::basic_ostream&lt; charT, traits &gt; &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#a9d2c06cb9672fe86dbeaa65e8f35a2bf">complex</a>&lt; ValueType &gt; &amp;&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adb57654e359a17e312e9aef986f956a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb57654e359a17e312e9aef986f956a8">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; hydra::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a> const &amp;&#160;</td>
          <td class="paramname"><em>var</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aea70aec01321527f54717a004a3df99d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea70aec01321527f54717a004a3df99d">&#9670;&nbsp;</a></span>operator==() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> bool hydra::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#a9d2c06cb9672fe86dbeaa65e8f35a2bf">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#a9d2c06cb9672fe86dbeaa65e8f35a2bf">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a227370a3dddcea864f09490bc65b93ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a227370a3dddcea864f09490bc65b93ad">&#9670;&nbsp;</a></span>operator==() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> bool hydra::operator== </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#a9d2c06cb9672fe86dbeaa65e8f35a2bf">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a99bf5390aa3ab39e8ac0cd109ef6b7c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99bf5390aa3ab39e8ac0cd109ef6b7c9">&#9670;&nbsp;</a></span>operator==() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> bool hydra::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#a9d2c06cb9672fe86dbeaa65e8f35a2bf">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab3bafbf7fa6e97bc40b02d74d7d596ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3bafbf7fa6e97bc40b02d74d7d596ea">&#9670;&nbsp;</a></span>operator==() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t N, hydra::detail::Backend BACKEND1, hydra::detail::Backend BACKEND2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool hydra::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#classhydra_1_1multiarray">multiarray</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND1 &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#classhydra_1_1multiarray">multiarray</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND2 &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a859dbfadafdb7de2fe58343b80555a6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a859dbfadafdb7de2fe58343b80555a6b">&#9670;&nbsp;</a></span>operator==() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND1, hydra::detail::Backend BACKEND2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool hydra::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; hydra::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND1 &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; hydra::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND2 &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a63ad8f84031200c3161c889507d3a9c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63ad8f84031200c3161c889507d3a9c0">&#9670;&nbsp;</a></span>operator&gt;&gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename charT , class traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::basic_istream&lt; charT,traits &gt;&amp; hydra::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::basic_istream&lt; charT, traits &gt; &amp;&#160;</td>
          <td class="paramname"><em>is</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#a9d2c06cb9672fe86dbeaa65e8f35a2bf">complex</a>&lt; ValueType &gt; &amp;&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4e1791730fd6db81f61c76881fa37a75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e1791730fd6db81f61c76881fa37a75">&#9670;&nbsp;</a></span>operator|() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterable , typename Functor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">hydra::thrust::detail::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">detail::is_iterable</a>&lt;Iterable&gt;::value &amp;&amp; ( <a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt;Functor&gt;::value || <a class="el" href="structhydra_1_1detail_1_1is__hydra__lambda.html">detail::is_hydra_lambda</a>&lt;Functor&gt;::value ) , <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt;decltype(std::declval&lt; const Iterable&gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()), Functor&gt; &gt;::type hydra::operator| </td>
          <td>(</td>
          <td class="paramtype">Iterable const &amp;&#160;</td>
          <td class="paramname"><em>iterable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Functor const &amp;&#160;</td>
          <td class="paramname"><em>functor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0ee022f8e7ac910d13bdda4d79415652"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ee022f8e7ac910d13bdda4d79415652">&#9670;&nbsp;</a></span>operator|() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterable , typename Functor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">hydra::thrust::detail::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">detail::is_iterable</a>&lt;Iterable&gt;::value &amp;&amp; (<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt;Functor&gt;::value || <a class="el" href="structhydra_1_1detail_1_1is__hydra__lambda.html">detail::is_hydra_lambda</a>&lt;Functor&gt;::value ), <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt;decltype(std::declval&lt;Iterable&gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()), Functor&gt; &gt;::type hydra::operator| </td>
          <td>(</td>
          <td class="paramtype">Iterable &amp;&amp;&#160;</td>
          <td class="paramname"><em>iterable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Functor const &amp;&#160;</td>
          <td class="paramname"><em>functor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8d01c3dc710d6d9c8950f67d03cdb14c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d01c3dc710d6d9c8950f67d03cdb14c">&#9670;&nbsp;</a></span>phase_space_range()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt;hydra::thrust::transform_iterator&lt; <a class="el" href="structhydra_1_1detail_1_1GenerateDecay.html">detail::GenerateDecay</a>&lt;N,hydra::thrust::random::default_random_engine&gt;, hydra::thrust::counting_iterator&lt;size_t&gt;, typename <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1tuple__cat__type">hydra::detail::tuple_cat_type</a>&lt; hydra::thrust::tuple&lt;<a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&gt;, typename <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1tuple__type">hydra::detail::tuple_type</a>&lt;N,Vector4R&gt;::type&gt;::type&gt; &gt; hydra::phase_space_range </td>
          <td>(</td>
          <td class="paramtype">Vector4R const &amp;&#160;</td>
          <td class="paramname"><em>mother</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>, N &gt;&#160;</td>
          <td class="paramname"><em>masses</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="range_semantics_8inl-example.html#a22">range_semantics.inl</a>.</dd>
</dl>
</div>
</div>
<a id="ae85d86e6980bcf24de91a003711b3224"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae85d86e6980bcf24de91a003711b3224">&#9670;&nbsp;</a></span>pmf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> hydra::pmf </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td>
          <td class="paramname"><em>mother_mass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td>
          <td class="paramname"><em>daughter1_mass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td>
          <td class="paramname"><em>daughter2_mass</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Momentum in mother frame of daughter particle in two-body-decay. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mother_mass</td><td></td></tr>
    <tr><td class="paramname">daughter1_mass</td><td></td></tr>
    <tr><td class="paramname">daughter2_mass</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="ae3cc52fabc8882be13d9a6ca92fc648e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3cc52fabc8882be13d9a6ca92fc648e">&#9670;&nbsp;</a></span>polar()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespacehydra.html#a9d2c06cb9672fe86dbeaa65e8f35a2bf">complex</a>&lt;T&gt; hydra::polar </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>theta</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a95aad7e7e244a3cb3c71a4d57e695511"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95aad7e7e244a3cb3c71a4d57e695511">&#9670;&nbsp;</a></span>pow() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , unsigned int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> T hydra::pow </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Power with integer exponent. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="ac2256bff965f5a7359591579a97114ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2256bff965f5a7359591579a97114ec">&#9670;&nbsp;</a></span>pow() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespacehydra.html#a9d2c06cb9672fe86dbeaa65e8f35a2bf">complex</a>&lt;T&gt; hydra::pow </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#a9d2c06cb9672fe86dbeaa65e8f35a2bf">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#a9d2c06cb9672fe86dbeaa65e8f35a2bf">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="dalitz_plot_8C-example.html#a43">dalitz_plot.C</a>, <a class="el" href="dalitz_plot_8inl-example.html#a46">dalitz_plot.inl</a>, <a class="el" href="gaussian_plus_argus_8inl-example.html#a33">gaussian_plus_argus.inl</a>, <a class="el" href="phsp_basic_8inl-example.html#a12">phsp_basic.inl</a>, <a class="el" href="phsp_chain_8inl-example.html#a10">phsp_chain.inl</a>, <a class="el" href="phsp_reweighting_8inl-example.html#a12">phsp_reweighting.inl</a>, <a class="el" href="phsp_unweighting_8inl-example.html#a12">phsp_unweighting.inl</a>, and <a class="el" href="phsp_unweighting_functor_8inl-example.html#a12">phsp_unweighting_functor.inl</a>.</dd>
</dl>
</div>
</div>
<a id="a4cf806d100f53f6d281b8b826697e10f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cf806d100f53f6d281b8b826697e10f">&#9670;&nbsp;</a></span>pow() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespacehydra.html#a9d2c06cb9672fe86dbeaa65e8f35a2bf">complex</a>&lt;T&gt; hydra::pow </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#a9d2c06cb9672fe86dbeaa65e8f35a2bf">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2e9146d77dfa5b6c0fcbcb31557f6854"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e9146d77dfa5b6c0fcbcb31557f6854">&#9670;&nbsp;</a></span>pow() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespacehydra.html#a9d2c06cb9672fe86dbeaa65e8f35a2bf">complex</a>&lt;T&gt; hydra::pow </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#a9d2c06cb9672fe86dbeaa65e8f35a2bf">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aee265139cfc0f8d933bae711850feb4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee265139cfc0f8d933bae711850feb4a">&#9670;&nbsp;</a></span>pow() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespacehydra.html#a9d2c06cb9672fe86dbeaa65e8f35a2bf">complex</a>&lt; typename hydra::thrust::detail::promoted_numerical_type&lt; T, U &gt;::type &gt; hydra::pow </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#a9d2c06cb9672fe86dbeaa65e8f35a2bf">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#a9d2c06cb9672fe86dbeaa65e8f35a2bf">complex</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a60f026a6918ec1392c7d9e7bb0a48f90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60f026a6918ec1392c7d9e7bb0a48f90">&#9670;&nbsp;</a></span>pow() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespacehydra.html#a9d2c06cb9672fe86dbeaa65e8f35a2bf">complex</a>&lt; typename hydra::thrust::detail::promoted_numerical_type&lt; T, U &gt;::type &gt; hydra::pow </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#a9d2c06cb9672fe86dbeaa65e8f35a2bf">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7d616da905f7096cf297aad08b2c23e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d616da905f7096cf297aad08b2c23e3">&#9670;&nbsp;</a></span>pow() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespacehydra.html#a9d2c06cb9672fe86dbeaa65e8f35a2bf">complex</a>&lt; typename hydra::thrust::detail::promoted_numerical_type&lt; T, U &gt;::type &gt; hydra::pow </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#a9d2c06cb9672fe86dbeaa65e8f35a2bf">complex</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acb0c9817024c69efe44c2d9653928519"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb0c9817024c69efe44c2d9653928519">&#9670;&nbsp;</a></span>PrintToStream()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void hydra::PrintToStream </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>ostream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ace0454750e3561d390ee18b96824227c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace0454750e3561d390ee18b96824227c">&#9670;&nbsp;</a></span>proj()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespacehydra.html#a9d2c06cb9672fe86dbeaa65e8f35a2bf">complex</a>&lt;T&gt; hydra::proj </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae624fce02dd351435098431f13679919"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae624fce02dd351435098431f13679919">&#9670;&nbsp;</a></span>random_range()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Engine  = hydra::default_random_engine, typename Functor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; hydra::thrust::transform_iterator&lt; <a class="el" href="structhydra_1_1detail_1_1Sampler.html">detail::Sampler</a>&lt;Functor,Engine &gt;, hydra::thrust::counting_iterator&lt;size_t&gt;, typename <a class="el" href="structhydra_1_1detail_1_1Sampler.html">detail::Sampler</a>&lt;Functor,Engine&gt;::value_type &gt; &gt; hydra::random_range </td>
          <td>(</td>
          <td class="paramtype">Functor const &amp;&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>seed</em> = <code>0x8ec74d321e6b5a27</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>rng_jump</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="basic_fit_8inl-example.html#a19">basic_fit.inl</a>, <a class="el" href="fit_gaussian_8C-example.html#a16">fit_gaussian.C</a>, <a class="el" href="fit_johnson_8C-example.html#a13">fit_johnson.C</a>, <a class="el" href="range_semantics_8inl-example.html#a11">range_semantics.inl</a>, and <a class="el" href="simultaneous_fit_8inl-example.html#a19">simultaneous_fit.inl</a>.</dd>
</dl>
</div>
</div>
<a id="a57a8dad11538cee5058cf0f6755f26a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57a8dad11538cee5058cf0f6755f26a3">&#9670;&nbsp;</a></span>range() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt;hydra::thrust::counting_iterator&lt;long <a class="el" href="namespace_3globalScope_4.html#classint">int</a>&gt; &gt; hydra::range </td>
          <td>(</td>
          <td class="paramtype">long <a class="el" href="namespace_3globalScope_4.html#classint">int</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long <a class="el" href="namespace_3globalScope_4.html#classint">int</a>&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="booststrapping_8inl-example.html#a4">booststrapping.inl</a>, <a class="el" href="dense_histogram_8inl-example.html#a14">dense_histogram.inl</a>, and <a class="el" href="fit_convoluted_pdfs_8inl-example.html#a36">fit_convoluted_pdfs.inl</a>.</dd>
</dl>
</div>
</div>
<a id="ab3208533344bd3938c87afbfd7d4d01b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3208533344bd3938c87afbfd7d4d01b">&#9670;&nbsp;</a></span>range() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_floating_point&lt;T&gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt;hydra::thrust::counting_iterator&lt;<a class="el" href="namespace_3globalScope_4.html#classunsigned">unsigned</a>&gt;, <a class="el" href="structhydra_1_1detail_1_1range_1_1Shift.html">detail::range::Shift</a>&lt;T&gt; &gt; &gt;::type hydra::range </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_3globalScope_4.html#classunsigned">unsigned</a>&#160;</td>
          <td class="paramname"><em>nbins</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a589e3fc7f3e94613126a8198bf90dd59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a589e3fc7f3e94613126a8198bf90dd59">&#9670;&nbsp;</a></span>Range&lt; iterator_type &gt;() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="basic__distributions_8inl.html#a9717e7bbecb906637e86cef6da3d83c2">return</a> <a class="el" href="namespacehydra.html#classhydra_1_1Range">hydra::Range</a>&lt; <a class="el" href="namespacehydra.html#a89686ff2116120de2d9e2ad6889a47de">iterator_type</a> &gt; </td>
          <td>(</td>
          <td class="paramtype">other.&#160;</td>
          <td class="paramname"><em>begin</em>cls..., </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">other.&#160;</td>
          <td class="paramname"><em>end</em>cls...&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{</div><div class="line"></div><div class="line">    <span class="keyword">typedef</span> decltype( other.begin(cls...)) <a class="code" href="namespacehydra.html#a89686ff2116120de2d9e2ad6889a47de">iterator_type</a></div><div class="ttc" id="namespacehydra_html_a89686ff2116120de2d9e2ad6889a47de"><div class="ttname"><a href="namespacehydra.html#a89686ff2116120de2d9e2ad6889a47de">hydra::iterator_type</a></div><div class="ttdeci">decltype(other.begin(placeholders::placeholder&lt; I &gt;{})) typedef iterator_type</div><div class="ttdef"><b>Definition:</b> multivector.h:1594</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="abf9723fecdbba95ef0e6ccfd8b30994a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf9723fecdbba95ef0e6ccfd8b30994a">&#9670;&nbsp;</a></span>Range&lt; iterator_type &gt;() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="basic__distributions_8inl.html#a9717e7bbecb906637e86cef6da3d83c2">return</a> <a class="el" href="namespacehydra.html#classhydra_1_1Range">hydra::Range</a>&lt; <a class="el" href="namespacehydra.html#a89686ff2116120de2d9e2ad6889a47de">iterator_type</a> &gt; </td>
          <td>(</td>
          <td class="paramtype">other.&#160;</td>
          <td class="paramname"><em>begin</em>placeholders::placeholder&lt; I &gt;{}, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">other.&#160;</td>
          <td class="paramname"><em>end</em>placeholders::placeholder&lt; I &gt;{}&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aadcca49207bf7ab79088f28cddb8f21d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadcca49207bf7ab79088f28cddb8f21d">&#9670;&nbsp;</a></span>rbegin() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::rbegin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="basic__distributions_8inl.html#a4900ef306eb9271438791f1a98b8ccba">C</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td> -&gt;  decltype(std::forward&lt; <a class="el" href="basic__distributions_8inl.html#a4900ef306eb9271438791f1a98b8ccba">C</a> &gt;(c).rbegin())</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a434c6a6c1a24dbd8ca880af38694803d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a434c6a6c1a24dbd8ca880af38694803d">&#9670;&nbsp;</a></span>rbegin() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::rbegin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="basic__distributions_8inl.html#a4900ef306eb9271438791f1a98b8ccba">C</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td> -&gt;  decltype(c.rbegin())</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0d87c9638b5f275d1fbbef560a3c0197"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d87c9638b5f275d1fbbef560a3c0197">&#9670;&nbsp;</a></span>rbegin() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T * hydra::rbegin </td>
          <td>(</td>
          <td class="paramtype">T(&amp;)&#160;</td>
          <td class="paramname"><em>array</em>[N]</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a69daea4927958e8a666ee6ed3a795cbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69daea4927958e8a666ee6ed3a795cbd">&#9670;&nbsp;</a></span>rbegin() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename T , size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::rbegin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#classhydra_1_1multiarray">multiarray</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(other.rbegin(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt;I&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a932ef4185794129e04c9a4220db464eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a932ef4185794129e04c9a4220db464eb">&#9670;&nbsp;</a></span>rbegin() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename T , size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::rbegin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#classhydra_1_1multiarray">multiarray</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(other.rbegin(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt;I&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2f0fb8d425a7340b07a03c08f4f3e73b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f0fb8d425a7340b07a03c08f4f3e73b">&#9670;&nbsp;</a></span>rbegin() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::rbegin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; hydra::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> -&gt; decltype(other.rbegin(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt;I&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af274ce4fee4b9c77c3f992939f29d8af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af274ce4fee4b9c77c3f992939f29d8af">&#9670;&nbsp;</a></span>rbegin() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::rbegin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; hydra::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> -&gt; decltype(other.rbegin(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt;I&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a81e867dc81c5f6665b28b83f873e4d7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81e867dc81c5f6665b28b83f873e4d7c">&#9670;&nbsp;</a></span>reduce() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterable &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;<a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt;Iterable&gt;::value,typename hydra::thrust::iterator_traits&lt;decltype(std::declval&lt;Iterable&gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>())&gt;::value_type &gt;::type hydra::reduce </td>
          <td>(</td>
          <td class="paramtype">Iterable &amp;&amp;&#160;</td>
          <td class="paramname"><em>iterable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a63b9d5a2744d5acc0852b40f5262eb17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63b9d5a2744d5acc0852b40f5262eb17">&#9670;&nbsp;</a></span>reduce() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterable , typename Functor , typename T  = typename hydra::thrust::iterator_traits&lt;		     decltype(std::declval&lt;Iterable&gt;().begin())&gt;::value_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;<a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt;Iterable&gt;::value, T &gt;::type hydra::reduce </td>
          <td>(</td>
          <td class="paramtype">Iterable &amp;&amp;&#160;</td>
          <td class="paramname"><em>iterable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Functor const &amp;&#160;</td>
          <td class="paramname"><em>binary_functor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a58e00797465282d00eeaf0cd82d1c076"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58e00797465282d00eeaf0cd82d1c076">&#9670;&nbsp;</a></span>rend() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::rend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="basic__distributions_8inl.html#a4900ef306eb9271438791f1a98b8ccba">C</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td> -&gt;  decltype(std::forward&lt; <a class="el" href="basic__distributions_8inl.html#a4900ef306eb9271438791f1a98b8ccba">C</a> &gt;(c).rend())</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a48be0e2a44047208c68e2c096683db35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48be0e2a44047208c68e2c096683db35">&#9670;&nbsp;</a></span>rend() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::rend </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="basic__distributions_8inl.html#a4900ef306eb9271438791f1a98b8ccba">C</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td> -&gt;  decltype(c.rend())</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7f3625ffa0bf89a7d056a0d2b226e882"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f3625ffa0bf89a7d056a0d2b226e882">&#9670;&nbsp;</a></span>rend() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T * hydra::rend </td>
          <td>(</td>
          <td class="paramtype">T(&amp;)&#160;</td>
          <td class="paramname"><em>array</em>[N]</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad79366fdc5ac96950ef240f03e0321b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad79366fdc5ac96950ef240f03e0321b5">&#9670;&nbsp;</a></span>rend() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename T , size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::rend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#classhydra_1_1multiarray">multiarray</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(other.rend(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt;I&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a175fc3749a8859251e455ea11b8739f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a175fc3749a8859251e455ea11b8739f8">&#9670;&nbsp;</a></span>rend() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename T , size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::rend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#classhydra_1_1multiarray">multiarray</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(other.rend(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt;I&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1872dcef050553663eec1f029a5a1449"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1872dcef050553663eec1f029a5a1449">&#9670;&nbsp;</a></span>rend() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::rend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; hydra::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> -&gt; decltype(other.rend(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt;I&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3b966d2403c1766f3b6ce6f97c4bd3fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b966d2403c1766f3b6ce6f97c4bd3fa">&#9670;&nbsp;</a></span>rend() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::rend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; hydra::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> -&gt; decltype(other.rend(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt;I&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a95552751864e14c366dd5ea7186d2ff4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95552751864e14c366dd5ea7186d2ff4">&#9670;&nbsp;</a></span>reverse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterable &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">hydra::thrust::detail::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">detail::is_iterable</a>&lt;Iterable&gt;::value , <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; hydra::thrust::reverse_iterator&lt; decltype(std::declval&lt;Iterable&gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()) &gt; &gt; &gt;::type hydra::reverse </td>
          <td>(</td>
          <td class="paramtype">Iterable &amp;&amp;&#160;</td>
          <td class="paramname"><em>iterable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad27ce158f82bfcf3ba0855a224a3f626"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad27ce158f82bfcf3ba0855a224a3f626">&#9670;&nbsp;</a></span>rint()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> hydra::rint </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4a9e21c7083ea65e58667297a801f0c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a9e21c7083ea65e58667297a801f0c0">&#9670;&nbsp;</a></span>rotateEuler() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> Vector4R hydra::rotateEuler </td>
          <td>(</td>
          <td class="paramtype">const Vector4R &amp;&#160;</td>
          <td class="paramname"><em>rs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>&#160;</td>
          <td class="paramname"><em>gamma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab9637ed446b2f89c3514f57bac1fd1be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9637ed446b2f89c3514f57bac1fd1be">&#9670;&nbsp;</a></span>rotateEuler() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> Vector3R hydra::rotateEuler </td>
          <td>(</td>
          <td class="paramtype">const Vector3R &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>&#160;</td>
          <td class="paramname"><em>phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>&#160;</td>
          <td class="paramname"><em>ksi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aeefa8e6c3af06dd76fce7b15bfeb3d8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeefa8e6c3af06dd76fce7b15bfeb3d8d">&#9670;&nbsp;</a></span>sample() <span class="overload">[1/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RNG , typename DerivedPolicy , typename Functor , typename Iterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1random_1_1is__callable.html">detail::random::is_callable</a>&lt; Functor &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1random_1_1is__iterator.html">detail::random::is_iterator</a>&lt; Iterator &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; Iterator &gt; &gt;::type hydra::sample </td>
          <td>(</td>
          <td class="paramtype">hydra::thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; const &amp;&#160;</td>
          <td class="paramname"><em>policy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td>
          <td class="paramname"><em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Functor const &amp;&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>seed</em> = <code>0xb56c4feeef1b</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>rng_jump</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fill a range with numbers distributed according a user defined distribution. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">policy</td><td>backend to perform the calculation. </td></tr>
    <tr><td class="paramname">begin</td><td>beginning of the range storing the generated values </td></tr>
    <tr><td class="paramname">end</td><td>ending of the range storing the generated values </td></tr>
    <tr><td class="paramname">min</td><td>lower limit of sampling region </td></tr>
    <tr><td class="paramname">max</td><td>upper limit of sampling region. </td></tr>
    <tr><td class="paramname">functor</td><td>distribution to be sampled </td></tr>
    <tr><td class="paramname">max_pdf</td><td>maximum pdf value for accept-reject method. If no value is set, the maximum value in the sample is used. </td></tr>
    <tr><td class="paramname">rng_seed</td><td>seed for the underlying pseudo-random number generator </td></tr>
    <tr><td class="paramname">rng_jump</td><td>sequence offset for the underlying pseudo-random number generator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>range with the generated values </dd></dl>

</div>
</div>
<a id="abdbd3d61d9788560832b988d7f091d94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdbd3d61d9788560832b988d7f091d94">&#9670;&nbsp;</a></span>sample() <span class="overload">[2/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RNG , typename Functor , typename Iterator , hydra::detail::Backend BACKEND&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1random_1_1is__callable.html">detail::random::is_callable</a>&lt; Functor &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1random_1_1is__iterator.html">detail::random::is_iterator</a>&lt; Iterator &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; Iterator &gt; &gt;::type hydra::sample </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; const &amp;&#160;</td>
          <td class="paramname"><em>policy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td>
          <td class="paramname"><em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Functor const &amp;&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>seed</em> = <code>0xb56c4feeef1b</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>rng_jump</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fill a range with numbers distributed according a user defined distribution. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">policy</td><td>backend to perform the calculation. </td></tr>
    <tr><td class="paramname">begin</td><td>beginning of the range storing the generated values </td></tr>
    <tr><td class="paramname">end</td><td>ending of the range storing the generated values </td></tr>
    <tr><td class="paramname">min</td><td>lower limit of sampling region </td></tr>
    <tr><td class="paramname">max</td><td>upper limit of sampling region. </td></tr>
    <tr><td class="paramname">functor</td><td>distribution to be sampled </td></tr>
    <tr><td class="paramname">max_pdf</td><td>maximum pdf value for accept-reject method. If no value is set, the maximum value in the sample is used. </td></tr>
    <tr><td class="paramname">rng_seed</td><td>seed for the underlying pseudo-random number generator </td></tr>
    <tr><td class="paramname">rng_jump</td><td>sequence offset for the underlying pseudo-random number generator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>range with the generated values </dd></dl>

</div>
</div>
<a id="a94f8c5c248211faf04726d832275af49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94f8c5c248211faf04726d832275af49">&#9670;&nbsp;</a></span>sample() <span class="overload">[3/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RNG , typename Functor , typename Iterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1random_1_1is__callable.html">detail::random::is_callable</a>&lt; Functor &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1random_1_1is__iterator.html">detail::random::is_iterator</a>&lt; Iterator &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; Iterator &gt; &gt;::type hydra::sample </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td>
          <td class="paramname"><em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Functor const &amp;&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>seed</em> = <code>0xb56c4feeef1b</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>rng_jump</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fill a range with numbers distributed according a user defined distribution. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>beginning of the range storing the generated values </td></tr>
    <tr><td class="paramname">end</td><td>ending of the range storing the generated values </td></tr>
    <tr><td class="paramname">min</td><td>lower limit of sampling region </td></tr>
    <tr><td class="paramname">max</td><td>upper limit of sampling region. </td></tr>
    <tr><td class="paramname">functor</td><td>distribution to be sampled </td></tr>
    <tr><td class="paramname">max_pdf</td><td>maximum pdf value for accept-reject method. If no value is set, the maximum value in the sample is used. </td></tr>
    <tr><td class="paramname">rng_seed</td><td>seed for the underlying pseudo-random number generator </td></tr>
    <tr><td class="paramname">rng_jump</td><td>sequence offset for the underlying pseudo-random number generator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>range with the generated values </dd></dl>

</div>
</div>
<a id="ad56d9801d61654d7fd47841afa712ebd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad56d9801d61654d7fd47841afa712ebd">&#9670;&nbsp;</a></span>sample() <span class="overload">[4/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RNG , typename Functor , typename Iterable &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1random_1_1is__callable.html">detail::random::is_callable</a>&lt; Functor &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1random_1_1is__iterable.html">detail::random::is_iterable</a>&lt; Iterable &gt;::value,<a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; decltype(std::declval&lt; Iterable &gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>())&gt; &gt;::type hydra::sample </td>
          <td>(</td>
          <td class="paramtype">Iterable &amp;&amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td>
          <td class="paramname"><em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Functor const &amp;&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>seed</em> = <code>0xb56c4feeef1b</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>rng_jump</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fill a range with numbers distributed according a user defined distribution. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">output</td><td>range storing the generated values </td></tr>
    <tr><td class="paramname">min</td><td>lower limit of sampling region </td></tr>
    <tr><td class="paramname">max</td><td>upper limit of sampling region. </td></tr>
    <tr><td class="paramname">functor</td><td>distribution to be sampled </td></tr>
    <tr><td class="paramname">max_pdf</td><td>maximum pdf value for accept-reject method. If no value is set, the maximum value in the sample is used. </td></tr>
    <tr><td class="paramname">rng_seed</td><td>seed for the underlying pseudo-random number generator </td></tr>
    <tr><td class="paramname">rng_jump</td><td>sequence offset for the underlying pseudo-random number generator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>range with the generated values </dd></dl>

</div>
</div>
<a id="accd7b2510c1c22431252d15d956b9c1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accd7b2510c1c22431252d15d956b9c1b">&#9670;&nbsp;</a></span>sample() <span class="overload">[5/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RNG , typename DerivedPolicy , typename Functor , typename Iterator , size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1random_1_1is__callable.html">detail::random::is_callable</a>&lt;Functor&gt;::value &amp;&amp; <a class="el" href="structhydra_1_1detail_1_1random_1_1is__iterator.html">detail::random::is_iterator</a>&lt;Iterator&gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt;Iterator&gt;&gt;::type hydra::sample </td>
          <td>(</td>
          <td class="paramtype">hydra::thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; const &amp;&#160;</td>
          <td class="paramname"><em>policy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>, N &gt;const &amp;&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>, N &gt;const &amp;&#160;</td>
          <td class="paramname"><em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Functor const &amp;&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>seed</em> = <code>0xb56c4feeef1b</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>rng_jump</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fill a range with numbers distributed according a user defined distribution. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">policy</td><td>backend to perform the calculation. </td></tr>
    <tr><td class="paramname">begin</td><td>beginning of the range storing the generated values </td></tr>
    <tr><td class="paramname">end</td><td>ending of the range storing the generated values </td></tr>
    <tr><td class="paramname">min</td><td>array of lower limits of sampling region </td></tr>
    <tr><td class="paramname">max</td><td>array of upper limits of sampling region. </td></tr>
    <tr><td class="paramname">max_pdf</td><td>maximum pdf value for accept-reject method. If no value is set, the maximum value in the sample is used. </td></tr>
    <tr><td class="paramname">rng_seed</td><td>seed for the underlying pseudo-random number generator </td></tr>
    <tr><td class="paramname">rng_jump</td><td>sequence offset for the underlying pseudo-random number generator </td></tr>
    <tr><td class="paramname">functor</td><td>distribution to be sampled </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a74d72b60139be864da3acc8dee2b3cd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74d72b60139be864da3acc8dee2b3cd2">&#9670;&nbsp;</a></span>sample() <span class="overload">[6/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RNG , typename Functor , typename Iterator , hydra::detail::Backend BACKEND, size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1random_1_1is__callable.html">detail::random::is_callable</a>&lt; Functor &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1random_1_1is__iterator.html">detail::random::is_iterator</a>&lt; Iterator &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; Iterator &gt; &gt;::type hydra::sample </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; const &amp;&#160;</td>
          <td class="paramname"><em>policy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>, N &gt;const &amp;&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>, N &gt;const &amp;&#160;</td>
          <td class="paramname"><em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Functor const &amp;&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>seed</em> = <code>0xb56c4feeef1b</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>rng_jump</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fill a range with numbers distributed according a user defined distribution. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">policy</td><td>backend to perform the calculation. </td></tr>
    <tr><td class="paramname">begin</td><td>beginning of the range storing the generated values </td></tr>
    <tr><td class="paramname">end</td><td>ending of the range storing the generated values </td></tr>
    <tr><td class="paramname">min</td><td>array of lower limits of sampling region </td></tr>
    <tr><td class="paramname">max</td><td>array of upper limits of sampling region. </td></tr>
    <tr><td class="paramname">max_pdf</td><td>maximum pdf value for accept-reject method. If no value is set, the maximum value in the sample is used. </td></tr>
    <tr><td class="paramname">rng_seed</td><td>seed for the underlying pseudo-random number generator </td></tr>
    <tr><td class="paramname">rng_jump</td><td>sequence offset for the underlying pseudo-random number generator </td></tr>
    <tr><td class="paramname">functor</td><td>distribution to be sampled </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1ced8bd2c8181d3d6f2d07b1513fc265"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ced8bd2c8181d3d6f2d07b1513fc265">&#9670;&nbsp;</a></span>sample() <span class="overload">[7/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RNG , typename Functor , typename Iterator , size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1random_1_1is__callable.html">detail::random::is_callable</a>&lt;Functor&gt;::value &amp;&amp; <a class="el" href="structhydra_1_1detail_1_1random_1_1is__iterator.html">detail::random::is_iterator</a>&lt;Iterator&gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt;Iterator&gt;&gt;::type hydra::sample </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>, N &gt;const &amp;&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>, N &gt;const &amp;&#160;</td>
          <td class="paramname"><em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Functor const &amp;&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>seed</em> = <code>0xb56c4feeef1b</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>rng_jump</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fill a range with numbers distributed according a user defined distribution. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>beginning of the range storing the generated values </td></tr>
    <tr><td class="paramname">end</td><td>ending of the range storing the generated values </td></tr>
    <tr><td class="paramname">min</td><td>array of lower limits of sampling region </td></tr>
    <tr><td class="paramname">max</td><td>array of upper limits of sampling region. </td></tr>
    <tr><td class="paramname">functor</td><td>distribution to be sampled </td></tr>
    <tr><td class="paramname">max_pdf</td><td>maximum pdf value for accept-reject method. If no value is set, the maximum value in the sample is used. </td></tr>
    <tr><td class="paramname">rng_seed</td><td>seed for the underlying pseudo-random number generator </td></tr>
    <tr><td class="paramname">rng_jump</td><td>sequence offset for the underlying pseudo-random number generator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>range with the generated values </dd></dl>

</div>
</div>
<a id="a412b8c1fc9904852adebe877474f739a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a412b8c1fc9904852adebe877474f739a">&#9670;&nbsp;</a></span>sample() <span class="overload">[8/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RNG , typename Functor , typename Iterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;<a class="el" href="structhydra_1_1detail_1_1random_1_1is__callable.html">detail::random::is_callable</a>&lt;Functor&gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1random_1_1is__iterator.html">detail::random::is_iterator</a>&lt;Iterator&gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1is__tuple__type.html">detail::is_tuple_type</a>&lt; decltype(*std::declval&lt;Iterator&gt;))&gt;::value,<a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt;Iterator&gt; &gt;::type hydra::sample </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Functor::argument_type const &amp;&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Functor::argument_type const &amp;&#160;</td>
          <td class="paramname"><em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Functor const &amp;&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>rng_jump</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4c41cef4b543ccd17e24018e36b758ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c41cef4b543ccd17e24018e36b758ad">&#9670;&nbsp;</a></span>sample() <span class="overload">[9/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RNG , typename Functor , typename Iterable , size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1random_1_1is__callable.html">detail::random::is_callable</a>&lt;Functor&gt;::value &amp;&amp; <a class="el" href="structhydra_1_1detail_1_1random_1_1is__iterable.html">detail::random::is_iterable</a>&lt;Iterable&gt;::value , <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; decltype(std::declval&lt;Iterable&gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>())&gt;&gt;::type hydra::sample </td>
          <td>(</td>
          <td class="paramtype">Iterable &amp;&amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>, N &gt;const &amp;&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>, N &gt;const &amp;&#160;</td>
          <td class="paramname"><em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Functor const &amp;&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>seed</em> = <code>0xb56c4feeef1b</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>rng_jump</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fill a range with numbers distributed according a user defined distribution. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">output</td><td>range storing the generated values </td></tr>
    <tr><td class="paramname">min</td><td>array of lower limits of sampling region </td></tr>
    <tr><td class="paramname">max</td><td>array of upper limits of sampling region. </td></tr>
    <tr><td class="paramname">functor</td><td>distribution to be sampled </td></tr>
    <tr><td class="paramname">max_pdf</td><td>maximum pdf value for accept-reject method. If no value is set, the maximum value in the sample is used. </td></tr>
    <tr><td class="paramname">rng_seed</td><td>seed for the underlying pseudo-random number generator </td></tr>
    <tr><td class="paramname">rng_jump</td><td>sequence offset for the underlying pseudo-random number generator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>output range with the generated values </dd></dl>

</div>
</div>
<a id="ad3f7e6110746692937a4925af19f3476"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3f7e6110746692937a4925af19f3476">&#9670;&nbsp;</a></span>sample() <span class="overload">[10/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RNG , typename Functor , typename Iterable &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1random_1_1is__callable.html">detail::random::is_callable</a>&lt; Functor &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1random_1_1is__iterable.html">detail::random::is_iterable</a>&lt; Iterable &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1is__tuple__type.html">detail::is_tuple_type</a>&lt; decltype(*std::declval&lt; Iterable &gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>())&gt;::value,<a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; decltype(std::declval&lt; Iterable &gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>())&gt; &gt;::type hydra::sample </td>
          <td>(</td>
          <td class="paramtype">Iterable &amp;&amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Functor::argument_type const &amp;&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Functor::argument_type const &amp;&#160;</td>
          <td class="paramname"><em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Functor const &amp;&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>seed</em> = <code>0xb56c4feeef1b</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>rng_jump</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fill a range with numbers distributed according a user defined distribution. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">output</td><td>range storing the generated values </td></tr>
    <tr><td class="paramname">min</td><td>tuple of lower limits of sampling region </td></tr>
    <tr><td class="paramname">max</td><td>tuple of upper limits of sampling region. </td></tr>
    <tr><td class="paramname">functor</td><td>distribution to be sampled </td></tr>
    <tr><td class="paramname">max_pdf</td><td>maximum pdf value for accept-reject method. If no value is set, the maximum value in the sample is used. </td></tr>
    <tr><td class="paramname">rng_seed</td><td>seed for the underlying pseudo-random number generator </td></tr>
    <tr><td class="paramname">rng_jump</td><td>sequence offset for the underlying pseudo-random number generator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>output range with the generated values </dd></dl>

</div>
</div>
<a id="adc25aa814da94f10c50c8d5c0e6b23db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc25aa814da94f10c50c8d5c0e6b23db">&#9670;&nbsp;</a></span>sample() <span class="overload">[11/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RNG  = default_random_engine, typename Functor , typename Iterator , size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;<a class="el" href="structhydra_1_1detail_1_1random_1_1is__callable.html">detail::random::is_callable</a>&lt;Functor&gt;::value &amp;&amp; <a class="el" href="structhydra_1_1detail_1_1random_1_1is__iterator.html">detail::random::is_iterator</a>&lt;Iterator&gt;::value,<a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt;Iterator&gt; &gt;::type hydra::sample </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>, N &gt;const &amp;&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>, N &gt;const &amp;&#160;</td>
          <td class="paramname"><em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Functor const &amp;&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>seed</em> = <code>0xb56c4feeef1b</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>rng_jump</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fill a range with numbers distributed according a user defined distribution. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>beginning of the range storing the generated values </td></tr>
    <tr><td class="paramname">end</td><td>ending of the range storing the generated values </td></tr>
    <tr><td class="paramname">min</td><td>array of lower limits of sampling region </td></tr>
    <tr><td class="paramname">max</td><td>array of upper limits of sampling region. </td></tr>
    <tr><td class="paramname">functor</td><td>distribution to be sampled </td></tr>
    <tr><td class="paramname">max_pdf</td><td>maximum pdf value for accept-reject method. If no value is set, the maximum value in the sample is used. </td></tr>
    <tr><td class="paramname">rng_seed</td><td>seed for the underlying pseudo-random number generator </td></tr>
    <tr><td class="paramname">rng_jump</td><td>sequence offset for the underlying pseudo-random number generator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>range with the generated values </dd></dl>

</div>
</div>
<a id="a18d244688e1a333fb925e222eeeb17d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18d244688e1a333fb925e222eeeb17d9">&#9670;&nbsp;</a></span>sample() <span class="overload">[12/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RNG  = default_random_engine, typename DerivedPolicy , typename Functor , typename Iterator , size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;<a class="el" href="structhydra_1_1detail_1_1random_1_1is__callable.html">detail::random::is_callable</a>&lt;Functor&gt;::value &amp;&amp; <a class="el" href="structhydra_1_1detail_1_1random_1_1is__iterator.html">detail::random::is_iterator</a>&lt;Iterator&gt;::value,<a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt;Iterator&gt; &gt;::type hydra::sample </td>
          <td>(</td>
          <td class="paramtype">hydra::thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; const &amp;&#160;</td>
          <td class="paramname"><em>policy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>, N &gt;const &amp;&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>, N &gt;const &amp;&#160;</td>
          <td class="paramname"><em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Functor const &amp;&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>seed</em> = <code>0xb56c4feeef1b</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>rng_jump</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fill a range with numbers distributed according a user defined distribution. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">policy</td><td>backend to perform the calculation. </td></tr>
    <tr><td class="paramname">begin</td><td>beginning of the range storing the generated values </td></tr>
    <tr><td class="paramname">end</td><td>ending of the range storing the generated values </td></tr>
    <tr><td class="paramname">min</td><td>array of lower limits of sampling region </td></tr>
    <tr><td class="paramname">max</td><td>array of upper limits of sampling region. </td></tr>
    <tr><td class="paramname">max_pdf</td><td>maximum pdf value for accept-reject method. If no value is set, the maximum value in the sample is used. </td></tr>
    <tr><td class="paramname">rng_seed</td><td>seed for the underlying pseudo-random number generator </td></tr>
    <tr><td class="paramname">rng_jump</td><td>sequence offset for the underlying pseudo-random number generator </td></tr>
    <tr><td class="paramname">functor</td><td>distribution to be sampled </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a296508ea7f57df138f13db7cdb95abc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a296508ea7f57df138f13db7cdb95abc2">&#9670;&nbsp;</a></span>sample() <span class="overload">[13/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RNG  = default_random_engine, typename Functor , typename Iterable , size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;<a class="el" href="structhydra_1_1detail_1_1random_1_1is__callable.html">detail::random::is_callable</a>&lt;Functor&gt;::value &amp;&amp; <a class="el" href="structhydra_1_1detail_1_1random_1_1is__iterable.html">detail::random::is_iterable</a>&lt;Iterable&gt;::value ,<a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; decltype(std::declval&lt;Iterable&gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>())&gt; &gt;::type hydra::sample </td>
          <td>(</td>
          <td class="paramtype">Iterable &amp;&amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>, N &gt;const &amp;&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>, N &gt;const &amp;&#160;</td>
          <td class="paramname"><em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Functor const &amp;&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>seed</em> = <code>0xb56c4feeef1b</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>rng_jump</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fill a range with numbers distributed according a user defined distribution. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">output</td><td>range storing the generated values </td></tr>
    <tr><td class="paramname">min</td><td>array of lower limits of sampling region </td></tr>
    <tr><td class="paramname">max</td><td>array of upper limits of sampling region. </td></tr>
    <tr><td class="paramname">functor</td><td>distribution to be sampled </td></tr>
    <tr><td class="paramname">max_pdf</td><td>maximum pdf value for accept-reject method. If no value is set, the maximum value in the sample is used. </td></tr>
    <tr><td class="paramname">rng_seed</td><td>seed for the underlying pseudo-random number generator </td></tr>
    <tr><td class="paramname">rng_jump</td><td>sequence offset for the underlying pseudo-random number generator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>output range with the generated values </dd></dl>

</div>
</div>
<a id="a7b62f11052cf4a8e258b21b9f64f0c6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b62f11052cf4a8e258b21b9f64f0c6d">&#9670;&nbsp;</a></span>scatter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterable_Source , typename Iterable_Target , typename Iterable_Map &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;<a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt;Iterable_Source&gt;::value &amp;&amp; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt;Iterable_Target&gt;::value &amp;&amp; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt;Iterable_Map&gt;::value,<a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt;decltype(std::declval&lt;Iterable_Target&amp;&gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>())&gt; &gt;::type hydra::scatter </td>
          <td>(</td>
          <td class="paramtype">Iterable_Source &amp;&amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterable_Map &amp;&amp;&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterable_Target &amp;&amp;&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8056e4374a5e077e4ecb940851166b51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8056e4374a5e077e4ecb940851166b51">&#9670;&nbsp;</a></span>segregate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterable , typename Functor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt;Iterable&gt;::value,std::pair&lt;<a class="el" href="namespacehydra.html#classhydra_1_1Range">hydra::Range</a>&lt;decltype(std::declval&lt;Iterable&gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>())&gt;, <a class="el" href="namespacehydra.html#classhydra_1_1Range">hydra::Range</a>&lt;decltype(std::declval&lt;Iterable&gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>())&gt; &gt; &gt;::type hydra::segregate </td>
          <td>(</td>
          <td class="paramtype">Iterable &amp;&amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Functor &amp;&amp;&#160;</td>
          <td class="paramname"><em>filter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae5337fca35f17ea6b1001e76ce351f9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5337fca35f17ea6b1001e76ce351f9e">&#9670;&nbsp;</a></span>segregate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterable , typename Functor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt;Iterable&gt;::value, std::pair&lt;<a class="el" href="namespacehydra.html#classhydra_1_1Range">hydra::Range</a>&lt;decltype(std::declval&lt;Iterable&gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>())&gt;, <a class="el" href="namespacehydra.html#classhydra_1_1Range">hydra::Range</a>&lt;decltype(std::declval&lt;Iterable&gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>())&gt; &gt; &gt;::type hydra::segregate </td>
          <td>(</td>
          <td class="paramtype">Iterable &amp;&amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Functor const &amp;&#160;</td>
          <td class="paramname"><em>filter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="acb7d0e5da38544692eb3545e81617e19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb7d0e5da38544692eb3545e81617e19">&#9670;&nbsp;</a></span>sin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespacehydra.html#a9d2c06cb9672fe86dbeaa65e8f35a2bf">complex</a>&lt;T&gt; hydra::sin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#a9d2c06cb9672fe86dbeaa65e8f35a2bf">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="dalitz_plot_8C-example.html#a30">dalitz_plot.C</a>, and <a class="el" href="dalitz_plot_8inl-example.html#a33">dalitz_plot.inl</a>.</dd>
</dl>
</div>
</div>
<a id="af59c474655ecd14c6748391d80e2e4c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af59c474655ecd14c6748391d80e2e4c2">&#9670;&nbsp;</a></span>sinh()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespacehydra.html#a9d2c06cb9672fe86dbeaa65e8f35a2bf">complex</a>&lt;T&gt; hydra::sinh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#a9d2c06cb9672fe86dbeaa65e8f35a2bf">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5b6b3a330b6d16d3221bb7b994b9329b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b6b3a330b6d16d3221bb7b994b9329b">&#9670;&nbsp;</a></span>sort() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterable , typename Iterator  = decltype(std::declval&lt;Iterable&gt;().begin())&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;<a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt;Iterable&gt;::value,<a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt;decltype(std::declval&lt;Iterable&amp;&gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>())&gt; &gt;::type hydra::sort </td>
          <td>(</td>
          <td class="paramtype">Iterable &amp;&#160;</td>
          <td class="paramname"><em>iterable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac64c757c35da63a927af0ad5147ac7c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac64c757c35da63a927af0ad5147ac7c5">&#9670;&nbsp;</a></span>sort() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterable , typename Functor , typename Iterator  = decltype(std::declval&lt;Iterable&gt;().begin())&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;<a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt;Iterable&gt;::value,<a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt;decltype(std::declval&lt;Iterable&amp;&gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>())&gt; &gt;::type hydra::sort </td>
          <td>(</td>
          <td class="paramtype">Iterable &amp;&#160;</td>
          <td class="paramname"><em>iterable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Functor const &amp;&#160;</td>
          <td class="paramname"><em>comparator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a34662231e9292fda55e3a182ea5d342a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34662231e9292fda55e3a182ea5d342a">&#9670;&nbsp;</a></span>sort_by_key() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterable , typename Iterable_Key , typename Iterator  = decltype(std::declval&lt;Iterable&gt;().begin()), typename Iterator_Key  = decltype(std::declval&lt;Iterable_Key&gt;().begin()), typename Value_Key  = decltype(*std::declval&lt;Iterator_Key&gt;().begin())&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;<a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt;Iterable&gt;::value,<a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt;decltype(std::declval&lt;Iterable&amp;&gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>())&gt; &gt;::type hydra::sort_by_key </td>
          <td>(</td>
          <td class="paramtype">Iterable &amp;&#160;</td>
          <td class="paramname"><em>iterable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterable_Key &amp;&#160;</td>
          <td class="paramname"><em>keys</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="range_semantics_8inl-example.html#a13">range_semantics.inl</a>.</dd>
</dl>
</div>
</div>
<a id="ae5d13834b7141cdaba43ad83ca671e7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5d13834b7141cdaba43ad83ca671e7a">&#9670;&nbsp;</a></span>sort_by_key() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterable , typename Iterator_Key , typename Functor , typename Iterator  = decltype(std::declval&lt;Iterable&gt;().begin()), typename Value_Key  = decltype(*std::declval&lt;Range&lt;Iterator_Key,Functor&gt;&gt;().begin())&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;<a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt;Iterable&gt;::value,<a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt;decltype(std::declval&lt;Iterable&amp;&gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>())&gt; &gt;::type hydra::sort_by_key </td>
          <td>(</td>
          <td class="paramtype">Iterable &amp;&#160;</td>
          <td class="paramname"><em>iterable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; Iterator_Key, Functor &gt;&#160;</td>
          <td class="paramname"><em>keys</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abfe40eab613a0a770c25a46e661ba808"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfe40eab613a0a770c25a46e661ba808">&#9670;&nbsp;</a></span>spline() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IterableX , typename IterableY , typename IterableM , typename TypeX , typename TypeY &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt;IterableX&gt;::value &amp;&amp; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt;IterableY&gt;::value &amp;&amp; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt;IterableM&gt;::value &amp;&amp; std::is_convertible&lt;typename IterableX::value_type, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt;::value &amp;&amp; std::is_convertible&lt;typename IterableY::value_type, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt;::value &amp;&amp; std::is_convertible&lt;typename IterableM::value_type, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt;::value &amp;&amp; std::is_convertible&lt;TypeX, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt;::value &amp;&amp; std::is_convertible&lt;TypeY, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt;::value , <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt;::type hydra::spline </td>
          <td>(</td>
          <td class="paramtype">IterableX &amp;&amp;&#160;</td>
          <td class="paramname"><em>abcissa_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IterableY &amp;&amp;&#160;</td>
          <td class="paramname"><em>abcissa_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IterableM&#160;</td>
          <td class="paramname"><em>measurements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TypeX&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TypeX&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad3cd7470ec536773f1107ff6af7c028b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3cd7470ec536773f1107ff6af7c028b">&#9670;&nbsp;</a></span>spline() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator1 , typename Iterator2 , typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> std::enable_if&lt; std::is_convertible&lt; typename hydra::thrust::iterator_traits&lt; Iterator1 &gt;::value_type, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt;::value &amp;&amp;std::is_convertible&lt; typename hydra::thrust::iterator_traits&lt; Iterator2 &gt;::value_type, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt;::value &amp;&amp;std::is_convertible&lt; Type, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt;::value, Type &gt;::type hydra::spline </td>
          <td>(</td>
          <td class="paramtype">Iterator1&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator1&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator2&#160;</td>
          <td class="paramname"><em>measurements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cubic monotone spline interpolation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Iterator1</td><td>Iterator type of the abcissae. Convertible to double </td></tr>
    <tr><td class="paramname">Iterator2</td><td>Iterator type of data to interpolate. Convertible to double </td></tr>
    <tr><td class="paramname">Type</td><td>interpolation point data. Convertible to double </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>iterator pointing to the first element of the abcissae range </td></tr>
    <tr><td class="paramname">last</td><td>iterator pointing to the last element of the abcissae range </td></tr>
    <tr><td class="paramname">measurements</td><td>iterator pointing to the first element of the data range with at least (last - first) elements </td></tr>
    <tr><td class="paramname">value</td><td>point where to calculate the interpolation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Interpolated value </dd></dl>

</div>
</div>
<a id="a75c9f64381a091df5fc576d74114c1eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75c9f64381a091df5fc576d74114c1eb">&#9670;&nbsp;</a></span>spline() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterable1 , typename Iterable2 , typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; Iterable1 &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; Iterable2 &gt;::value &amp;&amp;std::is_convertible&lt; typename Iterable1::value_type, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt;::value &amp;&amp;std::is_convertible&lt; typename Iterable2::value_type, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt;::value &amp;&amp;std::is_convertible&lt; Type, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt;::value, Type &gt;::type hydra::spline </td>
          <td>(</td>
          <td class="paramtype">Iterable1 &amp;&amp;&#160;</td>
          <td class="paramname"><em>abscissae</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterable2 &amp;&amp;&#160;</td>
          <td class="paramname"><em>ordinate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section pre"><dt>Precondition</dt><dd></dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd></dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Iterable1</td><td>Iterable range of the abcissae. Convertible to double </td></tr>
    <tr><td class="paramname">Iterable2</td><td>Iterable range of data to interpolate. Convertible to double </td></tr>
    <tr><td class="paramname">Type</td><td>Interpolation point data. Convertible to double </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">abiscissae</td><td>range of the abcissae </td></tr>
    <tr><td class="paramname">measurements</td><td>range of data to interpolate. Same size of abcissae </td></tr>
    <tr><td class="paramname">value</td><td>point where to calculate the interpolation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Interpolated value </dd></dl>

</div>
</div>
<a id="ab21df89c98da4cb935e4801272aadf3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab21df89c98da4cb935e4801272aadf3a">&#9670;&nbsp;</a></span>spline2D() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IteratorX , typename IteratorY , typename IteratorM , typename TypeX , typename TypeY &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> std::enable_if&lt; std::is_convertible&lt; typename hydra::thrust::iterator_traits&lt; IteratorX &gt;::value_type, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt;::value &amp;&amp;std::is_convertible&lt; typename hydra::thrust::iterator_traits&lt; IteratorY &gt;::value_type, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt;::value &amp;&amp;std::is_convertible&lt; typename hydra::thrust::iterator_traits&lt; IteratorM &gt;::value_type, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt;::value &amp;&amp;std::is_convertible&lt; TypeX, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt;::value &amp;&amp;std::is_convertible&lt; TypeY, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt;::value, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt;::type hydra::spline2D </td>
          <td>(</td>
          <td class="paramtype">IteratorX&#160;</td>
          <td class="paramname"><em>firstx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorX&#160;</td>
          <td class="paramname"><em>lastx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorY&#160;</td>
          <td class="paramname"><em>firsty</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorY&#160;</td>
          <td class="paramname"><em>lasty</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorM&#160;</td>
          <td class="paramname"><em>measurements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TypeX&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TypeY&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1c56eae6c288b029507ba62c90f1429c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c56eae6c288b029507ba62c90f1429c">&#9670;&nbsp;</a></span>spline2D() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IterableX , typename IterableY , typename IterableM , typename TypeX , typename TypeY &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt;IterableX&gt;::value &amp;&amp; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt;IterableY&gt;::value &amp;&amp; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt;IterableM&gt;::value &amp;&amp; std::is_convertible&lt;typename IterableX::value_type, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt;::value &amp;&amp; std::is_convertible&lt;typename IterableY::value_type, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt;::value &amp;&amp; std::is_convertible&lt;typename IterableM::value_type, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt;::value &amp;&amp; std::is_convertible&lt;TypeX, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt;::value &amp;&amp; std::is_convertible&lt;TypeY, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt;::value , <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt;::type hydra::spline2D </td>
          <td>(</td>
          <td class="paramtype">IterableX &amp;&amp;&#160;</td>
          <td class="paramname"><em>abscissa_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IterableY &amp;&amp;&#160;</td>
          <td class="paramname"><em>abscissa_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IterableM&#160;</td>
          <td class="paramname"><em>measurements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TypeX&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TypeX&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6962b0587db951690d13d7883d7088ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6962b0587db951690d13d7883d7088ee">&#9670;&nbsp;</a></span>spline3D() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IteratorX , typename IteratorY , typename IteratorZ , typename IteratorM , typename TypeX , typename TypeY , typename TypeZ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> std::enable_if&lt; std::is_convertible&lt;typename hydra::thrust::iterator_traits&lt;IteratorX&gt;::value_type, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt;::value &amp;&amp; std::is_convertible&lt;typename hydra::thrust::iterator_traits&lt;IteratorY&gt;::value_type, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt;::value &amp;&amp; std::is_convertible&lt;typename hydra::thrust::iterator_traits&lt;IteratorZ&gt;::value_type, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt;::value &amp;&amp; std::is_convertible&lt;typename hydra::thrust::iterator_traits&lt;IteratorM&gt;::value_type, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt;::value &amp;&amp; std::is_convertible&lt;TypeX, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt;::value &amp;&amp; std::is_convertible&lt;TypeY, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt;::value &amp;&amp; std::is_convertible&lt;TypeZ, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt;::value, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&gt;::type hydra::spline3D </td>
          <td>(</td>
          <td class="paramtype">IteratorX&#160;</td>
          <td class="paramname"><em>firstx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorX&#160;</td>
          <td class="paramname"><em>lastx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorY&#160;</td>
          <td class="paramname"><em>firsty</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorY&#160;</td>
          <td class="paramname"><em>lasty</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorZ&#160;</td>
          <td class="paramname"><em>firstz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorZ&#160;</td>
          <td class="paramname"><em>lastz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorM&#160;</td>
          <td class="paramname"><em>measurements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TypeX&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TypeY&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TypeZ&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac42536655f18622458ca9e69a055f4a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac42536655f18622458ca9e69a055f4a4">&#9670;&nbsp;</a></span>spline3D() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IterableX , typename IterableY , typename IterableZ , typename IterableM , typename TypeX , typename TypeY , typename TypeZ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; IterableX &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; IterableY &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; IterableZ &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; IterableM &gt;::value &amp;&amp;std::is_convertible&lt; typename IterableX::value_type, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt;::value &amp;&amp;std::is_convertible&lt; typename IterableY::value_type, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt;::value &amp;&amp;std::is_convertible&lt; typename IterableZ::value_type, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt;::value &amp;&amp;std::is_convertible&lt; typename IterableM::value_type, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt;::value &amp;&amp;std::is_convertible&lt; TypeX, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt;::value &amp;&amp;std::is_convertible&lt; TypeY, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt;::value &amp;&amp;std::is_convertible&lt; TypeZ, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt;::value, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt;::type hydra::spline3D </td>
          <td>(</td>
          <td class="paramtype">IterableX &amp;&amp;&#160;</td>
          <td class="paramname"><em>abscissa_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IterableY &amp;&amp;&#160;</td>
          <td class="paramname"><em>abscissa_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IterableZ &amp;&amp;&#160;</td>
          <td class="paramname"><em>abscissa_z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IterableM&#160;</td>
          <td class="paramname"><em>measurements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TypeX&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TypeX&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TypeZ&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a920dfa188c2124bedd5ff97e17581752"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a920dfa188c2124bedd5ff97e17581752">&#9670;&nbsp;</a></span>spline3D() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IteratorX , typename IteratorY , typename IteratorZ , typename IteratorM , typename TypeX , typename TypeY , typename TypeZ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> std::enable_if&lt; std::is_convertible&lt;typename hydra::thrust::iterator_traits&lt;IteratorX&gt;::value_type, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt;::value &amp;&amp; std::is_convertible&lt;typename hydra::thrust::iterator_traits&lt;IteratorY&gt;::value_type, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt;::value &amp;&amp; std::is_convertible&lt;typename hydra::thrust::iterator_traits&lt;IteratorZ&gt;::value_type, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt;::value &amp;&amp; std::is_convertible&lt;typename hydra::thrust::iterator_traits&lt;IteratorM&gt;::value_type, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt;::value &amp;&amp; std::is_convertible&lt;TypeX, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt;::value &amp;&amp; std::is_convertible&lt;TypeY, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt;::value &amp;&amp; std::is_convertible&lt;TypeZ, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt;::value, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&gt;::type hydra::spline3D </td>
          <td>(</td>
          <td class="paramtype">IteratorX&#160;</td>
          <td class="paramname"><em>firstx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorX&#160;</td>
          <td class="paramname"><em>lastx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorY&#160;</td>
          <td class="paramname"><em>firsty</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorY&#160;</td>
          <td class="paramname"><em>lasty</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorY&#160;</td>
          <td class="paramname"><em>firstz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorY&#160;</td>
          <td class="paramname"><em>lastz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorM&#160;</td>
          <td class="paramname"><em>measurements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TypeX&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TypeY&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TypeZ&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="adf75877945a3556c21b5f4e512c20fc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf75877945a3556c21b5f4e512c20fc7">&#9670;&nbsp;</a></span>spline3D() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IterableX , typename IterableY , typename IterableW , typename IterableZ , typename IterableM , typename TypeX , typename TypeY , typename TypeW , typename TypeZ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; IterableX &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; IterableY &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; IterableW &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; IterableZ &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; IterableM &gt;::value &amp;&amp;std::is_convertible&lt; typename IterableX::value_type, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt;::value &amp;&amp;std::is_convertible&lt; typename IterableY::value_type, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt;::value &amp;&amp;std::is_convertible&lt; typename IterableW::value_type, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt;::value &amp;&amp;std::is_convertible&lt; typename IterableZ::value_type, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt;::value &amp;&amp;std::is_convertible&lt; typename IterableM::value_type, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt;::value &amp;&amp;std::is_convertible&lt; TypeX, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt;::value &amp;&amp;std::is_convertible&lt; TypeY, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt;::value &amp;&amp;std::is_convertible&lt; TypeW, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt;::value &amp;&amp;std::is_convertible&lt; TypeZ, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt;::value, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt;::type hydra::spline3D </td>
          <td>(</td>
          <td class="paramtype">IterableX &amp;&amp;&#160;</td>
          <td class="paramname"><em>abscissa_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IterableY &amp;&amp;&#160;</td>
          <td class="paramname"><em>abscissa_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IterableW &amp;&amp;&#160;</td>
          <td class="paramname"><em>abscissa_w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IterableZ &amp;&amp;&#160;</td>
          <td class="paramname"><em>abscissa_z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IterableM&#160;</td>
          <td class="paramname"><em>measurements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TypeX&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TypeX&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TypeW&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TypeZ&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7f6ea1c8ee93dd574ab6f3fc9068f238"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f6ea1c8ee93dd574ab6f3fc9068f238">&#9670;&nbsp;</a></span>spline4D()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IteratorX , typename IteratorY , typename IteratorW , typename IteratorZ , typename IteratorM , typename TypeX , typename TypeY , typename TypeW , typename TypeZ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> std::enable_if&lt; std::is_convertible&lt; typename hydra::thrust::iterator_traits&lt; IteratorX &gt;::value_type, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt;::value &amp;&amp;std::is_convertible&lt; typename hydra::thrust::iterator_traits&lt; IteratorY &gt;::value_type, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt;::value &amp;&amp;std::is_convertible&lt; typename hydra::thrust::iterator_traits&lt; IteratorW &gt;::value_type, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt;::value &amp;&amp;std::is_convertible&lt; typename hydra::thrust::iterator_traits&lt; IteratorZ &gt;::value_type, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt;::value &amp;&amp;std::is_convertible&lt; typename hydra::thrust::iterator_traits&lt; IteratorM &gt;::value_type, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt;::value &amp;&amp;std::is_convertible&lt; TypeX, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt;::value &amp;&amp;std::is_convertible&lt; TypeY, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt;::value &amp;&amp;std::is_convertible&lt; TypeW, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt;::value &amp;&amp;std::is_convertible&lt; TypeZ, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt;::value, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt;::type hydra::spline4D </td>
          <td>(</td>
          <td class="paramtype">IteratorX&#160;</td>
          <td class="paramname"><em>firstx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorX&#160;</td>
          <td class="paramname"><em>lastx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorY&#160;</td>
          <td class="paramname"><em>firsty</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorY&#160;</td>
          <td class="paramname"><em>lasty</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorW&#160;</td>
          <td class="paramname"><em>firstw</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorW&#160;</td>
          <td class="paramname"><em>lastw</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorZ&#160;</td>
          <td class="paramname"><em>firstz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorZ&#160;</td>
          <td class="paramname"><em>lastz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorM&#160;</td>
          <td class="paramname"><em>measurements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TypeX&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TypeY&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TypeW&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TypeZ&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a74988a829019bf111e7f51d81b33eec7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74988a829019bf111e7f51d81b33eec7">&#9670;&nbsp;</a></span>sqrt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespacehydra.html#a9d2c06cb9672fe86dbeaa65e8f35a2bf">complex</a>&lt;T&gt; hydra::sqrt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#a9d2c06cb9672fe86dbeaa65e8f35a2bf">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="adaptive_gauss_kronrod_8inl-example.html#a8">adaptive_gauss_kronrod.inl</a>, <a class="el" href="binned_extended_logLL_fit_8inl-example.html#a26">binned_extended_logLL_fit.inl</a>, <a class="el" href="dense_histogram_8inl-example.html#a8">dense_histogram.inl</a>, <a class="el" href="extended_logLL_fit_8inl-example.html#a26">extended_logLL_fit.inl</a>, <a class="el" href="fit_convoluted_pdfs_8inl-example.html#a31">fit_convoluted_pdfs.inl</a>, <a class="el" href="gauss_kronrod_8inl-example.html#a8">gauss_kronrod.inl</a>, <a class="el" href="multidimensional_fit_8inl-example.html#a32">multidimensional_fit.inl</a>, <a class="el" href="phsp_chain_8inl-example.html#a14">phsp_chain.inl</a>, <a class="el" href="plain_mc_8inl-example.html#a9">plain_mc.inl</a>, <a class="el" href="range_semantics_8inl-example.html#a7">range_semantics.inl</a>, <a class="el" href="splot_8inl-example.html#a19">splot.inl</a>, and <a class="el" href="vegas_8inl-example.html#a8">vegas.inl</a>.</dd>
</dl>
</div>
</div>
<a id="aa792627bbf68dd5d3c3d969c3462808f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa792627bbf68dd5d3c3d969c3462808f">&#9670;&nbsp;</a></span>stream_array_helper() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t N, typename T , size_t I&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;(I==N), void&gt;::type hydra::stream_array_helper </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; T, N &gt; const &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>array streamer helper </p>

</div>
</div>
<a id="a6b2446e6e58a2466b66c1277d67075ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b2446e6e58a2466b66c1277d67075ad">&#9670;&nbsp;</a></span>stream_array_helper() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t N, typename T , size_t I = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; (I &lt; N), void&gt;::type hydra::stream_array_helper </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; T, N &gt; const &amp;&#160;</td>
          <td class="paramname"><em>obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afa8b42796ae70a6c34b6871a8755b382"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa8b42796ae70a6c34b6871a8755b382">&#9670;&nbsp;</a></span>stream_tuple_helper() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I, typename ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;(I==sizeof ...(T)), void&gt;::type hydra::stream_tuple_helper </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::tuple&lt; T... &gt; const &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>tuple streamer helper </p>

</div>
</div>
<a id="af0ba407638beac5920ac997d3021b413"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0ba407638beac5920ac997d3021b413">&#9670;&nbsp;</a></span>stream_tuple_helper() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I = 0, typename ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; (I &lt; sizeof ...(T)), void&gt;::type hydra::stream_tuple_helper </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::tuple&lt; T... &gt; const &amp;&#160;</td>
          <td class="paramname"><em>obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3e699b8e46110a6a9df156affb6d3308"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e699b8e46110a6a9df156affb6d3308">&#9670;&nbsp;</a></span>sum()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F1 , typename F2 , typename ... Fs&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;(<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt;F1&gt;::value || <a class="el" href="structhydra_1_1detail_1_1is__hydra__lambda.html">detail::is_hydra_lambda</a>&lt;F1&gt;::value ) &amp;&amp;(<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt;F2&gt;::value || <a class="el" href="structhydra_1_1detail_1_1is__hydra__lambda.html">detail::is_hydra_lambda</a>&lt;F2&gt;::value ) &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1all__true.html">detail::all_true</a>&lt;(<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt;Fs&gt;::value || <a class="el" href="structhydra_1_1detail_1_1is__hydra__lambda.html">detail::is_hydra_lambda</a>&lt;Fs&gt;::value )...&gt;::value,<a class="el" href="classhydra_1_1Sum.html">Sum</a>&lt;F1, F2,Fs...&gt; &gt;::type hydra::sum </td>
          <td>(</td>
          <td class="paramtype">F1 const &amp;&#160;</td>
          <td class="paramname"><em>f1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F2 const &amp;&#160;</td>
          <td class="paramname"><em>f2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Fs const &amp;...&#160;</td>
          <td class="paramname"><em>functors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa7d619f99868f45f5e06b9040bcc68b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7d619f99868f45f5e06b9040bcc68b7">&#9670;&nbsp;</a></span>swap() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> void hydra::swap </td>
          <td>(</td>
          <td class="paramtype">Vector3R &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector3R &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a67385a5afc562279b4419a11ab79e3d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67385a5afc562279b4419a11ab79e3d6">&#9670;&nbsp;</a></span>swap() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> void hydra::swap </td>
          <td>(</td>
          <td class="paramtype">Vector4R &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector4R &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a110443bb149efe88b6713bc5aca89b7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a110443bb149efe88b6713bc5aca89b7c">&#9670;&nbsp;</a></span>tan()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespacehydra.html#a9d2c06cb9672fe86dbeaa65e8f35a2bf">complex</a>&lt;T&gt; hydra::tan </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#a9d2c06cb9672fe86dbeaa65e8f35a2bf">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="pseudo_experiment_8inl-example.html#a29">pseudo_experiment.inl</a>.</dd>
</dl>
</div>
</div>
<a id="a5c39f4b7fa2b8b0c1e4066e9d059b435"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c39f4b7fa2b8b0c1e4066e9d059b435">&#9670;&nbsp;</a></span>tanh()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespacehydra.html#a9d2c06cb9672fe86dbeaa65e8f35a2bf">complex</a>&lt;T&gt; hydra::tanh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#a9d2c06cb9672fe86dbeaa65e8f35a2bf">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9654f2c52c92ba7219bfc4e6edb9ef58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9654f2c52c92ba7219bfc4e6edb9ef58">&#9670;&nbsp;</a></span>tie()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> auto hydra::tie </td>
          <td>(</td>
          <td class="paramtype">T &amp;...&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td> -&gt; decltype(hydra::thrust::tie(t...))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This version of <code>tie</code> creates a new <code>tuple</code> whose elements are references which refers to this function's arguments. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>The objects to reference. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>tuple</code> object with members which are references to <code>t</code>. </dd></dl>

</div>
</div>
<a id="a66e3f95285aed29c7f62df05eecf2f00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66e3f95285aed29c7f62df05eecf2f00">&#9670;&nbsp;</a></span>transform()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterable_Input , typename Iterable_Output , typename Functor , typename Iterator  = decltype(std::declval&lt;Iterable_Output&gt;().begin())&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;<a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt;Iterable_Output&gt;::value,<a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt;decltype(std::declval&lt;Iterable_Output&amp;&gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>())&gt; &gt;::type hydra::transform </td>
          <td>(</td>
          <td class="paramtype">Iterable_Input &amp;&amp;&#160;</td>
          <td class="paramname"><em>iterable_input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterable_Output &amp;&amp;&#160;</td>
          <td class="paramname"><em>iterable_output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Functor const &amp;&#160;</td>
          <td class="paramname"><em>unary_functor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a695d916ac439e7a655586ca4e52395c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a695d916ac439e7a655586ca4e52395c8">&#9670;&nbsp;</a></span>unweight() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RNG , typename IteratorData , typename IteratorWeight &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;<a class="el" href="structhydra_1_1detail_1_1random_1_1is__iterator.html">detail::random::is_iterator</a>&lt;IteratorData&gt;::value &amp;&amp; <a class="el" href="structhydra_1_1detail_1_1random_1_1is__iterator.html">detail::random::is_iterator</a>&lt;IteratorWeight&gt;::value,<a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt;IteratorData&gt; &gt;::type hydra::unweight </td>
          <td>(</td>
          <td class="paramtype">IteratorData&#160;</td>
          <td class="paramname"><em>data_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorData&#160;</td>
          <td class="paramname"><em>data_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorWeight&#160;</td>
          <td class="paramname"><em>weights_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td>
          <td class="paramname"><em>max_pdf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>rng_seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>rng_jump</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2775fa2909173fb09d8ffb19c5a8b4df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2775fa2909173fb09d8ffb19c5a8b4df">&#9670;&nbsp;</a></span>unweight() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RNG , typename IterableData , typename IterableWeight &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;<a class="el" href="structhydra_1_1detail_1_1random_1_1is__iterable.html">detail::random::is_iterable</a>&lt;IterableData&gt;::value &amp;&amp; <a class="el" href="structhydra_1_1detail_1_1random_1_1is__iterable.html">detail::random::is_iterable</a>&lt;IterableWeight&gt;::value,<a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; decltype(std::declval&lt;IterableData&gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>())&gt; &gt;::type hydra::unweight </td>
          <td>(</td>
          <td class="paramtype">IterableData &amp;&amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IterableWeight &amp;&amp;&#160;</td>
          <td class="paramname"><em>weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td>
          <td class="paramname"><em>max_pdf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>rng_seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>rng_jump</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a16cc58cf433d121a37c54f965023d49a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16cc58cf433d121a37c54f965023d49a">&#9670;&nbsp;</a></span>wigner_d_matrix() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> T hydra::wigner_d_matrix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>theta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aba159f9fe4df851059cae3f4ad676088"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba159f9fe4df851059cae3f4ad676088">&#9670;&nbsp;</a></span>wigner_d_matrix() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> hydra::wigner_d_matrix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_3globalScope_4.html#classunsigned">unsigned</a>&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_3globalScope_4.html#classunsigned">unsigned</a>&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_3globalScope_4.html#classunsigned">unsigned</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td>
          <td class="paramname"><em>theta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a094f4a025290ae35ad9eb8c553c7fc61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a094f4a025290ae35ad9eb8c553c7fc61">&#9670;&nbsp;</a></span>wrap_lambda() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LambdaType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhydra_1_1Lambda.html">hydra::Lambda</a>&lt;LambdaType, 0&gt; hydra::wrap_lambda </td>
          <td>(</td>
          <td class="paramtype">LambdaType const &amp;&#160;</td>
          <td class="paramname"><em>lambda</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="adaptive_gauss_kronrod_8inl-example.html#a11">adaptive_gauss_kronrod.inl</a>, <a class="el" href="basic_fit_range_semantics_8inl-example.html#a25">basic_fit_range_semantics.inl</a>, <a class="el" href="dalitz_plot_8C-example.html#a41">dalitz_plot.C</a>, <a class="el" href="dalitz_plot_8inl-example.html#a44">dalitz_plot.inl</a>, <a class="el" href="dense_histogram_8inl-example.html#a5">dense_histogram.inl</a>, <a class="el" href="extended_logLL_fit_8inl-example.html#a33">extended_logLL_fit.inl</a>, <a class="el" href="fit_johnson_8C-example.html#a15">fit_johnson.C</a>, <a class="el" href="fractional_logLL_fit_8inl-example.html#a31">fractional_logLL_fit.inl</a>, <a class="el" href="gauss_kronrod_8inl-example.html#a11">gauss_kronrod.inl</a>, <a class="el" href="multidimensional_fit_8inl-example.html#a26">multidimensional_fit.inl</a>, <a class="el" href="phsp_averaging_functor_8inl-example.html#a12">phsp_averaging_functor.inl</a>, <a class="el" href="phsp_basic_8inl-example.html#a18">phsp_basic.inl</a>, <a class="el" href="phsp_chain_8inl-example.html#a11">phsp_chain.inl</a>, <a class="el" href="phsp_reweighting_8inl-example.html#a18">phsp_reweighting.inl</a>, <a class="el" href="phsp_unweighting_8inl-example.html#a18">phsp_unweighting.inl</a>, <a class="el" href="phsp_unweighting_functor_8inl-example.html#a18">phsp_unweighting_functor.inl</a>, <a class="el" href="plain_mc_8inl-example.html#a12">plain_mc.inl</a>, <a class="el" href="range_semantics_8inl-example.html#a5">range_semantics.inl</a>, <a class="el" href="sample_distribution_8inl-example.html#a8">sample_distribution.inl</a>, <a class="el" href="splot_8inl-example.html#a32">splot.inl</a>, and <a class="el" href="vegas_8inl-example.html#a11">vegas.inl</a>.</dd>
</dl>
</div>
</div>
<a id="a5d026eb3807e3f2358feb9a7890b4598"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d026eb3807e3f2358feb9a7890b4598">&#9670;&nbsp;</a></span>wrap_lambda() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LambdaType , typename ... T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;<a class="el" href="structhydra_1_1detail_1_1all__true.html">detail::all_true</a>&lt;std::is_same&lt;T, <a class="el" href="group__fit.html#structhydra_1_1Parameter">hydra::Parameter</a>&gt;::value...&gt;::value,<a class="el" href="classhydra_1_1Lambda.html">hydra::Lambda</a>&lt;LambdaType, sizeof...(T)&gt; &gt;::type hydra::wrap_lambda </td>
          <td>(</td>
          <td class="paramtype">LambdaType const &amp;&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;...&#160;</td>
          <td class="paramname"><em>parameters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a25948c700f3cfb8ebc1752cfe765fc31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25948c700f3cfb8ebc1752cfe765fc31">&#9670;&nbsp;</a></span>zip()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... Iterables&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1all__true.html">detail::all_true</a>&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">detail::is_iterable</a>&lt;Iterables&gt;::value...&gt;::value,<a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; hydra::thrust::zip_iterator&lt; decltype(hydra::thrust::make_tuple(std::declval&lt;Iterables&amp;&gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()...))&gt; &gt; &gt;::type hydra::zip </td>
          <td>(</td>
          <td class="paramtype">Iterables &amp;&amp;...&#160;</td>
          <td class="paramname"><em>iterables</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="booststrapping_8inl-example.html#a6">booststrapping.inl</a>, <a class="el" href="cufft_8inl-example.html#a19">cufft.inl</a>, <a class="el" href="fft_8inl-example.html#a19">fft.inl</a>, and <a class="el" href="range_semantics_8inl-example.html#a10">range_semantics.inl</a>.</dd>
</dl>
</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a89686ff2116120de2d9e2ad6889a47de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89686ff2116120de2d9e2ad6889a47de">&#9670;&nbsp;</a></span>iterator_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">decltype( other.begin( <a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt;I&gt;{} )) typedef hydra::iterator_type</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{</div><div class="line"></div><div class="line">    constexpr <span class="keywordtype">size_t</span> I = detail::index_in_tuple&lt;Type, <a class="code" href="namespacehydra.html#ac3486502b2db72187626125cea971683">hydra::thrust::tuple</a>&lt;T...&gt; &gt;::value</div><div class="ttc" id="namespacehydra_html_ac3486502b2db72187626125cea971683"><div class="ttname"><a href="namespacehydra.html#ac3486502b2db72187626125cea971683">hydra::tuple</a></div><div class="ttdeci">hydra::thrust::tuple&lt; T... &gt; tuple</div><div class="ttdoc">tuple template is an alias to the variadic version of hydra::thrust::tuple and that can be instantiat...</div><div class="ttdef"><b>Definition:</b> Tuple.h:71</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ab14adaa26f703b8c130df530167ebd23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab14adaa26f703b8c130df530167ebd23">&#9670;&nbsp;</a></span>kFalse</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespacehydra.html#aa8c251ed5017d0638da929130062bcad">GBool_t</a> hydra::kFalse = false</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1556536d7a73fa95e5a9c9610f76a3c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1556536d7a73fa95e5a9c9610f76a3c1">&#9670;&nbsp;</a></span>kTrue</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespacehydra.html#aa8c251ed5017d0638da929130062bcad">GBool_t</a> hydra::kTrue = true</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5afb8f1b6ea1ba2b8fc79444e5d20f20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5afb8f1b6ea1ba2b8fc79444e5d20f20">&#9670;&nbsp;</a></span>PrintLevel</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_3globalScope_4.html#classint">int</a> hydra::PrintLevel = <a class="el" href="namespacehydra.html#a1107488f838687e73b39ddd8245f40d0a1bf857a06d5b8463494a6fcac6f4ea26">WARNING</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5b5278e8bbc808a52856865a2a39dba7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b5278e8bbc808a52856865a2a39dba7">&#9670;&nbsp;</a></span>sample</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RNG  = default_random_engine, typename Functor , typename Iterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;<a class="el" href="structhydra_1_1detail_1_1random_1_1is__callable.html">detail::random::is_callable</a>&lt;Functor&gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1random_1_1is__iterable.html">detail::random::is_iterable</a>&lt;Iterable&gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1is__tuple__type.html">detail::is_tuple_type</a>&lt; decltype(*std::declval&lt;Iterable&gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>())&gt;::value ,<a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; decltype(std::declval&lt;Iterable&gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>())&gt; &gt;::type hydra::sample(Iterable &amp;&amp;output, typename Functor::argument_type const  &amp;<a class="el" href="particle__mass_8inl.html#aad36546e8175d2922bee165fe028fedc">min</a>, typename Functor::argument_type const  &amp;<a class="el" href="particle__mass_8inl.html#a0b0ede69e8156eb97acc579b88e883de">max</a>, Functor const  &amp;functor, size_t seed=0xb56c4feeef1b, size_t rng_jump=0)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fill a range with numbers distributed according a user defined distribution. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>beginning of the range storing the generated values </td></tr>
    <tr><td class="paramname">end</td><td>ending of the range storing the generated values </td></tr>
    <tr><td class="paramname">min</td><td>tuple of lower limits of sampling region </td></tr>
    <tr><td class="paramname">max</td><td>tuple of upper limits of sampling region. </td></tr>
    <tr><td class="paramname">functor</td><td>distribution to be sampled </td></tr>
    <tr><td class="paramname">max_pdf</td><td>maximum pdf value for accept-reject method. If no value is set, the maximum value in the sample is used. </td></tr>
    <tr><td class="paramname">rng_seed</td><td>seed for the underlying pseudo-random number generator </td></tr>
    <tr><td class="paramname">rng_jump</td><td>sequence offset for the underlying pseudo-random number generator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>range with the generated values</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">output</td><td>range storing the generated values </td></tr>
    <tr><td class="paramname">min</td><td>tuple of lower limits of sampling region </td></tr>
    <tr><td class="paramname">max</td><td>tuple of upper limits of sampling region. </td></tr>
    <tr><td class="paramname">functor</td><td>distribution to be sampled </td></tr>
    <tr><td class="paramname">max_pdf</td><td>maximum pdf value for accept-reject method. If no value is set, the maximum value in the sample is used. </td></tr>
    <tr><td class="paramname">rng_seed</td><td>seed for the underlying pseudo-random number generator </td></tr>
    <tr><td class="paramname">rng_jump</td><td>sequence offset for the underlying pseudo-random number generator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>output range with the generated values </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="breit_wigner_plus_polynomial_8inl-example.html#a32">breit_wigner_plus_polynomial.inl</a>, <a class="el" href="crystal_ball_plus_exponential_8inl-example.html#a32">crystal_ball_plus_exponential.inl</a>, <a class="el" href="dalitz_plot_8C-example.html#a68">dalitz_plot.C</a>, <a class="el" href="dalitz_plot_8inl-example.html#a71">dalitz_plot.inl</a>, <a class="el" href="dense_histogram_8inl-example.html#a15">dense_histogram.inl</a>, <a class="el" href="double_gaussian_plus_exponential_8inl-example.html#a33">double_gaussian_plus_exponential.inl</a>, <a class="el" href="fit_convoluted_pdfs_8inl-example.html#a37">fit_convoluted_pdfs.inl</a>, <a class="el" href="gaussian_plus_argus_8inl-example.html#a36">gaussian_plus_argus.inl</a>, and <a class="el" href="sample_distribution_8inl-example.html#a16">sample_distribution.inl</a>.</dd>
</dl>
</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacehydra.html">hydra</a></li>
    <li class="footer">Generated on Sun Dec 3 2023 21:29:48 for Hydra by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.14 </li>
  </ul>
</div>
</body>
</html>
