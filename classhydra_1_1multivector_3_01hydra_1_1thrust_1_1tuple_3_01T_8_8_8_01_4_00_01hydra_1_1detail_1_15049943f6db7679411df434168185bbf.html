<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Hydra: hydra::multivector&lt; hydra::thrust::tuple&lt; T... &gt;, hydra::detail::BackendPolicy&lt; BACKEND &gt; &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo_Hydra2.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Hydra
   &#160;<span id="projectnumber">4.0.1</span>
   </div>
   <div id="projectbrief">A header-only templated C++ framework to perform data analysis on massively parallel platforms.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">hydra::multivector&lt; hydra::thrust::tuple&lt; T... &gt;, hydra::detail::BackendPolicy&lt; BACKEND &gt; &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This class implements storage in SoA layouts for table where all elements have the same type.  
 <a href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="">multivector.h</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for hydra::multivector&lt; hydra::thrust::tuple&lt; T... &gt;, hydra::detail::BackendPolicy&lt; BACKEND &gt; &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_197451c4283faaccc67cafef9d0d488c8.svg" width="230" height="279"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a0690bbe116fa4fbb03eb68c41fd46fd2"><td class="memTemplParams" colspan="2">template&lt;typename Functor &gt; </td></tr>
<tr class="memitem:a0690bbe116fa4fbb03eb68c41fd46fd2"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a0690bbe116fa4fbb03eb68c41fd46fd2">caster_iterator</a> = hydra::thrust::transform_iterator&lt; Functor, <a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a1629aefb94ab27551973be11a8ec38b7">iterator</a>, typename std::result_of&lt; Functor(tuple_type &amp;)&gt;::type &gt;</td></tr>
<tr class="separator:a0690bbe116fa4fbb03eb68c41fd46fd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af09cd871c1e32293d8c9cb44034f641e"><td class="memTemplParams" colspan="2">template&lt;typename Functor &gt; </td></tr>
<tr class="memitem:af09cd871c1e32293d8c9cb44034f641e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#af09cd871c1e32293d8c9cb44034f641e">caster_reverse_iterator</a> = hydra::thrust::transform_iterator&lt; Functor, <a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a9f1775925ab9f2f78ded2885ea7264e7">reverse_iterator</a>, typename std::result_of&lt; Functor(tuple_type &amp;)&gt;::type &gt;</td></tr>
<tr class="separator:af09cd871c1e32293d8c9cb44034f641e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d3e355ba73cc2409d11c30097bc5bb7"><td class="memTemplParams" colspan="2">template&lt;typename Iterators , unsigned int I1, unsigned int I2, unsigned int ... IN&gt; </td></tr>
<tr class="memitem:a1d3e355ba73cc2409d11c30097bc5bb7"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a1d3e355ba73cc2409d11c30097bc5bb7">columns_iterator</a> = hydra::thrust::zip_iterator&lt; hydra::thrust::tuple&lt; typename hydra::thrust::tuple_element&lt; I1, Iterators &gt;::type, typename hydra::thrust::tuple_element&lt; I2, Iterators &gt;::type, typename hydra::thrust::tuple_element&lt; IN, Iterators &gt;::type... &gt; &gt;</td></tr>
<tr class="separator:a1d3e355ba73cc2409d11c30097bc5bb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8b44a2d78e7178eb90fd48f4046a9a7"><td class="memItemLeft" align="right" valign="top">typedef hydra::thrust::zip_iterator&lt; <a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#adaee497bf961bd3dbeee656a32b41c5e">const_iterator_tuple</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#af8b44a2d78e7178eb90fd48f4046a9a7">const_iterator</a></td></tr>
<tr class="separator:af8b44a2d78e7178eb90fd48f4046a9a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaee497bf961bd3dbeee656a32b41c5e"><td class="memItemLeft" align="right" valign="top">typedef hydra::thrust::tuple&lt; _const_iterator&lt; T &gt;... &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#adaee497bf961bd3dbeee656a32b41c5e">const_iterator_tuple</a></td></tr>
<tr class="separator:adaee497bf961bd3dbeee656a32b41c5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf1fa17161766aad5401b5e85d19ad9c"><td class="memItemLeft" align="right" valign="top">typedef hydra::thrust::iterator_traits&lt; <a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#af8b44a2d78e7178eb90fd48f4046a9a7">const_iterator</a> &gt;::<a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a634a39e968ee0a327c3a19a5575e97b3">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#abf1fa17161766aad5401b5e85d19ad9c">const_reference</a></td></tr>
<tr class="separator:abf1fa17161766aad5401b5e85d19ad9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d281c4f5bed9f2a9e843454d58e19ee"><td class="memItemLeft" align="right" valign="top">typedef hydra::thrust::tuple&lt; _const_reference&lt; T &gt;... &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a5d281c4f5bed9f2a9e843454d58e19ee">const_reference_tuple</a></td></tr>
<tr class="separator:a5d281c4f5bed9f2a9e843454d58e19ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67ce921a4b57cea999ba65990aed85e5"><td class="memItemLeft" align="right" valign="top">typedef hydra::thrust::zip_iterator&lt; <a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#aa61175868b88391c2842e9d6920f2bb8">const_reverse_iterator_tuple</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a67ce921a4b57cea999ba65990aed85e5">const_reverse_iterator</a></td></tr>
<tr class="separator:a67ce921a4b57cea999ba65990aed85e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa61175868b88391c2842e9d6920f2bb8"><td class="memItemLeft" align="right" valign="top">typedef hydra::thrust::tuple&lt; _const_reverse_iterator&lt; T &gt;... &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#aa61175868b88391c2842e9d6920f2bb8">const_reverse_iterator_tuple</a></td></tr>
<tr class="separator:aa61175868b88391c2842e9d6920f2bb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1629aefb94ab27551973be11a8ec38b7"><td class="memItemLeft" align="right" valign="top">typedef hydra::thrust::zip_iterator&lt; <a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a368e387d8be3b7b37c2aafb9bea02957">iterator_tuple</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a1629aefb94ab27551973be11a8ec38b7">iterator</a></td></tr>
<tr class="separator:a1629aefb94ab27551973be11a8ec38b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42096e41cf6d517fb42f4f3c5ead940f"><td class="memItemLeft" align="right" valign="top">typedef hydra::thrust::iterator_traits&lt; <a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a1629aefb94ab27551973be11a8ec38b7">iterator</a> &gt;::<a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a42096e41cf6d517fb42f4f3c5ead940f">iterator_category</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a42096e41cf6d517fb42f4f3c5ead940f">iterator_category</a></td></tr>
<tr class="separator:a42096e41cf6d517fb42f4f3c5ead940f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a368e387d8be3b7b37c2aafb9bea02957"><td class="memItemLeft" align="right" valign="top">typedef hydra::thrust::tuple&lt; _iterator&lt; T &gt;... &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a368e387d8be3b7b37c2aafb9bea02957">iterator_tuple</a></td></tr>
<tr class="separator:a368e387d8be3b7b37c2aafb9bea02957"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03cac047f8021a587197d8cf38565a0f"><td class="memItemLeft" align="right" valign="top">typedef hydra::thrust::tuple&lt; _pointer&lt; T &gt;... &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a03cac047f8021a587197d8cf38565a0f">pointer_tuple</a></td></tr>
<tr class="separator:a03cac047f8021a587197d8cf38565a0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a634a39e968ee0a327c3a19a5575e97b3"><td class="memItemLeft" align="right" valign="top">typedef hydra::thrust::iterator_traits&lt; <a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a1629aefb94ab27551973be11a8ec38b7">iterator</a> &gt;::<a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a634a39e968ee0a327c3a19a5575e97b3">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a634a39e968ee0a327c3a19a5575e97b3">reference</a></td></tr>
<tr class="separator:a634a39e968ee0a327c3a19a5575e97b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02f65aaf76d1ac43a95e689b275bdc99"><td class="memItemLeft" align="right" valign="top">typedef hydra::thrust::tuple&lt; _reference&lt; T &gt;... &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a02f65aaf76d1ac43a95e689b275bdc99">reference_tuple</a></td></tr>
<tr class="separator:a02f65aaf76d1ac43a95e689b275bdc99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f1775925ab9f2f78ded2885ea7264e7"><td class="memItemLeft" align="right" valign="top">typedef hydra::thrust::zip_iterator&lt; <a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a61849adfc0c475aa23a72cc3e626cf89">reverse_iterator_tuple</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a9f1775925ab9f2f78ded2885ea7264e7">reverse_iterator</a></td></tr>
<tr class="separator:a9f1775925ab9f2f78ded2885ea7264e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61849adfc0c475aa23a72cc3e626cf89"><td class="memItemLeft" align="right" valign="top">typedef hydra::thrust::tuple&lt; _reverse_iterator&lt; T &gt;... &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a61849adfc0c475aa23a72cc3e626cf89">reverse_iterator_tuple</a></td></tr>
<tr class="separator:a61849adfc0c475aa23a72cc3e626cf89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f3b15a7a66792552891c6c25f69da59"><td class="memItemLeft" align="right" valign="top">typedef size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a9f3b15a7a66792552891c6c25f69da59">size_type</a></td></tr>
<tr class="separator:a9f3b15a7a66792552891c6c25f69da59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54b6ba02f47207787e936f2e49aec1ab"><td class="memItemLeft" align="right" valign="top">typedef hydra::thrust::tuple&lt; _vector&lt; T &gt;... &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a54b6ba02f47207787e936f2e49aec1ab">storage_tuple</a></td></tr>
<tr class="separator:a54b6ba02f47207787e936f2e49aec1ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d4313d2ba0e92aa16a82173ca63e7d1"><td class="memItemLeft" align="right" valign="top">typedef hydra::thrust::iterator_traits&lt; <a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a1629aefb94ab27551973be11a8ec38b7">iterator</a> &gt;::<a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a7d4313d2ba0e92aa16a82173ca63e7d1">value_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a7d4313d2ba0e92aa16a82173ca63e7d1">value_type</a></td></tr>
<tr class="separator:a7d4313d2ba0e92aa16a82173ca63e7d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf85a0b76263ff62736d98eb63c08713"><td class="memItemLeft" align="right" valign="top">typedef hydra::thrust::tuple&lt; _value_type&lt; T &gt;... &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#aaf85a0b76263ff62736d98eb63c08713">value_type_tuple</a></td></tr>
<tr class="separator:aaf85a0b76263ff62736d98eb63c08713"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac0f3f8241dc119c258ed79a957445c59"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#ac0f3f8241dc119c258ed79a957445c59">multivector</a> ()=default</td></tr>
<tr class="memdesc:ac0f3f8241dc119c258ed79a957445c59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="#ac0f3f8241dc119c258ed79a957445c59">More...</a><br /></td></tr>
<tr class="separator:ac0f3f8241dc119c258ed79a957445c59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b899533c37b03d9d1f21551a7b89745"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a9b899533c37b03d9d1f21551a7b89745">multivector</a> (size_t <a class="el" href="crystal__ball__plus__exponential_8inl.html#a21f77208d6bc667560ff8aaf8f943b6a">n</a>)</td></tr>
<tr class="memdesc:a9b899533c37b03d9d1f21551a7b89745"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor initializing the <code>multivector</code> with <code>n</code> entries.  <a href="#a9b899533c37b03d9d1f21551a7b89745">More...</a><br /></td></tr>
<tr class="separator:a9b899533c37b03d9d1f21551a7b89745"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecca33fdaf2bf772e4d3d5482109a063"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#aecca33fdaf2bf772e4d3d5482109a063">multivector</a> (size_t <a class="el" href="crystal__ball__plus__exponential_8inl.html#a21f77208d6bc667560ff8aaf8f943b6a">n</a>, <a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a7d4313d2ba0e92aa16a82173ca63e7d1">value_type</a> const &amp;value)</td></tr>
<tr class="memdesc:aecca33fdaf2bf772e4d3d5482109a063"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor initializing the multivector with <code>n</code> copies of <code>value</code> .  <a href="#aecca33fdaf2bf772e4d3d5482109a063">More...</a><br /></td></tr>
<tr class="separator:aecca33fdaf2bf772e4d3d5482109a063"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10e7230730406b1d121a99f95e34044e"><td class="memTemplParams" colspan="2">template&lt;typename Int , typename  = typename hydra::thrust::detail::enable_if&lt;std::is_integral&lt;Int&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a10e7230730406b1d121a99f95e34044e"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a10e7230730406b1d121a99f95e34044e">multivector</a> (<a class="el" href="namespacehydra.html#a1f40581ef3c81ef08844d3beb59842f7">hydra::pair</a>&lt; Int, hydra::thrust::tuple&lt; T... &gt; &gt; const &amp;<a class="el" href="namespacehydra.html#a1f40581ef3c81ef08844d3beb59842f7">pair</a>)</td></tr>
<tr class="memdesc:a10e7230730406b1d121a99f95e34044e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor initializing the multivector with <code>n</code> copies of <code>value</code> .  <a href="#a10e7230730406b1d121a99f95e34044e">More...</a><br /></td></tr>
<tr class="separator:a10e7230730406b1d121a99f95e34044e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad438442be2dbd1093b65a7ab4359b958"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#ad438442be2dbd1093b65a7ab4359b958">multivector</a> (<a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; hydra::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; const &amp;other)</td></tr>
<tr class="memdesc:ad438442be2dbd1093b65a7ab4359b958"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="#ad438442be2dbd1093b65a7ab4359b958">More...</a><br /></td></tr>
<tr class="separator:ad438442be2dbd1093b65a7ab4359b958"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cfebe548159e3bb83f1f81b609e4c16"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a3cfebe548159e3bb83f1f81b609e4c16">multivector</a> (<a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; hydra::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; &amp;&amp;other)</td></tr>
<tr class="memdesc:a3cfebe548159e3bb83f1f81b609e4c16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor.  <a href="#a3cfebe548159e3bb83f1f81b609e4c16">More...</a><br /></td></tr>
<tr class="separator:a3cfebe548159e3bb83f1f81b609e4c16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30d82b56fef7b14ab73b9bca95955553"><td class="memTemplParams" colspan="2">template&lt;hydra::detail::Backend BACKEND2&gt; </td></tr>
<tr class="memitem:a30d82b56fef7b14ab73b9bca95955553"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a30d82b56fef7b14ab73b9bca95955553">multivector</a> (<a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; hydra::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND2 &gt;&gt; const &amp;other)</td></tr>
<tr class="memdesc:a30d82b56fef7b14ab73b9bca95955553"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor for containers allocated in different backends.  <a href="#a30d82b56fef7b14ab73b9bca95955553">More...</a><br /></td></tr>
<tr class="separator:a30d82b56fef7b14ab73b9bca95955553"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7c0c982532d02bd407f131831cef444"><td class="memTemplParams" colspan="2">template&lt;typename Iterator &gt; </td></tr>
<tr class="memitem:af7c0c982532d02bd407f131831cef444"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#af7c0c982532d02bd407f131831cef444">multivector</a> (Iterator first, Iterator last)</td></tr>
<tr class="memdesc:af7c0c982532d02bd407f131831cef444"><td class="mdescLeft">&#160;</td><td class="mdescRight">This constructor builds a <code>multivector</code> from a range.  <a href="#af7c0c982532d02bd407f131831cef444">More...</a><br /></td></tr>
<tr class="separator:af7c0c982532d02bd407f131831cef444"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f86109bf2f713ae0970c31a37655888"><td class="memTemplParams" colspan="2">template&lt;typename Iterable , typename  = typename std::enable_if&lt;	           (detail::is_iterable&lt;Iterable&gt;::value) &amp;&amp;	          !(detail::is_iterator&lt;Iterable&gt;::value) &amp;&amp;	           (std::is_convertible&lt;decltype(*std::declval&lt;Iterable&gt;().begin()), value_type&gt;::value)	          &gt;::type&gt; </td></tr>
<tr class="memitem:a7f86109bf2f713ae0970c31a37655888"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a7f86109bf2f713ae0970c31a37655888">multivector</a> (Iterable &amp;&amp;other)</td></tr>
<tr class="separator:a7f86109bf2f713ae0970c31a37655888"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacaddbab1740ee8f92c7b05d12801851"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a634a39e968ee0a327c3a19a5575e97b3">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#aacaddbab1740ee8f92c7b05d12801851">back</a> ()</td></tr>
<tr class="memdesc:aacaddbab1740ee8f92c7b05d12801851"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method returns a reference referring to the last element of this vector_dev.  <a href="#aacaddbab1740ee8f92c7b05d12801851">More...</a><br /></td></tr>
<tr class="separator:aacaddbab1740ee8f92c7b05d12801851"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf0e4fd614d49752f28441651767a896"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#abf1fa17161766aad5401b5e85d19ad9c">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#adf0e4fd614d49752f28441651767a896">back</a> () const</td></tr>
<tr class="memdesc:adf0e4fd614d49752f28441651767a896"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method returns a const reference pointing to the last element of this <code>multivector</code>.  <a href="#adf0e4fd614d49752f28441651767a896">More...</a><br /></td></tr>
<tr class="separator:adf0e4fd614d49752f28441651767a896"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca913ba3cee6616d05e08d61379aed6e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a1629aefb94ab27551973be11a8ec38b7">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#aca913ba3cee6616d05e08d61379aed6e">begin</a> ()</td></tr>
<tr class="memdesc:aca913ba3cee6616d05e08d61379aed6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method returns an iterator pointing to the beginning of this <code>multivector</code>.  <a href="#aca913ba3cee6616d05e08d61379aed6e">More...</a><br /></td></tr>
<tr class="separator:aca913ba3cee6616d05e08d61379aed6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae49f4041910c6285a74871e3e619a386"><td class="memTemplParams" colspan="2">template&lt;typename Functor &gt; </td></tr>
<tr class="memitem:ae49f4041910c6285a74871e3e619a386"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a0690bbe116fa4fbb03eb68c41fd46fd2">caster_iterator</a>&lt; Functor &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#ae49f4041910c6285a74871e3e619a386">begin</a> (Functor const &amp;caster)</td></tr>
<tr class="separator:ae49f4041910c6285a74871e3e619a386"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a781e7ea3c4c2201a468244fbd2c94612"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#af8b44a2d78e7178eb90fd48f4046a9a7">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a781e7ea3c4c2201a468244fbd2c94612">begin</a> () const</td></tr>
<tr class="separator:a781e7ea3c4c2201a468244fbd2c94612"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40a8523aaebfa07b9295b31039873b29"><td class="memTemplParams" colspan="2">template&lt;unsigned int I1, unsigned int I2, unsigned int ... IN&gt; </td></tr>
<tr class="memitem:a40a8523aaebfa07b9295b31039873b29"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a1d3e355ba73cc2409d11c30097bc5bb7">columns_iterator</a>&lt; <a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a368e387d8be3b7b37c2aafb9bea02957">iterator_tuple</a>, I1, I2, IN... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a40a8523aaebfa07b9295b31039873b29">begin</a> (<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I1 &gt; <a class="el" href="breit__wigner__plus__polynomial_8inl.html#a8175ec4e5461dcd38d40ead25fef205c">c1</a>, <a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I2 &gt; <a class="el" href="breit__wigner__plus__polynomial_8inl.html#a024a3031e2ed14c5d1405f6e99df1158">c2</a>, <a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; IN &gt; ...cn)</td></tr>
<tr class="separator:a40a8523aaebfa07b9295b31039873b29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1992c0d4b108dbae5bb1d5e6afb878e4"><td class="memTemplParams" colspan="2">template&lt;unsigned int I&gt; </td></tr>
<tr class="memitem:a1992c0d4b108dbae5bb1d5e6afb878e4"><td class="memTemplItemLeft" align="right" valign="top">hydra::thrust::tuple_element&lt; I, <a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a368e387d8be3b7b37c2aafb9bea02957">iterator_tuple</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a1992c0d4b108dbae5bb1d5e6afb878e4">begin</a> (<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;)</td></tr>
<tr class="separator:a1992c0d4b108dbae5bb1d5e6afb878e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20a975ad5357fac102c786eb82af9da8"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:a20a975ad5357fac102c786eb82af9da8"><td class="memTemplItemLeft" align="right" valign="top">hydra::thrust::tuple_element&lt; <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1index__in__tuple">detail::index_in_tuple</a>&lt; Type, tuple_type &gt;::value, <a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a368e387d8be3b7b37c2aafb9bea02957">iterator_tuple</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a20a975ad5357fac102c786eb82af9da8">begin</a> ()</td></tr>
<tr class="separator:a20a975ad5357fac102c786eb82af9da8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9d3c549dc330e94ac5da3d4ded2ad35"><td class="memTemplParams" colspan="2">template&lt;unsigned int I1, unsigned int I2, unsigned int ... IN&gt; </td></tr>
<tr class="memitem:ac9d3c549dc330e94ac5da3d4ded2ad35"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a1d3e355ba73cc2409d11c30097bc5bb7">columns_iterator</a>&lt; <a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#adaee497bf961bd3dbeee656a32b41c5e">const_iterator_tuple</a>, I1, I2, IN... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#ac9d3c549dc330e94ac5da3d4ded2ad35">begin</a> (<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I1 &gt; <a class="el" href="breit__wigner__plus__polynomial_8inl.html#a8175ec4e5461dcd38d40ead25fef205c">c1</a>, <a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I2 &gt; <a class="el" href="breit__wigner__plus__polynomial_8inl.html#a024a3031e2ed14c5d1405f6e99df1158">c2</a>, <a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; IN &gt; ...cn) const</td></tr>
<tr class="separator:ac9d3c549dc330e94ac5da3d4ded2ad35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3334cdbee1acd115821877edf29f536d"><td class="memTemplParams" colspan="2">template&lt;unsigned int I&gt; </td></tr>
<tr class="memitem:a3334cdbee1acd115821877edf29f536d"><td class="memTemplItemLeft" align="right" valign="top">hydra::thrust::tuple_element&lt; I, <a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#adaee497bf961bd3dbeee656a32b41c5e">const_iterator_tuple</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a3334cdbee1acd115821877edf29f536d">begin</a> (<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;) const</td></tr>
<tr class="separator:a3334cdbee1acd115821877edf29f536d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc5ff995f315aed5649bbac9f818fe09"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a9f3b15a7a66792552891c6c25f69da59">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#afc5ff995f315aed5649bbac9f818fe09">capacity</a> () const</td></tr>
<tr class="memdesc:afc5ff995f315aed5649bbac9f818fe09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements which have been reserved in this <code>multivector</code>.  <a href="#afc5ff995f315aed5649bbac9f818fe09">More...</a><br /></td></tr>
<tr class="separator:afc5ff995f315aed5649bbac9f818fe09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f898f0ada6137978f786052903993c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#af8b44a2d78e7178eb90fd48f4046a9a7">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a8f898f0ada6137978f786052903993c1">cbegin</a> () const</td></tr>
<tr class="separator:a8f898f0ada6137978f786052903993c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c211c510c2e6bf93190c814b692a59e"><td class="memTemplParams" colspan="2">template&lt;unsigned int I1, unsigned int I2, unsigned int ... IN&gt; </td></tr>
<tr class="memitem:a7c211c510c2e6bf93190c814b692a59e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a1d3e355ba73cc2409d11c30097bc5bb7">columns_iterator</a>&lt; <a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#adaee497bf961bd3dbeee656a32b41c5e">const_iterator_tuple</a>, I1, I2, IN... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a7c211c510c2e6bf93190c814b692a59e">cbegin</a> (<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I1 &gt; <a class="el" href="breit__wigner__plus__polynomial_8inl.html#a8175ec4e5461dcd38d40ead25fef205c">c1</a>, <a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I2 &gt; <a class="el" href="breit__wigner__plus__polynomial_8inl.html#a024a3031e2ed14c5d1405f6e99df1158">c2</a>, <a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; IN &gt; ...cn) const</td></tr>
<tr class="separator:a7c211c510c2e6bf93190c814b692a59e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ec0e5092593a3637ef1904650d30a31"><td class="memTemplParams" colspan="2">template&lt;unsigned int I&gt; </td></tr>
<tr class="memitem:a3ec0e5092593a3637ef1904650d30a31"><td class="memTemplItemLeft" align="right" valign="top">hydra::thrust::tuple_element&lt; I, <a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#adaee497bf961bd3dbeee656a32b41c5e">const_iterator_tuple</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a3ec0e5092593a3637ef1904650d30a31">cbegin</a> (<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;) const</td></tr>
<tr class="separator:a3ec0e5092593a3637ef1904650d30a31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0327722cdc024b0545eb4b127180efdd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#af8b44a2d78e7178eb90fd48f4046a9a7">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a0327722cdc024b0545eb4b127180efdd">cend</a> () const</td></tr>
<tr class="separator:a0327722cdc024b0545eb4b127180efdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2206c55de389f1db8dac8ed9aa7a089"><td class="memTemplParams" colspan="2">template&lt;unsigned int I1, unsigned int I2, unsigned int ... IN&gt; </td></tr>
<tr class="memitem:ad2206c55de389f1db8dac8ed9aa7a089"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a1d3e355ba73cc2409d11c30097bc5bb7">columns_iterator</a>&lt; <a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#adaee497bf961bd3dbeee656a32b41c5e">const_iterator_tuple</a>, I1, I2, IN... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#ad2206c55de389f1db8dac8ed9aa7a089">cend</a> (<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I1 &gt; <a class="el" href="breit__wigner__plus__polynomial_8inl.html#a8175ec4e5461dcd38d40ead25fef205c">c1</a>, <a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I2 &gt; <a class="el" href="breit__wigner__plus__polynomial_8inl.html#a024a3031e2ed14c5d1405f6e99df1158">c2</a>, <a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; IN &gt; ...cn) const</td></tr>
<tr class="separator:ad2206c55de389f1db8dac8ed9aa7a089"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75aef0cdab9c5d1c33b326528c32c2c2"><td class="memTemplParams" colspan="2">template&lt;unsigned int I&gt; </td></tr>
<tr class="memitem:a75aef0cdab9c5d1c33b326528c32c2c2"><td class="memTemplItemLeft" align="right" valign="top">hydra::thrust::tuple_element&lt; I, <a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#adaee497bf961bd3dbeee656a32b41c5e">const_iterator_tuple</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a75aef0cdab9c5d1c33b326528c32c2c2">cend</a> (<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;) const</td></tr>
<tr class="separator:a75aef0cdab9c5d1c33b326528c32c2c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2484994f430390709776f9545fe20638"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a2484994f430390709776f9545fe20638">clear</a> ()</td></tr>
<tr class="memdesc:a2484994f430390709776f9545fe20638"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method resizes this <code>multivector</code> to 0.  <a href="#a2484994f430390709776f9545fe20638">More...</a><br /></td></tr>
<tr class="separator:a2484994f430390709776f9545fe20638"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0ba62e1f27193b467ce40c19334f506"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:ae0ba62e1f27193b467ce40c19334f506"><td class="memTemplItemLeft" align="right" valign="top">hydra::thrust::tuple_element&lt; <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1index__in__tuple">detail::index_in_tuple</a>&lt; Type, tuple_type &gt;::value, <a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a54b6ba02f47207787e936f2e49aec1ab">storage_tuple</a> &gt;::type &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#ae0ba62e1f27193b467ce40c19334f506">column</a> ()</td></tr>
<tr class="separator:ae0ba62e1f27193b467ce40c19334f506"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a3d4b0a9d7ead9db3bb72b2234818f0"><td class="memTemplParams" colspan="2">template&lt;unsigned int I&gt; </td></tr>
<tr class="memitem:a8a3d4b0a9d7ead9db3bb72b2234818f0"><td class="memTemplItemLeft" align="right" valign="top">hydra::thrust::tuple_element&lt; I, <a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a54b6ba02f47207787e936f2e49aec1ab">storage_tuple</a> &gt;::type &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a8a3d4b0a9d7ead9db3bb72b2234818f0">column</a> (<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;)</td></tr>
<tr class="separator:a8a3d4b0a9d7ead9db3bb72b2234818f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ad4bd53b050dda0e9dde80e267a9341"><td class="memTemplParams" colspan="2">template&lt;unsigned int I1, unsigned int I2, unsigned int ... IN&gt; </td></tr>
<tr class="memitem:a0ad4bd53b050dda0e9dde80e267a9341"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacehydra.html#classhydra_1_1Range">hydra::Range</a>&lt; <a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a1d3e355ba73cc2409d11c30097bc5bb7">columns_iterator</a>&lt; <a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a368e387d8be3b7b37c2aafb9bea02957">iterator_tuple</a>, I1, I2, IN... &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a0ad4bd53b050dda0e9dde80e267a9341">column</a> (<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I1 &gt; <a class="el" href="breit__wigner__plus__polynomial_8inl.html#a8175ec4e5461dcd38d40ead25fef205c">c1</a>, <a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I2 &gt; <a class="el" href="breit__wigner__plus__polynomial_8inl.html#a024a3031e2ed14c5d1405f6e99df1158">c2</a>, <a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; IN &gt; ...cn)</td></tr>
<tr class="separator:a0ad4bd53b050dda0e9dde80e267a9341"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe7c853a49281ce218c98aa2cf6ba1ca"><td class="memTemplParams" colspan="2">template&lt;unsigned int I&gt; </td></tr>
<tr class="memitem:abe7c853a49281ce218c98aa2cf6ba1ca"><td class="memTemplItemLeft" align="right" valign="top">const hydra::thrust::tuple_element&lt; I, <a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a54b6ba02f47207787e936f2e49aec1ab">storage_tuple</a> &gt;::type &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#abe7c853a49281ce218c98aa2cf6ba1ca">column</a> (<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;) const</td></tr>
<tr class="separator:abe7c853a49281ce218c98aa2cf6ba1ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a599c91eaf89a2d9510e3e93dc2bdbaa9"><td class="memTemplParams" colspan="2">template&lt;unsigned int I1, unsigned int I2, unsigned int ... IN&gt; </td></tr>
<tr class="memitem:a599c91eaf89a2d9510e3e93dc2bdbaa9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacehydra.html#classhydra_1_1Range">hydra::Range</a>&lt; <a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a1d3e355ba73cc2409d11c30097bc5bb7">columns_iterator</a>&lt; <a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#adaee497bf961bd3dbeee656a32b41c5e">const_iterator_tuple</a>, I1, I2, IN... &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a599c91eaf89a2d9510e3e93dc2bdbaa9">column</a> (<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I1 &gt; <a class="el" href="breit__wigner__plus__polynomial_8inl.html#a8175ec4e5461dcd38d40ead25fef205c">c1</a>, <a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I2 &gt; <a class="el" href="breit__wigner__plus__polynomial_8inl.html#a024a3031e2ed14c5d1405f6e99df1158">c2</a>, <a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; IN &gt; ...cn) const</td></tr>
<tr class="separator:a599c91eaf89a2d9510e3e93dc2bdbaa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c97d17a0ea17bbc9e6b303eccbe4d45"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a67ce921a4b57cea999ba65990aed85e5">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a5c97d17a0ea17bbc9e6b303eccbe4d45">crbegin</a> () const</td></tr>
<tr class="separator:a5c97d17a0ea17bbc9e6b303eccbe4d45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6895dbd3119c4a1624c82260eeac82ee"><td class="memTemplParams" colspan="2">template&lt;unsigned int I1, unsigned int I2, unsigned int ... IN&gt; </td></tr>
<tr class="memitem:a6895dbd3119c4a1624c82260eeac82ee"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a1d3e355ba73cc2409d11c30097bc5bb7">columns_iterator</a>&lt; <a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#aa61175868b88391c2842e9d6920f2bb8">const_reverse_iterator_tuple</a>, I1, I2, IN... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a6895dbd3119c4a1624c82260eeac82ee">crbegin</a> (<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I1 &gt; <a class="el" href="breit__wigner__plus__polynomial_8inl.html#a8175ec4e5461dcd38d40ead25fef205c">c1</a>, <a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I2 &gt; <a class="el" href="breit__wigner__plus__polynomial_8inl.html#a024a3031e2ed14c5d1405f6e99df1158">c2</a>, <a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; IN &gt; ...cn) const</td></tr>
<tr class="separator:a6895dbd3119c4a1624c82260eeac82ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96a4ec194174818cbf44f140d4af4889"><td class="memTemplParams" colspan="2">template&lt;unsigned int I&gt; </td></tr>
<tr class="memitem:a96a4ec194174818cbf44f140d4af4889"><td class="memTemplItemLeft" align="right" valign="top">hydra::thrust::tuple_element&lt; I, <a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#aa61175868b88391c2842e9d6920f2bb8">const_reverse_iterator_tuple</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a96a4ec194174818cbf44f140d4af4889">crbegin</a> (<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;) const</td></tr>
<tr class="separator:a96a4ec194174818cbf44f140d4af4889"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae600ca9c94d8ca8131a9967574ad9b2e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a67ce921a4b57cea999ba65990aed85e5">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#ae600ca9c94d8ca8131a9967574ad9b2e">crend</a> () const</td></tr>
<tr class="separator:ae600ca9c94d8ca8131a9967574ad9b2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a600af876d8240012011bfdb843a31272"><td class="memTemplParams" colspan="2">template&lt;unsigned int I1, unsigned int I2, unsigned int ... IN&gt; </td></tr>
<tr class="memitem:a600af876d8240012011bfdb843a31272"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a1d3e355ba73cc2409d11c30097bc5bb7">columns_iterator</a>&lt; <a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#aa61175868b88391c2842e9d6920f2bb8">const_reverse_iterator_tuple</a>, I1, I2, IN... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a600af876d8240012011bfdb843a31272">crend</a> (<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I1 &gt; <a class="el" href="breit__wigner__plus__polynomial_8inl.html#a8175ec4e5461dcd38d40ead25fef205c">c1</a>, <a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I2 &gt; <a class="el" href="breit__wigner__plus__polynomial_8inl.html#a024a3031e2ed14c5d1405f6e99df1158">c2</a>, <a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; IN &gt; ...cn) const</td></tr>
<tr class="separator:a600af876d8240012011bfdb843a31272"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a62c989cd7a5012785b2f711fde6f1e"><td class="memTemplParams" colspan="2">template&lt;unsigned int I&gt; </td></tr>
<tr class="memitem:a4a62c989cd7a5012785b2f711fde6f1e"><td class="memTemplItemLeft" align="right" valign="top">hydra::thrust::tuple_element&lt; I, <a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#aa61175868b88391c2842e9d6920f2bb8">const_reverse_iterator_tuple</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a4a62c989cd7a5012785b2f711fde6f1e">crend</a> (<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;) const</td></tr>
<tr class="separator:a4a62c989cd7a5012785b2f711fde6f1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d30985ed8a6bc605f98fd7ca3b2b76f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a2d30985ed8a6bc605f98fd7ca3b2b76f">empty</a> () const</td></tr>
<tr class="memdesc:a2d30985ed8a6bc605f98fd7ca3b2b76f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method returns true iff <a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a538b4dc02c86fa531e520179e3b3af46" title="Returns the number of elements in this multivector. ">size()</a> == 0.  <a href="#a2d30985ed8a6bc605f98fd7ca3b2b76f">More...</a><br /></td></tr>
<tr class="separator:a2d30985ed8a6bc605f98fd7ca3b2b76f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d0d4eeb0af21ae5ad8b94a99a963553"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a1629aefb94ab27551973be11a8ec38b7">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a3d0d4eeb0af21ae5ad8b94a99a963553">end</a> ()</td></tr>
<tr class="memdesc:a3d0d4eeb0af21ae5ad8b94a99a963553"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method returns a const_iterator pointing to one element past the last of this <code>multivector</code>.  <a href="#a3d0d4eeb0af21ae5ad8b94a99a963553">More...</a><br /></td></tr>
<tr class="separator:a3d0d4eeb0af21ae5ad8b94a99a963553"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6deaeb440a26993eeb44d37be2b23bc"><td class="memTemplParams" colspan="2">template&lt;typename Functor &gt; </td></tr>
<tr class="memitem:af6deaeb440a26993eeb44d37be2b23bc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a0690bbe116fa4fbb03eb68c41fd46fd2">caster_iterator</a>&lt; Functor &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#af6deaeb440a26993eeb44d37be2b23bc">end</a> (Functor const &amp;caster)</td></tr>
<tr class="separator:af6deaeb440a26993eeb44d37be2b23bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d150c40ca89a7126a80b71c858fc059"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#af8b44a2d78e7178eb90fd48f4046a9a7">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a8d150c40ca89a7126a80b71c858fc059">end</a> () const</td></tr>
<tr class="separator:a8d150c40ca89a7126a80b71c858fc059"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa8a518a5cace6250aac269bd68ac04d"><td class="memTemplParams" colspan="2">template&lt;unsigned int I1, unsigned int I2, unsigned int ... IN&gt; </td></tr>
<tr class="memitem:afa8a518a5cace6250aac269bd68ac04d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a1d3e355ba73cc2409d11c30097bc5bb7">columns_iterator</a>&lt; <a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a368e387d8be3b7b37c2aafb9bea02957">iterator_tuple</a>, I1, I2, IN... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#afa8a518a5cace6250aac269bd68ac04d">end</a> (<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I1 &gt; <a class="el" href="breit__wigner__plus__polynomial_8inl.html#a8175ec4e5461dcd38d40ead25fef205c">c1</a>, <a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I2 &gt; <a class="el" href="breit__wigner__plus__polynomial_8inl.html#a024a3031e2ed14c5d1405f6e99df1158">c2</a>, <a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; IN &gt; ...cn)</td></tr>
<tr class="separator:afa8a518a5cace6250aac269bd68ac04d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10cccaff21ca7227a7d384382b11c1fb"><td class="memTemplParams" colspan="2">template&lt;unsigned int I&gt; </td></tr>
<tr class="memitem:a10cccaff21ca7227a7d384382b11c1fb"><td class="memTemplItemLeft" align="right" valign="top">hydra::thrust::tuple_element&lt; I, <a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a368e387d8be3b7b37c2aafb9bea02957">iterator_tuple</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a10cccaff21ca7227a7d384382b11c1fb">end</a> (<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;)</td></tr>
<tr class="separator:a10cccaff21ca7227a7d384382b11c1fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc7d2c791b116198d15f465cb7cea924"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:abc7d2c791b116198d15f465cb7cea924"><td class="memTemplItemLeft" align="right" valign="top">hydra::thrust::tuple_element&lt; <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1index__in__tuple">detail::index_in_tuple</a>&lt; Type, tuple_type &gt;::value, <a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a368e387d8be3b7b37c2aafb9bea02957">iterator_tuple</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#abc7d2c791b116198d15f465cb7cea924">end</a> ()</td></tr>
<tr class="separator:abc7d2c791b116198d15f465cb7cea924"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad93d645db97afbb414bf4aed647076ad"><td class="memTemplParams" colspan="2">template&lt;unsigned int I1, unsigned int I2, unsigned int ... IN&gt; </td></tr>
<tr class="memitem:ad93d645db97afbb414bf4aed647076ad"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a1d3e355ba73cc2409d11c30097bc5bb7">columns_iterator</a>&lt; <a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#adaee497bf961bd3dbeee656a32b41c5e">const_iterator_tuple</a>, I1, I2, IN... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#ad93d645db97afbb414bf4aed647076ad">end</a> (<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I1 &gt; <a class="el" href="breit__wigner__plus__polynomial_8inl.html#a8175ec4e5461dcd38d40ead25fef205c">c1</a>, <a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I2 &gt; <a class="el" href="breit__wigner__plus__polynomial_8inl.html#a024a3031e2ed14c5d1405f6e99df1158">c2</a>, <a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; IN &gt; ...cn) const</td></tr>
<tr class="separator:ad93d645db97afbb414bf4aed647076ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a233e6a4be572ed0ee3ec8c6e7d71278d"><td class="memTemplParams" colspan="2">template&lt;unsigned int I&gt; </td></tr>
<tr class="memitem:a233e6a4be572ed0ee3ec8c6e7d71278d"><td class="memTemplItemLeft" align="right" valign="top">hydra::thrust::tuple_element&lt; I, <a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#adaee497bf961bd3dbeee656a32b41c5e">const_iterator_tuple</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a233e6a4be572ed0ee3ec8c6e7d71278d">end</a> (<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;) const</td></tr>
<tr class="separator:a233e6a4be572ed0ee3ec8c6e7d71278d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14dbc63f8e7e8ec3885a312c2e5d1d39"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a1629aefb94ab27551973be11a8ec38b7">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a14dbc63f8e7e8ec3885a312c2e5d1d39">erase</a> (<a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a1629aefb94ab27551973be11a8ec38b7">iterator</a> pos)</td></tr>
<tr class="memdesc:a14dbc63f8e7e8ec3885a312c2e5d1d39"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method removes the element at position pos.  <a href="#a14dbc63f8e7e8ec3885a312c2e5d1d39">More...</a><br /></td></tr>
<tr class="separator:a14dbc63f8e7e8ec3885a312c2e5d1d39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea268652a0d4f3c366e856e24b5069a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a1629aefb94ab27551973be11a8ec38b7">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#aea268652a0d4f3c366e856e24b5069a1">erase</a> (<a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a1629aefb94ab27551973be11a8ec38b7">iterator</a> first, <a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a1629aefb94ab27551973be11a8ec38b7">iterator</a> last)</td></tr>
<tr class="memdesc:aea268652a0d4f3c366e856e24b5069a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method removes the range of elements [first,last) from this <code>multivector</code>.  <a href="#aea268652a0d4f3c366e856e24b5069a1">More...</a><br /></td></tr>
<tr class="separator:aea268652a0d4f3c366e856e24b5069a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28e0d6656c560d6b21d907a2f0264901"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a634a39e968ee0a327c3a19a5575e97b3">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a28e0d6656c560d6b21d907a2f0264901">front</a> ()</td></tr>
<tr class="memdesc:a28e0d6656c560d6b21d907a2f0264901"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method returns a const_reference referring to the first element of this <code>multivector</code>.  <a href="#a28e0d6656c560d6b21d907a2f0264901">More...</a><br /></td></tr>
<tr class="separator:a28e0d6656c560d6b21d907a2f0264901"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c83a62b4698551a77aba946885e47c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#abf1fa17161766aad5401b5e85d19ad9c">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a9c83a62b4698551a77aba946885e47c9">front</a> () const</td></tr>
<tr class="memdesc:a9c83a62b4698551a77aba946885e47c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method returns a reference pointing to the first element of this <code>multivector</code>.  <a href="#a9c83a62b4698551a77aba946885e47c9">More...</a><br /></td></tr>
<tr class="separator:a9c83a62b4698551a77aba946885e47c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60518d1c9128e15689bd9e746ccc9f1e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a1629aefb94ab27551973be11a8ec38b7">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a60518d1c9128e15689bd9e746ccc9f1e">insert</a> (<a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a1629aefb94ab27551973be11a8ec38b7">iterator</a> pos, const <a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a7d4313d2ba0e92aa16a82173ca63e7d1">value_type</a> &amp;x)</td></tr>
<tr class="memdesc:a60518d1c9128e15689bd9e746ccc9f1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method inserts a single copy of a given exemplar value at the specified position in this <code>multivector</code>.  <a href="#a60518d1c9128e15689bd9e746ccc9f1e">More...</a><br /></td></tr>
<tr class="separator:a60518d1c9128e15689bd9e746ccc9f1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e1780ba1038452695c956bd4cd51f9b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a5e1780ba1038452695c956bd4cd51f9b">insert</a> (<a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a1629aefb94ab27551973be11a8ec38b7">iterator</a> pos, <a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a9f3b15a7a66792552891c6c25f69da59">size_type</a> <a class="el" href="crystal__ball__plus__exponential_8inl.html#a21f77208d6bc667560ff8aaf8f943b6a">n</a>, const <a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a7d4313d2ba0e92aa16a82173ca63e7d1">value_type</a> &amp;x)</td></tr>
<tr class="memdesc:a5e1780ba1038452695c956bd4cd51f9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method inserts a copy of an exemplar value to a range at the specified position in this <code>multivector</code>.  <a href="#a5e1780ba1038452695c956bd4cd51f9b">More...</a><br /></td></tr>
<tr class="separator:a5e1780ba1038452695c956bd4cd51f9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a585a8ae8a7c1716435a4beec93b73e1d"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator &gt; </td></tr>
<tr class="memitem:a585a8ae8a7c1716435a4beec93b73e1d"><td class="memTemplItemLeft" align="right" valign="top">hydra::thrust::detail::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__zip__iterator.html">detail::is_zip_iterator</a>&lt; InputIterator &gt;::value &amp;&amp;std::is_convertible&lt; typename hydra::thrust::iterator_traits&lt; InputIterator &gt;::<a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a7d4313d2ba0e92aa16a82173ca63e7d1">value_type</a>, <a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a7d4313d2ba0e92aa16a82173ca63e7d1">value_type</a> &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a585a8ae8a7c1716435a4beec93b73e1d">insert</a> (<a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a1629aefb94ab27551973be11a8ec38b7">iterator</a> pos, InputIterator first, InputIterator last)</td></tr>
<tr class="memdesc:a585a8ae8a7c1716435a4beec93b73e1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method inserts a copy of an input range at the specified position in this <code>multivector</code>.  <a href="#a585a8ae8a7c1716435a4beec93b73e1d">More...</a><br /></td></tr>
<tr class="separator:a585a8ae8a7c1716435a4beec93b73e1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb276a3aa3e7419a8c78a76587baba9d"><td class="memTemplParams" colspan="2">template&lt;typename ... Iterables&gt; </td></tr>
<tr class="memitem:abb276a3aa3e7419a8c78a76587baba9d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#abb276a3aa3e7419a8c78a76587baba9d">meld</a> (Iterables &amp;&amp;...iterables) -&gt; typename std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1all__true.html">detail::all_true</a>&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">detail::is_iterable</a>&lt; Iterables &gt;::value... &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1Range">hydra::Range</a>&lt; decltype(<a class="el" href="namespacehydra_1_1detail.html#a3d9f6a5b4844a887d53284f38f00f89a">detail::meld_iterators</a>(<a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#aca913ba3cee6616d05e08d61379aed6e">begin</a>(), std::forward&lt; Iterables &gt;(iterables).<a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#aca913ba3cee6616d05e08d61379aed6e">begin</a>()...))&gt;&gt;::type</td></tr>
<tr class="separator:abb276a3aa3e7419a8c78a76587baba9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a268c9a9878bd43e75764d056fb86011f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; hydra::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a268c9a9878bd43e75764d056fb86011f">operator=</a> (<a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; hydra::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; const &amp;other)</td></tr>
<tr class="memdesc:a268c9a9878bd43e75764d056fb86011f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator.  <a href="#a268c9a9878bd43e75764d056fb86011f">More...</a><br /></td></tr>
<tr class="separator:a268c9a9878bd43e75764d056fb86011f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab94fc7fa785f6fff4dbc95e8bedc7713"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; hydra::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#ab94fc7fa785f6fff4dbc95e8bedc7713">operator=</a> (<a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; hydra::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt; &gt; &amp;&amp;other)</td></tr>
<tr class="memdesc:ab94fc7fa785f6fff4dbc95e8bedc7713"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move-assignment operator.  <a href="#ab94fc7fa785f6fff4dbc95e8bedc7713">More...</a><br /></td></tr>
<tr class="separator:ab94fc7fa785f6fff4dbc95e8bedc7713"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1984d1637790e8722556f37db6800204"><td class="memTemplParams" colspan="2">template&lt;hydra::detail::Backend BACKEND2&gt; </td></tr>
<tr class="memitem:a1984d1637790e8722556f37db6800204"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; hydra::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt; &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a1984d1637790e8722556f37db6800204">operator=</a> (<a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; hydra::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND2 &gt; &gt; const &amp;other)</td></tr>
<tr class="memdesc:a1984d1637790e8722556f37db6800204"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator.  <a href="#a1984d1637790e8722556f37db6800204">More...</a><br /></td></tr>
<tr class="separator:a1984d1637790e8722556f37db6800204"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1514257c6702811609083568b7e5cb2"><td class="memTemplParams" colspan="2">template&lt;typename Functor &gt; </td></tr>
<tr class="memitem:ae1514257c6702811609083568b7e5cb2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a0690bbe116fa4fbb03eb68c41fd46fd2">caster_iterator</a>&lt; Functor &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#ae1514257c6702811609083568b7e5cb2">operator[]</a> (Functor const &amp;caster)</td></tr>
<tr class="separator:ae1514257c6702811609083568b7e5cb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5b0f4a34e75645248ce95c48a4d1dd7"><td class="memTemplParams" colspan="2">template&lt;unsigned int I&gt; </td></tr>
<tr class="memitem:aa5b0f4a34e75645248ce95c48a4d1dd7"><td class="memTemplItemLeft" align="right" valign="top">hydra::thrust::tuple_element&lt; I, <a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a368e387d8be3b7b37c2aafb9bea02957">iterator_tuple</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#aa5b0f4a34e75645248ce95c48a4d1dd7">operator[]</a> (<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt; index)</td></tr>
<tr class="separator:aa5b0f4a34e75645248ce95c48a4d1dd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fe837c8c1153d2223ba06a398aab1be"><td class="memTemplParams" colspan="2">template&lt;unsigned int I&gt; </td></tr>
<tr class="memitem:a4fe837c8c1153d2223ba06a398aab1be"><td class="memTemplItemLeft" align="right" valign="top">hydra::thrust::tuple_element&lt; I, <a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#adaee497bf961bd3dbeee656a32b41c5e">const_iterator_tuple</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a4fe837c8c1153d2223ba06a398aab1be">operator[]</a> (<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt; index) const</td></tr>
<tr class="separator:a4fe837c8c1153d2223ba06a398aab1be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca1c1d4a8d11520bfb3eabdf51fc0dbf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a634a39e968ee0a327c3a19a5575e97b3">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#aca1c1d4a8d11520bfb3eabdf51fc0dbf">operator[]</a> (size_t <a class="el" href="crystal__ball__plus__exponential_8inl.html#a21f77208d6bc667560ff8aaf8f943b6a">n</a>)</td></tr>
<tr class="memdesc:aca1c1d4a8d11520bfb3eabdf51fc0dbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscript access to the data contained in this vector_dev.  <a href="#aca1c1d4a8d11520bfb3eabdf51fc0dbf">More...</a><br /></td></tr>
<tr class="separator:aca1c1d4a8d11520bfb3eabdf51fc0dbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f75aa75bcf6042c5dda5689965f4817"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#abf1fa17161766aad5401b5e85d19ad9c">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a2f75aa75bcf6042c5dda5689965f4817">operator[]</a> (size_t <a class="el" href="crystal__ball__plus__exponential_8inl.html#a21f77208d6bc667560ff8aaf8f943b6a">n</a>) const</td></tr>
<tr class="memdesc:a2f75aa75bcf6042c5dda5689965f4817"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscript read access to the data contained in this vector_dev.  <a href="#a2f75aa75bcf6042c5dda5689965f4817">More...</a><br /></td></tr>
<tr class="separator:a2f75aa75bcf6042c5dda5689965f4817"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bd0e5a428350f2f697f8b0408cf8d49"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a3bd0e5a428350f2f697f8b0408cf8d49">pop_back</a> ()</td></tr>
<tr class="memdesc:a3bd0e5a428350f2f697f8b0408cf8d49"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method erases the last element of this <code>multivector</code>, invalidating all iterators and references to it.  <a href="#a3bd0e5a428350f2f697f8b0408cf8d49">More...</a><br /></td></tr>
<tr class="separator:a3bd0e5a428350f2f697f8b0408cf8d49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bfdf1d7b12bed0bd333e6953e6346b3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a9bfdf1d7b12bed0bd333e6953e6346b3">push_back</a> (<a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a7d4313d2ba0e92aa16a82173ca63e7d1">value_type</a> const &amp;value)</td></tr>
<tr class="memdesc:a9bfdf1d7b12bed0bd333e6953e6346b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method appends the given element to the end of this <code>multivector</code>.  <a href="#a9bfdf1d7b12bed0bd333e6953e6346b3">More...</a><br /></td></tr>
<tr class="separator:a9bfdf1d7b12bed0bd333e6953e6346b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad937b5f986a856a6ad739197cca54a04"><td class="memTemplParams" colspan="2">template&lt;typename Functor , typename Obj &gt; </td></tr>
<tr class="memitem:ad937b5f986a856a6ad739197cca54a04"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#ad937b5f986a856a6ad739197cca54a04">push_back</a> (Functor const &amp;functor, Obj const &amp;obj)</td></tr>
<tr class="memdesc:ad937b5f986a856a6ad739197cca54a04"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method appends the given element to the end of this <code>multivector</code>.  <a href="#ad937b5f986a856a6ad739197cca54a04">More...</a><br /></td></tr>
<tr class="separator:ad937b5f986a856a6ad739197cca54a04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8314472118ceddcf13458261395f6738"><td class="memTemplParams" colspan="2">template&lt;typename Functor &gt; </td></tr>
<tr class="memitem:a8314472118ceddcf13458261395f6738"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#af09cd871c1e32293d8c9cb44034f641e">caster_reverse_iterator</a>&lt; Functor &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a8314472118ceddcf13458261395f6738">rbegin</a> (Functor const &amp;caster)</td></tr>
<tr class="separator:a8314472118ceddcf13458261395f6738"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd5b3752b1f64b2d89f01152bd7be5e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a9f1775925ab9f2f78ded2885ea7264e7">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#acd5b3752b1f64b2d89f01152bd7be5e4">rbegin</a> ()</td></tr>
<tr class="separator:acd5b3752b1f64b2d89f01152bd7be5e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2951ce81ad290740e1a9dee62493e69"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a67ce921a4b57cea999ba65990aed85e5">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#aa2951ce81ad290740e1a9dee62493e69">rbegin</a> () const</td></tr>
<tr class="separator:aa2951ce81ad290740e1a9dee62493e69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8adf837cb83496b2b2e46248c0c4763f"><td class="memTemplParams" colspan="2">template&lt;unsigned int I1, unsigned int I2, unsigned int ... IN&gt; </td></tr>
<tr class="memitem:a8adf837cb83496b2b2e46248c0c4763f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a1d3e355ba73cc2409d11c30097bc5bb7">columns_iterator</a>&lt; <a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a61849adfc0c475aa23a72cc3e626cf89">reverse_iterator_tuple</a>, I1, I2, IN... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a8adf837cb83496b2b2e46248c0c4763f">rbegin</a> (<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I1 &gt; <a class="el" href="breit__wigner__plus__polynomial_8inl.html#a8175ec4e5461dcd38d40ead25fef205c">c1</a>, <a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I2 &gt; <a class="el" href="breit__wigner__plus__polynomial_8inl.html#a024a3031e2ed14c5d1405f6e99df1158">c2</a>, <a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; IN &gt; ...cn)</td></tr>
<tr class="separator:a8adf837cb83496b2b2e46248c0c4763f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85a64c6bcdad159e64d155eaad1b8e3d"><td class="memTemplParams" colspan="2">template&lt;unsigned int I&gt; </td></tr>
<tr class="memitem:a85a64c6bcdad159e64d155eaad1b8e3d"><td class="memTemplItemLeft" align="right" valign="top">hydra::thrust::tuple_element&lt; I, <a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a61849adfc0c475aa23a72cc3e626cf89">reverse_iterator_tuple</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a85a64c6bcdad159e64d155eaad1b8e3d">rbegin</a> (<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;)</td></tr>
<tr class="separator:a85a64c6bcdad159e64d155eaad1b8e3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5be3d2ea8d621768c901fd330820b4f9"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:a5be3d2ea8d621768c901fd330820b4f9"><td class="memTemplItemLeft" align="right" valign="top">hydra::thrust::tuple_element&lt; <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1index__in__tuple">detail::index_in_tuple</a>&lt; Type, tuple_type &gt;::value, <a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a61849adfc0c475aa23a72cc3e626cf89">reverse_iterator_tuple</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a5be3d2ea8d621768c901fd330820b4f9">rbegin</a> ()</td></tr>
<tr class="separator:a5be3d2ea8d621768c901fd330820b4f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aead81f943a98d93a69dffd428c5aa6c6"><td class="memTemplParams" colspan="2">template&lt;unsigned int I1, unsigned int I2, unsigned int ... IN&gt; </td></tr>
<tr class="memitem:aead81f943a98d93a69dffd428c5aa6c6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a1d3e355ba73cc2409d11c30097bc5bb7">columns_iterator</a>&lt; <a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#aa61175868b88391c2842e9d6920f2bb8">const_reverse_iterator_tuple</a>, I1, I2, IN... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#aead81f943a98d93a69dffd428c5aa6c6">rbegin</a> (<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I1 &gt; <a class="el" href="breit__wigner__plus__polynomial_8inl.html#a8175ec4e5461dcd38d40ead25fef205c">c1</a>, <a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I2 &gt; <a class="el" href="breit__wigner__plus__polynomial_8inl.html#a024a3031e2ed14c5d1405f6e99df1158">c2</a>, <a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; IN &gt; ...cn) const</td></tr>
<tr class="separator:aead81f943a98d93a69dffd428c5aa6c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af32389b6baedd3981effe4568173973f"><td class="memTemplParams" colspan="2">template&lt;unsigned int I&gt; </td></tr>
<tr class="memitem:af32389b6baedd3981effe4568173973f"><td class="memTemplItemLeft" align="right" valign="top">hydra::thrust::tuple_element&lt; I, <a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#aa61175868b88391c2842e9d6920f2bb8">const_reverse_iterator_tuple</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#af32389b6baedd3981effe4568173973f">rbegin</a> (<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;) const</td></tr>
<tr class="separator:af32389b6baedd3981effe4568173973f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46bb1c230398dc29b3acc4bb087ad1cf"><td class="memTemplParams" colspan="2">template&lt;typename Functor &gt; </td></tr>
<tr class="memitem:a46bb1c230398dc29b3acc4bb087ad1cf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#af09cd871c1e32293d8c9cb44034f641e">caster_reverse_iterator</a>&lt; Functor &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a46bb1c230398dc29b3acc4bb087ad1cf">rend</a> (Functor const &amp;caster)</td></tr>
<tr class="separator:a46bb1c230398dc29b3acc4bb087ad1cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf418b0ff574995b502c0f2257561204"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a9f1775925ab9f2f78ded2885ea7264e7">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#adf418b0ff574995b502c0f2257561204">rend</a> ()</td></tr>
<tr class="separator:adf418b0ff574995b502c0f2257561204"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a4b502c04ff0db98ebcc31a537f8963"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a67ce921a4b57cea999ba65990aed85e5">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a7a4b502c04ff0db98ebcc31a537f8963">rend</a> () const</td></tr>
<tr class="separator:a7a4b502c04ff0db98ebcc31a537f8963"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa37c0d25a456c3f4b3f5ad8622fd7246"><td class="memTemplParams" colspan="2">template&lt;unsigned int I1, unsigned int I2, unsigned int ... IN&gt; </td></tr>
<tr class="memitem:aa37c0d25a456c3f4b3f5ad8622fd7246"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a1d3e355ba73cc2409d11c30097bc5bb7">columns_iterator</a>&lt; <a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a61849adfc0c475aa23a72cc3e626cf89">reverse_iterator_tuple</a>, I1, I2, IN... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#aa37c0d25a456c3f4b3f5ad8622fd7246">rend</a> (<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I1 &gt; <a class="el" href="breit__wigner__plus__polynomial_8inl.html#a8175ec4e5461dcd38d40ead25fef205c">c1</a>, <a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I2 &gt; <a class="el" href="breit__wigner__plus__polynomial_8inl.html#a024a3031e2ed14c5d1405f6e99df1158">c2</a>, <a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; IN &gt; ...cn)</td></tr>
<tr class="separator:aa37c0d25a456c3f4b3f5ad8622fd7246"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83be5524db39b7f585e58af8db47fbfd"><td class="memTemplParams" colspan="2">template&lt;unsigned int I&gt; </td></tr>
<tr class="memitem:a83be5524db39b7f585e58af8db47fbfd"><td class="memTemplItemLeft" align="right" valign="top">hydra::thrust::tuple_element&lt; I, <a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a61849adfc0c475aa23a72cc3e626cf89">reverse_iterator_tuple</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a83be5524db39b7f585e58af8db47fbfd">rend</a> (<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;)</td></tr>
<tr class="separator:a83be5524db39b7f585e58af8db47fbfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d2894a60f904fe4bce6601db79d5735"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:a6d2894a60f904fe4bce6601db79d5735"><td class="memTemplItemLeft" align="right" valign="top">hydra::thrust::tuple_element&lt; <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1index__in__tuple">detail::index_in_tuple</a>&lt; Type, tuple_type &gt;::value, <a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a61849adfc0c475aa23a72cc3e626cf89">reverse_iterator_tuple</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a6d2894a60f904fe4bce6601db79d5735">rend</a> ()</td></tr>
<tr class="separator:a6d2894a60f904fe4bce6601db79d5735"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a805293521e50419aa0c2b49bb84f543b"><td class="memTemplParams" colspan="2">template&lt;unsigned int I1, unsigned int I2, unsigned int ... IN&gt; </td></tr>
<tr class="memitem:a805293521e50419aa0c2b49bb84f543b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a1d3e355ba73cc2409d11c30097bc5bb7">columns_iterator</a>&lt; <a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#aa61175868b88391c2842e9d6920f2bb8">const_reverse_iterator_tuple</a>, I1, I2, IN... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a805293521e50419aa0c2b49bb84f543b">rend</a> (<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I1 &gt; <a class="el" href="breit__wigner__plus__polynomial_8inl.html#a8175ec4e5461dcd38d40ead25fef205c">c1</a>, <a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I2 &gt; <a class="el" href="breit__wigner__plus__polynomial_8inl.html#a024a3031e2ed14c5d1405f6e99df1158">c2</a>, <a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; IN &gt; ...cn) const</td></tr>
<tr class="separator:a805293521e50419aa0c2b49bb84f543b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab598456eb7a907573814b339c573c551"><td class="memTemplParams" colspan="2">template&lt;unsigned int I&gt; </td></tr>
<tr class="memitem:ab598456eb7a907573814b339c573c551"><td class="memTemplItemLeft" align="right" valign="top">hydra::thrust::tuple_element&lt; I, <a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#aa61175868b88391c2842e9d6920f2bb8">const_reverse_iterator_tuple</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#ab598456eb7a907573814b339c573c551">rend</a> (<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;) const</td></tr>
<tr class="separator:ab598456eb7a907573814b339c573c551"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff78065f08c1dd5cf2efb98fc910b347"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#aff78065f08c1dd5cf2efb98fc910b347">reserve</a> (<a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a9f3b15a7a66792552891c6c25f69da59">size_type</a> <a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a538b4dc02c86fa531e520179e3b3af46">size</a>)</td></tr>
<tr class="memdesc:aff78065f08c1dd5cf2efb98fc910b347"><td class="mdescLeft">&#160;</td><td class="mdescRight">If n is less than or equal to <a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#afc5ff995f315aed5649bbac9f818fe09" title="Returns the number of elements which have been reserved in this multivector. ">capacity()</a>, this call has no effect.  <a href="#aff78065f08c1dd5cf2efb98fc910b347">More...</a><br /></td></tr>
<tr class="separator:aff78065f08c1dd5cf2efb98fc910b347"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a689167f4f3551861f83d4cef11dcb53b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a689167f4f3551861f83d4cef11dcb53b">resize</a> (<a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a9f3b15a7a66792552891c6c25f69da59">size_type</a> new_size)</td></tr>
<tr class="memdesc:a689167f4f3551861f83d4cef11dcb53b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes this <code>multivector</code> to the specified number of elements.  <a href="#a689167f4f3551861f83d4cef11dcb53b">More...</a><br /></td></tr>
<tr class="separator:a689167f4f3551861f83d4cef11dcb53b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6036eaf0cbafdaa91ba33bad59dfafd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#ab6036eaf0cbafdaa91ba33bad59dfafd">shrink_to_fit</a> ()</td></tr>
<tr class="memdesc:ab6036eaf0cbafdaa91ba33bad59dfafd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method shrinks the capacity of this <code>multivector</code> to exactly fit its elements.  <a href="#ab6036eaf0cbafdaa91ba33bad59dfafd">More...</a><br /></td></tr>
<tr class="separator:ab6036eaf0cbafdaa91ba33bad59dfafd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a538b4dc02c86fa531e520179e3b3af46"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a9f3b15a7a66792552891c6c25f69da59">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a538b4dc02c86fa531e520179e3b3af46">size</a> () const</td></tr>
<tr class="memdesc:a538b4dc02c86fa531e520179e3b3af46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements in this <code>multivector</code>.  <a href="#a538b4dc02c86fa531e520179e3b3af46">More...</a><br /></td></tr>
<tr class="separator:a538b4dc02c86fa531e520179e3b3af46"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename ... T, hydra::detail::Backend BACKEND&gt;<br />
class hydra::multivector&lt; hydra::thrust::tuple&lt; T... &gt;, hydra::detail::BackendPolicy&lt; BACKEND &gt; &gt;</h3>

<p>This class implements storage in SoA layouts for table where all elements have the same type. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a0690bbe116fa4fbb03eb68c41fd46fd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0690bbe116fa4fbb03eb68c41fd46fd2">&#9670;&nbsp;</a></span>caster_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<div class="memtemplate">
template&lt;typename Functor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::<a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a0690bbe116fa4fbb03eb68c41fd46fd2">caster_iterator</a> =  hydra::thrust::transform_iterator&lt; Functor, <a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a1629aefb94ab27551973be11a8ec38b7">iterator</a>, typename std::result_of&lt;Functor(tuple_type&amp;)&gt;::type &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af09cd871c1e32293d8c9cb44034f641e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af09cd871c1e32293d8c9cb44034f641e">&#9670;&nbsp;</a></span>caster_reverse_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<div class="memtemplate">
template&lt;typename Functor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::<a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#af09cd871c1e32293d8c9cb44034f641e">caster_reverse_iterator</a> =  hydra::thrust::transform_iterator&lt; Functor, <a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a9f1775925ab9f2f78ded2885ea7264e7">reverse_iterator</a>, typename std::result_of&lt;Functor(tuple_type&amp;)&gt;::type &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1d3e355ba73cc2409d11c30097bc5bb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d3e355ba73cc2409d11c30097bc5bb7">&#9670;&nbsp;</a></span>columns_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<div class="memtemplate">
template&lt;typename Iterators , unsigned int I1, unsigned int I2, unsigned int ... IN&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::<a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a1d3e355ba73cc2409d11c30097bc5bb7">columns_iterator</a> =  hydra::thrust::zip_iterator&lt; hydra::thrust::tuple&lt; typename hydra::thrust::tuple_element&lt; I1, Iterators &gt;::type, typename hydra::thrust::tuple_element&lt; I2, Iterators &gt;::type, typename hydra::thrust::tuple_element&lt; IN, Iterators &gt;::type...&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af8b44a2d78e7178eb90fd48f4046a9a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8b44a2d78e7178eb90fd48f4046a9a7">&#9670;&nbsp;</a></span>const_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef hydra::thrust::zip_iterator&lt;<a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#adaee497bf961bd3dbeee656a32b41c5e">const_iterator_tuple</a>&gt; <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::<a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#af8b44a2d78e7178eb90fd48f4046a9a7">const_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adaee497bf961bd3dbeee656a32b41c5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adaee497bf961bd3dbeee656a32b41c5e">&#9670;&nbsp;</a></span>const_iterator_tuple</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef hydra::thrust::tuple&lt; _const_iterator&lt;T&gt;... &gt; <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::<a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#adaee497bf961bd3dbeee656a32b41c5e">const_iterator_tuple</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abf1fa17161766aad5401b5e85d19ad9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf1fa17161766aad5401b5e85d19ad9c">&#9670;&nbsp;</a></span>const_reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef hydra::thrust::iterator_traits&lt;<a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#af8b44a2d78e7178eb90fd48f4046a9a7">const_iterator</a>&gt;::<a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a634a39e968ee0a327c3a19a5575e97b3">reference</a> <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::<a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#abf1fa17161766aad5401b5e85d19ad9c">const_reference</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5d281c4f5bed9f2a9e843454d58e19ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d281c4f5bed9f2a9e843454d58e19ee">&#9670;&nbsp;</a></span>const_reference_tuple</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef hydra::thrust::tuple&lt; _const_reference&lt;T&gt;... &gt; <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::<a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a5d281c4f5bed9f2a9e843454d58e19ee">const_reference_tuple</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a67ce921a4b57cea999ba65990aed85e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67ce921a4b57cea999ba65990aed85e5">&#9670;&nbsp;</a></span>const_reverse_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef hydra::thrust::zip_iterator&lt;<a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#aa61175868b88391c2842e9d6920f2bb8">const_reverse_iterator_tuple</a>&gt; <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::<a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a67ce921a4b57cea999ba65990aed85e5">const_reverse_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa61175868b88391c2842e9d6920f2bb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa61175868b88391c2842e9d6920f2bb8">&#9670;&nbsp;</a></span>const_reverse_iterator_tuple</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef hydra::thrust::tuple&lt; _const_reverse_iterator&lt;T&gt;...&gt; <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::<a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#aa61175868b88391c2842e9d6920f2bb8">const_reverse_iterator_tuple</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1629aefb94ab27551973be11a8ec38b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1629aefb94ab27551973be11a8ec38b7">&#9670;&nbsp;</a></span>iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef hydra::thrust::zip_iterator&lt;<a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a368e387d8be3b7b37c2aafb9bea02957">iterator_tuple</a>&gt; <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::<a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a1629aefb94ab27551973be11a8ec38b7">iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a42096e41cf6d517fb42f4f3c5ead940f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42096e41cf6d517fb42f4f3c5ead940f">&#9670;&nbsp;</a></span>iterator_category</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef hydra::thrust::iterator_traits&lt;<a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a1629aefb94ab27551973be11a8ec38b7">iterator</a>&gt;::<a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a42096e41cf6d517fb42f4f3c5ead940f">iterator_category</a> <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::<a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a42096e41cf6d517fb42f4f3c5ead940f">iterator_category</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a368e387d8be3b7b37c2aafb9bea02957"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a368e387d8be3b7b37c2aafb9bea02957">&#9670;&nbsp;</a></span>iterator_tuple</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef hydra::thrust::tuple&lt; _iterator&lt;T&gt;... &gt; <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::<a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a368e387d8be3b7b37c2aafb9bea02957">iterator_tuple</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a03cac047f8021a587197d8cf38565a0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03cac047f8021a587197d8cf38565a0f">&#9670;&nbsp;</a></span>pointer_tuple</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef hydra::thrust::tuple&lt; _pointer&lt;T&gt;... &gt; <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::<a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a03cac047f8021a587197d8cf38565a0f">pointer_tuple</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a634a39e968ee0a327c3a19a5575e97b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a634a39e968ee0a327c3a19a5575e97b3">&#9670;&nbsp;</a></span>reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef hydra::thrust::iterator_traits&lt;<a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a1629aefb94ab27551973be11a8ec38b7">iterator</a>&gt;::<a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a634a39e968ee0a327c3a19a5575e97b3">reference</a> <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::<a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a634a39e968ee0a327c3a19a5575e97b3">reference</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a02f65aaf76d1ac43a95e689b275bdc99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02f65aaf76d1ac43a95e689b275bdc99">&#9670;&nbsp;</a></span>reference_tuple</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef hydra::thrust::tuple&lt; _reference&lt;T&gt;... &gt; <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::<a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a02f65aaf76d1ac43a95e689b275bdc99">reference_tuple</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9f1775925ab9f2f78ded2885ea7264e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f1775925ab9f2f78ded2885ea7264e7">&#9670;&nbsp;</a></span>reverse_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef hydra::thrust::zip_iterator&lt;<a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a61849adfc0c475aa23a72cc3e626cf89">reverse_iterator_tuple</a>&gt; <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::<a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a9f1775925ab9f2f78ded2885ea7264e7">reverse_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a61849adfc0c475aa23a72cc3e626cf89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61849adfc0c475aa23a72cc3e626cf89">&#9670;&nbsp;</a></span>reverse_iterator_tuple</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef hydra::thrust::tuple&lt; _reverse_iterator&lt;T&gt;... &gt; <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::<a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a61849adfc0c475aa23a72cc3e626cf89">reverse_iterator_tuple</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9f3b15a7a66792552891c6c25f69da59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f3b15a7a66792552891c6c25f69da59">&#9670;&nbsp;</a></span>size_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef size_t <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::<a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a9f3b15a7a66792552891c6c25f69da59">size_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a54b6ba02f47207787e936f2e49aec1ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54b6ba02f47207787e936f2e49aec1ab">&#9670;&nbsp;</a></span>storage_tuple</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef hydra::thrust::tuple&lt; _vector&lt;T&gt;... &gt; <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::<a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a54b6ba02f47207787e936f2e49aec1ab">storage_tuple</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7d4313d2ba0e92aa16a82173ca63e7d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d4313d2ba0e92aa16a82173ca63e7d1">&#9670;&nbsp;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef hydra::thrust::iterator_traits&lt;<a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a1629aefb94ab27551973be11a8ec38b7">iterator</a>&gt;::<a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a7d4313d2ba0e92aa16a82173ca63e7d1">value_type</a> <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::<a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a7d4313d2ba0e92aa16a82173ca63e7d1">value_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aaf85a0b76263ff62736d98eb63c08713"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf85a0b76263ff62736d98eb63c08713">&#9670;&nbsp;</a></span>value_type_tuple</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef hydra::thrust::tuple&lt; _value_type&lt;T&gt;...&gt; <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::<a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#aaf85a0b76263ff62736d98eb63c08713">value_type_tuple</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ac0f3f8241dc119c258ed79a957445c59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0f3f8241dc119c258ed79a957445c59">&#9670;&nbsp;</a></span>multivector() <span class="overload">[1/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::<a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor. </p>
<p>This constructor creates an empty <code>multivector</code>. </p>

</div>
</div>
<a id="a9b899533c37b03d9d1f21551a7b89745"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b899533c37b03d9d1f21551a7b89745">&#9670;&nbsp;</a></span>multivector() <span class="overload">[2/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::<a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor initializing the <code>multivector</code> with <code>n</code> entries. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The number of elements to initially create. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aecca33fdaf2bf772e4d3d5482109a063"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecca33fdaf2bf772e4d3d5482109a063">&#9670;&nbsp;</a></span>multivector() <span class="overload">[3/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::<a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a7d4313d2ba0e92aa16a82173ca63e7d1">value_type</a> const &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor initializing the multivector with <code>n</code> copies of <code>value</code> . </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>number of elements </td></tr>
    <tr><td class="paramname">value</td><td>object to copy from (<a class="el" href="namespacehydra.html#ac3486502b2db72187626125cea971683" title="tuple template is an alias to the variadic version of hydra::thrust::tuple and that can be instantiat...">hydra::tuple</a> or convertible to <a class="el" href="namespacehydra.html#ac3486502b2db72187626125cea971683" title="tuple template is an alias to the variadic version of hydra::thrust::tuple and that can be instantiat...">hydra::tuple</a>) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a10e7230730406b1d121a99f95e34044e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10e7230730406b1d121a99f95e34044e">&#9670;&nbsp;</a></span>multivector() <span class="overload">[4/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<div class="memtemplate">
template&lt;typename Int , typename  = typename hydra::thrust::detail::enable_if&lt;std::is_integral&lt;Int&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::<a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#a1f40581ef3c81ef08844d3beb59842f7">hydra::pair</a>&lt; Int, hydra::thrust::tuple&lt; T... &gt; &gt; const &amp;&#160;</td>
          <td class="paramname"><em>pair</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor initializing the multivector with <code>n</code> copies of <code>value</code> . </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pair</td><td><a class="el" href="namespacehydra.html#a1f40581ef3c81ef08844d3beb59842f7" title="pair template is an alias to the hydra::thrust::pair structure. ">hydra::pair</a>&lt;size_t, <a class="el" href="namespacehydra.html#ac3486502b2db72187626125cea971683" title="tuple template is an alias to the variadic version of hydra::thrust::tuple and that can be instantiat...">hydra::tuple&lt;T...&gt;</a> &gt; object to copy from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad438442be2dbd1093b65a7ab4359b958"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad438442be2dbd1093b65a7ab4359b958">&#9670;&nbsp;</a></span>multivector() <span class="overload">[5/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::<a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; hydra::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3cfebe548159e3bb83f1f81b609e4c16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cfebe548159e3bb83f1f81b609e4c16">&#9670;&nbsp;</a></span>multivector() <span class="overload">[6/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::<a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; hydra::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a30d82b56fef7b14ab73b9bca95955553"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30d82b56fef7b14ab73b9bca95955553">&#9670;&nbsp;</a></span>multivector() <span class="overload">[7/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<div class="memtemplate">
template&lt;hydra::detail::Backend BACKEND2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::<a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; hydra::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND2 &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor for containers allocated in different backends. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af7c0c982532d02bd407f131831cef444"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7c0c982532d02bd407f131831cef444">&#9670;&nbsp;</a></span>multivector() <span class="overload">[8/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<div class="memtemplate">
template&lt;typename Iterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::<a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a> </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This constructor builds a <code>multivector</code> from a range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The beginning of the range. </td></tr>
    <tr><td class="paramname">last</td><td>The end of the range. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7f86109bf2f713ae0970c31a37655888"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f86109bf2f713ae0970c31a37655888">&#9670;&nbsp;</a></span>multivector() <span class="overload">[9/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<div class="memtemplate">
template&lt;typename Iterable , typename  = typename std::enable_if&lt;	           (detail::is_iterable&lt;Iterable&gt;::value) &amp;&amp;	          !(detail::is_iterator&lt;Iterable&gt;::value) &amp;&amp;	           (std::is_convertible&lt;decltype(*std::declval&lt;Iterable&gt;().begin()), value_type&gt;::value)	          &gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::<a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a> </td>
          <td>(</td>
          <td class="paramtype">Iterable &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aacaddbab1740ee8f92c7b05d12801851"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacaddbab1740ee8f92c7b05d12801851">&#9670;&nbsp;</a></span>back() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a634a39e968ee0a327c3a19a5575e97b3">reference</a> <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method returns a reference referring to the last element of this vector_dev. </p>
<dl class="section return"><dt>Returns</dt><dd>The last element of this <code>multivector</code>. </dd></dl>

</div>
</div>
<a id="adf0e4fd614d49752f28441651767a896"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf0e4fd614d49752f28441651767a896">&#9670;&nbsp;</a></span>back() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#abf1fa17161766aad5401b5e85d19ad9c">const_reference</a> <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method returns a const reference pointing to the last element of this <code>multivector</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>The last element of this <code>multivector</code>. </dd></dl>

</div>
</div>
<a id="aca913ba3cee6616d05e08d61379aed6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca913ba3cee6616d05e08d61379aed6e">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a1629aefb94ab27551973be11a8ec38b7">iterator</a> <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method returns an iterator pointing to the beginning of this <code>multivector</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>iterator </dd></dl>

</div>
</div>
<a id="ae49f4041910c6285a74871e3e619a386"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae49f4041910c6285a74871e3e619a386">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<div class="memtemplate">
template&lt;typename Functor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a0690bbe116fa4fbb03eb68c41fd46fd2">caster_iterator</a>&lt;Functor&gt; <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::begin </td>
          <td>(</td>
          <td class="paramtype">Functor const &amp;&#160;</td>
          <td class="paramname"><em>caster</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a781e7ea3c4c2201a468244fbd2c94612"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a781e7ea3c4c2201a468244fbd2c94612">&#9670;&nbsp;</a></span>begin() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#af8b44a2d78e7178eb90fd48f4046a9a7">const_iterator</a> <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a40a8523aaebfa07b9295b31039873b29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40a8523aaebfa07b9295b31039873b29">&#9670;&nbsp;</a></span>begin() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<div class="memtemplate">
template&lt;unsigned int I1, unsigned int I2, unsigned int ... IN&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a1d3e355ba73cc2409d11c30097bc5bb7">columns_iterator</a>&lt; <a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a368e387d8be3b7b37c2aafb9bea02957">iterator_tuple</a>, I1, I2,IN...&gt; <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::begin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I1 &gt;&#160;</td>
          <td class="paramname"><em>c1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I2 &gt;&#160;</td>
          <td class="paramname"><em>c2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; IN &gt; ...&#160;</td>
          <td class="paramname"><em>cn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1992c0d4b108dbae5bb1d5e6afb878e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1992c0d4b108dbae5bb1d5e6afb878e4">&#9670;&nbsp;</a></span>begin() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<div class="memtemplate">
template&lt;unsigned int I&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">hydra::thrust::tuple_element&lt;I, <a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a368e387d8be3b7b37c2aafb9bea02957">iterator_tuple</a>&gt;::type <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::begin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a20a975ad5357fac102c786eb82af9da8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20a975ad5357fac102c786eb82af9da8">&#9670;&nbsp;</a></span>begin() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<div class="memtemplate">
template&lt;typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">hydra::thrust::tuple_element&lt; <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1index__in__tuple">detail::index_in_tuple</a>&lt;Type, tuple_type&gt;::value , <a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a368e387d8be3b7b37c2aafb9bea02957">iterator_tuple</a> &gt;::type <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac9d3c549dc330e94ac5da3d4ded2ad35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9d3c549dc330e94ac5da3d4ded2ad35">&#9670;&nbsp;</a></span>begin() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<div class="memtemplate">
template&lt;unsigned int I1, unsigned int I2, unsigned int ... IN&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a1d3e355ba73cc2409d11c30097bc5bb7">columns_iterator</a>&lt; <a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#adaee497bf961bd3dbeee656a32b41c5e">const_iterator_tuple</a>, I1, I2,IN...&gt; <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::begin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I1 &gt;&#160;</td>
          <td class="paramname"><em>c1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I2 &gt;&#160;</td>
          <td class="paramname"><em>c2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; IN &gt; ...&#160;</td>
          <td class="paramname"><em>cn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3334cdbee1acd115821877edf29f536d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3334cdbee1acd115821877edf29f536d">&#9670;&nbsp;</a></span>begin() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<div class="memtemplate">
template&lt;unsigned int I&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">hydra::thrust::tuple_element&lt;I, <a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#adaee497bf961bd3dbeee656a32b41c5e">const_iterator_tuple</a>&gt;::type <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::begin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afc5ff995f315aed5649bbac9f818fe09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc5ff995f315aed5649bbac9f818fe09">&#9670;&nbsp;</a></span>capacity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a9f3b15a7a66792552891c6c25f69da59">size_type</a> <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::capacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of elements which have been reserved in this <code>multivector</code>. </p>

</div>
</div>
<a id="a8f898f0ada6137978f786052903993c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f898f0ada6137978f786052903993c1">&#9670;&nbsp;</a></span>cbegin() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#af8b44a2d78e7178eb90fd48f4046a9a7">const_iterator</a> <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7c211c510c2e6bf93190c814b692a59e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c211c510c2e6bf93190c814b692a59e">&#9670;&nbsp;</a></span>cbegin() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<div class="memtemplate">
template&lt;unsigned int I1, unsigned int I2, unsigned int ... IN&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a1d3e355ba73cc2409d11c30097bc5bb7">columns_iterator</a>&lt; <a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#adaee497bf961bd3dbeee656a32b41c5e">const_iterator_tuple</a>, I1, I2,IN...&gt; <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::cbegin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I1 &gt;&#160;</td>
          <td class="paramname"><em>c1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I2 &gt;&#160;</td>
          <td class="paramname"><em>c2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; IN &gt; ...&#160;</td>
          <td class="paramname"><em>cn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3ec0e5092593a3637ef1904650d30a31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ec0e5092593a3637ef1904650d30a31">&#9670;&nbsp;</a></span>cbegin() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<div class="memtemplate">
template&lt;unsigned int I&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">hydra::thrust::tuple_element&lt;I, <a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#adaee497bf961bd3dbeee656a32b41c5e">const_iterator_tuple</a>&gt;::type <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::cbegin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0327722cdc024b0545eb4b127180efdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0327722cdc024b0545eb4b127180efdd">&#9670;&nbsp;</a></span>cend() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#af8b44a2d78e7178eb90fd48f4046a9a7">const_iterator</a> <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::cend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad2206c55de389f1db8dac8ed9aa7a089"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2206c55de389f1db8dac8ed9aa7a089">&#9670;&nbsp;</a></span>cend() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<div class="memtemplate">
template&lt;unsigned int I1, unsigned int I2, unsigned int ... IN&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a1d3e355ba73cc2409d11c30097bc5bb7">columns_iterator</a>&lt; <a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#adaee497bf961bd3dbeee656a32b41c5e">const_iterator_tuple</a>, I1, I2,IN...&gt; <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::cend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I1 &gt;&#160;</td>
          <td class="paramname"><em>c1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I2 &gt;&#160;</td>
          <td class="paramname"><em>c2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; IN &gt; ...&#160;</td>
          <td class="paramname"><em>cn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a75aef0cdab9c5d1c33b326528c32c2c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75aef0cdab9c5d1c33b326528c32c2c2">&#9670;&nbsp;</a></span>cend() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<div class="memtemplate">
template&lt;unsigned int I&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">hydra::thrust::tuple_element&lt;I, <a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#adaee497bf961bd3dbeee656a32b41c5e">const_iterator_tuple</a>&gt;::type <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::cend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2484994f430390709776f9545fe20638"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2484994f430390709776f9545fe20638">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method resizes this <code>multivector</code> to 0. </p>

</div>
</div>
<a id="ae0ba62e1f27193b467ce40c19334f506"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0ba62e1f27193b467ce40c19334f506">&#9670;&nbsp;</a></span>column() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<div class="memtemplate">
template&lt;typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">hydra::thrust::tuple_element&lt;<a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1index__in__tuple">detail::index_in_tuple</a>&lt;Type, tuple_type&gt;::value , <a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a54b6ba02f47207787e936f2e49aec1ab">storage_tuple</a>&gt;::type&amp; <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::column </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8a3d4b0a9d7ead9db3bb72b2234818f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a3d4b0a9d7ead9db3bb72b2234818f0">&#9670;&nbsp;</a></span>column() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<div class="memtemplate">
template&lt;unsigned int I&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">hydra::thrust::tuple_element&lt;I, <a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a54b6ba02f47207787e936f2e49aec1ab">storage_tuple</a>&gt;::type&amp; <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::column </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0ad4bd53b050dda0e9dde80e267a9341"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ad4bd53b050dda0e9dde80e267a9341">&#9670;&nbsp;</a></span>column() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<div class="memtemplate">
template&lt;unsigned int I1, unsigned int I2, unsigned int ... IN&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacehydra.html#classhydra_1_1Range">hydra::Range</a>&lt;<a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a1d3e355ba73cc2409d11c30097bc5bb7">columns_iterator</a>&lt; <a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a368e387d8be3b7b37c2aafb9bea02957">iterator_tuple</a>, I1, I2,IN...&gt; &gt; <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::column </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I1 &gt;&#160;</td>
          <td class="paramname"><em>c1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I2 &gt;&#160;</td>
          <td class="paramname"><em>c2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; IN &gt; ...&#160;</td>
          <td class="paramname"><em>cn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abe7c853a49281ce218c98aa2cf6ba1ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe7c853a49281ce218c98aa2cf6ba1ca">&#9670;&nbsp;</a></span>column() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<div class="memtemplate">
template&lt;unsigned int I&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const hydra::thrust::tuple_element&lt;I, <a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a54b6ba02f47207787e936f2e49aec1ab">storage_tuple</a>&gt;::type&amp; <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::column </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a599c91eaf89a2d9510e3e93dc2bdbaa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a599c91eaf89a2d9510e3e93dc2bdbaa9">&#9670;&nbsp;</a></span>column() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<div class="memtemplate">
template&lt;unsigned int I1, unsigned int I2, unsigned int ... IN&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacehydra.html#classhydra_1_1Range">hydra::Range</a>&lt;<a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a1d3e355ba73cc2409d11c30097bc5bb7">columns_iterator</a>&lt; <a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#adaee497bf961bd3dbeee656a32b41c5e">const_iterator_tuple</a>, I1, I2,IN...&gt; &gt; <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::column </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I1 &gt;&#160;</td>
          <td class="paramname"><em>c1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I2 &gt;&#160;</td>
          <td class="paramname"><em>c2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; IN &gt; ...&#160;</td>
          <td class="paramname"><em>cn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5c97d17a0ea17bbc9e6b303eccbe4d45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c97d17a0ea17bbc9e6b303eccbe4d45">&#9670;&nbsp;</a></span>crbegin() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a67ce921a4b57cea999ba65990aed85e5">const_reverse_iterator</a> <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::crbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6895dbd3119c4a1624c82260eeac82ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6895dbd3119c4a1624c82260eeac82ee">&#9670;&nbsp;</a></span>crbegin() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<div class="memtemplate">
template&lt;unsigned int I1, unsigned int I2, unsigned int ... IN&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a1d3e355ba73cc2409d11c30097bc5bb7">columns_iterator</a>&lt; <a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#aa61175868b88391c2842e9d6920f2bb8">const_reverse_iterator_tuple</a>, I1, I2,IN...&gt; <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::crbegin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I1 &gt;&#160;</td>
          <td class="paramname"><em>c1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I2 &gt;&#160;</td>
          <td class="paramname"><em>c2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; IN &gt; ...&#160;</td>
          <td class="paramname"><em>cn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a96a4ec194174818cbf44f140d4af4889"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96a4ec194174818cbf44f140d4af4889">&#9670;&nbsp;</a></span>crbegin() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<div class="memtemplate">
template&lt;unsigned int I&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">hydra::thrust::tuple_element&lt;I, <a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#aa61175868b88391c2842e9d6920f2bb8">const_reverse_iterator_tuple</a>&gt;::type <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::crbegin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae600ca9c94d8ca8131a9967574ad9b2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae600ca9c94d8ca8131a9967574ad9b2e">&#9670;&nbsp;</a></span>crend() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a67ce921a4b57cea999ba65990aed85e5">const_reverse_iterator</a> <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::crend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a600af876d8240012011bfdb843a31272"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a600af876d8240012011bfdb843a31272">&#9670;&nbsp;</a></span>crend() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<div class="memtemplate">
template&lt;unsigned int I1, unsigned int I2, unsigned int ... IN&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a1d3e355ba73cc2409d11c30097bc5bb7">columns_iterator</a>&lt; <a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#aa61175868b88391c2842e9d6920f2bb8">const_reverse_iterator_tuple</a>, I1, I2,IN...&gt; <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::crend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I1 &gt;&#160;</td>
          <td class="paramname"><em>c1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I2 &gt;&#160;</td>
          <td class="paramname"><em>c2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; IN &gt; ...&#160;</td>
          <td class="paramname"><em>cn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4a62c989cd7a5012785b2f711fde6f1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a62c989cd7a5012785b2f711fde6f1e">&#9670;&nbsp;</a></span>crend() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<div class="memtemplate">
template&lt;unsigned int I&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">hydra::thrust::tuple_element&lt;I, <a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#aa61175868b88391c2842e9d6920f2bb8">const_reverse_iterator_tuple</a>&gt;::type <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::crend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2d30985ed8a6bc605f98fd7ca3b2b76f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d30985ed8a6bc605f98fd7ca3b2b76f">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method returns true iff <a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a538b4dc02c86fa531e520179e3b3af46" title="Returns the number of elements in this multivector. ">size()</a> == 0. </p>
<dl class="section return"><dt>Returns</dt><dd>true if <a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a538b4dc02c86fa531e520179e3b3af46" title="Returns the number of elements in this multivector. ">size()</a> == 0; false, otherwise. </dd></dl>

</div>
</div>
<a id="a3d0d4eeb0af21ae5ad8b94a99a963553"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d0d4eeb0af21ae5ad8b94a99a963553">&#9670;&nbsp;</a></span>end() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a1629aefb94ab27551973be11a8ec38b7">iterator</a> <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method returns a const_iterator pointing to one element past the last of this <code>multivector</code>. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#aca913ba3cee6616d05e08d61379aed6e" title="This method returns an iterator pointing to the beginning of this multivector. ">begin()</a> + <a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a538b4dc02c86fa531e520179e3b3af46" title="Returns the number of elements in this multivector. ">size()</a>. </dd></dl>

</div>
</div>
<a id="af6deaeb440a26993eeb44d37be2b23bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6deaeb440a26993eeb44d37be2b23bc">&#9670;&nbsp;</a></span>end() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<div class="memtemplate">
template&lt;typename Functor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a0690bbe116fa4fbb03eb68c41fd46fd2">caster_iterator</a>&lt;Functor&gt; <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::end </td>
          <td>(</td>
          <td class="paramtype">Functor const &amp;&#160;</td>
          <td class="paramname"><em>caster</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8d150c40ca89a7126a80b71c858fc059"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d150c40ca89a7126a80b71c858fc059">&#9670;&nbsp;</a></span>end() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#af8b44a2d78e7178eb90fd48f4046a9a7">const_iterator</a> <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afa8a518a5cace6250aac269bd68ac04d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa8a518a5cace6250aac269bd68ac04d">&#9670;&nbsp;</a></span>end() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<div class="memtemplate">
template&lt;unsigned int I1, unsigned int I2, unsigned int ... IN&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a1d3e355ba73cc2409d11c30097bc5bb7">columns_iterator</a>&lt; <a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a368e387d8be3b7b37c2aafb9bea02957">iterator_tuple</a>, I1, I2,IN...&gt; <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I1 &gt;&#160;</td>
          <td class="paramname"><em>c1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I2 &gt;&#160;</td>
          <td class="paramname"><em>c2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; IN &gt; ...&#160;</td>
          <td class="paramname"><em>cn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a10cccaff21ca7227a7d384382b11c1fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10cccaff21ca7227a7d384382b11c1fb">&#9670;&nbsp;</a></span>end() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<div class="memtemplate">
template&lt;unsigned int I&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">hydra::thrust::tuple_element&lt;I, <a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a368e387d8be3b7b37c2aafb9bea02957">iterator_tuple</a>&gt;::type <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abc7d2c791b116198d15f465cb7cea924"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc7d2c791b116198d15f465cb7cea924">&#9670;&nbsp;</a></span>end() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<div class="memtemplate">
template&lt;typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">hydra::thrust::tuple_element&lt; <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1index__in__tuple">detail::index_in_tuple</a>&lt;Type, tuple_type&gt;::value , <a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a368e387d8be3b7b37c2aafb9bea02957">iterator_tuple</a> &gt;::type <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad93d645db97afbb414bf4aed647076ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad93d645db97afbb414bf4aed647076ad">&#9670;&nbsp;</a></span>end() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<div class="memtemplate">
template&lt;unsigned int I1, unsigned int I2, unsigned int ... IN&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a1d3e355ba73cc2409d11c30097bc5bb7">columns_iterator</a>&lt; <a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#adaee497bf961bd3dbeee656a32b41c5e">const_iterator_tuple</a>, I1, I2,IN...&gt; <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I1 &gt;&#160;</td>
          <td class="paramname"><em>c1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I2 &gt;&#160;</td>
          <td class="paramname"><em>c2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; IN &gt; ...&#160;</td>
          <td class="paramname"><em>cn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a233e6a4be572ed0ee3ec8c6e7d71278d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a233e6a4be572ed0ee3ec8c6e7d71278d">&#9670;&nbsp;</a></span>end() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<div class="memtemplate">
template&lt;unsigned int I&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">hydra::thrust::tuple_element&lt;I, <a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#adaee497bf961bd3dbeee656a32b41c5e">const_iterator_tuple</a>&gt;::type <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a14dbc63f8e7e8ec3885a312c2e5d1d39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14dbc63f8e7e8ec3885a312c2e5d1d39">&#9670;&nbsp;</a></span>erase() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a1629aefb94ab27551973be11a8ec38b7">iterator</a> <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a1629aefb94ab27551973be11a8ec38b7">iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method removes the element at position pos. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The position of the element of interest. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator pointing to the new location of the element that followed the element at position pos. </dd></dl>

</div>
</div>
<a id="aea268652a0d4f3c366e856e24b5069a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea268652a0d4f3c366e856e24b5069a1">&#9670;&nbsp;</a></span>erase() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a1629aefb94ab27551973be11a8ec38b7">iterator</a> <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a1629aefb94ab27551973be11a8ec38b7">iterator</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a1629aefb94ab27551973be11a8ec38b7">iterator</a>&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method removes the range of elements [first,last) from this <code>multivector</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The beginning of the range of elements to remove. </td></tr>
    <tr><td class="paramname">last</td><td>The end of the range of elements to remove. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator pointing to the new location of the element that followed the last element in the sequence [first,last). </dd></dl>

</div>
</div>
<a id="a28e0d6656c560d6b21d907a2f0264901"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28e0d6656c560d6b21d907a2f0264901">&#9670;&nbsp;</a></span>front() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a634a39e968ee0a327c3a19a5575e97b3">reference</a> <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method returns a const_reference referring to the first element of this <code>multivector</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>The first element of this <code>multivector</code>. </dd></dl>

</div>
</div>
<a id="a9c83a62b4698551a77aba946885e47c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c83a62b4698551a77aba946885e47c9">&#9670;&nbsp;</a></span>front() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#abf1fa17161766aad5401b5e85d19ad9c">const_reference</a> <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method returns a reference pointing to the first element of this <code>multivector</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>The first element of this <code>multivector</code>. </dd></dl>

</div>
</div>
<a id="a60518d1c9128e15689bd9e746ccc9f1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60518d1c9128e15689bd9e746ccc9f1e">&#9670;&nbsp;</a></span>insert() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a1629aefb94ab27551973be11a8ec38b7">iterator</a> <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a1629aefb94ab27551973be11a8ec38b7">iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a7d4313d2ba0e92aa16a82173ca63e7d1">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method inserts a single copy of a given exemplar value at the specified position in this <code>multivector</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>The insertion position. </td></tr>
    <tr><td class="paramname">x</td><td>The exemplar element to copy &amp; insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator pointing to the newly inserted element. </dd></dl>

</div>
</div>
<a id="a5e1780ba1038452695c956bd4cd51f9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e1780ba1038452695c956bd4cd51f9b">&#9670;&nbsp;</a></span>insert() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a1629aefb94ab27551973be11a8ec38b7">iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a9f3b15a7a66792552891c6c25f69da59">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a7d4313d2ba0e92aa16a82173ca63e7d1">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method inserts a copy of an exemplar value to a range at the specified position in this <code>multivector</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>The insertion position </td></tr>
    <tr><td class="paramname">n</td><td>The number of insertions to perform. </td></tr>
    <tr><td class="paramname">x</td><td>The value to replicate and insert. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a585a8ae8a7c1716435a4beec93b73e1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a585a8ae8a7c1716435a4beec93b73e1d">&#9670;&nbsp;</a></span>insert() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<div class="memtemplate">
template&lt;typename InputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">hydra::thrust::detail::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__zip__iterator.html">detail::is_zip_iterator</a>&lt;InputIterator&gt;::value &amp;&amp; std::is_convertible&lt;typename hydra::thrust::iterator_traits&lt;InputIterator&gt;::<a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a7d4313d2ba0e92aa16a82173ca63e7d1">value_type</a>, <a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a7d4313d2ba0e92aa16a82173ca63e7d1">value_type</a>&gt;::value, void&gt;::type <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a1629aefb94ab27551973be11a8ec38b7">iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method inserts a copy of an input range at the specified position in this <code>multivector</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>The insertion position. </td></tr>
    <tr><td class="paramname">first</td><td>The beginning of the range to copy. </td></tr>
    <tr><td class="paramname">last</td><td>The end of the range to copy.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">InputIterator</td><td>is a model of &lt;a href="http://www.sgi.com/tech/stl/InputIterator.html&gt;Input Iterator&lt;/a&gt;,
                      and \p InputIterator's \c value_type is a model of &lt;a href="<a href="http://www.sgi.com/tech/stl/Assignable.html">http://www.sgi.com/tech/stl/Assignable.html</a>"&gt;Assignable. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abb276a3aa3e7419a8c78a76587baba9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb276a3aa3e7419a8c78a76587baba9d">&#9670;&nbsp;</a></span>meld()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<div class="memtemplate">
template&lt;typename ... Iterables&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::meld </td>
          <td>(</td>
          <td class="paramtype">Iterables &amp;&amp;...&#160;</td>
          <td class="paramname"><em>iterables</em></td><td>)</td>
          <td> -&gt; typename std::enable_if&lt;<a class="el" href="structhydra_1_1detail_1_1all__true.html">detail::all_true</a>&lt;<a class="el" href="structhydra_1_1detail_1_1is__iterable.html">detail::is_iterable</a>&lt;Iterables&gt;::value...&gt;::value,
	<a class="el" href="namespacehydra.html#classhydra_1_1Range">hydra::Range</a>&lt;decltype(<a class="el" href="namespacehydra_1_1detail.html#a3d9f6a5b4844a887d53284f38f00f89a">detail::meld_iterators</a>(<a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#aca913ba3cee6616d05e08d61379aed6e">begin</a>(), std::forward&lt;Iterables&gt;(iterables).<a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#aca913ba3cee6616d05e08d61379aed6e">begin</a>()... ))&gt;&gt;::type
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a268c9a9878bd43e75764d056fb86011f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a268c9a9878bd43e75764d056fb86011f">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt;hydra::thrust::tuple&lt;T...&gt;,<a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt;BACKEND&gt; &gt;&amp; <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; hydra::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assignment operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="ab94fc7fa785f6fff4dbc95e8bedc7713"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab94fc7fa785f6fff4dbc95e8bedc7713">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt;hydra::thrust::tuple&lt;T...&gt;,<a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt;BACKEND&gt; &gt;&amp; <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; hydra::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt; &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move-assignment operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a1984d1637790e8722556f37db6800204"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1984d1637790e8722556f37db6800204">&#9670;&nbsp;</a></span>operator=() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<div class="memtemplate">
template&lt;hydra::detail::Backend BACKEND2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt;hydra::thrust::tuple&lt;T...&gt;,<a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt;BACKEND&gt; &gt;&amp; <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; hydra::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND2 &gt; &gt; const &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assignment operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="ae1514257c6702811609083568b7e5cb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1514257c6702811609083568b7e5cb2">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<div class="memtemplate">
template&lt;typename Functor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a0690bbe116fa4fbb03eb68c41fd46fd2">caster_iterator</a>&lt;Functor&gt; <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">Functor const &amp;&#160;</td>
          <td class="paramname"><em>caster</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa5b0f4a34e75645248ce95c48a4d1dd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5b0f4a34e75645248ce95c48a4d1dd7">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<div class="memtemplate">
template&lt;unsigned int I&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">hydra::thrust::tuple_element&lt;I, <a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a368e387d8be3b7b37c2aafb9bea02957">iterator_tuple</a>&gt;::type <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4fe837c8c1153d2223ba06a398aab1be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fe837c8c1153d2223ba06a398aab1be">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<div class="memtemplate">
template&lt;unsigned int I&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">hydra::thrust::tuple_element&lt;I, <a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#adaee497bf961bd3dbeee656a32b41c5e">const_iterator_tuple</a>&gt;::type <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aca1c1d4a8d11520bfb3eabdf51fc0dbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca1c1d4a8d11520bfb3eabdf51fc0dbf">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a634a39e968ee0a327c3a19a5575e97b3">reference</a> <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscript access to the data contained in this vector_dev. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The index of the element for which data should be accessed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Read/write reference to data.</dd></dl>
<p>This operator allows for easy, array-style, data access. Note that data access with this operator is unchecked and out_of_range lookups are not defined. </p>

</div>
</div>
<a id="a2f75aa75bcf6042c5dda5689965f4817"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f75aa75bcf6042c5dda5689965f4817">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#abf1fa17161766aad5401b5e85d19ad9c">const_reference</a> <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscript read access to the data contained in this vector_dev. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The index of the element for which data should be accessed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Read reference to data.</dd></dl>
<p>This operator allows for easy, array-style, data access. Note that data access with this operator is unchecked and out_of_range lookups are not defined. </p>

</div>
</div>
<a id="a3bd0e5a428350f2f697f8b0408cf8d49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bd0e5a428350f2f697f8b0408cf8d49">&#9670;&nbsp;</a></span>pop_back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::pop_back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method erases the last element of this <code>multivector</code>, invalidating all iterators and references to it. </p>

</div>
</div>
<a id="a9bfdf1d7b12bed0bd333e6953e6346b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bfdf1d7b12bed0bd333e6953e6346b3">&#9670;&nbsp;</a></span>push_back() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a7d4313d2ba0e92aa16a82173ca63e7d1">value_type</a> const &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method appends the given element to the end of this <code>multivector</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The element to append. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad937b5f986a856a6ad739197cca54a04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad937b5f986a856a6ad739197cca54a04">&#9670;&nbsp;</a></span>push_back() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<div class="memtemplate">
template&lt;typename Functor , typename Obj &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">Functor const &amp;&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Obj const &amp;&#160;</td>
          <td class="paramname"><em>obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method appends the given element to the end of this <code>multivector</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The element to append. </td></tr>
    <tr><td class="paramname">functor</td><td>Functor to convert the element to a value_type tuple </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8314472118ceddcf13458261395f6738"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8314472118ceddcf13458261395f6738">&#9670;&nbsp;</a></span>rbegin() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<div class="memtemplate">
template&lt;typename Functor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#af09cd871c1e32293d8c9cb44034f641e">caster_reverse_iterator</a>&lt;Functor&gt; <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::rbegin </td>
          <td>(</td>
          <td class="paramtype">Functor const &amp;&#160;</td>
          <td class="paramname"><em>caster</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="acd5b3752b1f64b2d89f01152bd7be5e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd5b3752b1f64b2d89f01152bd7be5e4">&#9670;&nbsp;</a></span>rbegin() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a9f1775925ab9f2f78ded2885ea7264e7">reverse_iterator</a> <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa2951ce81ad290740e1a9dee62493e69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2951ce81ad290740e1a9dee62493e69">&#9670;&nbsp;</a></span>rbegin() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a67ce921a4b57cea999ba65990aed85e5">const_reverse_iterator</a> <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8adf837cb83496b2b2e46248c0c4763f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8adf837cb83496b2b2e46248c0c4763f">&#9670;&nbsp;</a></span>rbegin() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<div class="memtemplate">
template&lt;unsigned int I1, unsigned int I2, unsigned int ... IN&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a1d3e355ba73cc2409d11c30097bc5bb7">columns_iterator</a>&lt; <a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a61849adfc0c475aa23a72cc3e626cf89">reverse_iterator_tuple</a>, I1, I2,IN...&gt; <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::rbegin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I1 &gt;&#160;</td>
          <td class="paramname"><em>c1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I2 &gt;&#160;</td>
          <td class="paramname"><em>c2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; IN &gt; ...&#160;</td>
          <td class="paramname"><em>cn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a85a64c6bcdad159e64d155eaad1b8e3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85a64c6bcdad159e64d155eaad1b8e3d">&#9670;&nbsp;</a></span>rbegin() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<div class="memtemplate">
template&lt;unsigned int I&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">hydra::thrust::tuple_element&lt;I, <a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a61849adfc0c475aa23a72cc3e626cf89">reverse_iterator_tuple</a>&gt;::type <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::rbegin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5be3d2ea8d621768c901fd330820b4f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5be3d2ea8d621768c901fd330820b4f9">&#9670;&nbsp;</a></span>rbegin() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<div class="memtemplate">
template&lt;typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">hydra::thrust::tuple_element&lt; <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1index__in__tuple">detail::index_in_tuple</a>&lt;Type, tuple_type&gt;::value , <a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a61849adfc0c475aa23a72cc3e626cf89">reverse_iterator_tuple</a>&gt;::type <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aead81f943a98d93a69dffd428c5aa6c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aead81f943a98d93a69dffd428c5aa6c6">&#9670;&nbsp;</a></span>rbegin() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<div class="memtemplate">
template&lt;unsigned int I1, unsigned int I2, unsigned int ... IN&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a1d3e355ba73cc2409d11c30097bc5bb7">columns_iterator</a>&lt; <a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#aa61175868b88391c2842e9d6920f2bb8">const_reverse_iterator_tuple</a>, I1, I2,IN...&gt; <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::rbegin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I1 &gt;&#160;</td>
          <td class="paramname"><em>c1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I2 &gt;&#160;</td>
          <td class="paramname"><em>c2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; IN &gt; ...&#160;</td>
          <td class="paramname"><em>cn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af32389b6baedd3981effe4568173973f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af32389b6baedd3981effe4568173973f">&#9670;&nbsp;</a></span>rbegin() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<div class="memtemplate">
template&lt;unsigned int I&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">hydra::thrust::tuple_element&lt;I, <a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#aa61175868b88391c2842e9d6920f2bb8">const_reverse_iterator_tuple</a>&gt;::type <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::rbegin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a46bb1c230398dc29b3acc4bb087ad1cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46bb1c230398dc29b3acc4bb087ad1cf">&#9670;&nbsp;</a></span>rend() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<div class="memtemplate">
template&lt;typename Functor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#af09cd871c1e32293d8c9cb44034f641e">caster_reverse_iterator</a>&lt;Functor&gt; <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::rend </td>
          <td>(</td>
          <td class="paramtype">Functor const &amp;&#160;</td>
          <td class="paramname"><em>caster</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="adf418b0ff574995b502c0f2257561204"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf418b0ff574995b502c0f2257561204">&#9670;&nbsp;</a></span>rend() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a9f1775925ab9f2f78ded2885ea7264e7">reverse_iterator</a> <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7a4b502c04ff0db98ebcc31a537f8963"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a4b502c04ff0db98ebcc31a537f8963">&#9670;&nbsp;</a></span>rend() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a67ce921a4b57cea999ba65990aed85e5">const_reverse_iterator</a> <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa37c0d25a456c3f4b3f5ad8622fd7246"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa37c0d25a456c3f4b3f5ad8622fd7246">&#9670;&nbsp;</a></span>rend() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<div class="memtemplate">
template&lt;unsigned int I1, unsigned int I2, unsigned int ... IN&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a1d3e355ba73cc2409d11c30097bc5bb7">columns_iterator</a>&lt; <a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a61849adfc0c475aa23a72cc3e626cf89">reverse_iterator_tuple</a>, I1, I2,IN...&gt; <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::rend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I1 &gt;&#160;</td>
          <td class="paramname"><em>c1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I2 &gt;&#160;</td>
          <td class="paramname"><em>c2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; IN &gt; ...&#160;</td>
          <td class="paramname"><em>cn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a83be5524db39b7f585e58af8db47fbfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83be5524db39b7f585e58af8db47fbfd">&#9670;&nbsp;</a></span>rend() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<div class="memtemplate">
template&lt;unsigned int I&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">hydra::thrust::tuple_element&lt;I, <a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a61849adfc0c475aa23a72cc3e626cf89">reverse_iterator_tuple</a>&gt;::type <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::rend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6d2894a60f904fe4bce6601db79d5735"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d2894a60f904fe4bce6601db79d5735">&#9670;&nbsp;</a></span>rend() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<div class="memtemplate">
template&lt;typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">hydra::thrust::tuple_element&lt; <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1index__in__tuple">detail::index_in_tuple</a>&lt;Type, tuple_type&gt;::value , <a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a61849adfc0c475aa23a72cc3e626cf89">reverse_iterator_tuple</a> &gt;::type <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a805293521e50419aa0c2b49bb84f543b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a805293521e50419aa0c2b49bb84f543b">&#9670;&nbsp;</a></span>rend() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<div class="memtemplate">
template&lt;unsigned int I1, unsigned int I2, unsigned int ... IN&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a1d3e355ba73cc2409d11c30097bc5bb7">columns_iterator</a>&lt; <a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#aa61175868b88391c2842e9d6920f2bb8">const_reverse_iterator_tuple</a>, I1, I2,IN...&gt; <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::rend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I1 &gt;&#160;</td>
          <td class="paramname"><em>c1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I2 &gt;&#160;</td>
          <td class="paramname"><em>c2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; IN &gt; ...&#160;</td>
          <td class="paramname"><em>cn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab598456eb7a907573814b339c573c551"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab598456eb7a907573814b339c573c551">&#9670;&nbsp;</a></span>rend() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<div class="memtemplate">
template&lt;unsigned int I&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">hydra::thrust::tuple_element&lt;I, <a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#aa61175868b88391c2842e9d6920f2bb8">const_reverse_iterator_tuple</a>&gt;::type <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::rend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aff78065f08c1dd5cf2efb98fc910b347"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff78065f08c1dd5cf2efb98fc910b347">&#9670;&nbsp;</a></span>reserve()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::reserve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a9f3b15a7a66792552891c6c25f69da59">size_type</a>&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If n is less than or equal to <a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#afc5ff995f315aed5649bbac9f818fe09" title="Returns the number of elements which have been reserved in this multivector. ">capacity()</a>, this call has no effect. </p>
<p>Otherwise, this method is a request for allocation of additional memory. If the request is successful, then <a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#afc5ff995f315aed5649bbac9f818fe09" title="Returns the number of elements which have been reserved in this multivector. ">capacity()</a> is greater than or equal to n; otherwise, <a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#afc5ff995f315aed5649bbac9f818fe09" title="Returns the number of elements which have been reserved in this multivector. ">capacity()</a> is unchanged. In either case, <a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a538b4dc02c86fa531e520179e3b3af46" title="Returns the number of elements in this multivector. ">size()</a> is unchanged. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::length_error</td><td>If n exceeds max_size(). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a689167f4f3551861f83d4cef11dcb53b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a689167f4f3551861f83d4cef11dcb53b">&#9670;&nbsp;</a></span>resize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::resize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a9f3b15a7a66792552891c6c25f69da59">size_type</a>&#160;</td>
          <td class="paramname"><em>new_size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resizes this <code>multivector</code> to the specified number of elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_size</td><td>Number of elements this <code>multivector</code> should contain. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::length_error</td><td>If n exceeds max_size().</td></tr>
  </table>
  </dd>
</dl>
<p>This method will resize this <code>multivector</code> to the specified number of elements. If the number is smaller than this <code>multivector's</code> current size this <code>multivector</code> is truncated, otherwise this <code>multivector</code> is extended and new default initialized elements are populated. </p>

</div>
</div>
<a id="ab6036eaf0cbafdaa91ba33bad59dfafd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6036eaf0cbafdaa91ba33bad59dfafd">&#9670;&nbsp;</a></span>shrink_to_fit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::shrink_to_fit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method shrinks the capacity of this <code>multivector</code> to exactly fit its elements. </p>

</div>
</div>
<a id="a538b4dc02c86fa531e520179e3b3af46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a538b4dc02c86fa531e520179e3b3af46">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html#a9f3b15a7a66792552891c6c25f69da59">size_type</a> <a class="el" href="namespacehydra.html#classhydra_1_1multivector">hydra::multivector</a>&lt; hydra::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of elements in this <code>multivector</code>. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="">multivector.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacehydra.html">hydra</a></li><li class="navelem"><a class="el" href="classhydra_1_1multivector_3_01hydra_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_15049943f6db7679411df434168185bbf.html">multivector&lt; hydra::thrust::tuple&lt; T... &gt;, hydra::detail::BackendPolicy&lt; BACKEND &gt; &gt;</a></li>
    <li class="footer">Generated on Sun Dec 3 2023 21:29:48 for Hydra by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.14 </li>
  </ul>
</div>
</body>
</html>
