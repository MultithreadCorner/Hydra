<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Hydra: hydra Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Hydra
   &#160;<span id="projectnumber">2.1.0</span>
   </div>
   <div id="projectbrief">A header-only templated C++ framework to perform data analysis on massively parallel platforms.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('namespacehydra.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">hydra Namespace Reference<div class="ingroups"><a class="el" href="group__policy.html">Policy</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Generic policies definition.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacehydra_1_1cpp"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1cpp.html">cpp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacehydra_1_1cuda"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1cuda.html">cuda</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacehydra_1_1detail"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html">detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacehydra_1_1device"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1device.html">device</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacehydra_1_1experimental"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1experimental.html">experimental</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacehydra_1_1host"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1host.html">host</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacehydra_1_1math__constants"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1math__constants.html">math_constants</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacehydra_1_1omp"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1omp.html">omp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacehydra_1_1placeholders"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1placeholders.html">placeholders</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacehydra_1_1tbb"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1tbb.html">tbb</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1Argument.html">Argument</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1ArgusShape.html">ArgusShape</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation describing the ARGUS background shape.  <a href="classhydra_1_1ArgusShape.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1ArgusShapeAnalyticalIntegral.html">ArgusShapeAnalyticalIntegral</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of analytical integral for the ARGUS background shape with power = 0.5.  <a href="classhydra_1_1ArgusShapeAnalyticalIntegral.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1BaseFunctor"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__functor.html#classhydra_1_1BaseFunctor">BaseFunctor</a></td></tr>
<tr class="memdesc:classhydra_1_1BaseFunctor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all functors in hydra.  <a href="group__functor.html#classhydra_1_1BaseFunctor">More...</a><br /></td></tr>
<tr class="separator:classhydra_1_1BaseFunctor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1BreitWignerLineShape.html">BreitWignerLineShape</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1BreitWignerNR.html">BreitWignerNR</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1BreitWignerNRAnalyticalIntegral.html">BreitWignerNRAnalyticalIntegral</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1Cache"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#classhydra_1_1Cache">Cache</a></td></tr>
<tr class="separator:classhydra_1_1Cache"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1Cache_3_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_4_00_01Functors_8_8_8_01_4.html">Cache&lt; hydra::detail::BackendPolicy&lt; BACKEND &gt;, Functors... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1Chains"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__phsp.html#classhydra_1_1Chains">Chains</a></td></tr>
<tr class="separator:classhydra_1_1Chains"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1Chains_3_01Decays_3_01N_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_4_01_4_8_8_8_01_4"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__phsp.html#classhydra_1_1Chains_3_01Decays_3_01N_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_4_01_4_8_8_8_01_4">Chains&lt; Decays&lt; N, hydra::detail::BackendPolicy&lt; BACKEND &gt; &gt;... &gt;</a></td></tr>
<tr class="memdesc:classhydra_1_1Chains_3_01Decays_3_01N_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_4_01_4_8_8_8_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides memory storage for a chain of decays.  <a href="group__phsp.html#classhydra_1_1Chains_3_01Decays_3_01N_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_4_01_4_8_8_8_01_4">More...</a><br /></td></tr>
<tr class="separator:classhydra_1_1Chains_3_01Decays_3_01N_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_4_01_4_8_8_8_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1Compose.html">Compose</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1Constant.html">Constant</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1CosHelicityAngle.html">CosHelicityAngle</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1CrystalBallShape.html">CrystalBallShape</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation the Crystal Ball line shape.  <a href="classhydra_1_1CrystalBallShape.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1CrystalBallShapeAnalyticalIntegral.html">CrystalBallShapeAnalyticalIntegral</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1CubicSpiline.html">CubicSpiline</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><br />
<br />
 A simple method for a oneâ€”dimensional interpolation on a given set of data points (xi, yi).  <a href="classhydra_1_1CubicSpiline.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1Decays"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__phsp.html#classhydra_1_1Decays">Decays</a></td></tr>
<tr class="separator:classhydra_1_1Decays"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1Decays_3_01N_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_4_01_4"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__phsp.html#classhydra_1_1Decays_3_01N_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_4_01_4">Decays&lt; N, hydra::detail::BackendPolicy&lt; BACKEND &gt; &gt;</a></td></tr>
<tr class="memdesc:classhydra_1_1Decays_3_01N_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_4_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides storage for N-particle final states.  <a href="group__phsp.html#classhydra_1_1Decays_3_01N_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_4_01_4">More...</a><br /></td></tr>
<tr class="separator:classhydra_1_1Decays_3_01N_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_4_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1DenseHistogram"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__histogram.html#classhydra_1_1DenseHistogram">DenseHistogram</a></td></tr>
<tr class="separator:classhydra_1_1DenseHistogram"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1DenseHistogram_3_01T_00_011_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_47e77d3fa69b0393593bb979d3c5f9775"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__histogram.html#classhydra_1_1DenseHistogram_3_01T_00_011_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_47e77d3fa69b0393593bb979d3c5f9775">DenseHistogram&lt; T, 1, hydra::detail::BackendPolicy&lt; BACKEND &gt;, detail::unidimensional &gt;</a></td></tr>
<tr class="memdesc:classhydra_1_1DenseHistogram_3_01T_00_011_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_47e77d3fa69b0393593bb979d3c5f9775"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing one-dimensional dense histogram.  <a href="group__histogram.html#classhydra_1_1DenseHistogram_3_01T_00_011_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_47e77d3fa69b0393593bb979d3c5f9775">More...</a><br /></td></tr>
<tr class="separator:classhydra_1_1DenseHistogram_3_01T_00_011_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_47e77d3fa69b0393593bb979d3c5f9775"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1DenseHistogram_3_01T_00_01N_00_01detail_1_1BackendPolicy_3_01BACKEND_01_4_00_01detail_1_1multidimensional_01_4"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__histogram.html#classhydra_1_1DenseHistogram_3_01T_00_01N_00_01detail_1_1BackendPolicy_3_01BACKEND_01_4_00_01detail_1_1multidimensional_01_4">DenseHistogram&lt; T, N, detail::BackendPolicy&lt; BACKEND &gt;, detail::multidimensional &gt;</a></td></tr>
<tr class="memdesc:classhydra_1_1DenseHistogram_3_01T_00_01N_00_01detail_1_1BackendPolicy_3_01BACKEND_01_4_00_01detail_1_1multidimensional_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing multidimensional dense histograms.  <a href="group__histogram.html#classhydra_1_1DenseHistogram_3_01T_00_01N_00_01detail_1_1BackendPolicy_3_01BACKEND_01_4_00_01detail_1_1multidimensional_01_4">More...</a><br /></td></tr>
<tr class="separator:classhydra_1_1DenseHistogram_3_01T_00_01N_00_01detail_1_1BackendPolicy_3_01BACKEND_01_4_00_01detail_1_1multidimensional_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1Divide.html">Divide</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1Exponential.html">Exponential</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1ExponentialAnalyticalIntegral.html">ExponentialAnalyticalIntegral</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1FCN"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fit.html#classhydra_1_1FCN">FCN</a></td></tr>
<tr class="memdesc:classhydra_1_1FCN"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="group__fit.html#classhydra_1_1FCN" title="FCN base class. ">FCN</a> base class.  <a href="group__fit.html#classhydra_1_1FCN">More...</a><br /></td></tr>
<tr class="separator:classhydra_1_1FCN"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1FCN_3_01Estimator_3_01PDF_00_01Iterator_01_4_01_4.html">FCN&lt; Estimator&lt; PDF, Iterator &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1FCN_3_01Estimator_3_01PDF_00_01Iterator_00_01Iterators_8_8_8_01_4_01_4"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fit.html#classhydra_1_1FCN_3_01Estimator_3_01PDF_00_01Iterator_00_01Iterators_8_8_8_01_4_01_4">FCN&lt; Estimator&lt; PDF, Iterator, Iterators... &gt; &gt;</a></td></tr>
<tr class="separator:classhydra_1_1FCN_3_01Estimator_3_01PDF_00_01Iterator_00_01Iterators_8_8_8_01_4_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1Gaussian.html">Gaussian</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1GaussianAnalyticalIntegral.html">GaussianAnalyticalIntegral</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1GaussKronrodAdaptiveQuadrature"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#classhydra_1_1GaussKronrodAdaptiveQuadrature">GaussKronrodAdaptiveQuadrature</a></td></tr>
<tr class="separator:classhydra_1_1GaussKronrodAdaptiveQuadrature"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1GaussKronrodAdaptiveQuadrature_3_01NRULE_00_01NBIN_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_4_01_4.html">GaussKronrodAdaptiveQuadrature&lt; NRULE, NBIN, hydra::detail::BackendPolicy&lt; BACKEND &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1GaussKronrodBinary.html">GaussKronrodBinary</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1GaussKronrodCall.html">GaussKronrodCall</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1GaussKronrodQuadrature"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#classhydra_1_1GaussKronrodQuadrature">GaussKronrodQuadrature</a></td></tr>
<tr class="separator:classhydra_1_1GaussKronrodQuadrature"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1GaussKronrodQuadrature_3_01NRULE_00_01NBIN_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_4_01_4.html">GaussKronrodQuadrature&lt; NRULE, NBIN, hydra::detail::BackendPolicy&lt; BACKEND &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1GaussKronrodRule"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__numerical__integration.html#structhydra_1_1GaussKronrodRule">GaussKronrodRule</a></td></tr>
<tr class="memdesc:structhydra_1_1GaussKronrodRule"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rules for Gauss-Kronrod quadrature.  <a href="group__numerical__integration.html#structhydra_1_1GaussKronrodRule">More...</a><br /></td></tr>
<tr class="separator:structhydra_1_1GaussKronrodRule"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1GaussKronrodRuleSelector"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#structhydra_1_1GaussKronrodRuleSelector">GaussKronrodRuleSelector</a></td></tr>
<tr class="separator:structhydra_1_1GaussKronrodRuleSelector"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1GaussKronrodRuleSelector_3_0115_01_4"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__numerical__integration.html#structhydra_1_1GaussKronrodRuleSelector_3_0115_01_4">GaussKronrodRuleSelector&lt; 15 &gt;</a></td></tr>
<tr class="memdesc:structhydra_1_1GaussKronrodRuleSelector_3_0115_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rules for Gauss-Kronrod quadrature.  <a href="group__numerical__integration.html#structhydra_1_1GaussKronrodRuleSelector_3_0115_01_4">More...</a><br /></td></tr>
<tr class="separator:structhydra_1_1GaussKronrodRuleSelector_3_0115_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1GaussKronrodRuleSelector_3_0121_01_4"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__numerical__integration.html#structhydra_1_1GaussKronrodRuleSelector_3_0121_01_4">GaussKronrodRuleSelector&lt; 21 &gt;</a></td></tr>
<tr class="memdesc:structhydra_1_1GaussKronrodRuleSelector_3_0121_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rules for Gauss-Kronrod quadrature.  <a href="group__numerical__integration.html#structhydra_1_1GaussKronrodRuleSelector_3_0121_01_4">More...</a><br /></td></tr>
<tr class="separator:structhydra_1_1GaussKronrodRuleSelector_3_0121_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1GaussKronrodRuleSelector_3_0131_01_4"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__numerical__integration.html#structhydra_1_1GaussKronrodRuleSelector_3_0131_01_4">GaussKronrodRuleSelector&lt; 31 &gt;</a></td></tr>
<tr class="memdesc:structhydra_1_1GaussKronrodRuleSelector_3_0131_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rules for Gauss-Kronrod quadrature.  <a href="group__numerical__integration.html#structhydra_1_1GaussKronrodRuleSelector_3_0131_01_4">More...</a><br /></td></tr>
<tr class="separator:structhydra_1_1GaussKronrodRuleSelector_3_0131_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1GaussKronrodRuleSelector_3_0141_01_4"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__numerical__integration.html#structhydra_1_1GaussKronrodRuleSelector_3_0141_01_4">GaussKronrodRuleSelector&lt; 41 &gt;</a></td></tr>
<tr class="memdesc:structhydra_1_1GaussKronrodRuleSelector_3_0141_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rules for Gauss-Kronrod quadrature.  <a href="group__numerical__integration.html#structhydra_1_1GaussKronrodRuleSelector_3_0141_01_4">More...</a><br /></td></tr>
<tr class="separator:structhydra_1_1GaussKronrodRuleSelector_3_0141_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1GaussKronrodRuleSelector_3_0151_01_4"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__numerical__integration.html#structhydra_1_1GaussKronrodRuleSelector_3_0151_01_4">GaussKronrodRuleSelector&lt; 51 &gt;</a></td></tr>
<tr class="memdesc:structhydra_1_1GaussKronrodRuleSelector_3_0151_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rules for Gauss-Kronrod quadrature.  <a href="group__numerical__integration.html#structhydra_1_1GaussKronrodRuleSelector_3_0151_01_4">More...</a><br /></td></tr>
<tr class="separator:structhydra_1_1GaussKronrodRuleSelector_3_0151_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1GaussKronrodRuleSelector_3_0161_01_4"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__numerical__integration.html#structhydra_1_1GaussKronrodRuleSelector_3_0161_01_4">GaussKronrodRuleSelector&lt; 61 &gt;</a></td></tr>
<tr class="memdesc:structhydra_1_1GaussKronrodRuleSelector_3_0161_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rules for Gauss-Kronrod quadrature.  <a href="group__numerical__integration.html#structhydra_1_1GaussKronrodRuleSelector_3_0161_01_4">More...</a><br /></td></tr>
<tr class="separator:structhydra_1_1GaussKronrodRuleSelector_3_0161_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1GaussKronrodUnary.html">GaussKronrodUnary</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1GenericRange"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#classhydra_1_1GenericRange">GenericRange</a></td></tr>
<tr class="separator:classhydra_1_1GenericRange"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1GenericRange_3_01Iterator_01_4.html">GenericRange&lt; Iterator &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1GenericRange_3_01Iterator_00_01Functor_01_4.html">GenericRange&lt; Iterator, Functor &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1GenzMalikQuadrature"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#classhydra_1_1GenzMalikQuadrature">GenzMalikQuadrature</a></td></tr>
<tr class="separator:classhydra_1_1GenzMalikQuadrature"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1GenzMalikQuadrature_3_01N_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_4_01_4"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__numerical__integration.html#classhydra_1_1GenzMalikQuadrature_3_01N_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_4_01_4">GenzMalikQuadrature&lt; N, hydra::detail::BackendPolicy&lt; BACKEND &gt; &gt;</a></td></tr>
<tr class="memdesc:classhydra_1_1GenzMalikQuadrature_3_01N_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_4_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-adaptive Genz-Malik multidimensional quadrature.  <a href="group__numerical__integration.html#classhydra_1_1GenzMalikQuadrature_3_01N_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_4_01_4">More...</a><br /></td></tr>
<tr class="separator:classhydra_1_1GenzMalikQuadrature_3_01N_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_4_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1GenzMalikRule"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#classhydra_1_1GenzMalikRule">GenzMalikRule</a></td></tr>
<tr class="separator:classhydra_1_1GenzMalikRule"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1GenzMalikRule_3_01DIM_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_4_01_4"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__numerical__integration.html#classhydra_1_1GenzMalikRule_3_01DIM_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_4_01_4">GenzMalikRule&lt; DIM, hydra::detail::BackendPolicy&lt; BACKEND &gt; &gt;</a></td></tr>
<tr class="memdesc:classhydra_1_1GenzMalikRule_3_01DIM_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_4_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing Genz-Malik rule.  <a href="group__numerical__integration.html#classhydra_1_1GenzMalikRule_3_01DIM_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_4_01_4">More...</a><br /></td></tr>
<tr class="separator:classhydra_1_1GenzMalikRule_3_01DIM_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_4_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1GenzMalikRuleBase.html">GenzMalikRuleBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1Integrator.html">Integrator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1LambdaWrapper"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#classhydra_1_1LambdaWrapper">LambdaWrapper</a></td></tr>
<tr class="separator:classhydra_1_1LambdaWrapper"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1LambdaWrapper_3_01ReturnType_07ArgType_8_8_8_08_00_01L_00_01N_01_4"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__functor.html#classhydra_1_1LambdaWrapper_3_01ReturnType_07ArgType_8_8_8_08_00_01L_00_01N_01_4">LambdaWrapper&lt; ReturnType(ArgType...), L, N &gt;</a></td></tr>
<tr class="memdesc:classhydra_1_1LambdaWrapper_3_01ReturnType_07ArgType_8_8_8_08_00_01L_00_01N_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for lambda functions.  <a href="group__functor.html#classhydra_1_1LambdaWrapper_3_01ReturnType_07ArgType_8_8_8_08_00_01L_00_01N_01_4">More...</a><br /></td></tr>
<tr class="separator:classhydra_1_1LambdaWrapper_3_01ReturnType_07ArgType_8_8_8_08_00_01L_00_01N_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1LogLikelihoodFCN"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#classhydra_1_1LogLikelihoodFCN">LogLikelihoodFCN</a></td></tr>
<tr class="separator:classhydra_1_1LogLikelihoodFCN"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1LogLikelihoodFCN_3_01Pdf_3_01Functor_00_01Integrator_01_4_00_01IteratorD_00_01IteratorW_8_8_8_01_4"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fit.html#classhydra_1_1LogLikelihoodFCN_3_01Pdf_3_01Functor_00_01Integrator_01_4_00_01IteratorD_00_01IteratorW_8_8_8_01_4">LogLikelihoodFCN&lt; Pdf&lt; Functor, Integrator &gt;, IteratorD, IteratorW... &gt;</a></td></tr>
<tr class="memdesc:classhydra_1_1LogLikelihoodFCN_3_01Pdf_3_01Functor_00_01Integrator_01_4_00_01IteratorD_00_01IteratorW_8_8_8_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">LogLikehood object for not composed models represented by <a class="el" href="group__fit.html#classhydra_1_1Pdf" title="Class representing probability density functions. ">hydra::Pdf</a> objects.  <a href="group__fit.html#classhydra_1_1LogLikelihoodFCN_3_01Pdf_3_01Functor_00_01Integrator_01_4_00_01IteratorD_00_01IteratorW_8_8_8_01_4">More...</a><br /></td></tr>
<tr class="separator:classhydra_1_1LogLikelihoodFCN_3_01Pdf_3_01Functor_00_01Integrator_01_4_00_01IteratorD_00_01IteratorW_8_8_8_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1LogLikelihoodFCN_3_01PDFSumExtendable_3_01Pdfs_8_8_8_01_4_00_01IteratorD_00_01IteratorW_8_8_8_01_4"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fit.html#classhydra_1_1LogLikelihoodFCN_3_01PDFSumExtendable_3_01Pdfs_8_8_8_01_4_00_01IteratorD_00_01IteratorW_8_8_8_01_4">LogLikelihoodFCN&lt; PDFSumExtendable&lt; Pdfs... &gt;, IteratorD, IteratorW... &gt;</a></td></tr>
<tr class="memdesc:classhydra_1_1LogLikelihoodFCN_3_01PDFSumExtendable_3_01Pdfs_8_8_8_01_4_00_01IteratorD_00_01IteratorW_8_8_8_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">LogLikehood object for composed models represented by hydra::PDFSumExtendable&lt;Pdfs...&gt; objects.  <a href="group__fit.html#classhydra_1_1LogLikelihoodFCN_3_01PDFSumExtendable_3_01Pdfs_8_8_8_01_4_00_01IteratorD_00_01IteratorW_8_8_8_01_4">More...</a><br /></td></tr>
<tr class="separator:classhydra_1_1LogLikelihoodFCN_3_01PDFSumExtendable_3_01Pdfs_8_8_8_01_4_00_01IteratorD_00_01IteratorW_8_8_8_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1LogLikelihoodFCN_3_01PDFSumNonExtendable_3_01Pdfs_8_8_8_01_4_00_01IteratorD_00_01IteratorW_8_8_8_01_4"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fit.html#classhydra_1_1LogLikelihoodFCN_3_01PDFSumNonExtendable_3_01Pdfs_8_8_8_01_4_00_01IteratorD_00_01IteratorW_8_8_8_01_4">LogLikelihoodFCN&lt; PDFSumNonExtendable&lt; Pdfs... &gt;, IteratorD, IteratorW... &gt;</a></td></tr>
<tr class="memdesc:classhydra_1_1LogLikelihoodFCN_3_01PDFSumNonExtendable_3_01Pdfs_8_8_8_01_4_00_01IteratorD_00_01IteratorW_8_8_8_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">LogLikehood object for composed models represented by hydra::PDFSumNonExtendable&lt;Pdfs...&gt; objects.  <a href="group__fit.html#classhydra_1_1LogLikelihoodFCN_3_01PDFSumNonExtendable_3_01Pdfs_8_8_8_01_4_00_01IteratorD_00_01IteratorW_8_8_8_01_4">More...</a><br /></td></tr>
<tr class="separator:classhydra_1_1LogLikelihoodFCN_3_01PDFSumNonExtendable_3_01Pdfs_8_8_8_01_4_00_01IteratorD_00_01IteratorW_8_8_8_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1M12PhaseSpaceLineShape.html">M12PhaseSpaceLineShape</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Two-body phase-space distribution for \( m_{12}\): </p><p class="formulaDsp">
\[ \frac{dN}{dm_{m_12}} \propto q.p \]
</p>
<p>.  <a href="classhydra_1_1M12PhaseSpaceLineShape.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1M12SqPhaseSpaceLineShape.html">M12SqPhaseSpaceLineShape</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Two-body phase-space distribution for \( m_{12}^2\): </p><p class="formulaDsp">
\[ \frac{dN}{dm^2_{12}} \propto q.p/m^2_{12} \]
</p>
<p>.  <a href="classhydra_1_1M12SqPhaseSpaceLineShape.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1Minus.html">Minus</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1multiarray"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#classhydra_1_1multiarray">multiarray</a></td></tr>
<tr class="separator:classhydra_1_1multiarray"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multiarray_3_01T_00_01N_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_4_01_4.html">multiarray&lt; T, N, hydra::detail::BackendPolicy&lt; BACKEND &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1Multiply.html">Multiply</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1multivector"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a></td></tr>
<tr class="separator:classhydra_1_1multivector"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html">multivector&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, hydra::detail::BackendPolicy&lt; BACKEND &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements storage in SoA layouts for table where all elements have the same type.  <a href="classhydra_1_1multivector_3_01HYDRA__EXTERNAL__NS_1_1thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra3da03b988538add1b3f476b1ea399ad2.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1null__type"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#structhydra_1_1null__type">null_type</a></td></tr>
<tr class="separator:structhydra_1_1null__type"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1Parameter"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a></td></tr>
<tr class="memdesc:structhydra_1_1Parameter"><td class="mdescLeft">&#160;</td><td class="mdescRight"><br />
,  <a href="group__fit.html#structhydra_1_1Parameter">More...</a><br /></td></tr>
<tr class="separator:structhydra_1_1Parameter"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1Pdf"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fit.html#classhydra_1_1Pdf">Pdf</a></td></tr>
<tr class="memdesc:classhydra_1_1Pdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing probability density functions.  <a href="group__fit.html#classhydra_1_1Pdf">More...</a><br /></td></tr>
<tr class="separator:classhydra_1_1Pdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1PDFSumExtendable"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fit.html#classhydra_1_1PDFSumExtendable">PDFSumExtendable</a></td></tr>
<tr class="memdesc:classhydra_1_1PDFSumExtendable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing a pdf object built summing up other pdfs.  <a href="group__fit.html#classhydra_1_1PDFSumExtendable">More...</a><br /></td></tr>
<tr class="separator:classhydra_1_1PDFSumExtendable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1PDFSumNonExtendable"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fit.html#classhydra_1_1PDFSumNonExtendable">PDFSumNonExtendable</a></td></tr>
<tr class="memdesc:classhydra_1_1PDFSumNonExtendable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing a pdf object built summing a pdf adding other pdfs.  <a href="group__fit.html#classhydra_1_1PDFSumNonExtendable">More...</a><br /></td></tr>
<tr class="separator:classhydra_1_1PDFSumNonExtendable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1PhaseSpace"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__phsp.html#classhydra_1_1PhaseSpace">PhaseSpace</a></td></tr>
<tr class="memdesc:classhydra_1_1PhaseSpace"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements phase-space Monte Carlo generation in hydra.  <a href="group__phsp.html#classhydra_1_1PhaseSpace">More...</a><br /></td></tr>
<tr class="separator:classhydra_1_1PhaseSpace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1PhaseSpaceIntegrator"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__phsp.html#classhydra_1_1PhaseSpaceIntegrator">PhaseSpaceIntegrator</a></td></tr>
<tr class="separator:classhydra_1_1PhaseSpaceIntegrator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1PhaseSpaceIntegrator_3_01N_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_4_00_01GRND_01_4"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__phsp.html#classhydra_1_1PhaseSpaceIntegrator_3_01N_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_4_00_01GRND_01_4">PhaseSpaceIntegrator&lt; N, hydra::detail::BackendPolicy&lt; BACKEND &gt;, GRND &gt;</a></td></tr>
<tr class="separator:classhydra_1_1PhaseSpaceIntegrator_3_01N_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_4_00_01GRND_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1Plain"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#structhydra_1_1Plain">Plain</a></td></tr>
<tr class="separator:structhydra_1_1Plain"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1Plain_3_01N_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_4_00_01GRND_01_4"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__numerical__integration.html#classhydra_1_1Plain_3_01N_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_4_00_01GRND_01_4">Plain&lt; N, hydra::detail::BackendPolicy&lt; BACKEND &gt;, GRND &gt;</a></td></tr>
<tr class="memdesc:classhydra_1_1Plain_3_01N_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_4_00_01GRND_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements the <a class="el" href="namespacehydra.html#structhydra_1_1Plain">Plain</a> MC numerical integration algorithm in Hydra.  <a href="group__numerical__integration.html#classhydra_1_1Plain_3_01N_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_4_00_01GRND_01_4">More...</a><br /></td></tr>
<tr class="separator:classhydra_1_1Plain_3_01N_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_4_00_01GRND_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1PlainState"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__numerical__integration.html#structhydra_1_1PlainState">PlainState</a></td></tr>
<tr class="memdesc:structhydra_1_1PlainState"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple structure to hold the results of the <a class="el" href="namespacehydra.html#structhydra_1_1Plain">Plain</a> MC numerical integration.  <a href="group__numerical__integration.html#structhydra_1_1PlainState">More...</a><br /></td></tr>
<tr class="separator:structhydra_1_1PlainState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1Polynomial.html">Polynomial</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1PolynomialAnalyticalIntegral.html">PolynomialAnalyticalIntegral</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1Print.html">Print</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1ProcessGaussKronrodAdaptiveQuadrature.html">ProcessGaussKronrodAdaptiveQuadrature</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1Random"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__random.html#classhydra_1_1Random">Random</a></td></tr>
<tr class="memdesc:classhydra_1_1Random"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements functionalities associated to random number generation and pdf sampling.  <a href="group__random.html#classhydra_1_1Random">More...</a><br /></td></tr>
<tr class="separator:classhydra_1_1Random"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1SparseHistogram"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__histogram.html#classhydra_1_1SparseHistogram">SparseHistogram</a></td></tr>
<tr class="separator:classhydra_1_1SparseHistogram"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1SparseHistogram_3_01T_00_011_00_01detail_1_1BackendPolicy_3_01BACKEND_01_4_00_01detail_1_1unidimensional_01_4"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__histogram.html#classhydra_1_1SparseHistogram_3_01T_00_011_00_01detail_1_1BackendPolicy_3_01BACKEND_01_4_00_01detail_1_1unidimensional_01_4">SparseHistogram&lt; T, 1, detail::BackendPolicy&lt; BACKEND &gt;, detail::unidimensional &gt;</a></td></tr>
<tr class="memdesc:classhydra_1_1SparseHistogram_3_01T_00_011_00_01detail_1_1BackendPolicy_3_01BACKEND_01_4_00_01detail_1_1unidimensional_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing one-dimensional sparse histogram.  <a href="group__histogram.html#classhydra_1_1SparseHistogram_3_01T_00_011_00_01detail_1_1BackendPolicy_3_01BACKEND_01_4_00_01detail_1_1unidimensional_01_4">More...</a><br /></td></tr>
<tr class="separator:classhydra_1_1SparseHistogram_3_01T_00_011_00_01detail_1_1BackendPolicy_3_01BACKEND_01_4_00_01detail_1_1unidimensional_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1SparseHistogram_3_01T_00_01N_00_01detail_1_1BackendPolicy_3_01BACKEND_01_4_00_01detail_1_1multidimensional_01_4"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__histogram.html#classhydra_1_1SparseHistogram_3_01T_00_01N_00_01detail_1_1BackendPolicy_3_01BACKEND_01_4_00_01detail_1_1multidimensional_01_4">SparseHistogram&lt; T, N, detail::BackendPolicy&lt; BACKEND &gt;, detail::multidimensional &gt;</a></td></tr>
<tr class="memdesc:classhydra_1_1SparseHistogram_3_01T_00_01N_00_01detail_1_1BackendPolicy_3_01BACKEND_01_4_00_01detail_1_1multidimensional_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing multidimensional sparse histogram.  <a href="group__histogram.html#classhydra_1_1SparseHistogram_3_01T_00_01N_00_01detail_1_1BackendPolicy_3_01BACKEND_01_4_00_01detail_1_1multidimensional_01_4">More...</a><br /></td></tr>
<tr class="separator:classhydra_1_1SparseHistogram_3_01T_00_01N_00_01detail_1_1BackendPolicy_3_01BACKEND_01_4_00_01detail_1_1multidimensional_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1SPlot.html">SPlot</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1Sum.html">Sum</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1UserParameters"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fit.html#classhydra_1_1UserParameters">UserParameters</a></td></tr>
<tr class="memdesc:classhydra_1_1UserParameters"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class implementing a interface to ROOT::Minuit2::MnUserParameters.  <a href="group__fit.html#classhydra_1_1UserParameters">More...</a><br /></td></tr>
<tr class="separator:classhydra_1_1UserParameters"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1Vector3R"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__phsp.html#classhydra_1_1Vector3R">Vector3R</a></td></tr>
<tr class="memdesc:classhydra_1_1Vector3R"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents three-dimensional Euclidian vectors and implements common operation performed on it.  <a href="group__phsp.html#classhydra_1_1Vector3R">More...</a><br /></td></tr>
<tr class="separator:classhydra_1_1Vector3R"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1Vector4R"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__phsp.html#classhydra_1_1Vector4R">Vector4R</a></td></tr>
<tr class="memdesc:classhydra_1_1Vector4R"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents four-dimensional relativistic vectors and implements common operation performed on it.  <a href="group__phsp.html#classhydra_1_1Vector4R">More...</a><br /></td></tr>
<tr class="separator:classhydra_1_1Vector4R"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1Vegas"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#classhydra_1_1Vegas">Vegas</a></td></tr>
<tr class="separator:classhydra_1_1Vegas"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1Vegas_3_01N_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_4_00_01GRND_01_4"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__numerical__integration.html#classhydra_1_1Vegas_3_01N_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_4_00_01GRND_01_4">Vegas&lt; N, hydra::detail::BackendPolicy&lt; BACKEND &gt;, GRND &gt;</a></td></tr>
<tr class="memdesc:classhydra_1_1Vegas_3_01N_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_4_00_01GRND_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to perform numerical integration using <a class="el" href="namespacehydra.html#classhydra_1_1Vegas">Vegas</a> algorithm.  <a href="group__numerical__integration.html#classhydra_1_1Vegas_3_01N_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_4_00_01GRND_01_4">More...</a><br /></td></tr>
<tr class="separator:classhydra_1_1Vegas_3_01N_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_4_00_01GRND_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1VegasState"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__numerical__integration.html#classhydra_1_1VegasState">VegasState</a></td></tr>
<tr class="memdesc:classhydra_1_1VegasState"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to hold resources and state of <a class="el" href="namespacehydra.html#classhydra_1_1Vegas">hydra::Vegas</a> integration algorithm.  <a href="group__numerical__integration.html#classhydra_1_1VegasState">More...</a><br /></td></tr>
<tr class="separator:classhydra_1_1VegasState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1VegasState_3_01N_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_4_01_4"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__numerical__integration.html#classhydra_1_1VegasState_3_01N_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_4_01_4">VegasState&lt; N, hydra::detail::BackendPolicy&lt; BACKEND &gt; &gt;</a></td></tr>
<tr class="memdesc:classhydra_1_1VegasState_3_01N_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_4_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to hold resources and state of <a class="el" href="namespacehydra.html#classhydra_1_1Vegas">hydra::Vegas</a> integration algorithm.  <a href="group__numerical__integration.html#classhydra_1_1VegasState_3_01N_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_4_01_4">More...</a><br /></td></tr>
<tr class="separator:classhydra_1_1VegasState_3_01N_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_4_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1Weights"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#classhydra_1_1Weights">Weights</a></td></tr>
<tr class="separator:classhydra_1_1Weights"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1Weights_3_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_4_01_4.html">Weights&lt; hydra::detail::BackendPolicy&lt; BACKEND &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1WignerD.html">WignerD</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the beta-term </p><p class="formulaDsp">
\[ d^j_{mn}(beta) \]
</p>
<p> in the matrix element of the finite rotation operator (Wigner's D-function), according to formula 4.3.1(3) in D.A.  <a href="classhydra_1_1WignerD.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1ZemachFunction.html">ZemachFunction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Zemach's angular probability distribution for 3-body decays of spinless particle into spinless final states as a function of \(\theta\), the helicity angle:  <a href="classhydra_1_1ZemachFunction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a9fa75a3de2ad0fc8f3a5c8850fa2d9bc"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="namespacehydra.html#a648839818fa9d4a58c2195a55a51e773">mc_device_vector</a>&lt; <a class="el" href="namespacehydra.html#aa8c251ed5017d0638da929130062bcad">GBool_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a9fa75a3de2ad0fc8f3a5c8850fa2d9bc">BoolVector_d</a></td></tr>
<tr class="memdesc:a9fa75a3de2ad0fc8f3a5c8850fa2d9bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef for a <a class="el" href="group__phsp.html#classhydra_1_1Vector4R" title="This class represents four-dimensional relativistic vectors and implements common operation performed...">Vector4R</a> host vector.  <a href="#a9fa75a3de2ad0fc8f3a5c8850fa2d9bc">More...</a><br /></td></tr>
<tr class="separator:a9fa75a3de2ad0fc8f3a5c8850fa2d9bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a274b1c32d255fc13e78a08e96de133f0"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="namespacehydra.html#a6de6f086a44380382022dafca75de4c9">mc_host_vector</a>&lt; <a class="el" href="namespacehydra.html#aa8c251ed5017d0638da929130062bcad">GBool_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a274b1c32d255fc13e78a08e96de133f0">BoolVector_h</a></td></tr>
<tr class="memdesc:a274b1c32d255fc13e78a08e96de133f0"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="group__phsp.html#classhydra_1_1Vector3R" title="This class represents three-dimensional Euclidian vectors and implements common operation performed o...">Vector3R</a> host vector.  <a href="#a274b1c32d255fc13e78a08e96de133f0">More...</a><br /></td></tr>
<tr class="separator:a274b1c32d255fc13e78a08e96de133f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f9af1aefe36fa4f80f57289ffb84dca"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4f9af1aefe36fa4f80f57289ffb84dca"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a> = HYDRA_EXTERNAL_NS::thrust::complex&lt; T &gt;</td></tr>
<tr class="separator:a4f9af1aefe36fa4f80f57289ffb84dca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7670b2993eb064d9c192d9200ab82b89"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="namespacehydra.html#a648839818fa9d4a58c2195a55a51e773">mc_device_vector</a>&lt; <a class="el" href="namespacehydra.html#a7ab78a78009fd9969bce04250387d13e">GComplex_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a7670b2993eb064d9c192d9200ab82b89">ComplexVector_d</a></td></tr>
<tr class="memdesc:a7670b2993eb064d9c192d9200ab82b89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef for a GReal_t device vector.  <a href="#a7670b2993eb064d9c192d9200ab82b89">More...</a><br /></td></tr>
<tr class="separator:a7670b2993eb064d9c192d9200ab82b89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af30019aaf18d88f73acd61f2f363f9f6"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="namespacehydra.html#a6de6f086a44380382022dafca75de4c9">mc_host_vector</a>&lt; <a class="el" href="namespacehydra.html#a7ab78a78009fd9969bce04250387d13e">GComplex_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#af30019aaf18d88f73acd61f2f363f9f6">ComplexVector_h</a></td></tr>
<tr class="memdesc:af30019aaf18d88f73acd61f2f363f9f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef for a GReal_t host vector.  <a href="#af30019aaf18d88f73acd61f2f363f9f6">More...</a><br /></td></tr>
<tr class="separator:af30019aaf18d88f73acd61f2f363f9f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e747e9ec41024e3efe0349f8ac10062"><td class="memItemLeft" align="right" valign="top">typedef HYDRA_EXTERNAL_NS::thrust::random::default_random_engine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a1e747e9ec41024e3efe0349f8ac10062">default_random_engine</a></td></tr>
<tr class="memdesc:a1e747e9ec41024e3efe0349f8ac10062"><td class="mdescLeft">&#160;</td><td class="mdescRight">An implementation-defined "default" random number engine.  <a href="#a1e747e9ec41024e3efe0349f8ac10062">More...</a><br /></td></tr>
<tr class="separator:a1e747e9ec41024e3efe0349f8ac10062"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada2d81895ace081c5204b9adc76a2808"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="namespacehydra.html#a6de6f086a44380382022dafca75de4c9">mc_host_vector</a>&lt; <a class="el" href="group__phsp.html#classhydra_1_1Vector4R">Vector4R</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ada2d81895ace081c5204b9adc76a2808">FourVectors_h</a></td></tr>
<tr class="memdesc:ada2d81895ace081c5204b9adc76a2808"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef for complex number.  <a href="#ada2d81895ace081c5204b9adc76a2808">More...</a><br /></td></tr>
<tr class="separator:ada2d81895ace081c5204b9adc76a2808"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8c251ed5017d0638da929130062bcad"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="namespace_3globalScope_4.html#classbool">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#aa8c251ed5017d0638da929130062bcad">GBool_t</a></td></tr>
<tr class="memdesc:aa8c251ed5017d0638da929130062bcad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boolean (0=false, 1=true) (bool)  <a href="#aa8c251ed5017d0638da929130062bcad">More...</a><br /></td></tr>
<tr class="separator:aa8c251ed5017d0638da929130062bcad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2da2ab0037e6bca3cb7c15adc5c4125"><td class="memItemLeft" align="right" valign="top">typedef unsigned char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ae2da2ab0037e6bca3cb7c15adc5c4125">GByte_t</a></td></tr>
<tr class="memdesc:ae2da2ab0037e6bca3cb7c15adc5c4125"><td class="mdescLeft">&#160;</td><td class="mdescRight">Byte (8 bits) (unsigned char)  <a href="#ae2da2ab0037e6bca3cb7c15adc5c4125">More...</a><br /></td></tr>
<tr class="separator:ae2da2ab0037e6bca3cb7c15adc5c4125"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ab04a199389c4989174dc115507fa89"><td class="memItemLeft" align="right" valign="top">typedef char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a7ab04a199389c4989174dc115507fa89">GChar_t</a></td></tr>
<tr class="memdesc:a7ab04a199389c4989174dc115507fa89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed Character 1 byte (char)  <a href="#a7ab04a199389c4989174dc115507fa89">More...</a><br /></td></tr>
<tr class="separator:a7ab04a199389c4989174dc115507fa89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ab78a78009fd9969bce04250387d13e"><td class="memItemLeft" align="right" valign="top">typedef HYDRA_EXTERNAL_NS::thrust::complex&lt; <a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a7ab78a78009fd9969bce04250387d13e">GComplex_t</a></td></tr>
<tr class="separator:a7ab78a78009fd9969bce04250387d13e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af986267d40d932c5cbf0ae874a506f83"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#af986267d40d932c5cbf0ae874a506f83">GDouble_t</a></td></tr>
<tr class="memdesc:af986267d40d932c5cbf0ae874a506f83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Double 8 bytes.  <a href="#af986267d40d932c5cbf0ae874a506f83">More...</a><br /></td></tr>
<tr class="separator:af986267d40d932c5cbf0ae874a506f83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71bab7b854d7b3c3042fe47201b765eb"><td class="memItemLeft" align="right" valign="top">typedef float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a71bab7b854d7b3c3042fe47201b765eb">GFloat_t</a></td></tr>
<tr class="memdesc:a71bab7b854d7b3c3042fe47201b765eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Float 4 bytes (float)  <a href="#a71bab7b854d7b3c3042fe47201b765eb">More...</a><br /></td></tr>
<tr class="separator:a71bab7b854d7b3c3042fe47201b765eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c9fb4d7195ab952da10a82d5c4ad30e"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="namespace_3globalScope_4.html#classint">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a0c9fb4d7195ab952da10a82d5c4ad30e">GInt_t</a></td></tr>
<tr class="memdesc:a0c9fb4d7195ab952da10a82d5c4ad30e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed integer 4 bytes (int)  <a href="#a0c9fb4d7195ab952da10a82d5c4ad30e">More...</a><br /></td></tr>
<tr class="separator:a0c9fb4d7195ab952da10a82d5c4ad30e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d68c21fb715bbfb1edc5b1933b173e9"><td class="memItemLeft" align="right" valign="top">typedef long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a9d68c21fb715bbfb1edc5b1933b173e9">GLong64_t</a></td></tr>
<tr class="memdesc:a9d68c21fb715bbfb1edc5b1933b173e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Portable signed long integer 8 bytes.  <a href="#a9d68c21fb715bbfb1edc5b1933b173e9">More...</a><br /></td></tr>
<tr class="separator:a9d68c21fb715bbfb1edc5b1933b173e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f57a4025b40929c2708cd544c3a1ccd"><td class="memItemLeft" align="right" valign="top">typedef long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a5f57a4025b40929c2708cd544c3a1ccd">GLong_t</a></td></tr>
<tr class="memdesc:a5f57a4025b40929c2708cd544c3a1ccd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed long integer 4 bytes (long)  <a href="#a5f57a4025b40929c2708cd544c3a1ccd">More...</a><br /></td></tr>
<tr class="separator:a5f57a4025b40929c2708cd544c3a1ccd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a751abe69b482cde879c718fd4775733f"><td class="memItemLeft" align="right" valign="top">typedef long <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a751abe69b482cde879c718fd4775733f">GLongDouble_t</a></td></tr>
<tr class="memdesc:a751abe69b482cde879c718fd4775733f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Long Double.  <a href="#a751abe69b482cde879c718fd4775733f">More...</a><br /></td></tr>
<tr class="separator:a751abe69b482cde879c718fd4775733f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a971e94bcb8c43741d11f9d8eb98f5fab"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a></td></tr>
<tr class="memdesc:a971e94bcb8c43741d11f9d8eb98f5fab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Double 16 bytes or float 4 bytes.  <a href="#a971e94bcb8c43741d11f9d8eb98f5fab">More...</a><br /></td></tr>
<tr class="separator:a971e94bcb8c43741d11f9d8eb98f5fab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a589c60d92ba893c28d814edd6e149a9c"><td class="memItemLeft" align="right" valign="top">typedef short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a589c60d92ba893c28d814edd6e149a9c">GShort_t</a></td></tr>
<tr class="memdesc:a589c60d92ba893c28d814edd6e149a9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed Short integer 2 bytes (short)  <a href="#a589c60d92ba893c28d814edd6e149a9c">More...</a><br /></td></tr>
<tr class="separator:a589c60d92ba893c28d814edd6e149a9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc842c1ec8321e9637dee714dcdaebff"><td class="memItemLeft" align="right" valign="top">typedef char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#abc842c1ec8321e9637dee714dcdaebff">GText_t</a></td></tr>
<tr class="memdesc:abc842c1ec8321e9637dee714dcdaebff"><td class="mdescLeft">&#160;</td><td class="mdescRight">General string (char)  <a href="#abc842c1ec8321e9637dee714dcdaebff">More...</a><br /></td></tr>
<tr class="separator:abc842c1ec8321e9637dee714dcdaebff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51ef97faee95aa79f3839eb7abdf5238"><td class="memItemLeft" align="right" valign="top">typedef unsigned char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a51ef97faee95aa79f3839eb7abdf5238">GUChar_t</a></td></tr>
<tr class="memdesc:a51ef97faee95aa79f3839eb7abdf5238"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsigned Character 1 byte (unsigned char)  <a href="#a51ef97faee95aa79f3839eb7abdf5238">More...</a><br /></td></tr>
<tr class="separator:a51ef97faee95aa79f3839eb7abdf5238"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a251a7b1f515ac1ed9409afd67252a32b"><td class="memItemLeft" align="right" valign="top">typedef unsigned <a class="el" href="namespace_3globalScope_4.html#classint">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a251a7b1f515ac1ed9409afd67252a32b">GUInt_t</a></td></tr>
<tr class="memdesc:a251a7b1f515ac1ed9409afd67252a32b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsigned integer 4 bytes (unsigned int)  <a href="#a251a7b1f515ac1ed9409afd67252a32b">More...</a><br /></td></tr>
<tr class="separator:a251a7b1f515ac1ed9409afd67252a32b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55e8443cd746900da90cb1f77807e7c0"><td class="memItemLeft" align="right" valign="top">typedef unsigned long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a55e8443cd746900da90cb1f77807e7c0">GULong64_t</a></td></tr>
<tr class="memdesc:a55e8443cd746900da90cb1f77807e7c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Portable unsigned long integer 8 bytes.  <a href="#a55e8443cd746900da90cb1f77807e7c0">More...</a><br /></td></tr>
<tr class="separator:a55e8443cd746900da90cb1f77807e7c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf9a0d54fd4ed46052939549edd086c5"><td class="memItemLeft" align="right" valign="top">typedef unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#abf9a0d54fd4ed46052939549edd086c5">GULong_t</a></td></tr>
<tr class="separator:abf9a0d54fd4ed46052939549edd086c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a911a3042526fac189d0c87a089f52955"><td class="memItemLeft" align="right" valign="top">typedef unsigned short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a911a3042526fac189d0c87a089f52955">GUShort_t</a></td></tr>
<tr class="memdesc:a911a3042526fac189d0c87a089f52955"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsigned Short integer 2 bytes (unsigned short)  <a href="#a911a3042526fac189d0c87a089f52955">More...</a><br /></td></tr>
<tr class="separator:a911a3042526fac189d0c87a089f52955"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a648839818fa9d4a58c2195a55a51e773"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a648839818fa9d4a58c2195a55a51e773"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a648839818fa9d4a58c2195a55a51e773">mc_device_vector</a> = HYDRA_EXTERNAL_NS::thrust::device_vector&lt; T &gt;</td></tr>
<tr class="memdesc:a648839818fa9d4a58c2195a55a51e773"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic template typedef for HYDRA_EXTERNAL_NS::thrust::host_vector.  <a href="#a648839818fa9d4a58c2195a55a51e773">More...</a><br /></td></tr>
<tr class="separator:a648839818fa9d4a58c2195a55a51e773"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6de6f086a44380382022dafca75de4c9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6de6f086a44380382022dafca75de4c9"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a6de6f086a44380382022dafca75de4c9">mc_host_vector</a> = HYDRA_EXTERNAL_NS::thrust::host_vector&lt; T, HYDRA_EXTERNAL_NS::thrust::system::cuda::experimental::pinned_allocator&lt; T &gt; &gt;</td></tr>
<tr class="memdesc:a6de6f086a44380382022dafca75de4c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic template typedef for HYDRA_EXTERNAL_NS::thrust::host_vector.  <a href="#a6de6f086a44380382022dafca75de4c9">More...</a><br /></td></tr>
<tr class="separator:a6de6f086a44380382022dafca75de4c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeccdd58e3a4c27246dadd0930e3fb569"><td class="memItemLeft" align="right" valign="top">typedef HYDRA_EXTERNAL_NS::thrust::random::minstd_rand&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#aeccdd58e3a4c27246dadd0930e3fb569">minstd_rand</a></td></tr>
<tr class="memdesc:aeccdd58e3a4c27246dadd0930e3fb569"><td class="mdescLeft">&#160;</td><td class="mdescRight">A random number engine with predefined parameters which implements a version of the Minimal Standard random number generation algorithm.  <a href="#aeccdd58e3a4c27246dadd0930e3fb569">More...</a><br /></td></tr>
<tr class="separator:aeccdd58e3a4c27246dadd0930e3fb569"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7c3603cf7a6c467176d8be9dd2c82fd"><td class="memItemLeft" align="right" valign="top">typedef HYDRA_EXTERNAL_NS::thrust::random::minstd_rand0&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ab7c3603cf7a6c467176d8be9dd2c82fd">minstd_rand0</a></td></tr>
<tr class="memdesc:ab7c3603cf7a6c467176d8be9dd2c82fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">A random number engine with predefined parameters which implements a version of the Minimal Standard random number generation algorithm.  <a href="#ab7c3603cf7a6c467176d8be9dd2c82fd">More...</a><br /></td></tr>
<tr class="separator:ab7c3603cf7a6c467176d8be9dd2c82fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf5241d6a56b2040e9cc9ea860b4cbff"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:acf5241d6a56b2040e9cc9ea860b4cbff"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#acf5241d6a56b2040e9cc9ea860b4cbff">pair</a> = HYDRA_EXTERNAL_NS::thrust::pair&lt; T1, T2 &gt;</td></tr>
<tr class="memdesc:acf5241d6a56b2040e9cc9ea860b4cbff"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>pair</code> template is an alias to the HYDRA_EXTERNAL_NS::thrust::pair structure.  <a href="#acf5241d6a56b2040e9cc9ea860b4cbff">More...</a><br /></td></tr>
<tr class="separator:acf5241d6a56b2040e9cc9ea860b4cbff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae34184a169c185689e065d0c30f9ffba"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="namespacehydra.html#a648839818fa9d4a58c2195a55a51e773">mc_device_vector</a>&lt; <a class="el" href="group__phsp.html#classhydra_1_1Vector4R">Vector4R</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ae34184a169c185689e065d0c30f9ffba">Particles_d</a></td></tr>
<tr class="memdesc:ae34184a169c185689e065d0c30f9ffba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef for a GComplex_t device vector.  <a href="#ae34184a169c185689e065d0c30f9ffba">More...</a><br /></td></tr>
<tr class="separator:ae34184a169c185689e065d0c30f9ffba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9df2f3d6dc63cf297b0f74ba228f6c89"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="namespacehydra.html#a6de6f086a44380382022dafca75de4c9">mc_host_vector</a>&lt; <a class="el" href="group__phsp.html#classhydra_1_1Vector4R">Vector4R</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a9df2f3d6dc63cf297b0f74ba228f6c89">Particles_h</a></td></tr>
<tr class="memdesc:a9df2f3d6dc63cf297b0f74ba228f6c89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef for a GComplex_t host vector.  <a href="#a9df2f3d6dc63cf297b0f74ba228f6c89">More...</a><br /></td></tr>
<tr class="separator:a9df2f3d6dc63cf297b0f74ba228f6c89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a943a0571fdadbbb4bc9b17ba7ae4b59b"><td class="memItemLeft" align="right" valign="top">typedef HYDRA_EXTERNAL_NS::thrust::random::ranlux24&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a943a0571fdadbbb4bc9b17ba7ae4b59b">ranlux24</a></td></tr>
<tr class="memdesc:a943a0571fdadbbb4bc9b17ba7ae4b59b"><td class="mdescLeft">&#160;</td><td class="mdescRight">A random number engine with predefined parameters which implements the RANLUX level-3 random number generation algorithm.  <a href="#a943a0571fdadbbb4bc9b17ba7ae4b59b">More...</a><br /></td></tr>
<tr class="separator:a943a0571fdadbbb4bc9b17ba7ae4b59b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6950c5abef4e2015f833501684940b5d"><td class="memItemLeft" align="right" valign="top">typedef HYDRA_EXTERNAL_NS::thrust::random::ranlux48&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a6950c5abef4e2015f833501684940b5d">ranlux48</a></td></tr>
<tr class="memdesc:a6950c5abef4e2015f833501684940b5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A random number engine with predefined parameters which implements the RANLUX level-4 random number generation algorithm.  <a href="#a6950c5abef4e2015f833501684940b5d">More...</a><br /></td></tr>
<tr class="separator:a6950c5abef4e2015f833501684940b5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79fd090c6e39cfcdd744f369dacffabe"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="namespacehydra.html#a648839818fa9d4a58c2195a55a51e773">mc_device_vector</a>&lt; <a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a79fd090c6e39cfcdd744f369dacffabe">RealVector_d</a></td></tr>
<tr class="memdesc:a79fd090c6e39cfcdd744f369dacffabe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef for a GBool_t device vector.  <a href="#a79fd090c6e39cfcdd744f369dacffabe">More...</a><br /></td></tr>
<tr class="separator:a79fd090c6e39cfcdd744f369dacffabe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d21da5996b50a240e6f400025e3b139"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="namespacehydra.html#a6de6f086a44380382022dafca75de4c9">mc_host_vector</a>&lt; <a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a6d21da5996b50a240e6f400025e3b139">RealVector_h</a></td></tr>
<tr class="memdesc:a6d21da5996b50a240e6f400025e3b139"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef for a GBool_t host vector.  <a href="#a6d21da5996b50a240e6f400025e3b139">More...</a><br /></td></tr>
<tr class="separator:a6d21da5996b50a240e6f400025e3b139"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2633cfe1492c02cfb2aef6a79804f191"><td class="memItemLeft" align="right" valign="top">typedef HYDRA_EXTERNAL_NS::thrust::random::taus88&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a2633cfe1492c02cfb2aef6a79804f191">taus88</a></td></tr>
<tr class="memdesc:a2633cfe1492c02cfb2aef6a79804f191"><td class="mdescLeft">&#160;</td><td class="mdescRight">A random number engine with predefined parameters which implements L'Ecuyer's 1996 three-component Tausworthe random number generator.  <a href="#a2633cfe1492c02cfb2aef6a79804f191">More...</a><br /></td></tr>
<tr class="separator:a2633cfe1492c02cfb2aef6a79804f191"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dcdb1155222988a4250114d880e8b46"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="namespacehydra.html#a6de6f086a44380382022dafca75de4c9">mc_host_vector</a>&lt; <a class="el" href="group__phsp.html#classhydra_1_1Vector3R">Vector3R</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a7dcdb1155222988a4250114d880e8b46">ThreeVectors_h</a></td></tr>
<tr class="memdesc:a7dcdb1155222988a4250114d880e8b46"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="group__phsp.html#classhydra_1_1Vector4R" title="This class represents four-dimensional relativistic vectors and implements common operation performed...">Vector4R</a> host vector.  <a href="#a7dcdb1155222988a4250114d880e8b46">More...</a><br /></td></tr>
<tr class="separator:a7dcdb1155222988a4250114d880e8b46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e59cc0127adfac6b799c5fd6785431b"><td class="memTemplParams" colspan="2">template&lt;typename... T&gt; </td></tr>
<tr class="memitem:a5e59cc0127adfac6b799c5fd6785431b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a5e59cc0127adfac6b799c5fd6785431b">tuple</a> = HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;</td></tr>
<tr class="memdesc:a5e59cc0127adfac6b799c5fd6785431b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>tuple</code> template is an alias to the variadic version of HYDRA_EXTERNAL_NS::thrust::tuple and that can be instantiated with a indefinite number of arguments.  <a href="#a5e59cc0127adfac6b799c5fd6785431b">More...</a><br /></td></tr>
<tr class="separator:a5e59cc0127adfac6b799c5fd6785431b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ecb38ba9198aee2de36f374d07638de"><td class="memTemplParams" colspan="2">template&lt;int N, class T &gt; </td></tr>
<tr class="memitem:a3ecb38ba9198aee2de36f374d07638de"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a3ecb38ba9198aee2de36f374d07638de">tuple_element</a> = HYDRA_EXTERNAL_NS::thrust::tuple_element&lt; N, T &gt;</td></tr>
<tr class="memdesc:a3ecb38ba9198aee2de36f374d07638de"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <code>get</code> function returns a <code>const</code> reference to a <code>tuple</code> element of interest.  <a href="#a3ecb38ba9198aee2de36f374d07638de">More...</a><br /></td></tr>
<tr class="separator:a3ecb38ba9198aee2de36f374d07638de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab06a4451f99b94119ead1dcadf2b8e31"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ab06a4451f99b94119ead1dcadf2b8e31"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ab06a4451f99b94119ead1dcadf2b8e31">tuple_size</a> = HYDRA_EXTERNAL_NS::thrust::tuple_size&lt; T &gt;</td></tr>
<tr class="memdesc:ab06a4451f99b94119ead1dcadf2b8e31"><td class="mdescLeft">&#160;</td><td class="mdescRight">This metafunction returns the number of elements of a <code>tuple</code> type of interest.  <a href="#ab06a4451f99b94119ead1dcadf2b8e31">More...</a><br /></td></tr>
<tr class="separator:ab06a4451f99b94119ead1dcadf2b8e31"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:aed873b1b84fbec3791e721b22a52d1fe"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="namespacehydra.html#aed873b1b84fbec3791e721b22a52d1fea4517ec382985cb7a39393c0da09e58d5">INFO</a> =0, 
<a class="el" href="namespacehydra.html#aed873b1b84fbec3791e721b22a52d1fea1bf857a06d5b8463494a6fcac6f4ea26">WARNING</a> =1, 
<a class="el" href="namespacehydra.html#aed873b1b84fbec3791e721b22a52d1feadbc96f88184ea3a51f68df95e2b44851">ERROR</a> =2
 }</td></tr>
<tr class="separator:aed873b1b84fbec3791e721b22a52d1fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1107488f838687e73b39ddd8245f40d0"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="namespacehydra.html#a1107488f838687e73b39ddd8245f40d0aae772e8b4c5ada0e1e4c65495702176a">MODE_IMPORTANCE</a> = 1, 
<a class="el" href="namespacehydra.html#a1107488f838687e73b39ddd8245f40d0a28550661921a3af1306fa74a26b8569c">MODE_IMPORTANCE_ONLY</a> = 0, 
<a class="el" href="namespacehydra.html#a1107488f838687e73b39ddd8245f40d0acb2c0124fecbf6c1182f1cf7cd9bc37a">MODE_STRATIFIED</a> = -1, 
<a class="el" href="namespacehydra.html#a1107488f838687e73b39ddd8245f40d0aba2629d0445cc7ef401fd6793f047da0">BINS_MAX</a> = 50
 }</td></tr>
<tr class="separator:a1107488f838687e73b39ddd8245f40d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dc858c0fb14ade1e8abc19cdd0959e2"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a0dc858c0fb14ade1e8abc19cdd0959e2">Wave</a> { <br />
&#160;&#160;<a class="el" href="namespacehydra.html#a0dc858c0fb14ade1e8abc19cdd0959e2a4f4fc5545002d4eada7e2a14c27c5dfd">SWave</a> =0, 
<a class="el" href="namespacehydra.html#a0dc858c0fb14ade1e8abc19cdd0959e2ae382eaafad7afe6dee68693249ff8a45">PWave</a>, 
<a class="el" href="namespacehydra.html#a0dc858c0fb14ade1e8abc19cdd0959e2a74097dfe50b93307e587c23f9180b6b3">DWave</a>, 
<a class="el" href="namespacehydra.html#a0dc858c0fb14ade1e8abc19cdd0959e2a82415de987820fb86ab995f1dee87db1">FWave</a>, 
<br />
&#160;&#160;<a class="el" href="namespacehydra.html#a0dc858c0fb14ade1e8abc19cdd0959e2a113622b6b528bfd4a76d68e9a99ac032">GWave</a>, 
<a class="el" href="namespacehydra.html#a0dc858c0fb14ade1e8abc19cdd0959e2af168d5a7a174aa70e881f13fdeaf4426">HWave</a>
<br />
 }</td></tr>
<tr class="memdesc:a0dc858c0fb14ade1e8abc19cdd0959e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Orbital angular momentum tags.  <a href="namespacehydra.html#a0dc858c0fb14ade1e8abc19cdd0959e2">More...</a><br /></td></tr>
<tr class="separator:a0dc858c0fb14ade1e8abc19cdd0959e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a5e095cca28f6bec603156fd48914aefe"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5e095cca28f6bec603156fd48914aefe"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a5e095cca28f6bec603156fd48914aefe">abs</a> (const <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;z)</td></tr>
<tr class="separator:a5e095cca28f6bec603156fd48914aefe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a256097a85b1ce0eafa6e497f46d87383"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a256097a85b1ce0eafa6e497f46d87383"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a256097a85b1ce0eafa6e497f46d87383">acos</a> (const <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;z)</td></tr>
<tr class="separator:a256097a85b1ce0eafa6e497f46d87383"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec91f5ec5ff214023b38f72ec4ac1e76"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aec91f5ec5ff214023b38f72ec4ac1e76"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#aec91f5ec5ff214023b38f72ec4ac1e76">acosh</a> (const <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;z)</td></tr>
<tr class="separator:aec91f5ec5ff214023b38f72ec4ac1e76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5917e6644c8742bd0d3586066ee5de0"><td class="memTemplParams" colspan="2">template&lt;typename PDF1 , typename PDF2 , typename ... PDFs&gt; </td></tr>
<tr class="memitem:gad5917e6644c8742bd0d3586066ee5de0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__fit.html#classhydra_1_1PDFSumNonExtendable">PDFSumNonExtendable</a>&lt; PDF1, PDF2, PDFs... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__fit.html#gad5917e6644c8742bd0d3586066ee5de0">add_pdfs</a> (std::array&lt; <a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a>, sizeof...(PDFs)+1 &gt;const &amp;var_list, PDF1 const &amp;pdf1, PDF2 const &amp;pdf2, PDFs const &amp;...pdfs)</td></tr>
<tr class="memdesc:gad5917e6644c8742bd0d3586066ee5de0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to build up non-extendable pdfs models.  <a href="group__fit.html#gad5917e6644c8742bd0d3586066ee5de0">More...</a><br /></td></tr>
<tr class="separator:gad5917e6644c8742bd0d3586066ee5de0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e7cc3bb04eac1d1350bb41b254fc92b"><td class="memTemplParams" colspan="2">template&lt;typename PDF1 , typename PDF2 , typename ... PDFs&gt; </td></tr>
<tr class="memitem:ga7e7cc3bb04eac1d1350bb41b254fc92b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__fit.html#classhydra_1_1PDFSumExtendable">PDFSumExtendable</a>&lt; PDF1, PDF2, PDFs... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__fit.html#ga7e7cc3bb04eac1d1350bb41b254fc92b">add_pdfs</a> (std::array&lt; <a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a>, sizeof...(PDFs)+2 &gt;const &amp;var_list, PDF1 const &amp;pdf1, PDF2 const &amp;pdf2, PDFs const &amp;...pdfs)</td></tr>
<tr class="memdesc:ga7e7cc3bb04eac1d1350bb41b254fc92b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to build up extendable pdfs models.  <a href="group__fit.html#ga7e7cc3bb04eac1d1350bb41b254fc92b">More...</a><br /></td></tr>
<tr class="separator:ga7e7cc3bb04eac1d1350bb41b254fc92b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f175cc8f2c59f6cf2c416354fdb951f"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename Functor &gt; </td></tr>
<tr class="memitem:a4f175cc8f2c59f6cf2c416354fdb951f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacehydra.html#classhydra_1_1GenericRange">hydra::GenericRange</a>&lt; typename Container::iterator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a4f175cc8f2c59f6cf2c416354fdb951f">apply_filter</a> (Container &amp;container, Functor const  &amp;filter)</td></tr>
<tr class="memdesc:a4f175cc8f2c59f6cf2c416354fdb951f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a filter to the range [first, last] and return a pair of iterators for the filtered events.  <a href="#a4f175cc8f2c59f6cf2c416354fdb951f">More...</a><br /></td></tr>
<tr class="separator:a4f175cc8f2c59f6cf2c416354fdb951f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae96191cbaa62c58f63b7e58924362c24"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae96191cbaa62c58f63b7e58924362c24"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ae96191cbaa62c58f63b7e58924362c24">arg</a> (const <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;z)</td></tr>
<tr class="separator:ae96191cbaa62c58f63b7e58924362c24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a7e65b9bb4aca1f24356f2d43f91bda"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9a7e65b9bb4aca1f24356f2d43f91bda"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a9a7e65b9bb4aca1f24356f2d43f91bda">asin</a> (const <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;z)</td></tr>
<tr class="separator:a9a7e65b9bb4aca1f24356f2d43f91bda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd779382ac3242158686664a9a3ca3a0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abd779382ac3242158686664a9a3ca3a0"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#abd779382ac3242158686664a9a3ca3a0">asinh</a> (const <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;z)</td></tr>
<tr class="separator:abd779382ac3242158686664a9a3ca3a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9772b7e92ecdf60524cde428c1670bd4"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9772b7e92ecdf60524cde428c1670bd4"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a9772b7e92ecdf60524cde428c1670bd4">atan</a> (const <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;z)</td></tr>
<tr class="separator:a9772b7e92ecdf60524cde428c1670bd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24b7bc13880335fdf6964df5034ade29"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a24b7bc13880335fdf6964df5034ade29"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a24b7bc13880335fdf6964df5034ade29">atanh</a> (const <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;z)</td></tr>
<tr class="separator:a24b7bc13880335fdf6964df5034ade29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd995d684b15024c891571fe47518404"><td class="memTemplParams" colspan="2">template&lt;hydra::Wave L&gt; </td></tr>
<tr class="memitem:acd995d684b15024c891571fe47518404"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#acd995d684b15024c891571fe47518404">BarrierFactor</a> (const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> d, const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> p0, const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> p)</td></tr>
<tr class="memdesc:acd995d684b15024c891571fe47518404"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blatt-Weisskopf B' functions.  <a href="#acd995d684b15024c891571fe47518404">More...</a><br /></td></tr>
<tr class="separator:acd995d684b15024c891571fe47518404"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03f4e98f986e55037e1a01fe4d9b8fc8"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a03f4e98f986e55037e1a01fe4d9b8fc8"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a03f4e98f986e55037e1a01fe4d9b8fc8">BarrierFactor&lt; hydra::DWave &gt;</a> (const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> radi, const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> p0, const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> p)</td></tr>
<tr class="separator:a03f4e98f986e55037e1a01fe4d9b8fc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5a1e302e48427c947ab2084811df1df"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:ac5a1e302e48427c947ab2084811df1df"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ac5a1e302e48427c947ab2084811df1df">BarrierFactor&lt; hydra::FWave &gt;</a> (const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> radi, const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> p0, const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> p)</td></tr>
<tr class="separator:ac5a1e302e48427c947ab2084811df1df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0e0a9c294368d8d5b74fb919e261bef"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:ac0e0a9c294368d8d5b74fb919e261bef"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ac0e0a9c294368d8d5b74fb919e261bef">BarrierFactor&lt; hydra::GWave &gt;</a> (const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> radi, const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> p0, const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> p)</td></tr>
<tr class="separator:ac0e0a9c294368d8d5b74fb919e261bef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae223d417259cf7e660fd89a54438d45b"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:ae223d417259cf7e660fd89a54438d45b"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ae223d417259cf7e660fd89a54438d45b">BarrierFactor&lt; hydra::HWave &gt;</a> (const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> radi, const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> p0, const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> p)</td></tr>
<tr class="separator:ae223d417259cf7e660fd89a54438d45b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa78649879f76b3b52249830df2482980"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:aa78649879f76b3b52249830df2482980"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#aa78649879f76b3b52249830df2482980">BarrierFactor&lt; hydra::PWave &gt;</a> (const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> radi, const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> p0, const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> p)</td></tr>
<tr class="separator:aa78649879f76b3b52249830df2482980"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab59597f876fc220d388f5911bb9822c"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:aab59597f876fc220d388f5911bb9822c"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#aab59597f876fc220d388f5911bb9822c">BarrierFactor&lt; hydra::SWave &gt;</a> (const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>, const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>, const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>)</td></tr>
<tr class="separator:aab59597f876fc220d388f5911bb9822c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fabb476eec3a6c72fc8405f350946e1"><td class="memTemplParams" colspan="2">template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename T , size_t N&gt; </td></tr>
<tr class="memitem:a3fabb476eec3a6c72fc8405f350946e1"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a3fabb476eec3a6c72fc8405f350946e1">begin</a> (<a class="el" href="namespacehydra.html#classhydra_1_1multiarray">multiarray</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; const &amp;other) -&gt; decltype(other.begin(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;</td></tr>
<tr class="separator:a3fabb476eec3a6c72fc8405f350946e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8889ff1ca402595e22a39a1353161fcb"><td class="memTemplParams" colspan="2">template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename T , size_t N&gt; </td></tr>
<tr class="memitem:a8889ff1ca402595e22a39a1353161fcb"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a8889ff1ca402595e22a39a1353161fcb">begin</a> (<a class="el" href="namespacehydra.html#classhydra_1_1multiarray">multiarray</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; &amp;other) -&gt; decltype(other.begin(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;</td></tr>
<tr class="separator:a8889ff1ca402595e22a39a1353161fcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe8c272359dca5fb49f5a76d4cf93451"><td class="memTemplParams" colspan="2">template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename ... T&gt; </td></tr>
<tr class="memitem:afe8c272359dca5fb49f5a76d4cf93451"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#afe8c272359dca5fb49f5a76d4cf93451">begin</a> (<a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; const &amp;other) -&gt; decltype(other.begin(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;</td></tr>
<tr class="separator:afe8c272359dca5fb49f5a76d4cf93451"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f1cb0e2e3473d8e25b079dd72b8bc8a"><td class="memTemplParams" colspan="2">template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename ... T&gt; </td></tr>
<tr class="memitem:a4f1cb0e2e3473d8e25b079dd72b8bc8a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a4f1cb0e2e3473d8e25b079dd72b8bc8a">begin</a> (<a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; &amp;other) -&gt; decltype(other.begin(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;</td></tr>
<tr class="separator:a4f1cb0e2e3473d8e25b079dd72b8bc8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39ca77c714b3e8b913c37d323cfd5640"><td class="memItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ <a class="el" href="group__phsp.html#classhydra_1_1Vector4R">Vector4R</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a39ca77c714b3e8b913c37d323cfd5640">boostTo</a> (const <a class="el" href="group__phsp.html#classhydra_1_1Vector4R">Vector4R</a> &amp;rs, const <a class="el" href="group__phsp.html#classhydra_1_1Vector4R">Vector4R</a> &amp;p4, <a class="el" href="namespace_3globalScope_4.html#classbool">bool</a> inverse=false)</td></tr>
<tr class="separator:a39ca77c714b3e8b913c37d323cfd5640"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c1de9e4fabdb747b9e3352ef6298476"><td class="memItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ <a class="el" href="group__phsp.html#classhydra_1_1Vector4R">Vector4R</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a1c1de9e4fabdb747b9e3352ef6298476">boostTo</a> (const <a class="el" href="group__phsp.html#classhydra_1_1Vector4R">Vector4R</a> &amp;rs, const <a class="el" href="group__phsp.html#classhydra_1_1Vector3R">Vector3R</a> &amp;boost, <a class="el" href="namespace_3globalScope_4.html#classbool">bool</a> inverse=false)</td></tr>
<tr class="separator:a1c1de9e4fabdb747b9e3352ef6298476"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63f3e9bfd1cc2dc4e593ef68f76ba3c6"><td class="memTemplParams" colspan="2">template&lt;typename T0 , typename T1 , typename ... Ts, typename  = typename std::enable_if&lt;T0::is_functor::value &amp;&amp; T1::is_functor::value &amp;&amp; detail::all_true&lt;Ts::is_functor::value...&gt;::value &gt;::type&gt; </td></tr>
<tr class="memitem:a63f3e9bfd1cc2dc4e593ef68f76ba3c6"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ <a class="el" href="classhydra_1_1Compose.html">Compose</a>&lt; T0, T1, Ts... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a63f3e9bfd1cc2dc4e593ef68f76ba3c6">compose</a> (T0 const &amp;F0, T1 const &amp;F1, Ts const &amp;...Fs)</td></tr>
<tr class="separator:a63f3e9bfd1cc2dc4e593ef68f76ba3c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2ffe3ace108474a31b8cb84ceae7f14"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad2ffe3ace108474a31b8cb84ceae7f14"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ad2ffe3ace108474a31b8cb84ceae7f14">conj</a> (const <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;z)</td></tr>
<tr class="separator:ad2ffe3ace108474a31b8cb84ceae7f14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28aa8ffeea73bf98ccab0fb7cd1c8116"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename OutputIterator &gt; </td></tr>
<tr class="memitem:a28aa8ffeea73bf98ccab0fb7cd1c8116"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a28aa8ffeea73bf98ccab0fb7cd1c8116">copy</a> (InputIterator first, InputIterator last, OutputIterator result)</td></tr>
<tr class="separator:a28aa8ffeea73bf98ccab0fb7cd1c8116"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98b97d9c4a1b0350ef7c2d646c8c504a"><td class="memTemplParams" colspan="2">template&lt;detail::Backend Backend, typename InputIterator , typename OutputIterator &gt; </td></tr>
<tr class="memitem:a98b97d9c4a1b0350ef7c2d646c8c504a"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a98b97d9c4a1b0350ef7c2d646c8c504a">copy</a> (<a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; Backend &gt; const &amp;policy, InputIterator first, InputIterator last, OutputIterator result)</td></tr>
<tr class="separator:a98b97d9c4a1b0350ef7c2d646c8c504a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82497912f037617b630d048bfcc515c0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a82497912f037617b630d048bfcc515c0"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a82497912f037617b630d048bfcc515c0">cos</a> (const <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;z)</td></tr>
<tr class="separator:a82497912f037617b630d048bfcc515c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9aa7456a15f61cd1ed2b5ef7227409e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac9aa7456a15f61cd1ed2b5ef7227409e"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ac9aa7456a15f61cd1ed2b5ef7227409e">cosh</a> (const <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;z)</td></tr>
<tr class="separator:ac9aa7456a15f61cd1ed2b5ef7227409e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d55d71b4eca1da2fac83a615ea4b990"><td class="memItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ <a class="el" href="group__phsp.html#classhydra_1_1Vector3R">Vector3R</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a6d55d71b4eca1da2fac83a615ea4b990">cross</a> (const <a class="el" href="group__phsp.html#classhydra_1_1Vector3R">Vector3R</a> &amp;p1, const <a class="el" href="group__phsp.html#classhydra_1_1Vector3R">Vector3R</a> &amp;p2)</td></tr>
<tr class="separator:a6d55d71b4eca1da2fac83a615ea4b990"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31ec2838ed0b3d9f3e77d8b51f270c81"><td class="memTemplParams" colspan="2">template&lt;typename Iterator &gt; </td></tr>
<tr class="memitem:a31ec2838ed0b3d9f3e77d8b51f270c81"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a31ec2838ed0b3d9f3e77d8b51f270c81">distance</a> (Iterator first, Iterator last) -&gt; decltype(HYDRA_EXTERNAL_NS::thrust::distance&lt; Iterator &gt;(first, last))</td></tr>
<tr class="separator:a31ec2838ed0b3d9f3e77d8b51f270c81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd869e5bd355b1c4646e2c5e1f4ed332"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename  = typename std::enable_if&lt; T1::is_functor::value &amp;&amp; T2::is_functor::value&gt;::type&gt; </td></tr>
<tr class="memitem:afd869e5bd355b1c4646e2c5e1f4ed332"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ <a class="el" href="classhydra_1_1Divide.html">Divide</a>&lt; T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#afd869e5bd355b1c4646e2c5e1f4ed332">divide</a> (T1 const &amp;F1, T1 const &amp;F2)</td></tr>
<tr class="separator:afd869e5bd355b1c4646e2c5e1f4ed332"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbb0cd4e50b5ece72164e5a2bb6921ac"><td class="memTemplParams" colspan="2">template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename T , size_t N&gt; </td></tr>
<tr class="memitem:abbb0cd4e50b5ece72164e5a2bb6921ac"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#abbb0cd4e50b5ece72164e5a2bb6921ac">end</a> (<a class="el" href="namespacehydra.html#classhydra_1_1multiarray">multiarray</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; const &amp;other) -&gt; decltype(other.end(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;</td></tr>
<tr class="separator:abbb0cd4e50b5ece72164e5a2bb6921ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6394ef91cb6d9eb87c9a8f1a34fd3186"><td class="memTemplParams" colspan="2">template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename T , size_t N&gt; </td></tr>
<tr class="memitem:a6394ef91cb6d9eb87c9a8f1a34fd3186"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a6394ef91cb6d9eb87c9a8f1a34fd3186">end</a> (<a class="el" href="namespacehydra.html#classhydra_1_1multiarray">multiarray</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; &amp;other) -&gt; decltype(other.end(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;</td></tr>
<tr class="separator:a6394ef91cb6d9eb87c9a8f1a34fd3186"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f434b6fb7d95b6ca2a386e25e6b6733"><td class="memTemplParams" colspan="2">template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename ... T&gt; </td></tr>
<tr class="memitem:a5f434b6fb7d95b6ca2a386e25e6b6733"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a5f434b6fb7d95b6ca2a386e25e6b6733">end</a> (<a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; const &amp;other) -&gt; decltype(other.end(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;</td></tr>
<tr class="separator:a5f434b6fb7d95b6ca2a386e25e6b6733"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4f44ac4277e27b370317451862a091d"><td class="memTemplParams" colspan="2">template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename ... T&gt; </td></tr>
<tr class="memitem:ae4f44ac4277e27b370317451862a091d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ae4f44ac4277e27b370317451862a091d">end</a> (<a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; &amp;other) -&gt; decltype(other.end(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;</td></tr>
<tr class="separator:ae4f44ac4277e27b370317451862a091d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadea4fcd2b0a13095c4408fbee01c2c72"><td class="memTemplParams" colspan="2">template&lt;hydra::detail::Backend BACKEND, typename Iterator , typename Functor &gt; </td></tr>
<tr class="memitem:gadea4fcd2b0a13095c4408fbee01c2c72"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__generic.html#gadea4fcd2b0a13095c4408fbee01c2c72">eval</a> (<a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt;, Functor const  &amp;functor, Iterator <a class="el" href="namespacehydra.html#a3fabb476eec3a6c72fc8405f350946e1">begin</a>, Iterator <a class="el" href="namespacehydra.html#abbb0cd4e50b5ece72164e5a2bb6921ac">end</a>) -&gt; typename <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt;::template container&lt; typename Functor::return_type &gt;</td></tr>
<tr class="memdesc:gadea4fcd2b0a13095c4408fbee01c2c72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate a hydra functor on a range using the parallel policy.  <a href="group__generic.html#gadea4fcd2b0a13095c4408fbee01c2c72">More...</a><br /></td></tr>
<tr class="separator:gadea4fcd2b0a13095c4408fbee01c2c72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3d2db3d23126c08839d5304f84401a2"><td class="memTemplParams" colspan="2">template&lt;hydra::detail::Backend BACKEND, typename Iterator , typename ... Functors&gt; </td></tr>
<tr class="memitem:gaf3d2db3d23126c08839d5304f84401a2"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__generic.html#gaf3d2db3d23126c08839d5304f84401a2">eval</a> (<a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt;,HYDRA_EXTERNAL_NS::thrust::tuple&lt; Functors... &gt; const  &amp;functors, Iterator <a class="el" href="namespacehydra.html#a3fabb476eec3a6c72fc8405f350946e1">begin</a>, Iterator <a class="el" href="namespacehydra.html#abbb0cd4e50b5ece72164e5a2bb6921ac">end</a>) -&gt; <a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; typename Functors::return_type ... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt;&gt;</td></tr>
<tr class="memdesc:gaf3d2db3d23126c08839d5304f84401a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate a tuple of hydra functors on a range using the parallel policy.  <a href="group__generic.html#gaf3d2db3d23126c08839d5304f84401a2">More...</a><br /></td></tr>
<tr class="separator:gaf3d2db3d23126c08839d5304f84401a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8564abe3d04aa014ba0a6a40e6c5d599"><td class="memTemplParams" colspan="2">template&lt;hydra::detail::Backend BACKEND, typename Functor , typename Iterator , typename ... Iterators&gt; </td></tr>
<tr class="memitem:ga8564abe3d04aa014ba0a6a40e6c5d599"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__generic.html#ga8564abe3d04aa014ba0a6a40e6c5d599">eval</a> (<a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt;, Functor const  &amp;functor, Iterator <a class="el" href="namespacehydra.html#a3fabb476eec3a6c72fc8405f350946e1">begin</a>, Iterator <a class="el" href="namespacehydra.html#abbb0cd4e50b5ece72164e5a2bb6921ac">end</a>, Iterators... begins) -&gt; typename <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt;::template container&lt; typename Functor::return_type &gt;</td></tr>
<tr class="memdesc:ga8564abe3d04aa014ba0a6a40e6c5d599"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate a functor over a list of ranges.  <a href="group__generic.html#ga8564abe3d04aa014ba0a6a40e6c5d599">More...</a><br /></td></tr>
<tr class="separator:ga8564abe3d04aa014ba0a6a40e6c5d599"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b93fd9a039de79768e3c72de1db6842"><td class="memTemplParams" colspan="2">template&lt;hydra::detail::Backend BACKEND, typename Iterator , typename ... Iterators, typename ... Functors&gt; </td></tr>
<tr class="memitem:ga3b93fd9a039de79768e3c72de1db6842"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__generic.html#ga3b93fd9a039de79768e3c72de1db6842">eval</a> (<a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt;, HYDRA_EXTERNAL_NS::thrust::tuple&lt; Functors... &gt; const  &amp;functors, Iterator <a class="el" href="namespacehydra.html#a3fabb476eec3a6c72fc8405f350946e1">begin</a>, Iterator <a class="el" href="namespacehydra.html#abbb0cd4e50b5ece72164e5a2bb6921ac">end</a>, Iterators... begins) -&gt; <a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; typename Functors::return_type ... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;</td></tr>
<tr class="memdesc:ga3b93fd9a039de79768e3c72de1db6842"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate a tuple of functors over a list of ranges.  <a href="group__generic.html#ga3b93fd9a039de79768e3c72de1db6842">More...</a><br /></td></tr>
<tr class="separator:ga3b93fd9a039de79768e3c72de1db6842"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5acb87c4eb594ddbf0c4322a11cf4d8a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5acb87c4eb594ddbf0c4322a11cf4d8a"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a5acb87c4eb594ddbf0c4322a11cf4d8a">exp</a> (const <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;z)</td></tr>
<tr class="separator:a5acb87c4eb594ddbf0c4322a11cf4d8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a878a4b407da6caf1173b3939f3943d33"><td class="memTemplParams" colspan="2">template&lt;int N, typename ... T&gt; </td></tr>
<tr class="memitem:a878a4b407da6caf1173b3939f3943d33"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::tuple_element&lt; N, HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a878a4b407da6caf1173b3939f3943d33">get</a> (HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt; const &amp;t)</td></tr>
<tr class="memdesc:a878a4b407da6caf1173b3939f3943d33"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <code>get</code> function returns a reference to a <code>tuple</code> element of interest.  <a href="#a878a4b407da6caf1173b3939f3943d33">More...</a><br /></td></tr>
<tr class="separator:a878a4b407da6caf1173b3939f3943d33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c5d06da4c888dd9915f5b9b68ff324d"><td class="memTemplParams" colspan="2">template&lt;int N, typename ... T&gt; </td></tr>
<tr class="memitem:a7c5d06da4c888dd9915f5b9b68ff324d"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::tuple_element&lt; N, HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a7c5d06da4c888dd9915f5b9b68ff324d">get</a> (HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt; &amp;t)</td></tr>
<tr class="separator:a7c5d06da4c888dd9915f5b9b68ff324d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b44fb8fa5030736b4603699cf172253"><td class="memTemplParams" colspan="2">template&lt;int N, typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a7b44fb8fa5030736b4603699cf172253"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::tuple_element&lt; N, HYDRA_EXTERNAL_NS::thrust::pair&lt; T1, T2 &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a7b44fb8fa5030736b4603699cf172253">get</a> (HYDRA_EXTERNAL_NS::thrust::pair&lt; T1, T2 &gt; &amp;&amp;t)</td></tr>
<tr class="separator:a7b44fb8fa5030736b4603699cf172253"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24a594d0fa4c37b4550bb26317d33a42"><td class="memTemplParams" colspan="2">template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename T , size_t N&gt; </td></tr>
<tr class="memitem:a24a594d0fa4c37b4550bb26317d33a42"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a24a594d0fa4c37b4550bb26317d33a42">get</a> (<a class="el" href="namespacehydra.html#classhydra_1_1multiarray">multiarray</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; const &amp;other) -&gt; decltype(other.column(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;</td></tr>
<tr class="separator:a24a594d0fa4c37b4550bb26317d33a42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bd95a2e510a972665cc8e93abb7ad00"><td class="memTemplParams" colspan="2">template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename ... T&gt; </td></tr>
<tr class="memitem:a9bd95a2e510a972665cc8e93abb7ad00"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a9bd95a2e510a972665cc8e93abb7ad00">get</a> (<a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; const &amp;other) -&gt; decltype(other.column(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;</td></tr>
<tr class="separator:a9bd95a2e510a972665cc8e93abb7ad00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7582acf570b53c033d52c6ff0fecb43e"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a7582acf570b53c033d52c6ff0fecb43e"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a7582acf570b53c033d52c6ff0fecb43e">GetFormatedString</a> (const char *format, Args... args)</td></tr>
<tr class="separator:a7582acf570b53c033d52c6ff0fecb43e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a482394205426de2c1a57e3284cf60699"><td class="memTemplParams" colspan="2">template&lt;unsigned int L&gt; </td></tr>
<tr class="memitem:a482394205426de2c1a57e3284cf60699"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a482394205426de2c1a57e3284cf60699">legendre_polynomial</a> (const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> x)</td></tr>
<tr class="separator:a482394205426de2c1a57e3284cf60699"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94a09f96f01c93f8bbdddf5e4e221646"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a94a09f96f01c93f8bbdddf5e4e221646"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a94a09f96f01c93f8bbdddf5e4e221646">legendre_polynomial&lt; 0 &gt;</a> (const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>)</td></tr>
<tr class="separator:a94a09f96f01c93f8bbdddf5e4e221646"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f1343d6c785bde83e28804a5918ac20"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a6f1343d6c785bde83e28804a5918ac20"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a6f1343d6c785bde83e28804a5918ac20">legendre_polynomial&lt; 1 &gt;</a> (const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> x)</td></tr>
<tr class="separator:a6f1343d6c785bde83e28804a5918ac20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3af5e82c0ccbbf64729ecdf4dc3c3993"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a3af5e82c0ccbbf64729ecdf4dc3c3993"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a3af5e82c0ccbbf64729ecdf4dc3c3993">legendre_polynomial&lt; 2 &gt;</a> (const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> x)</td></tr>
<tr class="separator:a3af5e82c0ccbbf64729ecdf4dc3c3993"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab07923df7072e55120be2d5714f256a9"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:ab07923df7072e55120be2d5714f256a9"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ab07923df7072e55120be2d5714f256a9">legendre_polynomial&lt; 3 &gt;</a> (const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> x)</td></tr>
<tr class="separator:ab07923df7072e55120be2d5714f256a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9a14ff57f3a87cc8ea061105fddf100"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:ae9a14ff57f3a87cc8ea061105fddf100"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ae9a14ff57f3a87cc8ea061105fddf100">legendre_polynomial&lt; 4 &gt;</a> (const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> x)</td></tr>
<tr class="separator:ae9a14ff57f3a87cc8ea061105fddf100"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9913f02c30c0fd3d7664c104257f5ee9"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a9913f02c30c0fd3d7664c104257f5ee9"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a9913f02c30c0fd3d7664c104257f5ee9">legendre_polynomial&lt; 5 &gt;</a> (const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> x)</td></tr>
<tr class="separator:a9913f02c30c0fd3d7664c104257f5ee9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2725e178af11595cbeba053c1f84dfa8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2725e178af11595cbeba053c1f84dfa8"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a2725e178af11595cbeba053c1f84dfa8">log</a> (const <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;z)</td></tr>
<tr class="separator:a2725e178af11595cbeba053c1f84dfa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64d53a33e43032b9e482284fd1a38b08"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a64d53a33e43032b9e482284fd1a38b08"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a64d53a33e43032b9e482284fd1a38b08">log10</a> (const <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;z)</td></tr>
<tr class="separator:a64d53a33e43032b9e482284fd1a38b08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9c36400392fc1613db3bcabd7c74575"><td class="memTemplParams" colspan="2">template&lt;size_t ... N, hydra::detail::Backend BACKEND&gt; </td></tr>
<tr class="memitem:ac9c36400392fc1613db3bcabd7c74575"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__phsp.html#classhydra_1_1Chains">Chains</a>&lt; <a class="el" href="group__phsp.html#classhydra_1_1Decays">Decays</a>&lt; N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ac9c36400392fc1613db3bcabd7c74575">make_chain</a> (<a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt;, size_t entries)</td></tr>
<tr class="separator:ac9c36400392fc1613db3bcabd7c74575"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga71ecdc6e5a05bddea819b4affc65a8fa"><td class="memTemplParams" colspan="2">template&lt;typename Iterator , typename T , size_t N, hydra::detail::Backend BACKEND&gt; </td></tr>
<tr class="memitem:ga71ecdc6e5a05bddea819b4affc65a8fa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__histogram.html#classhydra_1_1DenseHistogram">DenseHistogram</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1multidimensional">detail::multidimensional</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__histogram.html#ga71ecdc6e5a05bddea819b4affc65a8fa">make_dense_histogram</a> (<a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt; backend, std::array&lt; size_t, N &gt; grid, std::array&lt; T, N &gt; const &amp;lowerlimits, std::array&lt; T, N &gt; const &amp;upperlimits, Iterator first, Iterator <a class="el" href="namespacehydra.html#abbb0cd4e50b5ece72164e5a2bb6921ac">end</a>)</td></tr>
<tr class="memdesc:ga71ecdc6e5a05bddea819b4affc65a8fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to make a N-dimensional dense histogram.  <a href="group__histogram.html#ga71ecdc6e5a05bddea819b4affc65a8fa">More...</a><br /></td></tr>
<tr class="separator:ga71ecdc6e5a05bddea819b4affc65a8fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac9110cb1abf49fb7f3fcaa31f24d3e84"><td class="memTemplParams" colspan="2">template&lt;typename Iterator , typename T , hydra::detail::Backend BACKEND&gt; </td></tr>
<tr class="memitem:gac9110cb1abf49fb7f3fcaa31f24d3e84"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__histogram.html#classhydra_1_1DenseHistogram">DenseHistogram</a>&lt; T, 1, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1multidimensional">detail::multidimensional</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__histogram.html#gac9110cb1abf49fb7f3fcaa31f24d3e84">make_dense_histogram</a> (<a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt; backend, size_t grid, T lowerlimits, T upperlimits, Iterator first, Iterator <a class="el" href="namespacehydra.html#abbb0cd4e50b5ece72164e5a2bb6921ac">end</a>)</td></tr>
<tr class="memdesc:gac9110cb1abf49fb7f3fcaa31f24d3e84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to make a N-dimensional dense histogram.  <a href="group__histogram.html#gac9110cb1abf49fb7f3fcaa31f24d3e84">More...</a><br /></td></tr>
<tr class="separator:gac9110cb1abf49fb7f3fcaa31f24d3e84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ec47177241d6057ab5d2e4ad5fc84a6"><td class="memTemplParams" colspan="2">template&lt;typename Functor , typename Integrator , typename Iterator , typename ... Iterators&gt; </td></tr>
<tr class="memitem:ga6ec47177241d6057ab5d2e4ad5fc84a6"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__fit.html#ga6ec47177241d6057ab5d2e4ad5fc84a6">make_loglikehood_fcn</a> (<a class="el" href="group__fit.html#classhydra_1_1Pdf">Pdf</a>&lt; Functor, <a class="el" href="structhydra_1_1Integrator.html">Integrator</a> &gt; const &amp;pdf, Iterator first, Iterator last, Iterators... weights) -&gt; <a class="el" href="namespacehydra.html#classhydra_1_1LogLikelihoodFCN">LogLikelihoodFCN</a>&lt; <a class="el" href="group__fit.html#classhydra_1_1Pdf">Pdf</a>&lt; Functor, <a class="el" href="structhydra_1_1Integrator.html">Integrator</a> &gt;, Iterator, Iterators... &gt;</td></tr>
<tr class="memdesc:ga6ec47177241d6057ab5d2e4ad5fc84a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conveniency function to build up loglikehood fcns.  <a href="group__fit.html#ga6ec47177241d6057ab5d2e4ad5fc84a6">More...</a><br /></td></tr>
<tr class="separator:ga6ec47177241d6057ab5d2e4ad5fc84a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89f620a60b4ae802f5dc2e219e7e8dbd"><td class="memTemplParams" colspan="2">template&lt;typename... Pdfs, typename Iterator , typename ... Iterators&gt; </td></tr>
<tr class="memitem:ga89f620a60b4ae802f5dc2e219e7e8dbd"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__fit.html#ga89f620a60b4ae802f5dc2e219e7e8dbd">make_loglikehood_fcn</a> (<a class="el" href="group__fit.html#classhydra_1_1PDFSumNonExtendable">PDFSumNonExtendable</a>&lt; Pdfs... &gt;const &amp;pdf, Iterator first, Iterator last, Iterators... weights) -&gt; <a class="el" href="namespacehydra.html#classhydra_1_1LogLikelihoodFCN">LogLikelihoodFCN</a>&lt; <a class="el" href="group__fit.html#classhydra_1_1PDFSumNonExtendable">PDFSumNonExtendable</a>&lt; Pdfs... &gt;, Iterator, Iterators... &gt;</td></tr>
<tr class="memdesc:ga89f620a60b4ae802f5dc2e219e7e8dbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conveniency function to build up loglikehood fcns.  <a href="group__fit.html#ga89f620a60b4ae802f5dc2e219e7e8dbd">More...</a><br /></td></tr>
<tr class="separator:ga89f620a60b4ae802f5dc2e219e7e8dbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaedfd3c104a7e4ee0ec981db5b9d1ab85"><td class="memTemplParams" colspan="2">template&lt;typename... Pdfs, typename Iterator , typename ... Iterators&gt; </td></tr>
<tr class="memitem:gaedfd3c104a7e4ee0ec981db5b9d1ab85"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__fit.html#gaedfd3c104a7e4ee0ec981db5b9d1ab85">make_loglikehood_fcn</a> (<a class="el" href="group__fit.html#classhydra_1_1PDFSumExtendable">PDFSumExtendable</a>&lt; Pdfs... &gt; const &amp;functor, Iterator first, Iterator last, Iterators... weights) -&gt; <a class="el" href="namespacehydra.html#classhydra_1_1LogLikelihoodFCN">LogLikelihoodFCN</a>&lt; <a class="el" href="group__fit.html#classhydra_1_1PDFSumExtendable">PDFSumExtendable</a>&lt; Pdfs... &gt;, Iterator, Iterators... &gt;</td></tr>
<tr class="memdesc:gaedfd3c104a7e4ee0ec981db5b9d1ab85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conveniency function to build up loglikehood fcns.  <a href="group__fit.html#gaedfd3c104a7e4ee0ec981db5b9d1ab85">More...</a><br /></td></tr>
<tr class="separator:gaedfd3c104a7e4ee0ec981db5b9d1ab85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8b9fd25a44634ab41c7c102a97e42cb"><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 &gt; </td></tr>
<tr class="memitem:ab8b9fd25a44634ab41c7c102a97e42cb"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ab8b9fd25a44634ab41c7c102a97e42cb">make_pair</a> (T1 &amp;&amp;t1, T2 &amp;&amp;t2) -&gt; decltype(HYDRA_EXTERNAL_NS::thrust::make_pair(std::forward&lt; T1 &gt;(t1), std::forward&lt; T2 &gt;(t2)))</td></tr>
<tr class="memdesc:ab8b9fd25a44634ab41c7c102a97e42cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This version of <code>make_pair</code> creates a new <code>pair</code> object from a list of objects.  <a href="#ab8b9fd25a44634ab41c7c102a97e42cb">More...</a><br /></td></tr>
<tr class="separator:ab8b9fd25a44634ab41c7c102a97e42cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d468a0d98a74f41479f8ccb95f5533e"><td class="memTemplParams" colspan="2">template&lt;typename FUNCTOR , typename INTEGRATOR &gt; </td></tr>
<tr class="memitem:ga2d468a0d98a74f41479f8ccb95f5533e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__fit.html#classhydra_1_1Pdf">Pdf</a>&lt; FUNCTOR, INTEGRATOR &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__fit.html#ga2d468a0d98a74f41479f8ccb95f5533e">make_pdf</a> (FUNCTOR const &amp;functor, INTEGRATOR integrator)</td></tr>
<tr class="memdesc:ga2d468a0d98a74f41479f8ccb95f5533e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a <a class="el" href="group__fit.html#classhydra_1_1Pdf" title="Class representing probability density functions. ">hydra::Pdf</a> given a shape described by a functor and a integrator (algorithm or functor).  <a href="group__fit.html#ga2d468a0d98a74f41479f8ccb95f5533e">More...</a><br /></td></tr>
<tr class="separator:ga2d468a0d98a74f41479f8ccb95f5533e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d210727c4d8b6989542eff5fd3f6319"><td class="memTemplParams" colspan="2">template&lt;typename Iterator &gt; </td></tr>
<tr class="memitem:a8d210727c4d8b6989542eff5fd3f6319"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacehydra.html#classhydra_1_1GenericRange">GenericRange</a>&lt; Iterator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a8d210727c4d8b6989542eff5fd3f6319">make_range</a> (Iterator <a class="el" href="namespacehydra.html#a3fabb476eec3a6c72fc8405f350946e1">begin</a>, Iterator <a class="el" href="namespacehydra.html#abbb0cd4e50b5ece72164e5a2bb6921ac">end</a>)</td></tr>
<tr class="separator:a8d210727c4d8b6989542eff5fd3f6319"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a30c855dde97a05b730cebc6682758b"><td class="memTemplParams" colspan="2">template&lt;typename Iterator , typename Functor &gt; </td></tr>
<tr class="memitem:a1a30c855dde97a05b730cebc6682758b"><td class="memTemplItemLeft" align="right" valign="top">HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt; Functor &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1GenericRange">GenericRange</a>&lt; Iterator, Functor &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a1a30c855dde97a05b730cebc6682758b">make_range</a> (Iterator <a class="el" href="namespacehydra.html#a3fabb476eec3a6c72fc8405f350946e1">begin</a>, Iterator <a class="el" href="namespacehydra.html#abbb0cd4e50b5ece72164e5a2bb6921ac">end</a>, Functor const &amp;functor)</td></tr>
<tr class="separator:a1a30c855dde97a05b730cebc6682758b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2cea405a4f933f25af1f2afe7e67c381"><td class="memTemplParams" colspan="2">template&lt;typename Iterator , typename T , size_t N, hydra::detail::Backend BACKEND&gt; </td></tr>
<tr class="memitem:ga2cea405a4f933f25af1f2afe7e67c381"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__histogram.html#classhydra_1_1SparseHistogram">SparseHistogram</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1multidimensional">detail::multidimensional</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__histogram.html#ga2cea405a4f933f25af1f2afe7e67c381">make_sparse_histogram</a> (<a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt; backend, std::array&lt; size_t, N &gt; grid, std::array&lt; T, N &gt; const  &amp;lowerlimits, std::array&lt; T, N &gt; const  &amp;upperlimits, Iterator first, Iterator <a class="el" href="namespacehydra.html#abbb0cd4e50b5ece72164e5a2bb6921ac">end</a>)</td></tr>
<tr class="memdesc:ga2cea405a4f933f25af1f2afe7e67c381"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to make a N-dimensional sparse histogram.  <a href="group__histogram.html#ga2cea405a4f933f25af1f2afe7e67c381">More...</a><br /></td></tr>
<tr class="separator:ga2cea405a4f933f25af1f2afe7e67c381"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a1d65c69312c606d2379539278aa702"><td class="memTemplParams" colspan="2">template&lt;typename Iterator , typename T , hydra::detail::Backend BACKEND&gt; </td></tr>
<tr class="memitem:ga9a1d65c69312c606d2379539278aa702"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__histogram.html#classhydra_1_1SparseHistogram">SparseHistogram</a>&lt; T, 1, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1multidimensional">detail::multidimensional</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__histogram.html#ga9a1d65c69312c606d2379539278aa702">make_sparse_histogram</a> (<a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt; backend, size_t grid, T lowerlimits, T upperlimits, Iterator first, Iterator <a class="el" href="namespacehydra.html#abbb0cd4e50b5ece72164e5a2bb6921ac">end</a>)</td></tr>
<tr class="memdesc:ga9a1d65c69312c606d2379539278aa702"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to make a N-dimensional sparse histogram.  <a href="group__histogram.html#ga9a1d65c69312c606d2379539278aa702">More...</a><br /></td></tr>
<tr class="separator:ga9a1d65c69312c606d2379539278aa702"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5314ace45b4baa7084a9addb625ca99"><td class="memTemplParams" colspan="2">template&lt;typename PDF1 , typename PDF2 , typename ... PDFs&gt; </td></tr>
<tr class="memitem:af5314ace45b4baa7084a9addb625ca99"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classhydra_1_1SPlot.html">SPlot</a>&lt; PDF1, PDF2, PDFs... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#af5314ace45b4baa7084a9addb625ca99">make_splot</a> (<a class="el" href="group__fit.html#classhydra_1_1PDFSumExtendable">PDFSumExtendable</a>&lt; PDF1, PDF2, PDFs... &gt; const &amp;pdf)</td></tr>
<tr class="separator:af5314ace45b4baa7084a9addb625ca99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac70a2baeff9ebf89f64ebd08ebaab2d7"><td class="memTemplParams" colspan="2">template&lt;class ... T&gt; </td></tr>
<tr class="memitem:ac70a2baeff9ebf89f64ebd08ebaab2d7"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ac70a2baeff9ebf89f64ebd08ebaab2d7">make_tuple</a> (T const &amp;... t) -&gt; decltype(HYDRA_EXTERNAL_NS::thrust::make_tuple(t...))</td></tr>
<tr class="memdesc:ac70a2baeff9ebf89f64ebd08ebaab2d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This version of <code>make_tuple</code> creates a new <code>tuple</code> object from a list of objects.  <a href="#ac70a2baeff9ebf89f64ebd08ebaab2d7">More...</a><br /></td></tr>
<tr class="separator:ac70a2baeff9ebf89f64ebd08ebaab2d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16ca94258b9800a2b2fe700f7012f545"><td class="memTemplParams" colspan="2">template&lt;class ... T&gt; </td></tr>
<tr class="memitem:a16ca94258b9800a2b2fe700f7012f545"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a16ca94258b9800a2b2fe700f7012f545">make_tuple</a> (T &amp;&amp;... t) -&gt; decltype(HYDRA_EXTERNAL_NS::thrust::make_tuple(std::forward&lt; T &gt;(t)...))</td></tr>
<tr class="memdesc:a16ca94258b9800a2b2fe700f7012f545"><td class="mdescLeft">&#160;</td><td class="mdescRight">This version of <code>make_tuple</code> creates a new <code>tuple</code> object from a list of objects.  <a href="#a16ca94258b9800a2b2fe700f7012f545">More...</a><br /></td></tr>
<tr class="separator:a16ca94258b9800a2b2fe700f7012f545"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdb8665ee28f5e766b614992c0491dd7"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename  = typename std::enable_if&lt; T1::is_functor::value &amp;&amp; T2::is_functor::value&gt;::type&gt; </td></tr>
<tr class="memitem:acdb8665ee28f5e766b614992c0491dd7"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ <a class="el" href="classhydra_1_1Minus.html">Minus</a>&lt; T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#acdb8665ee28f5e766b614992c0491dd7">minus</a> (T1 const &amp;F1, T1 const &amp;F2)</td></tr>
<tr class="separator:acdb8665ee28f5e766b614992c0491dd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a237ae37875016b34f82e3664703be679"><td class="memTemplParams" colspan="2">template&lt;typename F1 , typename F2 , typename ... Fs&gt; </td></tr>
<tr class="memitem:a237ae37875016b34f82e3664703be679"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ <a class="el" href="classhydra_1_1Multiply.html">Multiply</a>&lt; F1, F2, Fs... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a237ae37875016b34f82e3664703be679">multiply</a> (F1 const &amp;f1, F2 const &amp;f2, Fs const &amp;... functors)</td></tr>
<tr class="separator:a237ae37875016b34f82e3664703be679"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f06ee4cd16c4cd697a380053748bf67"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2f06ee4cd16c4cd697a380053748bf67"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ <a class="el" href="namespace_3globalScope_4.html#classint">int</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a2f06ee4cd16c4cd697a380053748bf67">nint</a> (const T x)</td></tr>
<tr class="memdesc:a2f06ee4cd16c4cd697a380053748bf67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Round to nearest integer.  <a href="#a2f06ee4cd16c4cd697a380053748bf67">More...</a><br /></td></tr>
<tr class="separator:a2f06ee4cd16c4cd697a380053748bf67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5fd2d8f62c3075ccdd36241e8dc6881"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab5fd2d8f62c3075ccdd36241e8dc6881"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ab5fd2d8f62c3075ccdd36241e8dc6881">norm</a> (const <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;z)</td></tr>
<tr class="separator:ab5fd2d8f62c3075ccdd36241e8dc6881"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24943c0d2419a40a68f0fb61e0a1b05f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a24943c0d2419a40a68f0fb61e0a1b05f"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ <a class="el" href="namespace_3globalScope_4.html#classbool">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a24943c0d2419a40a68f0fb61e0a1b05f">operator!=</a> (const <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;lhs, const <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="separator:a24943c0d2419a40a68f0fb61e0a1b05f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a716c80436ab96c757325cae3cd517960"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a716c80436ab96c757325cae3cd517960"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ <a class="el" href="namespace_3globalScope_4.html#classbool">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a716c80436ab96c757325cae3cd517960">operator!=</a> (const T &amp;lhs, const <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="separator:a716c80436ab96c757325cae3cd517960"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91d952f42e31697e4b457b1a58424cb5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a91d952f42e31697e4b457b1a58424cb5"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ <a class="el" href="namespace_3globalScope_4.html#classbool">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a91d952f42e31697e4b457b1a58424cb5">operator!=</a> (const <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;lhs, const T &amp;rhs)</td></tr>
<tr class="separator:a91d952f42e31697e4b457b1a58424cb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74f09f60eaa232f756f2e5ee0ccb5326"><td class="memTemplParams" colspan="2">template&lt;size_t N1, hydra::detail::Backend BACKEND1, size_t N2, hydra::detail::Backend BACKEND2&gt; </td></tr>
<tr class="memitem:a74f09f60eaa232f756f2e5ee0ccb5326"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespace_3globalScope_4.html#classbool">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a74f09f60eaa232f756f2e5ee0ccb5326">operator!=</a> (const <a class="el" href="group__phsp.html#classhydra_1_1Decays">Decays</a>&lt; N1, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND1 &gt; &gt; &amp;lhs, const <a class="el" href="group__phsp.html#classhydra_1_1Decays">Decays</a>&lt; N2, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND2 &gt; &gt; &amp;rhs)</td></tr>
<tr class="separator:a74f09f60eaa232f756f2e5ee0ccb5326"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa51499fa04d39681eb6244313d32a16c"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N, hydra::detail::Backend BACKEND1, hydra::detail::Backend BACKEND2&gt; </td></tr>
<tr class="memitem:aa51499fa04d39681eb6244313d32a16c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespace_3globalScope_4.html#classbool">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#aa51499fa04d39681eb6244313d32a16c">operator!=</a> (const <a class="el" href="namespacehydra.html#classhydra_1_1multiarray">multiarray</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND1 &gt;&gt; &amp;lhs, const <a class="el" href="namespacehydra.html#classhydra_1_1multiarray">multiarray</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND2 &gt;&gt; &amp;rhs)</td></tr>
<tr class="separator:aa51499fa04d39681eb6244313d32a16c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a258cacce52e3670d4880af1576a16a22"><td class="memTemplParams" colspan="2">template&lt;typename ... T, hydra::detail::Backend BACKEND1, hydra::detail::Backend BACKEND2&gt; </td></tr>
<tr class="memitem:a258cacce52e3670d4880af1576a16a22"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespace_3globalScope_4.html#classbool">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a258cacce52e3670d4880af1576a16a22">operator!=</a> (const <a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND1 &gt;&gt; &amp;lhs, const <a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND2 &gt;&gt; &amp;rhs)</td></tr>
<tr class="separator:a258cacce52e3670d4880af1576a16a22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad01febd59c4dfebc87b5d363955d65db"><td class="memItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ <a class="el" href="group__phsp.html#classhydra_1_1Vector3R">Vector3R</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ad01febd59c4dfebc87b5d363955d65db">operator*</a> (<a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> c, const <a class="el" href="group__phsp.html#classhydra_1_1Vector3R">Vector3R</a> &amp;v2)</td></tr>
<tr class="separator:ad01febd59c4dfebc87b5d363955d65db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa868eaf400c854297996c269f401e69e"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename  = typename std::enable_if&lt; T1::is_functor::value &amp;&amp; T2::is_functor::value&gt;::type&gt; </td></tr>
<tr class="memitem:aa868eaf400c854297996c269f401e69e"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ <a class="el" href="classhydra_1_1Multiply.html">Multiply</a>&lt; T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#aa868eaf400c854297996c269f401e69e">operator*</a> (T1 const &amp;F1, T2 const &amp;F2)</td></tr>
<tr class="separator:aa868eaf400c854297996c269f401e69e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dce6130507b07eaac142c1815ade3f2"><td class="memItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ <a class="el" href="group__phsp.html#classhydra_1_1Vector3R">Vector3R</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a0dce6130507b07eaac142c1815ade3f2">operator*</a> (const <a class="el" href="group__phsp.html#classhydra_1_1Vector3R">Vector3R</a> &amp;v1, <a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> c)</td></tr>
<tr class="separator:a0dce6130507b07eaac142c1815ade3f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2021f911a26d3c79b62d1a2f1fa9dcf0"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename  = typename std::enable_if&lt; (std::is_convertible&lt;T1, double&gt;::value ||		std::is_constructible&lt;HYDRA_EXTERNAL_NS::thrust::complex&lt;double&gt;,T1&gt;::value) &amp;&amp; T2::is_functor::value&gt;::type&gt; </td></tr>
<tr class="memitem:a2021f911a26d3c79b62d1a2f1fa9dcf0"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ <a class="el" href="classhydra_1_1Multiply.html">Multiply</a>&lt; <a class="el" href="structhydra_1_1Constant.html">Constant</a>&lt; T1 &gt;, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a2021f911a26d3c79b62d1a2f1fa9dcf0">operator*</a> (T1 const cte, T2 const &amp;F2)</td></tr>
<tr class="separator:a2021f911a26d3c79b62d1a2f1fa9dcf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd42c2a636a5bfb4e605ddd9f1ea069a"><td class="memItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ <a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#afd42c2a636a5bfb4e605ddd9f1ea069a">operator*</a> (const <a class="el" href="group__phsp.html#classhydra_1_1Vector3R">Vector3R</a> &amp;v1, const <a class="el" href="group__phsp.html#classhydra_1_1Vector3R">Vector3R</a> &amp;v2)</td></tr>
<tr class="separator:afd42c2a636a5bfb4e605ddd9f1ea069a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa9d6d9136eecf2c929dd9b12356d833"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename  = typename std::enable_if&lt; (std::is_convertible&lt;T1, double&gt;::value ||		std::is_constructible&lt;HYDRA_EXTERNAL_NS::thrust::complex&lt;double&gt;,T1&gt;::value) &amp;&amp; T2::is_functor::value&gt;::type&gt; </td></tr>
<tr class="memitem:afa9d6d9136eecf2c929dd9b12356d833"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ <a class="el" href="classhydra_1_1Multiply.html">Multiply</a>&lt; <a class="el" href="structhydra_1_1Constant.html">Constant</a>&lt; T1 &gt;, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#afa9d6d9136eecf2c929dd9b12356d833">operator*</a> (T2 const &amp;F2, T1 const cte)</td></tr>
<tr class="separator:afa9d6d9136eecf2c929dd9b12356d833"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5bae5caa4d9b5c0190220e55f650859"><td class="memItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ <a class="el" href="group__phsp.html#classhydra_1_1Vector4R">Vector4R</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ae5bae5caa4d9b5c0190220e55f650859">operator*</a> (<a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> c, const <a class="el" href="group__phsp.html#classhydra_1_1Vector4R">Vector4R</a> &amp;v2)</td></tr>
<tr class="separator:ae5bae5caa4d9b5c0190220e55f650859"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2b0be1f22ac4914bd6ce0bc97411bff"><td class="memItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ <a class="el" href="group__phsp.html#classhydra_1_1Vector4R">Vector4R</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ae2b0be1f22ac4914bd6ce0bc97411bff">operator*</a> (const <a class="el" href="group__phsp.html#classhydra_1_1Vector4R">Vector4R</a> &amp;v2, <a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> c)</td></tr>
<tr class="separator:ae2b0be1f22ac4914bd6ce0bc97411bff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb096b020e55914fe7a1e885dd66b17e"><td class="memItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ <a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#adb096b020e55914fe7a1e885dd66b17e">operator*</a> (const <a class="el" href="group__phsp.html#classhydra_1_1Vector4R">Vector4R</a> &amp;v1, const <a class="el" href="group__phsp.html#classhydra_1_1Vector4R">Vector4R</a> &amp;v2)</td></tr>
<tr class="separator:adb096b020e55914fe7a1e885dd66b17e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31bdba87b791f8a68e8571eaa00788cd"><td class="memTemplParams" colspan="2">template&lt;typename ... T&gt; </td></tr>
<tr class="memitem:a31bdba87b791f8a68e8571eaa00788cd"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a31bdba87b791f8a68e8571eaa00788cd">operator*</a> (const HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt; &amp;a, const HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt; &amp;b)</td></tr>
<tr class="separator:a31bdba87b791f8a68e8571eaa00788cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b98f3604eca3a6023551cd4ce98020a"><td class="memItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ <a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a0b98f3604eca3a6023551cd4ce98020a">operator*</a> (<a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a> par1, <a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a> const &amp;par2)</td></tr>
<tr class="separator:a0b98f3604eca3a6023551cd4ce98020a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac480ecaec81a0040f3b466ca5904ed5b"><td class="memItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ <a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ac480ecaec81a0040f3b466ca5904ed5b">operator*</a> (<a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a> par1, <a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> par2)</td></tr>
<tr class="separator:ac480ecaec81a0040f3b466ca5904ed5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0bc15a0070c95cad2a9b6e300b430cc"><td class="memItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ <a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#aa0bc15a0070c95cad2a9b6e300b430cc">operator*</a> (<a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> par1, <a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a> const &amp;par2)</td></tr>
<tr class="separator:aa0bc15a0070c95cad2a9b6e300b430cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81ab71f63c56b41e970fee5c7fa48915"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename  = typename std::enable_if&lt; T1::is_functor::value &amp;&amp; T2::is_functor::value&gt;&gt; </td></tr>
<tr class="memitem:a81ab71f63c56b41e970fee5c7fa48915"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ <a class="el" href="classhydra_1_1Sum.html">Sum</a>&lt; T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a81ab71f63c56b41e970fee5c7fa48915">operator+</a> (T1 const &amp;F1, T2 const &amp;F2)</td></tr>
<tr class="separator:a81ab71f63c56b41e970fee5c7fa48915"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58bc87dddca38c44ed5276eedb78a176"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename  = typename std::enable_if&lt; (std::is_convertible&lt;T1, double&gt;::value ||		std::is_constructible&lt;HYDRA_EXTERNAL_NS::thrust::complex&lt;double&gt;,T1&gt;::value) &amp;&amp; T2::is_functor::value&gt;::type&gt; </td></tr>
<tr class="memitem:a58bc87dddca38c44ed5276eedb78a176"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ <a class="el" href="classhydra_1_1Sum.html">Sum</a>&lt; <a class="el" href="structhydra_1_1Constant.html">Constant</a>&lt; T1 &gt;, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a58bc87dddca38c44ed5276eedb78a176">operator+</a> (T1 const cte, T2 const &amp;F2)</td></tr>
<tr class="separator:a58bc87dddca38c44ed5276eedb78a176"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd8f4a42269c2f7b4316a413efe5190e"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename  = typename std::enable_if&lt; (std::is_convertible&lt;T1, double&gt;::value ||		std::is_constructible&lt;HYDRA_EXTERNAL_NS::thrust::complex&lt;double&gt;,T1&gt;::value) &amp;&amp; T2::is_functor::value&gt;::type&gt; </td></tr>
<tr class="memitem:acd8f4a42269c2f7b4316a413efe5190e"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ <a class="el" href="classhydra_1_1Sum.html">Sum</a>&lt; <a class="el" href="structhydra_1_1Constant.html">Constant</a>&lt; T1 &gt;, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#acd8f4a42269c2f7b4316a413efe5190e">operator+</a> (T2 const &amp;F2, T1 const cte)</td></tr>
<tr class="separator:acd8f4a42269c2f7b4316a413efe5190e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c1fc13eb2a4a440f72991b4347a472c"><td class="memItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ <a class="el" href="group__phsp.html#classhydra_1_1Vector3R">Vector3R</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a1c1fc13eb2a4a440f72991b4347a472c">operator+</a> (const <a class="el" href="group__phsp.html#classhydra_1_1Vector3R">Vector3R</a> &amp;v1, const <a class="el" href="group__phsp.html#classhydra_1_1Vector3R">Vector3R</a> &amp;v2)</td></tr>
<tr class="separator:a1c1fc13eb2a4a440f72991b4347a472c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a781df21a8dca74210f8dc39b340b58ec"><td class="memTemplParams" colspan="2">template&lt;typename ... T&gt; </td></tr>
<tr class="memitem:a781df21a8dca74210f8dc39b340b58ec"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a781df21a8dca74210f8dc39b340b58ec">operator+</a> (const HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt; &amp;a, const HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt; &amp;b)</td></tr>
<tr class="separator:a781df21a8dca74210f8dc39b340b58ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af68a4c9bed0e1a2cf2ed9ba9ab057dd0"><td class="memItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ <a class="el" href="group__phsp.html#classhydra_1_1Vector4R">Vector4R</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#af68a4c9bed0e1a2cf2ed9ba9ab057dd0">operator+</a> (const <a class="el" href="group__phsp.html#classhydra_1_1Vector4R">Vector4R</a> &amp;v1, const <a class="el" href="group__phsp.html#classhydra_1_1Vector4R">Vector4R</a> &amp;v2)</td></tr>
<tr class="separator:af68a4c9bed0e1a2cf2ed9ba9ab057dd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26e3492eb046c39e1b578738cd5ad7b7"><td class="memItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ <a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a26e3492eb046c39e1b578738cd5ad7b7">operator+</a> (<a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a> par1, <a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a> const &amp;par2)</td></tr>
<tr class="separator:a26e3492eb046c39e1b578738cd5ad7b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a357a28a5ec78cd838e8e90face792425"><td class="memItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ <a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a357a28a5ec78cd838e8e90face792425">operator+</a> (<a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a> par1, <a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> par2)</td></tr>
<tr class="separator:a357a28a5ec78cd838e8e90face792425"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e6b67d073431ddbbc9df286683b6391"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename  = typename std::enable_if&lt; T1::is_functor::value &amp;&amp; T2::is_functor::value&gt;&gt; </td></tr>
<tr class="memitem:a8e6b67d073431ddbbc9df286683b6391"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ <a class="el" href="classhydra_1_1Minus.html">Minus</a>&lt; T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a8e6b67d073431ddbbc9df286683b6391">operator-</a> (T1 const &amp;F1, T2 const &amp;F2)</td></tr>
<tr class="separator:a8e6b67d073431ddbbc9df286683b6391"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab209688d56c7888c7fb173e06b4a63b8"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename  = typename std::enable_if&lt; (std::is_convertible&lt;T1, double&gt;::value ||		std::is_constructible&lt;HYDRA_EXTERNAL_NS::thrust::complex&lt;double&gt;,T1&gt;::value) &amp;&amp; T2::is_functor::value&gt;::type&gt; </td></tr>
<tr class="memitem:ab209688d56c7888c7fb173e06b4a63b8"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ <a class="el" href="classhydra_1_1Minus.html">Minus</a>&lt; <a class="el" href="structhydra_1_1Constant.html">Constant</a>&lt; T1 &gt;, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ab209688d56c7888c7fb173e06b4a63b8">operator-</a> (T1 const cte, T2 const &amp;F2)</td></tr>
<tr class="separator:ab209688d56c7888c7fb173e06b4a63b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0ab9137952e574434bb5457b5e7624b"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename  = typename std::enable_if&lt; (std::is_convertible&lt;T1, double&gt;::value ||		std::is_constructible&lt;HYDRA_EXTERNAL_NS::thrust::complex&lt;double&gt;,T1&gt;::value) &amp;&amp; T2::is_functor::value&gt;::type&gt; </td></tr>
<tr class="memitem:aa0ab9137952e574434bb5457b5e7624b"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ <a class="el" href="classhydra_1_1Minus.html">Minus</a>&lt; T2, <a class="el" href="structhydra_1_1Constant.html">Constant</a>&lt; T1 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#aa0ab9137952e574434bb5457b5e7624b">operator-</a> (T2 const &amp;F2, T1 const cte)</td></tr>
<tr class="separator:aa0ab9137952e574434bb5457b5e7624b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1113b35a5588af8a55453fbd5e1b2651"><td class="memItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ <a class="el" href="group__phsp.html#classhydra_1_1Vector3R">Vector3R</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a1113b35a5588af8a55453fbd5e1b2651">operator-</a> (const <a class="el" href="group__phsp.html#classhydra_1_1Vector3R">Vector3R</a> &amp;v1, const <a class="el" href="group__phsp.html#classhydra_1_1Vector3R">Vector3R</a> &amp;v2)</td></tr>
<tr class="separator:a1113b35a5588af8a55453fbd5e1b2651"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28b7a7b4b2afa53b5b17883d43c6635b"><td class="memTemplParams" colspan="2">template&lt;typename ... T&gt; </td></tr>
<tr class="memitem:a28b7a7b4b2afa53b5b17883d43c6635b"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a28b7a7b4b2afa53b5b17883d43c6635b">operator-</a> (const HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt; &amp;a, const HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt; &amp;b)</td></tr>
<tr class="separator:a28b7a7b4b2afa53b5b17883d43c6635b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a950f2d5dc4356f6c6c13b9fc3bc7c0ef"><td class="memItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ <a class="el" href="group__phsp.html#classhydra_1_1Vector4R">Vector4R</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a950f2d5dc4356f6c6c13b9fc3bc7c0ef">operator-</a> (const <a class="el" href="group__phsp.html#classhydra_1_1Vector4R">Vector4R</a> &amp;v1, const <a class="el" href="group__phsp.html#classhydra_1_1Vector4R">Vector4R</a> &amp;v2)</td></tr>
<tr class="separator:a950f2d5dc4356f6c6c13b9fc3bc7c0ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68375d62444cb2341ade99f0ac15972f"><td class="memItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ <a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a68375d62444cb2341ade99f0ac15972f">operator-</a> (<a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a> par1, <a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a> const &amp;par2)</td></tr>
<tr class="separator:a68375d62444cb2341ade99f0ac15972f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07c46e4c59a5208f5d495b4ddaf3af75"><td class="memItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ <a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a07c46e4c59a5208f5d495b4ddaf3af75">operator-</a> (<a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a> par1, <a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> par2)</td></tr>
<tr class="separator:a07c46e4c59a5208f5d495b4ddaf3af75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a247f457807559c67d34c5b9d15c0b4b4"><td class="memItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ <a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a247f457807559c67d34c5b9d15c0b4b4">operator-</a> (<a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> par1, <a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a> par2)</td></tr>
<tr class="separator:a247f457807559c67d34c5b9d15c0b4b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fa3a711732edb66303a415b0053ab30"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename  = typename std::enable_if&lt; T1::is_functor::value &amp;&amp; T2::is_functor::value&gt;&gt; </td></tr>
<tr class="memitem:a0fa3a711732edb66303a415b0053ab30"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ <a class="el" href="classhydra_1_1Divide.html">Divide</a>&lt; T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a0fa3a711732edb66303a415b0053ab30">operator/</a> (T1 const &amp;F1, T2 const &amp;F2)</td></tr>
<tr class="separator:a0fa3a711732edb66303a415b0053ab30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51adfe83d6139c094696c576cac08eb9"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename  = typename std::enable_if&lt; (std::is_convertible&lt;T1, double&gt;::value ||		std::is_constructible&lt;HYDRA_EXTERNAL_NS::thrust::complex&lt;double&gt;,T1&gt;::value) &amp;&amp; T2::is_functor::value&gt;::type&gt; </td></tr>
<tr class="memitem:a51adfe83d6139c094696c576cac08eb9"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ <a class="el" href="classhydra_1_1Divide.html">Divide</a>&lt; <a class="el" href="structhydra_1_1Constant.html">Constant</a>&lt; T1 &gt;, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a51adfe83d6139c094696c576cac08eb9">operator/</a> (T1 const cte, T2 const &amp;F2)</td></tr>
<tr class="separator:a51adfe83d6139c094696c576cac08eb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73f958068c4dcdbb79b40925e2da4b24"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename  = typename std::enable_if&lt; (std::is_convertible&lt;T1, double&gt;::value ||		std::is_constructible&lt;HYDRA_EXTERNAL_NS::thrust::complex&lt;double&gt;,T1&gt;::value) &amp;&amp; T2::is_functor::value&gt;::type&gt; </td></tr>
<tr class="memitem:a73f958068c4dcdbb79b40925e2da4b24"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ <a class="el" href="classhydra_1_1Divide.html">Divide</a>&lt; T2, <a class="el" href="structhydra_1_1Constant.html">Constant</a>&lt; T1 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a73f958068c4dcdbb79b40925e2da4b24">operator/</a> (T2 const &amp;F2, T1 const cte)</td></tr>
<tr class="separator:a73f958068c4dcdbb79b40925e2da4b24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94cb4a79113148abd78aa8e4d6f7e41d"><td class="memItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ <a class="el" href="group__phsp.html#classhydra_1_1Vector3R">Vector3R</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a94cb4a79113148abd78aa8e4d6f7e41d">operator/</a> (const <a class="el" href="group__phsp.html#classhydra_1_1Vector3R">Vector3R</a> &amp;v1, <a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> c)</td></tr>
<tr class="separator:a94cb4a79113148abd78aa8e4d6f7e41d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4db4d6d0e3fe03dccf661b7ac0751fe7"><td class="memItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ <a class="el" href="group__phsp.html#classhydra_1_1Vector4R">Vector4R</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a4db4d6d0e3fe03dccf661b7ac0751fe7">operator/</a> (const <a class="el" href="group__phsp.html#classhydra_1_1Vector4R">Vector4R</a> &amp;v2, <a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> c)</td></tr>
<tr class="separator:a4db4d6d0e3fe03dccf661b7ac0751fe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61779a5f2bd6e73c2808fc388b3aa496"><td class="memTemplParams" colspan="2">template&lt;typename ... T&gt; </td></tr>
<tr class="memitem:a61779a5f2bd6e73c2808fc388b3aa496"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a61779a5f2bd6e73c2808fc388b3aa496">operator/</a> (const HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt; &amp;a, const HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt; &amp;b)</td></tr>
<tr class="separator:a61779a5f2bd6e73c2808fc388b3aa496"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9b1664e58d41d5f8e7ec6d1c20bf9c0"><td class="memItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ <a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ac9b1664e58d41d5f8e7ec6d1c20bf9c0">operator/</a> (<a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a> par1, <a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a> const par2)</td></tr>
<tr class="separator:ac9b1664e58d41d5f8e7ec6d1c20bf9c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a4133d480d7e9f3f5e85286e47a3709"><td class="memItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ <a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a0a4133d480d7e9f3f5e85286e47a3709">operator/</a> (<a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a> par1, <a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> par2)</td></tr>
<tr class="separator:a0a4133d480d7e9f3f5e85286e47a3709"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af29cde1e70c62bec6f1fa1ee52940887"><td class="memItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ <a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#af29cde1e70c62bec6f1fa1ee52940887">operator/</a> (<a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> par1, <a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a> par2)</td></tr>
<tr class="separator:af29cde1e70c62bec6f1fa1ee52940887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15cdb083719133399edb77f5ef3eb547"><td class="memTemplParams" colspan="2">template&lt;size_t N, typename T &gt; </td></tr>
<tr class="memitem:a15cdb083719133399edb77f5ef3eb547"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a15cdb083719133399edb77f5ef3eb547">operator&lt;&lt;</a> (std::ostream &amp;os, std::array&lt; T, N &gt; const &amp;obj)</td></tr>
<tr class="separator:a15cdb083719133399edb77f5ef3eb547"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fab8d226ee701c0755c60202fc30f6c"><td class="memTemplParams" colspan="2">template&lt;typename ... T&gt; </td></tr>
<tr class="memitem:a6fab8d226ee701c0755c60202fc30f6c"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a6fab8d226ee701c0755c60202fc30f6c">operator&lt;&lt;</a> (std::ostream &amp;os, std::tuple&lt; T... &gt; const &amp;obj)</td></tr>
<tr class="separator:a6fab8d226ee701c0755c60202fc30f6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4d7f13d811f0d63d4ce49d31b6cfbe0"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ad4d7f13d811f0d63d4ce49d31b6cfbe0"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ad4d7f13d811f0d63d4ce49d31b6cfbe0">operator&lt;&lt;</a> (std::ostream &amp;os, std::pair&lt; T1, T2 &gt; const &amp;obj)</td></tr>
<tr class="separator:ad4d7f13d811f0d63d4ce49d31b6cfbe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fa8037907332bf633dfc1bc3b40865c"><td class="memItemLeft" align="right" valign="top">ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a3fa8037907332bf633dfc1bc3b40865c">operator&lt;&lt;</a> (ostream &amp;s, const <a class="el" href="group__phsp.html#classhydra_1_1Vector3R">Vector3R</a> &amp;v)</td></tr>
<tr class="separator:a3fa8037907332bf633dfc1bc3b40865c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaacce78528c9499de97312cbe606ece4"><td class="memItemLeft" align="right" valign="top">ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#aaacce78528c9499de97312cbe606ece4">operator&lt;&lt;</a> (ostream &amp;s, const <a class="el" href="group__phsp.html#classhydra_1_1Vector4R">Vector4R</a> &amp;v)</td></tr>
<tr class="separator:aaacce78528c9499de97312cbe606ece4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3be8e63c60c604b927f9638600a598b"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ad3be8e63c60c604b927f9638600a598b">operator&lt;&lt;</a> (std::ostream &amp;os, <a class="el" href="group__fit.html#classhydra_1_1UserParameters">UserParameters</a> const &amp;par)</td></tr>
<tr class="memdesc:ad3be8e63c60c604b927f9638600a598b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classhydra_1_1Print.html">Print</a> the ROOT::Minuit2 state to stream.  <a href="#ad3be8e63c60c604b927f9638600a598b">More...</a><br /></td></tr>
<tr class="separator:ad3be8e63c60c604b927f9638600a598b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21d7262b80d73f956ed1a477607b9053"><td class="memTemplParams" colspan="2">template&lt;typename ValueType , class charT , class traits &gt; </td></tr>
<tr class="memitem:a21d7262b80d73f956ed1a477607b9053"><td class="memTemplItemLeft" align="right" valign="top">std::basic_ostream&lt; charT, traits &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a21d7262b80d73f956ed1a477607b9053">operator&lt;&lt;</a> (std::basic_ostream&lt; charT, traits &gt; &amp;os, const <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; ValueType &gt; &amp;z)</td></tr>
<tr class="separator:a21d7262b80d73f956ed1a477607b9053"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28117308ddccfecc1cf7cf76c8810f95"><td class="memItemLeft" align="right" valign="top">__hydra_host__ std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a28117308ddccfecc1cf7cf76c8810f95">operator&lt;&lt;</a> (std::ostream &amp;os, <a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a> const &amp;var)</td></tr>
<tr class="separator:a28117308ddccfecc1cf7cf76c8810f95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea70aec01321527f54717a004a3df99d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aea70aec01321527f54717a004a3df99d"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ <a class="el" href="namespace_3globalScope_4.html#classbool">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#aea70aec01321527f54717a004a3df99d">operator==</a> (const <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;lhs, const <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="separator:aea70aec01321527f54717a004a3df99d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a227370a3dddcea864f09490bc65b93ad"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a227370a3dddcea864f09490bc65b93ad"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ <a class="el" href="namespace_3globalScope_4.html#classbool">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a227370a3dddcea864f09490bc65b93ad">operator==</a> (const T &amp;lhs, const <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="separator:a227370a3dddcea864f09490bc65b93ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99bf5390aa3ab39e8ac0cd109ef6b7c9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a99bf5390aa3ab39e8ac0cd109ef6b7c9"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ <a class="el" href="namespace_3globalScope_4.html#classbool">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a99bf5390aa3ab39e8ac0cd109ef6b7c9">operator==</a> (const <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;lhs, const T &amp;rhs)</td></tr>
<tr class="separator:a99bf5390aa3ab39e8ac0cd109ef6b7c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebc9da09d22eae43ed970a123baa27f1"><td class="memTemplParams" colspan="2">template&lt;size_t N1, hydra::detail::Backend BACKEND1, size_t N2, hydra::detail::Backend BACKEND2&gt; </td></tr>
<tr class="memitem:aebc9da09d22eae43ed970a123baa27f1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespace_3globalScope_4.html#classbool">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#aebc9da09d22eae43ed970a123baa27f1">operator==</a> (const <a class="el" href="group__phsp.html#classhydra_1_1Decays">Decays</a>&lt; N1, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND1 &gt; &gt; &amp;lhs, const <a class="el" href="group__phsp.html#classhydra_1_1Decays">Decays</a>&lt; N2, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND2 &gt; &gt; &amp;rhs)</td></tr>
<tr class="separator:aebc9da09d22eae43ed970a123baa27f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3bafbf7fa6e97bc40b02d74d7d596ea"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N, hydra::detail::Backend BACKEND1, hydra::detail::Backend BACKEND2&gt; </td></tr>
<tr class="memitem:ab3bafbf7fa6e97bc40b02d74d7d596ea"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespace_3globalScope_4.html#classbool">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ab3bafbf7fa6e97bc40b02d74d7d596ea">operator==</a> (const <a class="el" href="namespacehydra.html#classhydra_1_1multiarray">multiarray</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND1 &gt;&gt; &amp;lhs, const <a class="el" href="namespacehydra.html#classhydra_1_1multiarray">multiarray</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND2 &gt;&gt; &amp;rhs)</td></tr>
<tr class="separator:ab3bafbf7fa6e97bc40b02d74d7d596ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49a0907b93c595507fbd2ea319f2f5d6"><td class="memTemplParams" colspan="2">template&lt;typename ... T, hydra::detail::Backend BACKEND1, hydra::detail::Backend BACKEND2&gt; </td></tr>
<tr class="memitem:a49a0907b93c595507fbd2ea319f2f5d6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespace_3globalScope_4.html#classbool">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a49a0907b93c595507fbd2ea319f2f5d6">operator==</a> (const <a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND1 &gt;&gt; &amp;lhs, const <a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND2 &gt;&gt; &amp;rhs)</td></tr>
<tr class="separator:a49a0907b93c595507fbd2ea319f2f5d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63ad8f84031200c3161c889507d3a9c0"><td class="memTemplParams" colspan="2">template&lt;typename ValueType , typename charT , class traits &gt; </td></tr>
<tr class="memitem:a63ad8f84031200c3161c889507d3a9c0"><td class="memTemplItemLeft" align="right" valign="top">std::basic_istream&lt; charT, traits &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a63ad8f84031200c3161c889507d3a9c0">operator&gt;&gt;</a> (std::basic_istream&lt; charT, traits &gt; &amp;is, <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; ValueType &gt; &amp;z)</td></tr>
<tr class="separator:a63ad8f84031200c3161c889507d3a9c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae85d86e6980bcf24de91a003711b3224"><td class="memItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ae85d86e6980bcf24de91a003711b3224">pmf</a> (const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> mother_mass, const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> daughter1_mass, const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> daughter2_mass)</td></tr>
<tr class="memdesc:ae85d86e6980bcf24de91a003711b3224"><td class="mdescLeft">&#160;</td><td class="mdescRight">Momentum in mother frame of daughter particle in two-body-decay.  <a href="#ae85d86e6980bcf24de91a003711b3224">More...</a><br /></td></tr>
<tr class="separator:ae85d86e6980bcf24de91a003711b3224"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3cc52fabc8882be13d9a6ca92fc648e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae3cc52fabc8882be13d9a6ca92fc648e"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ae3cc52fabc8882be13d9a6ca92fc648e">polar</a> (const T &amp;m, const T &amp;theta=0)</td></tr>
<tr class="separator:ae3cc52fabc8882be13d9a6ca92fc648e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93feeb5a117184a56c3151d3b7685c1d"><td class="memTemplParams" colspan="2">template&lt;typename T , unsigned int N&gt; </td></tr>
<tr class="memitem:a93feeb5a117184a56c3151d3b7685c1d"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a93feeb5a117184a56c3151d3b7685c1d">pow</a> (const T x)</td></tr>
<tr class="memdesc:a93feeb5a117184a56c3151d3b7685c1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Power with integer exponent.  <a href="#a93feeb5a117184a56c3151d3b7685c1d">More...</a><br /></td></tr>
<tr class="separator:a93feeb5a117184a56c3151d3b7685c1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2256bff965f5a7359591579a97114ec"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac2256bff965f5a7359591579a97114ec"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ac2256bff965f5a7359591579a97114ec">pow</a> (const <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;x, const <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;y)</td></tr>
<tr class="separator:ac2256bff965f5a7359591579a97114ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cf806d100f53f6d281b8b826697e10f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4cf806d100f53f6d281b8b826697e10f"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a4cf806d100f53f6d281b8b826697e10f">pow</a> (const <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:a4cf806d100f53f6d281b8b826697e10f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e9146d77dfa5b6c0fcbcb31557f6854"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2e9146d77dfa5b6c0fcbcb31557f6854"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a2e9146d77dfa5b6c0fcbcb31557f6854">pow</a> (const T &amp;x, const <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;y)</td></tr>
<tr class="separator:a2e9146d77dfa5b6c0fcbcb31557f6854"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5e9dc190c08a69b225d320ab8da1582"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ab5e9dc190c08a69b225d320ab8da1582"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; typename HYDRA_EXTERNAL_NS::thrust::detail::promoted_numerical_type&lt; T, U &gt;::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ab5e9dc190c08a69b225d320ab8da1582">pow</a> (const <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;x, const <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; U &gt; &amp;y)</td></tr>
<tr class="separator:ab5e9dc190c08a69b225d320ab8da1582"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adddd0dd31b59ee6d761eccb6cd78b452"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:adddd0dd31b59ee6d761eccb6cd78b452"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; typename HYDRA_EXTERNAL_NS::thrust::detail::promoted_numerical_type&lt; T, U &gt;::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#adddd0dd31b59ee6d761eccb6cd78b452">pow</a> (const <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;x, const U &amp;y)</td></tr>
<tr class="separator:adddd0dd31b59ee6d761eccb6cd78b452"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab57b4e7a8e408d4e545f46a2c1923cd5"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ab57b4e7a8e408d4e545f46a2c1923cd5"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; typename HYDRA_EXTERNAL_NS::thrust::detail::promoted_numerical_type&lt; T, U &gt;::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ab57b4e7a8e408d4e545f46a2c1923cd5">pow</a> (const T &amp;x, const <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; U &gt; &amp;y)</td></tr>
<tr class="separator:ab57b4e7a8e408d4e545f46a2c1923cd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb0c9817024c69efe44c2d9653928519"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:acb0c9817024c69efe44c2d9653928519"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#acb0c9817024c69efe44c2d9653928519">PrintToStream</a> (std::ostream &amp;ostream, const char *format, Args... args)</td></tr>
<tr class="separator:acb0c9817024c69efe44c2d9653928519"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace0454750e3561d390ee18b96824227c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ace0454750e3561d390ee18b96824227c"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ace0454750e3561d390ee18b96824227c">proj</a> (const T &amp;z)</td></tr>
<tr class="separator:ace0454750e3561d390ee18b96824227c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88492da245c1e30c636a6862b3db2854"><td class="memTemplParams" colspan="2">template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename T , size_t N&gt; </td></tr>
<tr class="memitem:a88492da245c1e30c636a6862b3db2854"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a88492da245c1e30c636a6862b3db2854">rbegin</a> (<a class="el" href="namespacehydra.html#classhydra_1_1multiarray">multiarray</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; const &amp;other) -&gt; decltype(other.rbegin(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;</td></tr>
<tr class="separator:a88492da245c1e30c636a6862b3db2854"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa6e43a3fe1002f340251042beefbddd"><td class="memTemplParams" colspan="2">template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename T , size_t N&gt; </td></tr>
<tr class="memitem:afa6e43a3fe1002f340251042beefbddd"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#afa6e43a3fe1002f340251042beefbddd">rbegin</a> (<a class="el" href="namespacehydra.html#classhydra_1_1multiarray">multiarray</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; &amp;other) -&gt; decltype(other.rbegin(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;</td></tr>
<tr class="separator:afa6e43a3fe1002f340251042beefbddd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68b257293c03a3475bb28e9575e941ad"><td class="memTemplParams" colspan="2">template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename ... T&gt; </td></tr>
<tr class="memitem:a68b257293c03a3475bb28e9575e941ad"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a68b257293c03a3475bb28e9575e941ad">rbegin</a> (<a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; const &amp;other) -&gt; decltype(other.rbegin(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;</td></tr>
<tr class="separator:a68b257293c03a3475bb28e9575e941ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2906e8baa707b7e3cbe3ab1c1aa3fa7c"><td class="memTemplParams" colspan="2">template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename ... T&gt; </td></tr>
<tr class="memitem:a2906e8baa707b7e3cbe3ab1c1aa3fa7c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a2906e8baa707b7e3cbe3ab1c1aa3fa7c">rbegin</a> (<a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; &amp;other) -&gt; decltype(other.rbegin(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;</td></tr>
<tr class="separator:a2906e8baa707b7e3cbe3ab1c1aa3fa7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adeb4e3f7995b809a28ab9efd97909874"><td class="memTemplParams" colspan="2">template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename T , size_t N&gt; </td></tr>
<tr class="memitem:adeb4e3f7995b809a28ab9efd97909874"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#adeb4e3f7995b809a28ab9efd97909874">rend</a> (<a class="el" href="namespacehydra.html#classhydra_1_1multiarray">multiarray</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; const &amp;other) -&gt; decltype(other.rend(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;</td></tr>
<tr class="separator:adeb4e3f7995b809a28ab9efd97909874"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61c8453a5cf5c68eb4f1a074db0135f6"><td class="memTemplParams" colspan="2">template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename T , size_t N&gt; </td></tr>
<tr class="memitem:a61c8453a5cf5c68eb4f1a074db0135f6"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a61c8453a5cf5c68eb4f1a074db0135f6">rend</a> (<a class="el" href="namespacehydra.html#classhydra_1_1multiarray">multiarray</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; &amp;other) -&gt; decltype(other.rend(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;</td></tr>
<tr class="separator:a61c8453a5cf5c68eb4f1a074db0135f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53513fea217a83151a1c98692a1bdbc7"><td class="memTemplParams" colspan="2">template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename ... T&gt; </td></tr>
<tr class="memitem:a53513fea217a83151a1c98692a1bdbc7"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a53513fea217a83151a1c98692a1bdbc7">rend</a> (<a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; const &amp;other) -&gt; decltype(other.rend(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;</td></tr>
<tr class="separator:a53513fea217a83151a1c98692a1bdbc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96fc64d77a9d74b4606c449937491181"><td class="memTemplParams" colspan="2">template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename ... T&gt; </td></tr>
<tr class="memitem:a96fc64d77a9d74b4606c449937491181"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a96fc64d77a9d74b4606c449937491181">rend</a> (<a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; &amp;other) -&gt; decltype(other.rend(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;</td></tr>
<tr class="separator:a96fc64d77a9d74b4606c449937491181"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a9e21c7083ea65e58667297a801f0c0"><td class="memItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ <a class="el" href="group__phsp.html#classhydra_1_1Vector4R">Vector4R</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a4a9e21c7083ea65e58667297a801f0c0">rotateEuler</a> (const <a class="el" href="group__phsp.html#classhydra_1_1Vector4R">Vector4R</a> &amp;rs, <a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> alpha, <a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> beta, <a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> gamma)</td></tr>
<tr class="separator:a4a9e21c7083ea65e58667297a801f0c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9637ed446b2f89c3514f57bac1fd1be"><td class="memItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ <a class="el" href="group__phsp.html#classhydra_1_1Vector3R">Vector3R</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ab9637ed446b2f89c3514f57bac1fd1be">rotateEuler</a> (const <a class="el" href="group__phsp.html#classhydra_1_1Vector3R">Vector3R</a> &amp;v, <a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> phi, <a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> theta, <a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> ksi)</td></tr>
<tr class="separator:ab9637ed446b2f89c3514f57bac1fd1be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb7d0e5da38544692eb3545e81617e19"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:acb7d0e5da38544692eb3545e81617e19"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#acb7d0e5da38544692eb3545e81617e19">sin</a> (const <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;z)</td></tr>
<tr class="separator:acb7d0e5da38544692eb3545e81617e19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af59c474655ecd14c6748391d80e2e4c2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af59c474655ecd14c6748391d80e2e4c2"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#af59c474655ecd14c6748391d80e2e4c2">sinh</a> (const <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;z)</td></tr>
<tr class="separator:af59c474655ecd14c6748391d80e2e4c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74988a829019bf111e7f51d81b33eec7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a74988a829019bf111e7f51d81b33eec7"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a74988a829019bf111e7f51d81b33eec7">sqrt</a> (const <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;z)</td></tr>
<tr class="separator:a74988a829019bf111e7f51d81b33eec7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa792627bbf68dd5d3c3d969c3462808f"><td class="memTemplParams" colspan="2">template&lt;size_t N, typename T , size_t I&gt; </td></tr>
<tr class="memitem:aa792627bbf68dd5d3c3d969c3462808f"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;(I==N), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#aa792627bbf68dd5d3c3d969c3462808f">stream_array_helper</a> (std::ostream &amp;, std::array&lt; T, N &gt; const &amp;)</td></tr>
<tr class="memdesc:aa792627bbf68dd5d3c3d969c3462808f"><td class="mdescLeft">&#160;</td><td class="mdescRight">array streamer helper  <a href="#aa792627bbf68dd5d3c3d969c3462808f">More...</a><br /></td></tr>
<tr class="separator:aa792627bbf68dd5d3c3d969c3462808f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b2446e6e58a2466b66c1277d67075ad"><td class="memTemplParams" colspan="2">template&lt;size_t N, typename T , size_t I = 0&gt; </td></tr>
<tr class="memitem:a6b2446e6e58a2466b66c1277d67075ad"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;(I&lt; N), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a6b2446e6e58a2466b66c1277d67075ad">stream_array_helper</a> (std::ostream &amp;os, std::array&lt; T, N &gt; const &amp;obj)</td></tr>
<tr class="separator:a6b2446e6e58a2466b66c1277d67075ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa8b42796ae70a6c34b6871a8755b382"><td class="memTemplParams" colspan="2">template&lt;size_t I, typename ... T&gt; </td></tr>
<tr class="memitem:afa8b42796ae70a6c34b6871a8755b382"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;(I==sizeof ...(T)), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#afa8b42796ae70a6c34b6871a8755b382">stream_tuple_helper</a> (std::ostream &amp;, std::tuple&lt; T... &gt; const &amp;)</td></tr>
<tr class="memdesc:afa8b42796ae70a6c34b6871a8755b382"><td class="mdescLeft">&#160;</td><td class="mdescRight">tuple streamer helper  <a href="#afa8b42796ae70a6c34b6871a8755b382">More...</a><br /></td></tr>
<tr class="separator:afa8b42796ae70a6c34b6871a8755b382"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0ba407638beac5920ac997d3021b413"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename ... T&gt; </td></tr>
<tr class="memitem:af0ba407638beac5920ac997d3021b413"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;(I&lt; sizeof ...(T)), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#af0ba407638beac5920ac997d3021b413">stream_tuple_helper</a> (std::ostream &amp;os, std::tuple&lt; T... &gt; const &amp;obj)</td></tr>
<tr class="separator:af0ba407638beac5920ac997d3021b413"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae69d22c1daecb87a2e29aae2703bac16"><td class="memTemplParams" colspan="2">template&lt;typename F1 , typename F2 , typename ... Fs&gt; </td></tr>
<tr class="memitem:ae69d22c1daecb87a2e29aae2703bac16"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ <a class="el" href="classhydra_1_1Sum.html">Sum</a>&lt; F1, F2, Fs... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ae69d22c1daecb87a2e29aae2703bac16">sum</a> (F1 const &amp;f1, F2 const &amp;f2, Fs const &amp;... functors)</td></tr>
<tr class="separator:ae69d22c1daecb87a2e29aae2703bac16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7d619f99868f45f5e06b9040bcc68b7"><td class="memItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#aa7d619f99868f45f5e06b9040bcc68b7">swap</a> (<a class="el" href="group__phsp.html#classhydra_1_1Vector3R">Vector3R</a> &amp;v1, <a class="el" href="group__phsp.html#classhydra_1_1Vector3R">Vector3R</a> &amp;v2)</td></tr>
<tr class="separator:aa7d619f99868f45f5e06b9040bcc68b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67385a5afc562279b4419a11ab79e3d6"><td class="memItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a67385a5afc562279b4419a11ab79e3d6">swap</a> (<a class="el" href="group__phsp.html#classhydra_1_1Vector4R">Vector4R</a> &amp;v1, <a class="el" href="group__phsp.html#classhydra_1_1Vector4R">Vector4R</a> &amp;v2)</td></tr>
<tr class="separator:a67385a5afc562279b4419a11ab79e3d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a110443bb149efe88b6713bc5aca89b7c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a110443bb149efe88b6713bc5aca89b7c"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a110443bb149efe88b6713bc5aca89b7c">tan</a> (const <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;z)</td></tr>
<tr class="separator:a110443bb149efe88b6713bc5aca89b7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c39f4b7fa2b8b0c1e4066e9d059b435"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5c39f4b7fa2b8b0c1e4066e9d059b435"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a5c39f4b7fa2b8b0c1e4066e9d059b435">tanh</a> (const <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;z)</td></tr>
<tr class="separator:a5c39f4b7fa2b8b0c1e4066e9d059b435"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e16e05c122a0b3b48937b89de17b621"><td class="memTemplParams" colspan="2">template&lt;class ... T&gt; </td></tr>
<tr class="memitem:a0e16e05c122a0b3b48937b89de17b621"><td class="memTemplItemLeft" align="right" valign="top">__hydra_host__ __hydra_device__ auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a0e16e05c122a0b3b48937b89de17b621">tie</a> (T &amp;&amp;...t) -&gt; decltype(HYDRA_EXTERNAL_NS::thrust::tie(std::forward&lt; T &gt;(t)...))</td></tr>
<tr class="memdesc:a0e16e05c122a0b3b48937b89de17b621"><td class="mdescLeft">&#160;</td><td class="mdescRight">This version of <code>tie</code> creates a new <code>tuple</code> whose elements are references which refers to this function's arguments.  <a href="#a0e16e05c122a0b3b48937b89de17b621">More...</a><br /></td></tr>
<tr class="separator:a0e16e05c122a0b3b48937b89de17b621"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb028ec526f8e42bf272cd1908fae5fb"><td class="memTemplParams" colspan="2">template&lt;hydra::detail::Backend BACKEND, typename Iterator1 , typename Iterator2 &gt; </td></tr>
<tr class="memitem:gaeb028ec526f8e42bf272cd1908fae5fb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacehydra.html#classhydra_1_1GenericRange">GenericRange</a>&lt; Iterator2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__random.html#gaeb028ec526f8e42bf272cd1908fae5fb">unweight</a> (<a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; const  &amp;policy, Iterator1 wbegin, Iterator1 wend, Iterator2 <a class="el" href="namespacehydra.html#a3fabb476eec3a6c72fc8405f350946e1">begin</a>)</td></tr>
<tr class="memdesc:gaeb028ec526f8e42bf272cd1908fae5fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This functions reorder a dataset to put produce a unweighted sample according to the weights [wbegin, wend].  <a href="group__random.html#gaeb028ec526f8e42bf272cd1908fae5fb">More...</a><br /></td></tr>
<tr class="separator:gaeb028ec526f8e42bf272cd1908fae5fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6666975955b48dc2551ceb413ffa611"><td class="memTemplParams" colspan="2">template&lt;hydra::detail::Backend BACKEND, typename Functor , typename Iterator &gt; </td></tr>
<tr class="memitem:gae6666975955b48dc2551ceb413ffa611"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">hydra::detail::is_hydra_functor</a>&lt; Functor &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1GenericRange">GenericRange</a>&lt; Iterator &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__random.html#gae6666975955b48dc2551ceb413ffa611">unweight</a> (<a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; const  &amp;policy, Iterator <a class="el" href="namespacehydra.html#a3fabb476eec3a6c72fc8405f350946e1">begin</a>, Iterator <a class="el" href="namespacehydra.html#abbb0cd4e50b5ece72164e5a2bb6921ac">end</a>, Functor const  &amp;functor)</td></tr>
<tr class="memdesc:gae6666975955b48dc2551ceb413ffa611"><td class="mdescLeft">&#160;</td><td class="mdescRight">This functions reorder a dataset to put produce a unweighted sample according to.  <a href="group__random.html#gae6666975955b48dc2551ceb413ffa611">More...</a><br /></td></tr>
<tr class="separator:gae6666975955b48dc2551ceb413ffa611"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga039a5582fbb2830db577f02056555a6d"><td class="memTemplParams" colspan="2">template&lt;typename L , typename ... T&gt; </td></tr>
<tr class="memitem:ga039a5582fbb2830db577f02056555a6d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__functor.html#ga039a5582fbb2830db577f02056555a6d">wrap_lambda</a> (L const &amp;f, T ...pars) -&gt; decltype(<a class="el" href="namespacehydra_1_1detail.html#a34f5637c265f0432130b335c2590345b">detail::wrap_lambda_helper</a>(f, typename <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1function__traits">detail::function_traits</a>&lt; L &gt;::return_type(), typename <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1function__traits">detail::function_traits</a>&lt; L &gt;::args_type(), std::array&lt; <a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a>, sizeof...(T)&gt;()))</td></tr>
<tr class="memdesc:ga039a5582fbb2830db577f02056555a6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function template for wrap a C++11 lambda into a hydra lambda with a certain number of parameters.  <a href="group__functor.html#ga039a5582fbb2830db577f02056555a6d">More...</a><br /></td></tr>
<tr class="separator:ga039a5582fbb2830db577f02056555a6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53506830108537bc49811415296ba738"><td class="memTemplParams" colspan="2">template&lt;typename L &gt; </td></tr>
<tr class="memitem:ga53506830108537bc49811415296ba738"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__functor.html#ga53506830108537bc49811415296ba738">wrap_lambda</a> (L const &amp;f) -&gt; decltype(<a class="el" href="namespacehydra_1_1detail.html#a34f5637c265f0432130b335c2590345b">detail::wrap_lambda_helper</a>(f, typename <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1function__traits">detail::function_traits</a>&lt; L &gt;::return_type(), typename <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1function__traits">detail::function_traits</a>&lt; L &gt;::args_type()))</td></tr>
<tr class="memdesc:ga53506830108537bc49811415296ba738"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function template for wrap a C++11 lambda into a hydra lambda.  <a href="group__functor.html#ga53506830108537bc49811415296ba738">More...</a><br /></td></tr>
<tr class="separator:ga53506830108537bc49811415296ba738"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ab14adaa26f703b8c130df530167ebd23"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacehydra.html#aa8c251ed5017d0638da929130062bcad">GBool_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ab14adaa26f703b8c130df530167ebd23">kFalse</a> = false</td></tr>
<tr class="separator:ab14adaa26f703b8c130df530167ebd23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1556536d7a73fa95e5a9c9610f76a3c1"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacehydra.html#aa8c251ed5017d0638da929130062bcad">GBool_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a1556536d7a73fa95e5a9c9610f76a3c1">kTrue</a> = true</td></tr>
<tr class="separator:a1556536d7a73fa95e5a9c9610f76a3c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5afb8f1b6ea1ba2b8fc79444e5d20f20"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_3globalScope_4.html#classint">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a5afb8f1b6ea1ba2b8fc79444e5d20f20">PrintLevel</a> = <a class="el" href="namespacehydra.html#aed873b1b84fbec3791e721b22a52d1fea1bf857a06d5b8463494a6fcac6f4ea26">WARNING</a></td></tr>
<tr class="separator:a5afb8f1b6ea1ba2b8fc79444e5d20f20"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Generic policies definition. </p>
<p>namespace thrust</p>
<p><code>thrust</code> is the top-level namespace which contains all Hydra functions and types.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000002">Todo:</a></b></dt><dd>: fix compile error in nvcc adding variants to vectors</dd></dl>
</div><hr/><h2 class="groupheader">Data Structure Documentation</h2>
<a name="classhydra_1_1Cache" id="classhydra_1_1Cache"></a>
<h2 class="memtitle"><span class="permalink"><a href="#classhydra_1_1Cache">&#9670;&nbsp;</a></span>hydra::Cache</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class hydra::Cache</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename Backend, typename ... Functors&gt;<br />
class hydra::Cache&lt; Backend, Functors &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::Cache&lt; Backend, Functors &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classhydra_1_1Cache__coll__graph.svg" width="178" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a name="classhydra_1_1GaussKronrodAdaptiveQuadrature" id="classhydra_1_1GaussKronrodAdaptiveQuadrature"></a>
<h2 class="memtitle"><span class="permalink"><a href="#classhydra_1_1GaussKronrodAdaptiveQuadrature">&#9670;&nbsp;</a></span>hydra::GaussKronrodAdaptiveQuadrature</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class hydra::GaussKronrodAdaptiveQuadrature</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;size_t NRULE, size_t NBIN, typename BACKEND&gt;<br />
class hydra::GaussKronrodAdaptiveQuadrature&lt; NRULE, NBIN, BACKEND &gt;</h3>

<dl><dt><b>Examples: </b></dt><dd><a class="el" href="adaptive_gauss_kronrod_8inl-example.html#_a5">adaptive_gauss_kronrod.inl</a>.</dd>
</dl></div><div class="dynheader">
Collaboration diagram for hydra::GaussKronrodAdaptiveQuadrature&lt; NRULE, NBIN, BACKEND &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classhydra_1_1GaussKronrodAdaptiveQuadrature__coll__graph.svg" width="207" height="118"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a name="classhydra_1_1GaussKronrodQuadrature" id="classhydra_1_1GaussKronrodQuadrature"></a>
<h2 class="memtitle"><span class="permalink"><a href="#classhydra_1_1GaussKronrodQuadrature">&#9670;&nbsp;</a></span>hydra::GaussKronrodQuadrature</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class hydra::GaussKronrodQuadrature</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;size_t NRULE, size_t NBIN, typename BACKEND&gt;<br />
class hydra::GaussKronrodQuadrature&lt; NRULE, NBIN, BACKEND &gt;</h3>

<dl><dt><b>Examples: </b></dt><dd><a class="el" href="gauss_kronrod_8inl-example.html#_a5">gauss_kronrod.inl</a>, and <a class="el" href="splot_8inl-example.html#_a11">splot.inl</a>.</dd>
</dl></div><div class="dynheader">
Collaboration diagram for hydra::GaussKronrodQuadrature&lt; NRULE, NBIN, BACKEND &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classhydra_1_1GaussKronrodQuadrature__coll__graph.svg" width="220" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a name="structhydra_1_1GaussKronrodRuleSelector" id="structhydra_1_1GaussKronrodRuleSelector"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1GaussKronrodRuleSelector">&#9670;&nbsp;</a></span>hydra::GaussKronrodRuleSelector</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::GaussKronrodRuleSelector</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;size_t N&gt;<br />
struct hydra::GaussKronrodRuleSelector&lt; N &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::GaussKronrodRuleSelector&lt; N &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1GaussKronrodRuleSelector__coll__graph.svg" width="266" height="88"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a name="classhydra_1_1GenericRange" id="classhydra_1_1GenericRange"></a>
<h2 class="memtitle"><span class="permalink"><a href="#classhydra_1_1GenericRange">&#9670;&nbsp;</a></span>hydra::GenericRange</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class hydra::GenericRange</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename ... T&gt;<br />
class hydra::GenericRange&lt; T &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::GenericRange&lt; T &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classhydra_1_1GenericRange__coll__graph.svg" width="188" height="88"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a name="classhydra_1_1GenzMalikQuadrature" id="classhydra_1_1GenzMalikQuadrature"></a>
<h2 class="memtitle"><span class="permalink"><a href="#classhydra_1_1GenzMalikQuadrature">&#9670;&nbsp;</a></span>hydra::GenzMalikQuadrature</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class hydra::GenzMalikQuadrature</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;size_t N, typename BACKEND&gt;<br />
class hydra::GenzMalikQuadrature&lt; N, BACKEND &gt;</h3>

<dl><dt><b>Examples: </b></dt><dd><a class="el" href="multidimensional_fit_8inl-example.html#_a13">multidimensional_fit.inl</a>.</dd>
</dl></div><div class="dynheader">
Collaboration diagram for hydra::GenzMalikQuadrature&lt; N, BACKEND &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classhydra_1_1GenzMalikQuadrature__coll__graph.svg" width="199" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a name="classhydra_1_1GenzMalikRule" id="classhydra_1_1GenzMalikRule"></a>
<h2 class="memtitle"><span class="permalink"><a href="#classhydra_1_1GenzMalikRule">&#9670;&nbsp;</a></span>hydra::GenzMalikRule</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class hydra::GenzMalikRule</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;size_t DIM, typename BACKEND&gt;<br />
class hydra::GenzMalikRule&lt; DIM, BACKEND &gt;</h3>

</div><div class="dynheader">
Inheritance diagram for hydra::GenzMalikRule&lt; DIM, BACKEND &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classhydra_1_1GenzMalikRule__inherit__graph.svg" width="300" height="287"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Collaboration diagram for hydra::GenzMalikRule&lt; DIM, BACKEND &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classhydra_1_1GenzMalikRule__coll__graph.svg" width="162" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a name="classhydra_1_1LambdaWrapper" id="classhydra_1_1LambdaWrapper"></a>
<h2 class="memtitle"><span class="permalink"><a href="#classhydra_1_1LambdaWrapper">&#9670;&nbsp;</a></span>hydra::LambdaWrapper</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class hydra::LambdaWrapper</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename Sig, typename L, size_t N, typename = typename std::enable_if&lt;std::is_constructible&lt;std::function&lt;Sig&gt;, L&gt;::value&gt;::type&gt;<br />
class hydra::LambdaWrapper&lt; Sig, L, N, typename &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::LambdaWrapper&lt; Sig, L, N, typename &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classhydra_1_1LambdaWrapper__coll__graph.svg" width="174" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a name="classhydra_1_1LogLikelihoodFCN" id="classhydra_1_1LogLikelihoodFCN"></a>
<h2 class="memtitle"><span class="permalink"><a href="#classhydra_1_1LogLikelihoodFCN">&#9670;&nbsp;</a></span>hydra::LogLikelihoodFCN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class hydra::LogLikelihoodFCN</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename PDF, typename Iterator, typename... Extensions&gt;<br />
class hydra::LogLikelihoodFCN&lt; PDF, Iterator, Extensions &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::LogLikelihoodFCN&lt; PDF, Iterator, Extensions &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classhydra_1_1LogLikelihoodFCN__coll__graph.svg" width="206" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a name="classhydra_1_1multiarray" id="classhydra_1_1multiarray"></a>
<h2 class="memtitle"><span class="permalink"><a href="#classhydra_1_1multiarray">&#9670;&nbsp;</a></span>hydra::multiarray</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class hydra::multiarray</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename T, size_t N, typename BACKEND&gt;<br />
class hydra::multiarray&lt; T, N, BACKEND &gt;</h3>

<dl><dt><b>Examples: </b></dt><dd><a class="el" href="dense_histogram_8inl-example.html#_a6">dense_histogram.inl</a>, <a class="el" href="multiarray_container_8inl-example.html#_a3">multiarray_container.inl</a>, <a class="el" href="multidimensional_fit_8inl-example.html#_a15">multidimensional_fit.inl</a>, <a class="el" href="sample_distribution_8inl-example.html#_a6">sample_distribution.inl</a>, <a class="el" href="sparse_histogram_8inl-example.html#_a6">sparse_histogram.inl</a>, and <a class="el" href="splot_8inl-example.html#_a14">splot.inl</a>.</dd>
</dl></div><div class="dynheader">
Inheritance diagram for hydra::multiarray&lt; T, N, BACKEND &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classhydra_1_1multiarray__inherit__graph.svg" width="318" height="316"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Collaboration diagram for hydra::multiarray&lt; T, N, BACKEND &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classhydra_1_1multiarray__coll__graph.svg" width="150" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a name="classhydra_1_1multivector" id="classhydra_1_1multivector"></a>
<h2 class="memtitle"><span class="permalink"><a href="#classhydra_1_1multivector">&#9670;&nbsp;</a></span>hydra::multivector</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class hydra::multivector</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename T, typename BACKEND&gt;<br />
class hydra::multivector&lt; T, BACKEND &gt;</h3>

<dl><dt><b>Examples: </b></dt><dd><a class="el" href="multivector_container_8inl-example.html#_a3">multivector_container.inl</a>.</dd>
</dl></div><div class="dynheader">
Inheritance diagram for hydra::multivector&lt; T, BACKEND &gt;:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="classhydra_1_1multivector__inherit__graph.svg" width="100%" height="537"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</div>
<div class="dynheader">
Collaboration diagram for hydra::multivector&lt; T, BACKEND &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classhydra_1_1multivector__coll__graph.svg" width="139" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a name="structhydra_1_1null__type" id="structhydra_1_1null__type"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1null__type">&#9670;&nbsp;</a></span>hydra::null_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::null_type</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"></div><div class="dynheader">
Collaboration diagram for hydra::null_type:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1null__type__coll__graph.svg" width="126" height="88"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a name="structhydra_1_1Plain" id="structhydra_1_1Plain"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1Plain">&#9670;&nbsp;</a></span>hydra::Plain</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::Plain</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;size_t N, typename BACKEND, typename GRND = HYDRA_EXTERNAL_NS::thrust::random::default_random_engine&gt;<br />
struct hydra::Plain&lt; N, BACKEND, GRND &gt;</h3>

<dl><dt><b>Examples: </b></dt><dd><a class="el" href="plain_mc_8inl-example.html#_a5">plain_mc.inl</a>.</dd>
</dl></div><div class="dynheader">
Collaboration diagram for hydra::Plain&lt; N, BACKEND, GRND &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1Plain__coll__graph.svg" width="202" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a name="classhydra_1_1Vegas" id="classhydra_1_1Vegas"></a>
<h2 class="memtitle"><span class="permalink"><a href="#classhydra_1_1Vegas">&#9670;&nbsp;</a></span>hydra::Vegas</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class hydra::Vegas</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;size_t N, typename BACKEND, typename GRND = HYDRA_EXTERNAL_NS::thrust::random::default_random_engine&gt;<br />
class hydra::Vegas&lt; N, BACKEND, GRND &gt;</h3>

<dl><dt><b>Examples: </b></dt><dd><a class="el" href="vegas_8inl-example.html#_a6">vegas.inl</a>.</dd>
</dl></div><div class="dynheader">
Collaboration diagram for hydra::Vegas&lt; N, BACKEND, GRND &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classhydra_1_1Vegas__coll__graph.svg" width="210" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a name="classhydra_1_1Weights" id="classhydra_1_1Weights"></a>
<h2 class="memtitle"><span class="permalink"><a href="#classhydra_1_1Weights">&#9670;&nbsp;</a></span>hydra::Weights</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class hydra::Weights</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename Backend&gt;<br />
class hydra::Weights&lt; Backend &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::Weights&lt; Backend &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classhydra_1_1Weights__coll__graph.svg" width="196" height="88"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a9fa75a3de2ad0fc8f3a5c8850fa2d9bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fa75a3de2ad0fc8f3a5c8850fa2d9bc">&#9670;&nbsp;</a></span>BoolVector_d</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="namespacehydra.html#a648839818fa9d4a58c2195a55a51e773">mc_device_vector</a>&lt;<a class="el" href="namespacehydra.html#aa8c251ed5017d0638da929130062bcad">GBool_t</a>&gt; <a class="el" href="namespacehydra.html#a9fa75a3de2ad0fc8f3a5c8850fa2d9bc">hydra::BoolVector_d</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Typedef for a <a class="el" href="group__phsp.html#classhydra_1_1Vector4R" title="This class represents four-dimensional relativistic vectors and implements common operation performed...">Vector4R</a> host vector. </p>

</div>
</div>
<a id="a274b1c32d255fc13e78a08e96de133f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a274b1c32d255fc13e78a08e96de133f0">&#9670;&nbsp;</a></span>BoolVector_h</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="namespacehydra.html#a6de6f086a44380382022dafca75de4c9">mc_host_vector</a>&lt;<a class="el" href="namespacehydra.html#aa8c251ed5017d0638da929130062bcad">GBool_t</a>&gt; <a class="el" href="namespacehydra.html#a274b1c32d255fc13e78a08e96de133f0">hydra::BoolVector_h</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="group__phsp.html#classhydra_1_1Vector3R" title="This class represents three-dimensional Euclidian vectors and implements common operation performed o...">Vector3R</a> host vector. </p>
<p>Use it to store four-vectors at <b>hydra_host</b>. </p>

</div>
</div>
<a id="a4f9af1aefe36fa4f80f57289ffb84dca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f9af1aefe36fa4f80f57289ffb84dca">&#9670;&nbsp;</a></span>complex</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">hydra::complex</a> = typedef HYDRA_EXTERNAL_NS::thrust::complex&lt;T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="dalitz_plot_8inl-example.html#a10">dalitz_plot.inl</a>.</dd>
</dl>
</div>
</div>
<a id="a7670b2993eb064d9c192d9200ab82b89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7670b2993eb064d9c192d9200ab82b89">&#9670;&nbsp;</a></span>ComplexVector_d</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="namespacehydra.html#a648839818fa9d4a58c2195a55a51e773">mc_device_vector</a>&lt;<a class="el" href="namespacehydra.html#a7ab78a78009fd9969bce04250387d13e">GComplex_t</a>&gt; <a class="el" href="namespacehydra.html#a7670b2993eb064d9c192d9200ab82b89">hydra::ComplexVector_d</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Typedef for a GReal_t device vector. </p>

</div>
</div>
<a id="af30019aaf18d88f73acd61f2f363f9f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af30019aaf18d88f73acd61f2f363f9f6">&#9670;&nbsp;</a></span>ComplexVector_h</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="namespacehydra.html#a6de6f086a44380382022dafca75de4c9">mc_host_vector</a>&lt;<a class="el" href="namespacehydra.html#a7ab78a78009fd9969bce04250387d13e">GComplex_t</a>&gt; <a class="el" href="namespacehydra.html#af30019aaf18d88f73acd61f2f363f9f6">hydra::ComplexVector_h</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Typedef for a GReal_t host vector. </p>

</div>
</div>
<a id="a1e747e9ec41024e3efe0349f8ac10062"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e747e9ec41024e3efe0349f8ac10062">&#9670;&nbsp;</a></span>default_random_engine</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacehydra.html#a1e747e9ec41024e3efe0349f8ac10062">hydra::default_random_engine</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An implementation-defined "default" random number engine. </p>
<dl class="section note"><dt>Note</dt><dd><code>default_random_engine</code> is currently an alias for <code>minstd_rand</code>, and may change in a future version. </dd></dl>

</div>
</div>
<a id="ada2d81895ace081c5204b9adc76a2808"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada2d81895ace081c5204b9adc76a2808">&#9670;&nbsp;</a></span>FourVectors_h</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="namespacehydra.html#a6de6f086a44380382022dafca75de4c9">mc_host_vector</a>&lt;<a class="el" href="group__phsp.html#classhydra_1_1Vector4R">Vector4R</a>&gt; <a class="el" href="namespacehydra.html#ada2d81895ace081c5204b9adc76a2808">hydra::FourVectors_h</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Typedef for complex number. </p>

</div>
</div>
<a id="aa8c251ed5017d0638da929130062bcad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8c251ed5017d0638da929130062bcad">&#9670;&nbsp;</a></span>GBool_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="namespace_3globalScope_4.html#classbool">bool</a> <a class="el" href="namespacehydra.html#aa8c251ed5017d0638da929130062bcad">hydra::GBool_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Boolean (0=false, 1=true) (bool) </p>

</div>
</div>
<a id="ae2da2ab0037e6bca3cb7c15adc5c4125"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2da2ab0037e6bca3cb7c15adc5c4125">&#9670;&nbsp;</a></span>GByte_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef unsigned char <a class="el" href="namespacehydra.html#ae2da2ab0037e6bca3cb7c15adc5c4125">hydra::GByte_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Byte (8 bits) (unsigned char) </p>

</div>
</div>
<a id="a7ab04a199389c4989174dc115507fa89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ab04a199389c4989174dc115507fa89">&#9670;&nbsp;</a></span>GChar_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef char <a class="el" href="namespacehydra.html#a7ab04a199389c4989174dc115507fa89">hydra::GChar_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signed Character 1 byte (char) </p>

</div>
</div>
<a id="a7ab78a78009fd9969bce04250387d13e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ab78a78009fd9969bce04250387d13e">&#9670;&nbsp;</a></span>GComplex_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef HYDRA_EXTERNAL_NS::thrust::complex&lt;<a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>&gt; <a class="el" href="namespacehydra.html#a7ab78a78009fd9969bce04250387d13e">hydra::GComplex_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af986267d40d932c5cbf0ae874a506f83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af986267d40d932c5cbf0ae874a506f83">&#9670;&nbsp;</a></span>GDouble_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> <a class="el" href="namespacehydra.html#af986267d40d932c5cbf0ae874a506f83">hydra::GDouble_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Double 8 bytes. </p>

</div>
</div>
<a id="a71bab7b854d7b3c3042fe47201b765eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71bab7b854d7b3c3042fe47201b765eb">&#9670;&nbsp;</a></span>GFloat_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef float <a class="el" href="namespacehydra.html#a71bab7b854d7b3c3042fe47201b765eb">hydra::GFloat_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Float 4 bytes (float) </p>

</div>
</div>
<a id="a0c9fb4d7195ab952da10a82d5c4ad30e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c9fb4d7195ab952da10a82d5c4ad30e">&#9670;&nbsp;</a></span>GInt_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="namespace_3globalScope_4.html#classint">int</a> <a class="el" href="namespacehydra.html#a0c9fb4d7195ab952da10a82d5c4ad30e">hydra::GInt_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signed integer 4 bytes (int) </p>

</div>
</div>
<a id="a9d68c21fb715bbfb1edc5b1933b173e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d68c21fb715bbfb1edc5b1933b173e9">&#9670;&nbsp;</a></span>GLong64_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef long long <a class="el" href="namespacehydra.html#a9d68c21fb715bbfb1edc5b1933b173e9">hydra::GLong64_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Portable signed long integer 8 bytes. </p>

</div>
</div>
<a id="a5f57a4025b40929c2708cd544c3a1ccd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f57a4025b40929c2708cd544c3a1ccd">&#9670;&nbsp;</a></span>GLong_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef long <a class="el" href="namespacehydra.html#a5f57a4025b40929c2708cd544c3a1ccd">hydra::GLong_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signed long integer 4 bytes (long) </p>

</div>
</div>
<a id="a751abe69b482cde879c718fd4775733f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a751abe69b482cde879c718fd4775733f">&#9670;&nbsp;</a></span>GLongDouble_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef long <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> <a class="el" href="namespacehydra.html#a751abe69b482cde879c718fd4775733f">hydra::GLongDouble_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Long Double. </p>

</div>
</div>
<a id="a971e94bcb8c43741d11f9d8eb98f5fab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a971e94bcb8c43741d11f9d8eb98f5fab">&#9670;&nbsp;</a></span>GReal_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> <a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">hydra::GReal_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Double 16 bytes or float 4 bytes. </p>

</div>
</div>
<a id="a589c60d92ba893c28d814edd6e149a9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a589c60d92ba893c28d814edd6e149a9c">&#9670;&nbsp;</a></span>GShort_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef short <a class="el" href="namespacehydra.html#a589c60d92ba893c28d814edd6e149a9c">hydra::GShort_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signed Short integer 2 bytes (short) </p>

</div>
</div>
<a id="abc842c1ec8321e9637dee714dcdaebff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc842c1ec8321e9637dee714dcdaebff">&#9670;&nbsp;</a></span>GText_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef char <a class="el" href="namespacehydra.html#abc842c1ec8321e9637dee714dcdaebff">hydra::GText_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>General string (char) </p>

</div>
</div>
<a id="a51ef97faee95aa79f3839eb7abdf5238"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51ef97faee95aa79f3839eb7abdf5238">&#9670;&nbsp;</a></span>GUChar_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef unsigned char <a class="el" href="namespacehydra.html#a51ef97faee95aa79f3839eb7abdf5238">hydra::GUChar_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unsigned Character 1 byte (unsigned char) </p>

</div>
</div>
<a id="a251a7b1f515ac1ed9409afd67252a32b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a251a7b1f515ac1ed9409afd67252a32b">&#9670;&nbsp;</a></span>GUInt_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef unsigned <a class="el" href="namespace_3globalScope_4.html#classint">int</a> <a class="el" href="namespacehydra.html#a251a7b1f515ac1ed9409afd67252a32b">hydra::GUInt_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unsigned integer 4 bytes (unsigned int) </p>

</div>
</div>
<a id="a55e8443cd746900da90cb1f77807e7c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55e8443cd746900da90cb1f77807e7c0">&#9670;&nbsp;</a></span>GULong64_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef unsigned long long <a class="el" href="namespacehydra.html#a55e8443cd746900da90cb1f77807e7c0">hydra::GULong64_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Portable unsigned long integer 8 bytes. </p>

</div>
</div>
<a id="abf9a0d54fd4ed46052939549edd086c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf9a0d54fd4ed46052939549edd086c5">&#9670;&nbsp;</a></span>GULong_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef unsigned long <a class="el" href="namespacehydra.html#abf9a0d54fd4ed46052939549edd086c5">hydra::GULong_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a911a3042526fac189d0c87a089f52955"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a911a3042526fac189d0c87a089f52955">&#9670;&nbsp;</a></span>GUShort_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef unsigned short <a class="el" href="namespacehydra.html#a911a3042526fac189d0c87a089f52955">hydra::GUShort_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unsigned Short integer 2 bytes (unsigned short) </p>

</div>
</div>
<a id="a648839818fa9d4a58c2195a55a51e773"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a648839818fa9d4a58c2195a55a51e773">&#9670;&nbsp;</a></span>mc_device_vector</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacehydra.html#a648839818fa9d4a58c2195a55a51e773">hydra::mc_device_vector</a> = typedef HYDRA_EXTERNAL_NS::thrust::device_vector&lt;T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generic template typedef for HYDRA_EXTERNAL_NS::thrust::host_vector. </p>
<p>Use it instead of Thrust implementation in order to avoid problems to compile OpenMP based applications using gcc and without a cuda runtime installation. </p>

</div>
</div>
<a id="a6de6f086a44380382022dafca75de4c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6de6f086a44380382022dafca75de4c9">&#9670;&nbsp;</a></span>mc_host_vector</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacehydra.html#a6de6f086a44380382022dafca75de4c9">hydra::mc_host_vector</a> = typedef HYDRA_EXTERNAL_NS::thrust::host_vector&lt;T, HYDRA_EXTERNAL_NS::thrust::system::cuda::experimental::pinned_allocator&lt;T&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generic template typedef for HYDRA_EXTERNAL_NS::thrust::host_vector. </p>
<p>Use it instead of Thrust implementation in order to avoid problems to compile OpenMP based applications using gcc and without a cuda runtime installation. mc_host_vectot will always allocate page locked memory on CUDA backends in order to maximize speed in memory transfers to the device. </p>

</div>
</div>
<a id="aeccdd58e3a4c27246dadd0930e3fb569"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeccdd58e3a4c27246dadd0930e3fb569">&#9670;&nbsp;</a></span>minstd_rand</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacehydra.html#aeccdd58e3a4c27246dadd0930e3fb569">hydra::minstd_rand</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A random number engine with predefined parameters which implements a version of the Minimal Standard random number generation algorithm. </p>
<dl class="section note"><dt>Note</dt><dd>The 10000th consecutive invocation of a default-constructed object of type <code>minstd_rand</code> shall produce the value <code>399268537</code> . </dd></dl>

</div>
</div>
<a id="ab7c3603cf7a6c467176d8be9dd2c82fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7c3603cf7a6c467176d8be9dd2c82fd">&#9670;&nbsp;</a></span>minstd_rand0</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacehydra.html#ab7c3603cf7a6c467176d8be9dd2c82fd">hydra::minstd_rand0</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A random number engine with predefined parameters which implements a version of the Minimal Standard random number generation algorithm. </p>
<dl class="section note"><dt>Note</dt><dd>The 10000th consecutive invocation of a default-constructed object of type <code>minstd_rand0</code> shall produce the value <code>1043618065</code> . </dd></dl>

</div>
</div>
<a id="acf5241d6a56b2040e9cc9ea860b4cbff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf5241d6a56b2040e9cc9ea860b4cbff">&#9670;&nbsp;</a></span>pair</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacehydra.html#acf5241d6a56b2040e9cc9ea860b4cbff">hydra::pair</a> = typedef HYDRA_EXTERNAL_NS::thrust::pair&lt;T1,T2&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>pair</code> template is an alias to the HYDRA_EXTERNAL_NS::thrust::pair structure. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>The type of <code>pair's</code> first object type. There are no requirements on the type of <code>T1</code>. <code>T1</code>'s type is provided by <code>pair::first_type</code>.</td></tr>
    <tr><td class="paramname">T2</td><td>The type of <code>pair's</code> second object type. There are no requirements on the type of <code>T2</code>. <code>T2</code>'s type is provided by <code>pair::second_type</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae34184a169c185689e065d0c30f9ffba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae34184a169c185689e065d0c30f9ffba">&#9670;&nbsp;</a></span>Particles_d</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="namespacehydra.html#a648839818fa9d4a58c2195a55a51e773">mc_device_vector</a>&lt;<a class="el" href="group__phsp.html#classhydra_1_1Vector4R">Vector4R</a>&gt; <a class="el" href="namespacehydra.html#ae34184a169c185689e065d0c30f9ffba">hydra::Particles_d</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Typedef for a GComplex_t device vector. </p>

</div>
</div>
<a id="a9df2f3d6dc63cf297b0f74ba228f6c89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9df2f3d6dc63cf297b0f74ba228f6c89">&#9670;&nbsp;</a></span>Particles_h</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="namespacehydra.html#a6de6f086a44380382022dafca75de4c9">mc_host_vector</a>&lt;<a class="el" href="group__phsp.html#classhydra_1_1Vector4R">Vector4R</a>&gt; <a class="el" href="namespacehydra.html#a9df2f3d6dc63cf297b0f74ba228f6c89">hydra::Particles_h</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Typedef for a GComplex_t host vector. </p>

</div>
</div>
<a id="a943a0571fdadbbb4bc9b17ba7ae4b59b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a943a0571fdadbbb4bc9b17ba7ae4b59b">&#9670;&nbsp;</a></span>ranlux24</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacehydra.html#a943a0571fdadbbb4bc9b17ba7ae4b59b">hydra::ranlux24</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A random number engine with predefined parameters which implements the RANLUX level-3 random number generation algorithm. </p>
<dl class="section note"><dt>Note</dt><dd>The 10000th consecutive invocation of a default-constructed object of type <code>ranlux24</code> shall produce the value <code>9901578</code> . </dd></dl>

</div>
</div>
<a id="a6950c5abef4e2015f833501684940b5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6950c5abef4e2015f833501684940b5d">&#9670;&nbsp;</a></span>ranlux48</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacehydra.html#a6950c5abef4e2015f833501684940b5d">hydra::ranlux48</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A random number engine with predefined parameters which implements the RANLUX level-4 random number generation algorithm. </p>
<dl class="section note"><dt>Note</dt><dd>The 10000th consecutive invocation of a default-constructed object of type <code>ranlux48</code> shall produce the value <code>88229545517833</code> . </dd></dl>

</div>
</div>
<a id="a79fd090c6e39cfcdd744f369dacffabe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79fd090c6e39cfcdd744f369dacffabe">&#9670;&nbsp;</a></span>RealVector_d</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="namespacehydra.html#a648839818fa9d4a58c2195a55a51e773">mc_device_vector</a>&lt;<a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>&gt; <a class="el" href="namespacehydra.html#a79fd090c6e39cfcdd744f369dacffabe">hydra::RealVector_d</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Typedef for a GBool_t device vector. </p>

</div>
</div>
<a id="a6d21da5996b50a240e6f400025e3b139"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d21da5996b50a240e6f400025e3b139">&#9670;&nbsp;</a></span>RealVector_h</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="namespacehydra.html#a6de6f086a44380382022dafca75de4c9">mc_host_vector</a>&lt;<a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>&gt; <a class="el" href="namespacehydra.html#a6d21da5996b50a240e6f400025e3b139">hydra::RealVector_h</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Typedef for a GBool_t host vector. </p>

</div>
</div>
<a id="a2633cfe1492c02cfb2aef6a79804f191"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2633cfe1492c02cfb2aef6a79804f191">&#9670;&nbsp;</a></span>taus88</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacehydra.html#a2633cfe1492c02cfb2aef6a79804f191">hydra::taus88</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A random number engine with predefined parameters which implements L'Ecuyer's 1996 three-component Tausworthe random number generator. </p>
<dl class="section note"><dt>Note</dt><dd>The 10000th consecutive invocation of a default-constructed object of type <code>taus88</code> shall produce the value <code>3535848941</code> . </dd></dl>

</div>
</div>
<a id="a7dcdb1155222988a4250114d880e8b46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dcdb1155222988a4250114d880e8b46">&#9670;&nbsp;</a></span>ThreeVectors_h</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="namespacehydra.html#a6de6f086a44380382022dafca75de4c9">mc_host_vector</a>&lt;<a class="el" href="group__phsp.html#classhydra_1_1Vector3R">Vector3R</a>&gt; <a class="el" href="namespacehydra.html#a7dcdb1155222988a4250114d880e8b46">hydra::ThreeVectors_h</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="group__phsp.html#classhydra_1_1Vector4R" title="This class represents four-dimensional relativistic vectors and implements common operation performed...">Vector4R</a> host vector. </p>
<p>Use it to store four-vectors at <b>hydra_host</b>. </p>

</div>
</div>
<a id="a5e59cc0127adfac6b799c5fd6785431b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e59cc0127adfac6b799c5fd6785431b">&#9670;&nbsp;</a></span>tuple</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacehydra.html#a5e59cc0127adfac6b799c5fd6785431b">hydra::tuple</a> = typedef HYDRA_EXTERNAL_NS::thrust::tuple&lt;T...&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>tuple</code> template is an alias to the variadic version of HYDRA_EXTERNAL_NS::thrust::tuple and that can be instantiated with a indefinite number of arguments. </p>
<p>Each template argument specifies the type of element in the <code>tuple</code>. Consequently, tuples are heterogeneous, fixed-size collections of values. An instantiation of <code>tuple</code> with two arguments is similar to an instantiation of <code>pair</code> with the same two arguments. Individual elements of a <code>tuple</code> may be accessed with the <code>get</code> function.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TN</td><td>The type of the <code>N</code> <code>tuple</code> element.</td></tr>
  </table>
  </dd>
</dl>
<p>The following code snippet demonstrates how to create a new <code>tuple</code> object and inspect and modify the value of its elements.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;hydra/tuple.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line">...</div><div class="line"><span class="comment">// create a tuple containing an int, a float, and a string</span></div><div class="line">hydra::tuple&lt;<a class="code" href="namespace_3globalScope_4.html#classint">int</a>, float, <span class="keyword">const</span> <span class="keywordtype">char</span>*&gt; t(13, 0.1f, <span class="stringliteral">&quot;hydra&quot;</span>);</div><div class="line"></div><div class="line"><span class="comment">// individual members are accessed with the free function get</span></div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;The first element&#39;s value is &quot;</span> &lt;&lt; hydra::get&lt;0&gt;(t) &lt;&lt; std::endl;</div><div class="line"></div><div class="line"><span class="comment">// or the member function get</span></div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;The second element&#39;s value is &quot;</span> &lt;&lt; t.get&lt;1&gt;() &lt;&lt; std::endl;</div><div class="line"></div><div class="line"><span class="comment">// we can also modify elements with the same function</span></div><div class="line">hydra::get&lt;0&gt;(t) += 10;</div></div><!-- fragment --> 
</div>
</div>
<a id="a3ecb38ba9198aee2de36f374d07638de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ecb38ba9198aee2de36f374d07638de">&#9670;&nbsp;</a></span>tuple_element</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N, class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacehydra.html#a3ecb38ba9198aee2de36f374d07638de">hydra::tuple_element</a> = typedef HYDRA_EXTERNAL_NS::thrust::tuple_element&lt;N,T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The <code>get</code> function returns a <code>const</code> reference to a <code>tuple</code> element of interest. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>A reference to a <code>tuple</code> of interest. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>const</code> reference to <code>t's</code> <code>N</code>th element.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">N</td><td>The index of the element of interest.</td></tr>
  </table>
  </dd>
</dl>
<p>The following code snippet demonstrates how to use <code>get</code> to print the value of a <code>tuple</code> element.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="Tuple_8h.html">hydra/Tuple.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line">...</div><div class="line">hydra::tuple&lt;<a class="code" href="namespace_3globalScope_4.html#classint">int</a>, <span class="keyword">const</span> <span class="keywordtype">char</span> *&gt; t(13, <span class="stringliteral">&quot;hydra&quot;</span>);</div><div class="line"></div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;The 1st value of t is &quot;</span> &lt;&lt; hydra::get&lt;0&gt;(t) &lt;&lt; std::endl;</div></div><!-- fragment --><p>This metafunction returns the type of a <code>tuple's</code> <code>N</code>th element.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">N</td><td>This parameter selects the element of interest. </td></tr>
    <tr><td class="paramname">T</td><td>A <code>tuple</code> type of interest. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab06a4451f99b94119ead1dcadf2b8e31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab06a4451f99b94119ead1dcadf2b8e31">&#9670;&nbsp;</a></span>tuple_size</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacehydra.html#ab06a4451f99b94119ead1dcadf2b8e31">hydra::tuple_size</a> = typedef HYDRA_EXTERNAL_NS::thrust::tuple_size&lt;T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This metafunction returns the number of elements of a <code>tuple</code> type of interest. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>A <code>tuple</code> type of interest. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="aed873b1b84fbec3791e721b22a52d1fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed873b1b84fbec3791e721b22a52d1fe">&#9670;&nbsp;</a></span>anonymous enum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aed873b1b84fbec3791e721b22a52d1fea4517ec382985cb7a39393c0da09e58d5"></a>INFO&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aed873b1b84fbec3791e721b22a52d1fea1bf857a06d5b8463494a6fcac6f4ea26"></a>WARNING&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aed873b1b84fbec3791e721b22a52d1feadbc96f88184ea3a51f68df95e2b44851"></a>ERROR&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a1107488f838687e73b39ddd8245f40d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1107488f838687e73b39ddd8245f40d0">&#9670;&nbsp;</a></span>anonymous enum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a1107488f838687e73b39ddd8245f40d0aae772e8b4c5ada0e1e4c65495702176a"></a>MODE_IMPORTANCE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1107488f838687e73b39ddd8245f40d0a28550661921a3af1306fa74a26b8569c"></a>MODE_IMPORTANCE_ONLY&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1107488f838687e73b39ddd8245f40d0acb2c0124fecbf6c1182f1cf7cd9bc37a"></a>MODE_STRATIFIED&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1107488f838687e73b39ddd8245f40d0aba2629d0445cc7ef401fd6793f047da0"></a>BINS_MAX&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a0dc858c0fb14ade1e8abc19cdd0959e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dc858c0fb14ade1e8abc19cdd0959e2">&#9670;&nbsp;</a></span>Wave</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacehydra.html#a0dc858c0fb14ade1e8abc19cdd0959e2">hydra::Wave</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Orbital angular momentum tags. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a0dc858c0fb14ade1e8abc19cdd0959e2a4f4fc5545002d4eada7e2a14c27c5dfd"></a>SWave&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0dc858c0fb14ade1e8abc19cdd0959e2ae382eaafad7afe6dee68693249ff8a45"></a>PWave&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0dc858c0fb14ade1e8abc19cdd0959e2a74097dfe50b93307e587c23f9180b6b3"></a>DWave&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0dc858c0fb14ade1e8abc19cdd0959e2a82415de987820fb86ab995f1dee87db1"></a>FWave&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0dc858c0fb14ade1e8abc19cdd0959e2a113622b6b528bfd4a76d68e9a99ac032"></a>GWave&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0dc858c0fb14ade1e8abc19cdd0959e2af168d5a7a174aa70e881f13fdeaf4426"></a>HWave&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a5e095cca28f6bec603156fd48914aefe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e095cca28f6bec603156fd48914aefe">&#9670;&nbsp;</a></span>abs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ T hydra::abs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a256097a85b1ce0eafa6e497f46d87383"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a256097a85b1ce0eafa6e497f46d87383">&#9670;&nbsp;</a></span>acos()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt;T&gt; hydra::acos </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aec91f5ec5ff214023b38f72ec4ac1e76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec91f5ec5ff214023b38f72ec4ac1e76">&#9670;&nbsp;</a></span>acosh()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt;T&gt; hydra::acosh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4f175cc8f2c59f6cf2c416354fdb951f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f175cc8f2c59f6cf2c416354fdb951f">&#9670;&nbsp;</a></span>apply_filter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , typename Functor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacehydra.html#classhydra_1_1GenericRange">hydra::GenericRange</a>&lt; typename Container::iterator &gt; hydra::apply_filter </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Functor const &amp;&#160;</td>
          <td class="paramname"><em>filter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply a filter to the range [first, last] and return a pair of iterators for the filtered events. </p>
<p>This function will not change the size of the original range, [first, last], but will reorder the entries to put together the accepted entries. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>Iterator pointing to the begin of the range to filter. </td></tr>
    <tr><td class="paramname">last</td><td>Iterator pointing to the end of the range to filter. </td></tr>
    <tr><td class="paramname">filter</td><td>Functor returning bool. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="basic_fit_8inl-example.html#a13">basic_fit.inl</a>, <a class="el" href="extended_logLL_fit_8inl-example.html#a19">extended_logLL_fit.inl</a>, <a class="el" href="fit_gaussian_8C-example.html#a13">fit_gaussian.C</a>, <a class="el" href="fractional_logLL_fit_8inl-example.html#a18">fractional_logLL_fit.inl</a>, <a class="el" href="multidimensional_fit_8inl-example.html#a18">multidimensional_fit.inl</a>, and <a class="el" href="splot_8inl-example.html#a20">splot.inl</a>.</dd>
</dl>
</div>
</div>
<a id="ae96191cbaa62c58f63b7e58924362c24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae96191cbaa62c58f63b7e58924362c24">&#9670;&nbsp;</a></span>arg()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ T hydra::arg </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9a7e65b9bb4aca1f24356f2d43f91bda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a7e65b9bb4aca1f24356f2d43f91bda">&#9670;&nbsp;</a></span>asin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt;T&gt; hydra::asin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abd779382ac3242158686664a9a3ca3a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd779382ac3242158686664a9a3ca3a0">&#9670;&nbsp;</a></span>asinh()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt;T&gt; hydra::asinh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9772b7e92ecdf60524cde428c1670bd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9772b7e92ecdf60524cde428c1670bd4">&#9670;&nbsp;</a></span>atan()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt;T&gt; hydra::atan </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a24b7bc13880335fdf6964df5034ade29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24b7bc13880335fdf6964df5034ade29">&#9670;&nbsp;</a></span>atanh()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt;T&gt; hydra::atanh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acd995d684b15024c891571fe47518404"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd995d684b15024c891571fe47518404">&#9670;&nbsp;</a></span>BarrierFactor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;hydra::Wave L&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> hydra::BarrierFactor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td>
          <td class="paramname"><em>p0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Blatt-Weisskopf B' functions. </p>
<p>These functions are normalized to give to give \( B&#39;_L = 1 \) for \( z = z_0 = (|p_0 |/d)^2\) where \( p_0\) is the value of p when \( m_ab = m_r \). The centrifugal barrier is to be moved to the dynamical functions.</p>
<p class="formulaDsp">
\[ B&#39;_{0}(d,p_0,p) =1\\ B&#39;_{1}(d,p_0,p) = \sqrt{ \frac{1 +(p_0d)^2 }{ 1 +(pd)^2 } \\ B&#39;_{2}(d,p_0,p) = \sqrt{ \frac{9 + 3(p_0d)^2 + (p_0d)^4 }{9 + 3(pd)^2 + (pd)^4} \\ B&#39;_{3}(d,p_0,p) = \sqrt{ \frac{225 + 45(p_0d)^2 + 6(p_0d)^4 + (p_0d)^6 }{225 + 45(pd)^2 + 6(pd)^4 + (pd)^6 } \\ B&#39;_{4}(d,p_0,p) = \sqrt{ \frac{11025 + 1575(p_0d)^2 + 135(p_0d)^4 + 10(p_0d)^6 + (p_0 d)^8}{11025 + 1575(p_0d)^2 + 135(p_0d)^4 + 10(p_0d)^6 + (p_0 d)^8} \\ B&#39;_{5}(d,p_0,p) = \sqrt{ \frac{893025 + 99225(p_0d)^2 + 6300(p_0d)^4 + 315(p_0d)^6 + 15(p_0d)^8 + (p_0d)^10 }{893025 + 99225(pd)^2 + 6300(pd)^4 + 315(pd)^6 + 15(pd)^8 + (pd)^10}\\ \]
</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">L</td><td><a class="el" href="namespacehydra.html#a0dc858c0fb14ade1e8abc19cdd0959e2" title="Orbital angular momentum tags. ">hydra::Wave</a> vertex wave </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">radi</td><td>decay vertex radio </td></tr>
    <tr><td class="paramname">p0</td><td>momentum of the resonance at the decaying particle rest frame with nominal mass. </td></tr>
    <tr><td class="paramname">p</td><td>p momentum of the resonance at the decaying particle rest frame with a given invariant mass. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>real number</dd></dl>
<p>References:</p><ul>
<li>J. Blatt and V. Weisskopf, Theoretical Nuclear Physics , New York: John Wiley &amp; Sons (1952)</li>
<li>M. Lax, H. Feshbach J. Acoust Soc.Am. 1948 20:2, 108-124 (<a href="https://doi.org/10.1121/1.1906352">https://doi.org/10.1121/1.1906352</a>)</li>
<li>S. U. Chung, Formulas for Angular-Momentum Barrier Factors, BNL-QGS-06-101 </li>
</ul>

</div>
</div>
<a id="a03f4e98f986e55037e1a01fe4d9b8fc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03f4e98f986e55037e1a01fe4d9b8fc8">&#9670;&nbsp;</a></span>BarrierFactor&lt; hydra::DWave &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> <a class="el" href="namespacehydra.html#acd995d684b15024c891571fe47518404">hydra::BarrierFactor</a>&lt; <a class="el" href="namespacehydra.html#a0dc858c0fb14ade1e8abc19cdd0959e2a74097dfe50b93307e587c23f9180b6b3">hydra::DWave</a> &gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td>
          <td class="paramname"><em>radi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td>
          <td class="paramname"><em>p0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac5a1e302e48427c947ab2084811df1df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5a1e302e48427c947ab2084811df1df">&#9670;&nbsp;</a></span>BarrierFactor&lt; hydra::FWave &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> <a class="el" href="namespacehydra.html#acd995d684b15024c891571fe47518404">hydra::BarrierFactor</a>&lt; <a class="el" href="namespacehydra.html#a0dc858c0fb14ade1e8abc19cdd0959e2a82415de987820fb86ab995f1dee87db1">hydra::FWave</a> &gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td>
          <td class="paramname"><em>radi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td>
          <td class="paramname"><em>p0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac0e0a9c294368d8d5b74fb919e261bef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0e0a9c294368d8d5b74fb919e261bef">&#9670;&nbsp;</a></span>BarrierFactor&lt; hydra::GWave &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> <a class="el" href="namespacehydra.html#acd995d684b15024c891571fe47518404">hydra::BarrierFactor</a>&lt; <a class="el" href="namespacehydra.html#a0dc858c0fb14ade1e8abc19cdd0959e2a113622b6b528bfd4a76d68e9a99ac032">hydra::GWave</a> &gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td>
          <td class="paramname"><em>radi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td>
          <td class="paramname"><em>p0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae223d417259cf7e660fd89a54438d45b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae223d417259cf7e660fd89a54438d45b">&#9670;&nbsp;</a></span>BarrierFactor&lt; hydra::HWave &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> <a class="el" href="namespacehydra.html#acd995d684b15024c891571fe47518404">hydra::BarrierFactor</a>&lt; <a class="el" href="namespacehydra.html#a0dc858c0fb14ade1e8abc19cdd0959e2af168d5a7a174aa70e881f13fdeaf4426">hydra::HWave</a> &gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td>
          <td class="paramname"><em>radi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td>
          <td class="paramname"><em>p0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa78649879f76b3b52249830df2482980"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa78649879f76b3b52249830df2482980">&#9670;&nbsp;</a></span>BarrierFactor&lt; hydra::PWave &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> <a class="el" href="namespacehydra.html#acd995d684b15024c891571fe47518404">hydra::BarrierFactor</a>&lt; <a class="el" href="namespacehydra.html#a0dc858c0fb14ade1e8abc19cdd0959e2ae382eaafad7afe6dee68693249ff8a45">hydra::PWave</a> &gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td>
          <td class="paramname"><em>radi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td>
          <td class="paramname"><em>p0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aab59597f876fc220d388f5911bb9822c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab59597f876fc220d388f5911bb9822c">&#9670;&nbsp;</a></span>BarrierFactor&lt; hydra::SWave &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> <a class="el" href="namespacehydra.html#acd995d684b15024c891571fe47518404">hydra::BarrierFactor</a>&lt; <a class="el" href="namespacehydra.html#a0dc858c0fb14ade1e8abc19cdd0959e2a4f4fc5545002d4eada7e2a14c27c5dfd">hydra::SWave</a> &gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3fabb476eec3a6c72fc8405f350946e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fabb476eec3a6c72fc8405f350946e1">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename T , size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::begin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#classhydra_1_1multiarray">multiarray</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> -&gt; decltype(other.begin(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt;I&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8889ff1ca402595e22a39a1353161fcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8889ff1ca402595e22a39a1353161fcb">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename T , size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::begin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#classhydra_1_1multiarray">multiarray</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> -&gt; decltype(other.begin(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt;I&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afe8c272359dca5fb49f5a76d4cf93451"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe8c272359dca5fb49f5a76d4cf93451">&#9670;&nbsp;</a></span>begin() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::begin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> -&gt; decltype(other.begin(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt;I&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4f1cb0e2e3473d8e25b079dd72b8bc8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f1cb0e2e3473d8e25b079dd72b8bc8a">&#9670;&nbsp;</a></span>begin() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::begin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> -&gt; decltype(other.begin(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt;I&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a39ca77c714b3e8b913c37d323cfd5640"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39ca77c714b3e8b913c37d323cfd5640">&#9670;&nbsp;</a></span>boostTo() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ <a class="el" href="group__phsp.html#classhydra_1_1Vector4R">Vector4R</a> hydra::boostTo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__phsp.html#classhydra_1_1Vector4R">Vector4R</a> &amp;&#160;</td>
          <td class="paramname"><em>rs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__phsp.html#classhydra_1_1Vector4R">Vector4R</a> &amp;&#160;</td>
          <td class="paramname"><em>p4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_3globalScope_4.html#classbool">bool</a>&#160;</td>
          <td class="paramname"><em>inverse</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1c1de9e4fabdb747b9e3352ef6298476"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c1de9e4fabdb747b9e3352ef6298476">&#9670;&nbsp;</a></span>boostTo() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ <a class="el" href="group__phsp.html#classhydra_1_1Vector4R">Vector4R</a> hydra::boostTo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__phsp.html#classhydra_1_1Vector4R">Vector4R</a> &amp;&#160;</td>
          <td class="paramname"><em>rs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__phsp.html#classhydra_1_1Vector3R">Vector3R</a> &amp;&#160;</td>
          <td class="paramname"><em>boost</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_3globalScope_4.html#classbool">bool</a>&#160;</td>
          <td class="paramname"><em>inverse</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a63f3e9bfd1cc2dc4e593ef68f76ba3c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63f3e9bfd1cc2dc4e593ef68f76ba3c6">&#9670;&nbsp;</a></span>compose()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T0 , typename T1 , typename ... Ts, typename  = typename std::enable_if&lt;T0::is_functor::value &amp;&amp; T1::is_functor::value &amp;&amp; detail::all_true&lt;Ts::is_functor::value...&gt;::value &gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ <a class="el" href="classhydra_1_1Compose.html">Compose</a>&lt;T0,T1,Ts...&gt; hydra::compose </td>
          <td>(</td>
          <td class="paramtype">T0 const &amp;&#160;</td>
          <td class="paramname"><em>F0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T1 const &amp;&#160;</td>
          <td class="paramname"><em>F1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ts const &amp;...&#160;</td>
          <td class="paramname"><em>Fs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="dalitz_plot_8inl-example.html#a27">dalitz_plot.inl</a>.</dd>
</dl>
</div>
</div>
<a id="ad2ffe3ace108474a31b8cb84ceae7f14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2ffe3ace108474a31b8cb84ceae7f14">&#9670;&nbsp;</a></span>conj()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt;T&gt; hydra::conj </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a28aa8ffeea73bf98ccab0fb7cd1c8116"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28aa8ffeea73bf98ccab0fb7cd1c8116">&#9670;&nbsp;</a></span>copy() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator , typename OutputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator hydra::copy </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="basic_distributions_8inl-example.html#a3">basic_distributions.inl</a>, <a class="el" href="sample_distribution_8inl-example.html#a7">sample_distribution.inl</a>, and <a class="el" href="splot_8inl-example.html#a18">splot.inl</a>.</dd>
</dl>
</div>
</div>
<a id="a98b97d9c4a1b0350ef7c2d646c8c504a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98b97d9c4a1b0350ef7c2d646c8c504a">&#9670;&nbsp;</a></span>copy() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;detail::Backend Backend, typename InputIterator , typename OutputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator hydra::copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; Backend &gt; const &amp;&#160;</td>
          <td class="paramname"><em>policy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a82497912f037617b630d048bfcc515c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82497912f037617b630d048bfcc515c0">&#9670;&nbsp;</a></span>cos()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt;T&gt; hydra::cos </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="dalitz_plot_8inl-example.html#a17">dalitz_plot.inl</a>.</dd>
</dl>
</div>
</div>
<a id="ac9aa7456a15f61cd1ed2b5ef7227409e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9aa7456a15f61cd1ed2b5ef7227409e">&#9670;&nbsp;</a></span>cosh()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt;T&gt; hydra::cosh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6d55d71b4eca1da2fac83a615ea4b990"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d55d71b4eca1da2fac83a615ea4b990">&#9670;&nbsp;</a></span>cross()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ <a class="el" href="group__phsp.html#classhydra_1_1Vector3R">Vector3R</a> hydra::cross </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__phsp.html#classhydra_1_1Vector3R">Vector3R</a> &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__phsp.html#classhydra_1_1Vector3R">Vector3R</a> &amp;&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a31ec2838ed0b3d9f3e77d8b51f270c81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31ec2838ed0b3d9f3e77d8b51f270c81">&#9670;&nbsp;</a></span>distance()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ auto hydra::distance </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype( HYDRA_EXTERNAL_NS::thrust::distance&lt;Iterator&gt;(first,last))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afd869e5bd355b1c4646e2c5e1f4ed332"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd869e5bd355b1c4646e2c5e1f4ed332">&#9670;&nbsp;</a></span>divide()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename  = typename std::enable_if&lt; T1::is_functor::value &amp;&amp; T2::is_functor::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ <a class="el" href="classhydra_1_1Divide.html">Divide</a>&lt;T1,T2&gt; hydra::divide </td>
          <td>(</td>
          <td class="paramtype">T1 const &amp;&#160;</td>
          <td class="paramname"><em>F1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T1 const &amp;&#160;</td>
          <td class="paramname"><em>F2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abbb0cd4e50b5ece72164e5a2bb6921ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbb0cd4e50b5ece72164e5a2bb6921ac">&#9670;&nbsp;</a></span>end() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename T , size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#classhydra_1_1multiarray">multiarray</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> -&gt; decltype(other.end(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt;I&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="adaptive_gauss_kronrod_8inl-example.html#a6">adaptive_gauss_kronrod.inl</a>, <a class="el" href="dalitz_plot_8inl-example.html#a33">dalitz_plot.inl</a>, <a class="el" href="gauss_kronrod_8inl-example.html#a6">gauss_kronrod.inl</a>, <a class="el" href="phsp_averaging_functor_8inl-example.html#a8">phsp_averaging_functor.inl</a>, <a class="el" href="phsp_basic_8inl-example.html#a7">phsp_basic.inl</a>, <a class="el" href="phsp_chain_8inl-example.html#a15">phsp_chain.inl</a>, <a class="el" href="phsp_reweighting_8inl-example.html#a7">phsp_reweighting.inl</a>, <a class="el" href="phsp_unweighting_8inl-example.html#a6">phsp_unweighting.inl</a>, <a class="el" href="phsp_unweighting_functor_8inl-example.html#a7">phsp_unweighting_functor.inl</a>, and <a class="el" href="plain_mc_8inl-example.html#a6">plain_mc.inl</a>.</dd>
</dl>
</div>
</div>
<a id="a6394ef91cb6d9eb87c9a8f1a34fd3186"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6394ef91cb6d9eb87c9a8f1a34fd3186">&#9670;&nbsp;</a></span>end() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename T , size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#classhydra_1_1multiarray">multiarray</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> -&gt; decltype(other.end(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt;I&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5f434b6fb7d95b6ca2a386e25e6b6733"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f434b6fb7d95b6ca2a386e25e6b6733">&#9670;&nbsp;</a></span>end() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> -&gt; decltype(other.end(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt;I&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae4f44ac4277e27b370317451862a091d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4f44ac4277e27b370317451862a091d">&#9670;&nbsp;</a></span>end() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> -&gt; decltype(other.end(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt;I&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5acb87c4eb594ddbf0c4322a11cf4d8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5acb87c4eb594ddbf0c4322a11cf4d8a">&#9670;&nbsp;</a></span>exp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt;T&gt; hydra::exp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="adaptive_gauss_kronrod_8inl-example.html#a1">adaptive_gauss_kronrod.inl</a>, <a class="el" href="dense_histogram_8inl-example.html#a1">dense_histogram.inl</a>, <a class="el" href="gauss_kronrod_8inl-example.html#a1">gauss_kronrod.inl</a>, <a class="el" href="multidimensional_fit_8inl-example.html#a10">multidimensional_fit.inl</a>, <a class="el" href="plain_mc_8inl-example.html#a1">plain_mc.inl</a>, <a class="el" href="sample_distribution_8inl-example.html#a1">sample_distribution.inl</a>, <a class="el" href="sparse_histogram_8inl-example.html#a1">sparse_histogram.inl</a>, and <a class="el" href="vegas_8inl-example.html#a1">vegas.inl</a>.</dd>
</dl>
</div>
</div>
<a id="a878a4b407da6caf1173b3939f3943d33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a878a4b407da6caf1173b3939f3943d33">&#9670;&nbsp;</a></span>get() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N, typename ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::tuple_element&lt;N,HYDRA_EXTERNAL_NS::thrust::tuple&lt;T...&gt; &gt;::type hydra::get </td>
          <td>(</td>
          <td class="paramtype">HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt; const &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The <code>get</code> function returns a reference to a <code>tuple</code> element of interest. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>A reference to a <code>tuple</code> of interest. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to <code>t's</code> <code>N</code>th element.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">N</td><td>The index of the element of interest.</td></tr>
  </table>
  </dd>
</dl>
<p>The following code snippet demonstrates how to use <code>get</code> to print the value of a <code>tuple</code> element.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="Tuple_8h.html">hydra/Tuple.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line">...</div><div class="line">hydra::tuple&lt;<a class="code" href="namespace_3globalScope_4.html#classint">int</a>, <span class="keyword">const</span> <span class="keywordtype">char</span> *&gt; t(13, <span class="stringliteral">&quot;hydra&quot;</span>);</div><div class="line"></div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;The 1st value of t is &quot;</span> &lt;&lt; hydra::get&lt;0&gt;(t) &lt;&lt; std::endl;</div></div><!-- fragment --> 
</div>
</div>
<a id="a7c5d06da4c888dd9915f5b9b68ff324d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c5d06da4c888dd9915f5b9b68ff324d">&#9670;&nbsp;</a></span>get() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N, typename ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::tuple_element&lt;N,HYDRA_EXTERNAL_NS::thrust::tuple&lt;T...&gt; &gt;::type hydra::get </td>
          <td>(</td>
          <td class="paramtype">HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7b44fb8fa5030736b4603699cf172253"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b44fb8fa5030736b4603699cf172253">&#9670;&nbsp;</a></span>get() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N, typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::tuple_element&lt;N,HYDRA_EXTERNAL_NS::thrust::pair&lt;T1,T2&gt; &gt;::type hydra::get </td>
          <td>(</td>
          <td class="paramtype">HYDRA_EXTERNAL_NS::thrust::pair&lt; T1, T2 &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a24a594d0fa4c37b4550bb26317d33a42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24a594d0fa4c37b4550bb26317d33a42">&#9670;&nbsp;</a></span>get() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename T , size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#classhydra_1_1multiarray">multiarray</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> -&gt; decltype(other.column(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt;I&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9bd95a2e510a972665cc8e93abb7ad00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bd95a2e510a972665cc8e93abb7ad00">&#9670;&nbsp;</a></span>get() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> -&gt; decltype(other.column(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt;I&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7582acf570b53c033d52c6ff0fecb43e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7582acf570b53c033d52c6ff0fecb43e">&#9670;&nbsp;</a></span>GetFormatedString()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string hydra::GetFormatedString </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a482394205426de2c1a57e3284cf60699"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a482394205426de2c1a57e3284cf60699">&#9670;&nbsp;</a></span>legendre_polynomial()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int L&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> hydra::legendre_polynomial </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a94a09f96f01c93f8bbdddf5e4e221646"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94a09f96f01c93f8bbdddf5e4e221646">&#9670;&nbsp;</a></span>legendre_polynomial&lt; 0 &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> <a class="el" href="namespacehydra.html#a482394205426de2c1a57e3284cf60699">hydra::legendre_polynomial</a>&lt; 0 &gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6f1343d6c785bde83e28804a5918ac20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f1343d6c785bde83e28804a5918ac20">&#9670;&nbsp;</a></span>legendre_polynomial&lt; 1 &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> <a class="el" href="namespacehydra.html#a482394205426de2c1a57e3284cf60699">hydra::legendre_polynomial</a>&lt; 1 &gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3af5e82c0ccbbf64729ecdf4dc3c3993"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3af5e82c0ccbbf64729ecdf4dc3c3993">&#9670;&nbsp;</a></span>legendre_polynomial&lt; 2 &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> <a class="el" href="namespacehydra.html#a482394205426de2c1a57e3284cf60699">hydra::legendre_polynomial</a>&lt; 2 &gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab07923df7072e55120be2d5714f256a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab07923df7072e55120be2d5714f256a9">&#9670;&nbsp;</a></span>legendre_polynomial&lt; 3 &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> <a class="el" href="namespacehydra.html#a482394205426de2c1a57e3284cf60699">hydra::legendre_polynomial</a>&lt; 3 &gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae9a14ff57f3a87cc8ea061105fddf100"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9a14ff57f3a87cc8ea061105fddf100">&#9670;&nbsp;</a></span>legendre_polynomial&lt; 4 &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> <a class="el" href="namespacehydra.html#a482394205426de2c1a57e3284cf60699">hydra::legendre_polynomial</a>&lt; 4 &gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9913f02c30c0fd3d7664c104257f5ee9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9913f02c30c0fd3d7664c104257f5ee9">&#9670;&nbsp;</a></span>legendre_polynomial&lt; 5 &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> <a class="el" href="namespacehydra.html#a482394205426de2c1a57e3284cf60699">hydra::legendre_polynomial</a>&lt; 5 &gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2725e178af11595cbeba053c1f84dfa8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2725e178af11595cbeba053c1f84dfa8">&#9670;&nbsp;</a></span>log()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt;T&gt; hydra::log </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a64d53a33e43032b9e482284fd1a38b08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64d53a33e43032b9e482284fd1a38b08">&#9670;&nbsp;</a></span>log10()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt;T&gt; hydra::log10 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac9c36400392fc1613db3bcabd7c74575"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9c36400392fc1613db3bcabd7c74575">&#9670;&nbsp;</a></span>make_chain()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t ... N, hydra::detail::Backend BACKEND&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__phsp.html#classhydra_1_1Chains">Chains</a>&lt; <a class="el" href="group__phsp.html#classhydra_1_1Decays">Decays</a>&lt;N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt;BACKEND&gt; &gt;...&gt; hydra::make_chain </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>entries</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab8b9fd25a44634ab41c7c102a97e42cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8b9fd25a44634ab41c7c102a97e42cb">&#9670;&nbsp;</a></span>make_pair()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ auto hydra::make_pair </td>
          <td>(</td>
          <td class="paramtype">T1 &amp;&amp;&#160;</td>
          <td class="paramname"><em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2 &amp;&amp;&#160;</td>
          <td class="paramname"><em>t2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(HYDRA_EXTERNAL_NS::thrust::make_pair( std::forward&lt;T1&gt;(t1),std::forward&lt;T2&gt;(t2) ))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This version of <code>make_pair</code> creates a new <code>pair</code> object from a list of objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">T1</td><td>The first object to copy from. </td></tr>
    <tr><td class="paramname">T2</td><td>The second object to copy from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>pair</code> object with members which are copies of <code>t</code>. </dd></dl>

</div>
</div>
<a id="a8d210727c4d8b6989542eff5fd3f6319"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d210727c4d8b6989542eff5fd3f6319">&#9670;&nbsp;</a></span>make_range() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacehydra.html#classhydra_1_1GenericRange">GenericRange</a>&lt;Iterator&gt; hydra::make_range </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="dalitz_plot_8inl-example.html#a34">dalitz_plot.inl</a>, and <a class="el" href="phsp_basic_8inl-example.html#a8">phsp_basic.inl</a>.</dd>
</dl>
</div>
</div>
<a id="a1a30c855dde97a05b730cebc6682758b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a30c855dde97a05b730cebc6682758b">&#9670;&nbsp;</a></span>make_range() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator , typename Functor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">HYDRA_EXTERNAL_NS::thrust::detail::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt;Functor&gt;::value , <a class="el" href="namespacehydra.html#classhydra_1_1GenericRange">GenericRange</a>&lt;Iterator, Functor&gt; &gt;::type hydra::make_range </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Functor const &amp;&#160;</td>
          <td class="paramname"><em>functor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af5314ace45b4baa7084a9addb625ca99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5314ace45b4baa7084a9addb625ca99">&#9670;&nbsp;</a></span>make_splot()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PDF1 , typename PDF2 , typename ... PDFs&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhydra_1_1SPlot.html">SPlot</a>&lt;PDF1, PDF2, PDFs...&gt; hydra::make_splot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__fit.html#classhydra_1_1PDFSumExtendable">PDFSumExtendable</a>&lt; PDF1, PDF2, PDFs... &gt; const &amp;&#160;</td>
          <td class="paramname"><em>pdf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="splot_8inl-example.html#a24">splot.inl</a>.</dd>
</dl>
</div>
</div>
<a id="ac70a2baeff9ebf89f64ebd08ebaab2d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac70a2baeff9ebf89f64ebd08ebaab2d7">&#9670;&nbsp;</a></span>make_tuple() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ auto hydra::make_tuple </td>
          <td>(</td>
          <td class="paramtype">T const &amp;...&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td> -&gt; decltype(HYDRA_EXTERNAL_NS::thrust::make_tuple(t...))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This version of <code>make_tuple</code> creates a new <code>tuple</code> object from a list of objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">T</td><td>The first object to copy from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>tuple</code> object with members which are copies of <code>t</code>. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="dalitz_plot_8inl-example.html#a29">dalitz_plot.inl</a>, <a class="el" href="multiarray_container_8inl-example.html#a1">multiarray_container.inl</a>, <a class="el" href="multidimensional_fit_8inl-example.html#a23">multidimensional_fit.inl</a>, <a class="el" href="multivector_container_8inl-example.html#a1">multivector_container.inl</a>, and <a class="el" href="phsp_basic_8inl-example.html#a5">phsp_basic.inl</a>.</dd>
</dl>
</div>
</div>
<a id="a16ca94258b9800a2b2fe700f7012f545"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16ca94258b9800a2b2fe700f7012f545">&#9670;&nbsp;</a></span>make_tuple() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ auto hydra::make_tuple </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;...&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td> -&gt; decltype(HYDRA_EXTERNAL_NS::thrust::make_tuple( std::forward&lt;T&gt;(t)...))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This version of <code>make_tuple</code> creates a new <code>tuple</code> object from a list of objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">T</td><td>The first object to copy from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>tuple</code> object with members which are copies of <code>t</code>. </dd></dl>

</div>
</div>
<a id="acdb8665ee28f5e766b614992c0491dd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdb8665ee28f5e766b614992c0491dd7">&#9670;&nbsp;</a></span>minus()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename  = typename std::enable_if&lt; T1::is_functor::value &amp;&amp; T2::is_functor::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ <a class="el" href="classhydra_1_1Minus.html">Minus</a>&lt;T1,T2&gt; hydra::minus </td>
          <td>(</td>
          <td class="paramtype">T1 const &amp;&#160;</td>
          <td class="paramname"><em>F1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T1 const &amp;&#160;</td>
          <td class="paramname"><em>F2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a237ae37875016b34f82e3664703be679"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a237ae37875016b34f82e3664703be679">&#9670;&nbsp;</a></span>multiply()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F1 , typename F2 , typename ... Fs&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ <a class="el" href="classhydra_1_1Multiply.html">Multiply</a>&lt;F1,F2,Fs...&gt; hydra::multiply </td>
          <td>(</td>
          <td class="paramtype">F1 const &amp;&#160;</td>
          <td class="paramname"><em>f1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F2 const &amp;&#160;</td>
          <td class="paramname"><em>f2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Fs const &amp;...&#160;</td>
          <td class="paramname"><em>functors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2f06ee4cd16c4cd697a380053748bf67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f06ee4cd16c4cd697a380053748bf67">&#9670;&nbsp;</a></span>nint()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ <a class="el" href="namespace_3globalScope_4.html#classint">int</a> hydra::nint </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Round to nearest integer. </p>
<p>Rounds half integers to the nearest even integer. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="ab5fd2d8f62c3075ccdd36241e8dc6881"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5fd2d8f62c3075ccdd36241e8dc6881">&#9670;&nbsp;</a></span>norm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ T hydra::norm </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="dalitz_plot_8inl-example.html#a26">dalitz_plot.inl</a>.</dd>
</dl>
</div>
</div>
<a id="a24943c0d2419a40a68f0fb61e0a1b05f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24943c0d2419a40a68f0fb61e0a1b05f">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ <a class="el" href="namespace_3globalScope_4.html#classbool">bool</a> hydra::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a716c80436ab96c757325cae3cd517960"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a716c80436ab96c757325cae3cd517960">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ <a class="el" href="namespace_3globalScope_4.html#classbool">bool</a> hydra::operator!= </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a91d952f42e31697e4b457b1a58424cb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91d952f42e31697e4b457b1a58424cb5">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ <a class="el" href="namespace_3globalScope_4.html#classbool">bool</a> hydra::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a74f09f60eaa232f756f2e5ee0ccb5326"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74f09f60eaa232f756f2e5ee0ccb5326">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t N1, hydra::detail::Backend BACKEND1, size_t N2, hydra::detail::Backend BACKEND2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_3globalScope_4.html#classbool">bool</a> hydra::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__phsp.html#classhydra_1_1Decays">Decays</a>&lt; N1, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND1 &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__phsp.html#classhydra_1_1Decays">Decays</a>&lt; N2, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND2 &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa51499fa04d39681eb6244313d32a16c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa51499fa04d39681eb6244313d32a16c">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t N, hydra::detail::Backend BACKEND1, hydra::detail::Backend BACKEND2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_3globalScope_4.html#classbool">bool</a> hydra::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#classhydra_1_1multiarray">multiarray</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND1 &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#classhydra_1_1multiarray">multiarray</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND2 &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a258cacce52e3670d4880af1576a16a22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a258cacce52e3670d4880af1576a16a22">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND1, hydra::detail::Backend BACKEND2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_3globalScope_4.html#classbool">bool</a> hydra::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND1 &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND2 &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad01febd59c4dfebc87b5d363955d65db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad01febd59c4dfebc87b5d363955d65db">&#9670;&nbsp;</a></span>operator*() <span class="overload">[1/13]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ <a class="el" href="group__phsp.html#classhydra_1_1Vector3R">Vector3R</a> hydra::operator* </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__phsp.html#classhydra_1_1Vector3R">Vector3R</a> &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa868eaf400c854297996c269f401e69e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa868eaf400c854297996c269f401e69e">&#9670;&nbsp;</a></span>operator*() <span class="overload">[2/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename  = typename std::enable_if&lt; T1::is_functor::value &amp;&amp; T2::is_functor::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ <a class="el" href="classhydra_1_1Multiply.html">Multiply</a>&lt;T1,T2&gt; hydra::operator* </td>
          <td>(</td>
          <td class="paramtype">T1 const &amp;&#160;</td>
          <td class="paramname"><em>F1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2 const &amp;&#160;</td>
          <td class="paramname"><em>F2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0dce6130507b07eaac142c1815ade3f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dce6130507b07eaac142c1815ade3f2">&#9670;&nbsp;</a></span>operator*() <span class="overload">[3/13]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ <a class="el" href="group__phsp.html#classhydra_1_1Vector3R">Vector3R</a> hydra::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__phsp.html#classhydra_1_1Vector3R">Vector3R</a> &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2021f911a26d3c79b62d1a2f1fa9dcf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2021f911a26d3c79b62d1a2f1fa9dcf0">&#9670;&nbsp;</a></span>operator*() <span class="overload">[4/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename  = typename std::enable_if&lt; (std::is_convertible&lt;T1, double&gt;::value ||		std::is_constructible&lt;HYDRA_EXTERNAL_NS::thrust::complex&lt;double&gt;,T1&gt;::value) &amp;&amp; T2::is_functor::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ <a class="el" href="classhydra_1_1Multiply.html">Multiply</a>&lt;<a class="el" href="structhydra_1_1Constant.html">Constant</a>&lt;T1&gt;, T2&gt; hydra::operator* </td>
          <td>(</td>
          <td class="paramtype">T1 const&#160;</td>
          <td class="paramname"><em>cte</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2 const &amp;&#160;</td>
          <td class="paramname"><em>F2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afd42c2a636a5bfb4e605ddd9f1ea069a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd42c2a636a5bfb4e605ddd9f1ea069a">&#9670;&nbsp;</a></span>operator*() <span class="overload">[5/13]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ <a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> hydra::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__phsp.html#classhydra_1_1Vector3R">Vector3R</a> &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__phsp.html#classhydra_1_1Vector3R">Vector3R</a> &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afa9d6d9136eecf2c929dd9b12356d833"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa9d6d9136eecf2c929dd9b12356d833">&#9670;&nbsp;</a></span>operator*() <span class="overload">[6/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename  = typename std::enable_if&lt; (std::is_convertible&lt;T1, double&gt;::value ||		std::is_constructible&lt;HYDRA_EXTERNAL_NS::thrust::complex&lt;double&gt;,T1&gt;::value) &amp;&amp; T2::is_functor::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ <a class="el" href="classhydra_1_1Multiply.html">Multiply</a>&lt;<a class="el" href="structhydra_1_1Constant.html">Constant</a>&lt;T1&gt;, T2&gt; hydra::operator* </td>
          <td>(</td>
          <td class="paramtype">T2 const &amp;&#160;</td>
          <td class="paramname"><em>F2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T1 const&#160;</td>
          <td class="paramname"><em>cte</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae5bae5caa4d9b5c0190220e55f650859"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5bae5caa4d9b5c0190220e55f650859">&#9670;&nbsp;</a></span>operator*() <span class="overload">[7/13]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ <a class="el" href="group__phsp.html#classhydra_1_1Vector4R">Vector4R</a> hydra::operator* </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__phsp.html#classhydra_1_1Vector4R">Vector4R</a> &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae2b0be1f22ac4914bd6ce0bc97411bff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2b0be1f22ac4914bd6ce0bc97411bff">&#9670;&nbsp;</a></span>operator*() <span class="overload">[8/13]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ <a class="el" href="group__phsp.html#classhydra_1_1Vector4R">Vector4R</a> hydra::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__phsp.html#classhydra_1_1Vector4R">Vector4R</a> &amp;&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="adb096b020e55914fe7a1e885dd66b17e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb096b020e55914fe7a1e885dd66b17e">&#9670;&nbsp;</a></span>operator*() <span class="overload">[9/13]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ <a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> hydra::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__phsp.html#classhydra_1_1Vector4R">Vector4R</a> &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__phsp.html#classhydra_1_1Vector4R">Vector4R</a> &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a31bdba87b791f8a68e8571eaa00788cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31bdba87b791f8a68e8571eaa00788cd">&#9670;&nbsp;</a></span>operator*() <span class="overload">[10/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::tuple&lt;T...&gt; hydra::operator* </td>
          <td>(</td>
          <td class="paramtype">const HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0b98f3604eca3a6023551cd4ce98020a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b98f3604eca3a6023551cd4ce98020a">&#9670;&nbsp;</a></span>operator*() <span class="overload">[11/13]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ <a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a> hydra::operator* </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a>&#160;</td>
          <td class="paramname"><em>par1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a> const &amp;&#160;</td>
          <td class="paramname"><em>par2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac480ecaec81a0040f3b466ca5904ed5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac480ecaec81a0040f3b466ca5904ed5b">&#9670;&nbsp;</a></span>operator*() <span class="overload">[12/13]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ <a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> hydra::operator* </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a>&#160;</td>
          <td class="paramname"><em>par1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>&#160;</td>
          <td class="paramname"><em>par2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa0bc15a0070c95cad2a9b6e300b430cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0bc15a0070c95cad2a9b6e300b430cc">&#9670;&nbsp;</a></span>operator*() <span class="overload">[13/13]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ <a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> hydra::operator* </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>&#160;</td>
          <td class="paramname"><em>par1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a> const &amp;&#160;</td>
          <td class="paramname"><em>par2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a81ab71f63c56b41e970fee5c7fa48915"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81ab71f63c56b41e970fee5c7fa48915">&#9670;&nbsp;</a></span>operator+() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename  = typename std::enable_if&lt; T1::is_functor::value &amp;&amp; T2::is_functor::value&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ <a class="el" href="classhydra_1_1Sum.html">Sum</a>&lt;T1, T2&gt; hydra::operator+ </td>
          <td>(</td>
          <td class="paramtype">T1 const &amp;&#160;</td>
          <td class="paramname"><em>F1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2 const &amp;&#160;</td>
          <td class="paramname"><em>F2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a58bc87dddca38c44ed5276eedb78a176"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58bc87dddca38c44ed5276eedb78a176">&#9670;&nbsp;</a></span>operator+() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename  = typename std::enable_if&lt; (std::is_convertible&lt;T1, double&gt;::value ||		std::is_constructible&lt;HYDRA_EXTERNAL_NS::thrust::complex&lt;double&gt;,T1&gt;::value) &amp;&amp; T2::is_functor::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ <a class="el" href="classhydra_1_1Sum.html">Sum</a>&lt;<a class="el" href="structhydra_1_1Constant.html">Constant</a>&lt;T1&gt;, T2&gt; hydra::operator+ </td>
          <td>(</td>
          <td class="paramtype">T1 const&#160;</td>
          <td class="paramname"><em>cte</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2 const &amp;&#160;</td>
          <td class="paramname"><em>F2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="acd8f4a42269c2f7b4316a413efe5190e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd8f4a42269c2f7b4316a413efe5190e">&#9670;&nbsp;</a></span>operator+() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename  = typename std::enable_if&lt; (std::is_convertible&lt;T1, double&gt;::value ||		std::is_constructible&lt;HYDRA_EXTERNAL_NS::thrust::complex&lt;double&gt;,T1&gt;::value) &amp;&amp; T2::is_functor::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ <a class="el" href="classhydra_1_1Sum.html">Sum</a>&lt;<a class="el" href="structhydra_1_1Constant.html">Constant</a>&lt;T1&gt;, T2&gt; hydra::operator+ </td>
          <td>(</td>
          <td class="paramtype">T2 const &amp;&#160;</td>
          <td class="paramname"><em>F2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T1 const&#160;</td>
          <td class="paramname"><em>cte</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1c1fc13eb2a4a440f72991b4347a472c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c1fc13eb2a4a440f72991b4347a472c">&#9670;&nbsp;</a></span>operator+() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ <a class="el" href="group__phsp.html#classhydra_1_1Vector3R">Vector3R</a> hydra::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__phsp.html#classhydra_1_1Vector3R">Vector3R</a> &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__phsp.html#classhydra_1_1Vector3R">Vector3R</a> &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a781df21a8dca74210f8dc39b340b58ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a781df21a8dca74210f8dc39b340b58ec">&#9670;&nbsp;</a></span>operator+() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::tuple&lt;T...&gt; hydra::operator+ </td>
          <td>(</td>
          <td class="paramtype">const HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af68a4c9bed0e1a2cf2ed9ba9ab057dd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af68a4c9bed0e1a2cf2ed9ba9ab057dd0">&#9670;&nbsp;</a></span>operator+() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ <a class="el" href="group__phsp.html#classhydra_1_1Vector4R">Vector4R</a> hydra::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__phsp.html#classhydra_1_1Vector4R">Vector4R</a> &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__phsp.html#classhydra_1_1Vector4R">Vector4R</a> &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a26e3492eb046c39e1b578738cd5ad7b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26e3492eb046c39e1b578738cd5ad7b7">&#9670;&nbsp;</a></span>operator+() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ <a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a> hydra::operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a>&#160;</td>
          <td class="paramname"><em>par1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a> const &amp;&#160;</td>
          <td class="paramname"><em>par2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a357a28a5ec78cd838e8e90face792425"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a357a28a5ec78cd838e8e90face792425">&#9670;&nbsp;</a></span>operator+() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ <a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> hydra::operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a>&#160;</td>
          <td class="paramname"><em>par1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>&#160;</td>
          <td class="paramname"><em>par2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8e6b67d073431ddbbc9df286683b6391"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e6b67d073431ddbbc9df286683b6391">&#9670;&nbsp;</a></span>operator-() <span class="overload">[1/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename  = typename std::enable_if&lt; T1::is_functor::value &amp;&amp; T2::is_functor::value&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ <a class="el" href="classhydra_1_1Minus.html">Minus</a>&lt;T1,T2&gt; hydra::operator- </td>
          <td>(</td>
          <td class="paramtype">T1 const &amp;&#160;</td>
          <td class="paramname"><em>F1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2 const &amp;&#160;</td>
          <td class="paramname"><em>F2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab209688d56c7888c7fb173e06b4a63b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab209688d56c7888c7fb173e06b4a63b8">&#9670;&nbsp;</a></span>operator-() <span class="overload">[2/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename  = typename std::enable_if&lt; (std::is_convertible&lt;T1, double&gt;::value ||		std::is_constructible&lt;HYDRA_EXTERNAL_NS::thrust::complex&lt;double&gt;,T1&gt;::value) &amp;&amp; T2::is_functor::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ <a class="el" href="classhydra_1_1Minus.html">Minus</a>&lt;<a class="el" href="structhydra_1_1Constant.html">Constant</a>&lt;T1&gt;, T2&gt; hydra::operator- </td>
          <td>(</td>
          <td class="paramtype">T1 const&#160;</td>
          <td class="paramname"><em>cte</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2 const &amp;&#160;</td>
          <td class="paramname"><em>F2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa0ab9137952e574434bb5457b5e7624b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0ab9137952e574434bb5457b5e7624b">&#9670;&nbsp;</a></span>operator-() <span class="overload">[3/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename  = typename std::enable_if&lt; (std::is_convertible&lt;T1, double&gt;::value ||		std::is_constructible&lt;HYDRA_EXTERNAL_NS::thrust::complex&lt;double&gt;,T1&gt;::value) &amp;&amp; T2::is_functor::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ <a class="el" href="classhydra_1_1Minus.html">Minus</a>&lt;T2,<a class="el" href="structhydra_1_1Constant.html">Constant</a>&lt;T1&gt; &gt; hydra::operator- </td>
          <td>(</td>
          <td class="paramtype">T2 const &amp;&#160;</td>
          <td class="paramname"><em>F2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T1 const&#160;</td>
          <td class="paramname"><em>cte</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1113b35a5588af8a55453fbd5e1b2651"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1113b35a5588af8a55453fbd5e1b2651">&#9670;&nbsp;</a></span>operator-() <span class="overload">[4/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ <a class="el" href="group__phsp.html#classhydra_1_1Vector3R">Vector3R</a> hydra::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__phsp.html#classhydra_1_1Vector3R">Vector3R</a> &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__phsp.html#classhydra_1_1Vector3R">Vector3R</a> &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a28b7a7b4b2afa53b5b17883d43c6635b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28b7a7b4b2afa53b5b17883d43c6635b">&#9670;&nbsp;</a></span>operator-() <span class="overload">[5/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::tuple&lt;T...&gt; hydra::operator- </td>
          <td>(</td>
          <td class="paramtype">const HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a950f2d5dc4356f6c6c13b9fc3bc7c0ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a950f2d5dc4356f6c6c13b9fc3bc7c0ef">&#9670;&nbsp;</a></span>operator-() <span class="overload">[6/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ <a class="el" href="group__phsp.html#classhydra_1_1Vector4R">Vector4R</a> hydra::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__phsp.html#classhydra_1_1Vector4R">Vector4R</a> &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__phsp.html#classhydra_1_1Vector4R">Vector4R</a> &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a68375d62444cb2341ade99f0ac15972f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68375d62444cb2341ade99f0ac15972f">&#9670;&nbsp;</a></span>operator-() <span class="overload">[7/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ <a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a> hydra::operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a>&#160;</td>
          <td class="paramname"><em>par1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a> const &amp;&#160;</td>
          <td class="paramname"><em>par2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a07c46e4c59a5208f5d495b4ddaf3af75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07c46e4c59a5208f5d495b4ddaf3af75">&#9670;&nbsp;</a></span>operator-() <span class="overload">[8/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ <a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> hydra::operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a>&#160;</td>
          <td class="paramname"><em>par1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>&#160;</td>
          <td class="paramname"><em>par2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a247f457807559c67d34c5b9d15c0b4b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a247f457807559c67d34c5b9d15c0b4b4">&#9670;&nbsp;</a></span>operator-() <span class="overload">[9/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ <a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> hydra::operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>&#160;</td>
          <td class="paramname"><em>par1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a>&#160;</td>
          <td class="paramname"><em>par2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0fa3a711732edb66303a415b0053ab30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fa3a711732edb66303a415b0053ab30">&#9670;&nbsp;</a></span>operator/() <span class="overload">[1/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename  = typename std::enable_if&lt; T1::is_functor::value &amp;&amp; T2::is_functor::value&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ <a class="el" href="classhydra_1_1Divide.html">Divide</a>&lt;T1,T2&gt; hydra::operator/ </td>
          <td>(</td>
          <td class="paramtype">T1 const &amp;&#160;</td>
          <td class="paramname"><em>F1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2 const &amp;&#160;</td>
          <td class="paramname"><em>F2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a51adfe83d6139c094696c576cac08eb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51adfe83d6139c094696c576cac08eb9">&#9670;&nbsp;</a></span>operator/() <span class="overload">[2/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename  = typename std::enable_if&lt; (std::is_convertible&lt;T1, double&gt;::value ||		std::is_constructible&lt;HYDRA_EXTERNAL_NS::thrust::complex&lt;double&gt;,T1&gt;::value) &amp;&amp; T2::is_functor::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ <a class="el" href="classhydra_1_1Divide.html">Divide</a>&lt;<a class="el" href="structhydra_1_1Constant.html">Constant</a>&lt;T1&gt;, T2&gt; hydra::operator/ </td>
          <td>(</td>
          <td class="paramtype">T1 const&#160;</td>
          <td class="paramname"><em>cte</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2 const &amp;&#160;</td>
          <td class="paramname"><em>F2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a73f958068c4dcdbb79b40925e2da4b24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73f958068c4dcdbb79b40925e2da4b24">&#9670;&nbsp;</a></span>operator/() <span class="overload">[3/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename  = typename std::enable_if&lt; (std::is_convertible&lt;T1, double&gt;::value ||		std::is_constructible&lt;HYDRA_EXTERNAL_NS::thrust::complex&lt;double&gt;,T1&gt;::value) &amp;&amp; T2::is_functor::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ <a class="el" href="classhydra_1_1Divide.html">Divide</a>&lt;T2,<a class="el" href="structhydra_1_1Constant.html">Constant</a>&lt;T1&gt; &gt; hydra::operator/ </td>
          <td>(</td>
          <td class="paramtype">T2 const &amp;&#160;</td>
          <td class="paramname"><em>F2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T1 const&#160;</td>
          <td class="paramname"><em>cte</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a94cb4a79113148abd78aa8e4d6f7e41d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94cb4a79113148abd78aa8e4d6f7e41d">&#9670;&nbsp;</a></span>operator/() <span class="overload">[4/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ <a class="el" href="group__phsp.html#classhydra_1_1Vector3R">Vector3R</a> hydra::operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__phsp.html#classhydra_1_1Vector3R">Vector3R</a> &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4db4d6d0e3fe03dccf661b7ac0751fe7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4db4d6d0e3fe03dccf661b7ac0751fe7">&#9670;&nbsp;</a></span>operator/() <span class="overload">[5/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ <a class="el" href="group__phsp.html#classhydra_1_1Vector4R">Vector4R</a> hydra::operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__phsp.html#classhydra_1_1Vector4R">Vector4R</a> &amp;&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a61779a5f2bd6e73c2808fc388b3aa496"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61779a5f2bd6e73c2808fc388b3aa496">&#9670;&nbsp;</a></span>operator/() <span class="overload">[6/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ HYDRA_EXTERNAL_NS::thrust::tuple&lt;T...&gt; hydra::operator/ </td>
          <td>(</td>
          <td class="paramtype">const HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac9b1664e58d41d5f8e7ec6d1c20bf9c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9b1664e58d41d5f8e7ec6d1c20bf9c0">&#9670;&nbsp;</a></span>operator/() <span class="overload">[7/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ <a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a> hydra::operator/ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a>&#160;</td>
          <td class="paramname"><em>par1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a> const&#160;</td>
          <td class="paramname"><em>par2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0a4133d480d7e9f3f5e85286e47a3709"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a4133d480d7e9f3f5e85286e47a3709">&#9670;&nbsp;</a></span>operator/() <span class="overload">[8/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ <a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> hydra::operator/ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a>&#160;</td>
          <td class="paramname"><em>par1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>&#160;</td>
          <td class="paramname"><em>par2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af29cde1e70c62bec6f1fa1ee52940887"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af29cde1e70c62bec6f1fa1ee52940887">&#9670;&nbsp;</a></span>operator/() <span class="overload">[9/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ <a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> hydra::operator/ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>&#160;</td>
          <td class="paramname"><em>par1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a>&#160;</td>
          <td class="paramname"><em>par2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a15cdb083719133399edb77f5ef3eb547"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15cdb083719133399edb77f5ef3eb547">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t N, typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; hydra::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; T, N &gt; const &amp;&#160;</td>
          <td class="paramname"><em>obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6fab8d226ee701c0755c60202fc30f6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fab8d226ee701c0755c60202fc30f6c">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; hydra::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::tuple&lt; T... &gt; const &amp;&#160;</td>
          <td class="paramname"><em>obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad4d7f13d811f0d63d4ce49d31b6cfbe0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4d7f13d811f0d63d4ce49d31b6cfbe0">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; hydra::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::pair&lt; T1, T2 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3fa8037907332bf633dfc1bc3b40865c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fa8037907332bf633dfc1bc3b40865c">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ostream&amp; hydra::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__phsp.html#classhydra_1_1Vector3R">Vector3R</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aaacce78528c9499de97312cbe606ece4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaacce78528c9499de97312cbe606ece4">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ostream&amp; hydra::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__phsp.html#classhydra_1_1Vector4R">Vector4R</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad3be8e63c60c604b927f9638600a598b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3be8e63c60c604b927f9638600a598b">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; hydra::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__fit.html#classhydra_1_1UserParameters">UserParameters</a> const &amp;&#160;</td>
          <td class="paramname"><em>par</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classhydra_1_1Print.html">Print</a> the ROOT::Minuit2 state to stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>std::ostream </td></tr>
    <tr><td class="paramname">par</td><td><a class="el" href="group__fit.html#classhydra_1_1UserParameters" title="Class implementing a interface to ROOT::Minuit2::MnUserParameters. ">hydra::UserParameters</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a21d7262b80d73f956ed1a477607b9053"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21d7262b80d73f956ed1a477607b9053">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , class charT , class traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::basic_ostream&lt; charT,traits &gt;&amp; hydra::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::basic_ostream&lt; charT, traits &gt; &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; ValueType &gt; &amp;&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a28117308ddccfecc1cf7cf76c8810f95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28117308ddccfecc1cf7cf76c8810f95">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ std::ostream&amp; hydra::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a> const &amp;&#160;</td>
          <td class="paramname"><em>var</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aea70aec01321527f54717a004a3df99d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea70aec01321527f54717a004a3df99d">&#9670;&nbsp;</a></span>operator==() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ <a class="el" href="namespace_3globalScope_4.html#classbool">bool</a> hydra::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a227370a3dddcea864f09490bc65b93ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a227370a3dddcea864f09490bc65b93ad">&#9670;&nbsp;</a></span>operator==() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ <a class="el" href="namespace_3globalScope_4.html#classbool">bool</a> hydra::operator== </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a99bf5390aa3ab39e8ac0cd109ef6b7c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99bf5390aa3ab39e8ac0cd109ef6b7c9">&#9670;&nbsp;</a></span>operator==() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ <a class="el" href="namespace_3globalScope_4.html#classbool">bool</a> hydra::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aebc9da09d22eae43ed970a123baa27f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebc9da09d22eae43ed970a123baa27f1">&#9670;&nbsp;</a></span>operator==() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t N1, hydra::detail::Backend BACKEND1, size_t N2, hydra::detail::Backend BACKEND2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_3globalScope_4.html#classbool">bool</a> hydra::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__phsp.html#classhydra_1_1Decays">Decays</a>&lt; N1, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND1 &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__phsp.html#classhydra_1_1Decays">Decays</a>&lt; N2, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND2 &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab3bafbf7fa6e97bc40b02d74d7d596ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3bafbf7fa6e97bc40b02d74d7d596ea">&#9670;&nbsp;</a></span>operator==() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t N, hydra::detail::Backend BACKEND1, hydra::detail::Backend BACKEND2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_3globalScope_4.html#classbool">bool</a> hydra::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#classhydra_1_1multiarray">multiarray</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND1 &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#classhydra_1_1multiarray">multiarray</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND2 &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a49a0907b93c595507fbd2ea319f2f5d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49a0907b93c595507fbd2ea319f2f5d6">&#9670;&nbsp;</a></span>operator==() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND1, hydra::detail::Backend BACKEND2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_3globalScope_4.html#classbool">bool</a> hydra::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND1 &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND2 &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a63ad8f84031200c3161c889507d3a9c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63ad8f84031200c3161c889507d3a9c0">&#9670;&nbsp;</a></span>operator&gt;&gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename charT , class traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::basic_istream&lt; charT,traits &gt;&amp; hydra::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::basic_istream&lt; charT, traits &gt; &amp;&#160;</td>
          <td class="paramname"><em>is</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; ValueType &gt; &amp;&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae85d86e6980bcf24de91a003711b3224"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae85d86e6980bcf24de91a003711b3224">&#9670;&nbsp;</a></span>pmf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> hydra::pmf </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td>
          <td class="paramname"><em>mother_mass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td>
          <td class="paramname"><em>daughter1_mass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td>
          <td class="paramname"><em>daughter2_mass</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Momentum in mother frame of daughter particle in two-body-decay. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mother_mass</td><td></td></tr>
    <tr><td class="paramname">daughter1_mass</td><td></td></tr>
    <tr><td class="paramname">daughter2_mass</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="ae3cc52fabc8882be13d9a6ca92fc648e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3cc52fabc8882be13d9a6ca92fc648e">&#9670;&nbsp;</a></span>polar()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt;T&gt; hydra::polar </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>theta</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a93feeb5a117184a56c3151d3b7685c1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93feeb5a117184a56c3151d3b7685c1d">&#9670;&nbsp;</a></span>pow() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , unsigned int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ T hydra::pow </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Power with integer exponent. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="ac2256bff965f5a7359591579a97114ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2256bff965f5a7359591579a97114ec">&#9670;&nbsp;</a></span>pow() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt;T&gt; hydra::pow </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="dalitz_plot_8inl-example.html#a30">dalitz_plot.inl</a>, <a class="el" href="gaussian_plus_argus_8inl-example.html#a15">gaussian_plus_argus.inl</a>, <a class="el" href="phsp_basic_8inl-example.html#a1">phsp_basic.inl</a>, <a class="el" href="phsp_chain_8inl-example.html#a1">phsp_chain.inl</a>, <a class="el" href="phsp_reweighting_8inl-example.html#a1">phsp_reweighting.inl</a>, <a class="el" href="phsp_unweighting_8inl-example.html#a1">phsp_unweighting.inl</a>, and <a class="el" href="phsp_unweighting_functor_8inl-example.html#a1">phsp_unweighting_functor.inl</a>.</dd>
</dl>
</div>
</div>
<a id="a4cf806d100f53f6d281b8b826697e10f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cf806d100f53f6d281b8b826697e10f">&#9670;&nbsp;</a></span>pow() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt;T&gt; hydra::pow </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2e9146d77dfa5b6c0fcbcb31557f6854"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e9146d77dfa5b6c0fcbcb31557f6854">&#9670;&nbsp;</a></span>pow() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt;T&gt; hydra::pow </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab5e9dc190c08a69b225d320ab8da1582"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5e9dc190c08a69b225d320ab8da1582">&#9670;&nbsp;</a></span>pow() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; typename HYDRA_EXTERNAL_NS::thrust::detail::promoted_numerical_type&lt; T, U &gt;::type &gt; hydra::pow </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adddd0dd31b59ee6d761eccb6cd78b452"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adddd0dd31b59ee6d761eccb6cd78b452">&#9670;&nbsp;</a></span>pow() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; typename HYDRA_EXTERNAL_NS::thrust::detail::promoted_numerical_type&lt; T, U &gt;::type &gt; hydra::pow </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab57b4e7a8e408d4e545f46a2c1923cd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab57b4e7a8e408d4e545f46a2c1923cd5">&#9670;&nbsp;</a></span>pow() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; typename HYDRA_EXTERNAL_NS::thrust::detail::promoted_numerical_type&lt; T, U &gt;::type &gt; hydra::pow </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acb0c9817024c69efe44c2d9653928519"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb0c9817024c69efe44c2d9653928519">&#9670;&nbsp;</a></span>PrintToStream()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void hydra::PrintToStream </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>ostream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ace0454750e3561d390ee18b96824227c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace0454750e3561d390ee18b96824227c">&#9670;&nbsp;</a></span>proj()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt;T&gt; hydra::proj </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a88492da245c1e30c636a6862b3db2854"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88492da245c1e30c636a6862b3db2854">&#9670;&nbsp;</a></span>rbegin() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename T , size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::rbegin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#classhydra_1_1multiarray">multiarray</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> -&gt; decltype(other.rbegin(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt;I&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afa6e43a3fe1002f340251042beefbddd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa6e43a3fe1002f340251042beefbddd">&#9670;&nbsp;</a></span>rbegin() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename T , size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::rbegin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#classhydra_1_1multiarray">multiarray</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> -&gt; decltype(other.rbegin(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt;I&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a68b257293c03a3475bb28e9575e941ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68b257293c03a3475bb28e9575e941ad">&#9670;&nbsp;</a></span>rbegin() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::rbegin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> -&gt; decltype(other.rbegin(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt;I&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2906e8baa707b7e3cbe3ab1c1aa3fa7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2906e8baa707b7e3cbe3ab1c1aa3fa7c">&#9670;&nbsp;</a></span>rbegin() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::rbegin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> -&gt; decltype(other.rbegin(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt;I&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="adeb4e3f7995b809a28ab9efd97909874"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adeb4e3f7995b809a28ab9efd97909874">&#9670;&nbsp;</a></span>rend() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename T , size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::rend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#classhydra_1_1multiarray">multiarray</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> -&gt; decltype(other.rend(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt;I&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a61c8453a5cf5c68eb4f1a074db0135f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61c8453a5cf5c68eb4f1a074db0135f6">&#9670;&nbsp;</a></span>rend() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename T , size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::rend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#classhydra_1_1multiarray">multiarray</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> -&gt; decltype(other.rend(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt;I&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a53513fea217a83151a1c98692a1bdbc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53513fea217a83151a1c98692a1bdbc7">&#9670;&nbsp;</a></span>rend() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::rend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> -&gt; decltype(other.rend(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt;I&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a96fc64d77a9d74b4606c449937491181"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96fc64d77a9d74b4606c449937491181">&#9670;&nbsp;</a></span>rend() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::rend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; HYDRA_EXTERNAL_NS::thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> -&gt; decltype(other.rend(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt;I&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4a9e21c7083ea65e58667297a801f0c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a9e21c7083ea65e58667297a801f0c0">&#9670;&nbsp;</a></span>rotateEuler() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ <a class="el" href="group__phsp.html#classhydra_1_1Vector4R">Vector4R</a> hydra::rotateEuler </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__phsp.html#classhydra_1_1Vector4R">Vector4R</a> &amp;&#160;</td>
          <td class="paramname"><em>rs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>&#160;</td>
          <td class="paramname"><em>gamma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab9637ed446b2f89c3514f57bac1fd1be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9637ed446b2f89c3514f57bac1fd1be">&#9670;&nbsp;</a></span>rotateEuler() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ <a class="el" href="group__phsp.html#classhydra_1_1Vector3R">Vector3R</a> hydra::rotateEuler </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__phsp.html#classhydra_1_1Vector3R">Vector3R</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>&#160;</td>
          <td class="paramname"><em>phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>&#160;</td>
          <td class="paramname"><em>ksi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="acb7d0e5da38544692eb3545e81617e19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb7d0e5da38544692eb3545e81617e19">&#9670;&nbsp;</a></span>sin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt;T&gt; hydra::sin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="dalitz_plot_8inl-example.html#a18">dalitz_plot.inl</a>.</dd>
</dl>
</div>
</div>
<a id="af59c474655ecd14c6748391d80e2e4c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af59c474655ecd14c6748391d80e2e4c2">&#9670;&nbsp;</a></span>sinh()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt;T&gt; hydra::sinh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a74988a829019bf111e7f51d81b33eec7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74988a829019bf111e7f51d81b33eec7">&#9670;&nbsp;</a></span>sqrt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt;T&gt; hydra::sqrt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="adaptive_gauss_kronrod_8inl-example.html#a2">adaptive_gauss_kronrod.inl</a>, <a class="el" href="binned_extended_logLL_fit_8inl-example.html#a13">binned_extended_logLL_fit.inl</a>, <a class="el" href="dense_histogram_8inl-example.html#a2">dense_histogram.inl</a>, <a class="el" href="extended_logLL_fit_8inl-example.html#a13">extended_logLL_fit.inl</a>, <a class="el" href="gauss_kronrod_8inl-example.html#a2">gauss_kronrod.inl</a>, <a class="el" href="multidimensional_fit_8inl-example.html#a11">multidimensional_fit.inl</a>, <a class="el" href="phsp_averaging_functor_8inl-example.html#a3">phsp_averaging_functor.inl</a>, <a class="el" href="phsp_chain_8inl-example.html#a4">phsp_chain.inl</a>, <a class="el" href="plain_mc_8inl-example.html#a2">plain_mc.inl</a>, <a class="el" href="sample_distribution_8inl-example.html#a2">sample_distribution.inl</a>, <a class="el" href="sparse_histogram_8inl-example.html#a2">sparse_histogram.inl</a>, <a class="el" href="splot_8inl-example.html#a10">splot.inl</a>, and <a class="el" href="vegas_8inl-example.html#a2">vegas.inl</a>.</dd>
</dl>
</div>
</div>
<a id="aa792627bbf68dd5d3c3d969c3462808f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa792627bbf68dd5d3c3d969c3462808f">&#9670;&nbsp;</a></span>stream_array_helper() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t N, typename T , size_t I&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;(I==N), void&gt;::type hydra::stream_array_helper </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; T, N &gt; const &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>array streamer helper </p>

</div>
</div>
<a id="a6b2446e6e58a2466b66c1277d67075ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b2446e6e58a2466b66c1277d67075ad">&#9670;&nbsp;</a></span>stream_array_helper() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t N, typename T , size_t I = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; (I &lt; N), void&gt;::type hydra::stream_array_helper </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; T, N &gt; const &amp;&#160;</td>
          <td class="paramname"><em>obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afa8b42796ae70a6c34b6871a8755b382"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa8b42796ae70a6c34b6871a8755b382">&#9670;&nbsp;</a></span>stream_tuple_helper() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I, typename ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;(I==sizeof ...(T)), void&gt;::type hydra::stream_tuple_helper </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::tuple&lt; T... &gt; const &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>tuple streamer helper </p>

</div>
</div>
<a id="af0ba407638beac5920ac997d3021b413"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0ba407638beac5920ac997d3021b413">&#9670;&nbsp;</a></span>stream_tuple_helper() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I = 0, typename ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; (I &lt; sizeof ...(T)), void&gt;::type hydra::stream_tuple_helper </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::tuple&lt; T... &gt; const &amp;&#160;</td>
          <td class="paramname"><em>obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae69d22c1daecb87a2e29aae2703bac16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae69d22c1daecb87a2e29aae2703bac16">&#9670;&nbsp;</a></span>sum()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F1 , typename F2 , typename ... Fs&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ <a class="el" href="classhydra_1_1Sum.html">Sum</a>&lt;F1, F2,Fs...&gt; hydra::sum </td>
          <td>(</td>
          <td class="paramtype">F1 const &amp;&#160;</td>
          <td class="paramname"><em>f1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F2 const &amp;&#160;</td>
          <td class="paramname"><em>f2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Fs const &amp;...&#160;</td>
          <td class="paramname"><em>functors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa7d619f99868f45f5e06b9040bcc68b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7d619f99868f45f5e06b9040bcc68b7">&#9670;&nbsp;</a></span>swap() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ void hydra::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__phsp.html#classhydra_1_1Vector3R">Vector3R</a> &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__phsp.html#classhydra_1_1Vector3R">Vector3R</a> &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a67385a5afc562279b4419a11ab79e3d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67385a5afc562279b4419a11ab79e3d6">&#9670;&nbsp;</a></span>swap() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ void hydra::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__phsp.html#classhydra_1_1Vector4R">Vector4R</a> &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__phsp.html#classhydra_1_1Vector4R">Vector4R</a> &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a110443bb149efe88b6713bc5aca89b7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a110443bb149efe88b6713bc5aca89b7c">&#9670;&nbsp;</a></span>tan()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt;T&gt; hydra::tan </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5c39f4b7fa2b8b0c1e4066e9d059b435"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c39f4b7fa2b8b0c1e4066e9d059b435">&#9670;&nbsp;</a></span>tanh()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt;T&gt; hydra::tanh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#a4f9af1aefe36fa4f80f57289ffb84dca">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0e16e05c122a0b3b48937b89de17b621"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e16e05c122a0b3b48937b89de17b621">&#9670;&nbsp;</a></span>tie()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_host__ __hydra_device__ auto hydra::tie </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;...&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td> -&gt; decltype(HYDRA_EXTERNAL_NS::thrust::tie(std::forward&lt;T&gt;(t)...))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This version of <code>tie</code> creates a new <code>tuple</code> whose elements are references which refers to this function's arguments. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>The objects to reference. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>tuple</code> object with members which are references to <code>t</code>. </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ab14adaa26f703b8c130df530167ebd23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab14adaa26f703b8c130df530167ebd23">&#9670;&nbsp;</a></span>kFalse</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespacehydra.html#aa8c251ed5017d0638da929130062bcad">GBool_t</a> hydra::kFalse = false</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1556536d7a73fa95e5a9c9610f76a3c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1556536d7a73fa95e5a9c9610f76a3c1">&#9670;&nbsp;</a></span>kTrue</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespacehydra.html#aa8c251ed5017d0638da929130062bcad">GBool_t</a> hydra::kTrue = true</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5afb8f1b6ea1ba2b8fc79444e5d20f20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5afb8f1b6ea1ba2b8fc79444e5d20f20">&#9670;&nbsp;</a></span>PrintLevel</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_3globalScope_4.html#classint">int</a> hydra::PrintLevel = <a class="el" href="namespacehydra.html#aed873b1b84fbec3791e721b22a52d1fea1bf857a06d5b8463494a6fcac6f4ea26">WARNING</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacehydra.html">hydra</a></li>
    <li class="footer">Generated on Fri Mar 23 2018 14:51:41 for Hydra by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.14 </li>
  </ul>
</div>
</body>
</html>
