<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Hydra: hydra::detail Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo_Hydra2.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Hydra
   &#160;<span id="projectnumber">3.0.0</span>
   </div>
   <div id="projectbrief">A header-only templated C++ framework to perform data analysis on massively parallel platforms.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('namespacehydra_1_1detail.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">hydra::detail Namespace Reference<div class="ingroups"><a class="el" href="group__policy.html">Policy</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacehydra_1_1detail_1_1convolution"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail_1_1convolution.html">convolution</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacehydra_1_1detail_1_1cpp"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail_1_1cpp.html">cpp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacehydra_1_1detail_1_1cuda"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail_1_1cuda.html">cuda</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacehydra_1_1detail_1_1cufft"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail_1_1cufft.html">cufft</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacehydra_1_1detail_1_1device"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail_1_1device.html">device</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacehydra_1_1detail_1_1fa__impl"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail_1_1fa__impl.html">fa_impl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacehydra_1_1detail_1_1fftw"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail_1_1fftw.html">fftw</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacehydra_1_1detail_1_1host"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail_1_1host.html">host</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacehydra_1_1detail_1_1impl"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail_1_1impl.html">impl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacehydra_1_1detail_1_1jacobi"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail_1_1jacobi.html">jacobi</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacehydra_1_1detail_1_1meld__iterators__ns"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail_1_1meld__iterators__ns.html">meld_iterators_ns</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacehydra_1_1detail_1_1omp"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail_1_1omp.html">omp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacehydra_1_1detail_1_1random"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail_1_1random.html">random</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacehydra_1_1detail_1_1range"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail_1_1range.html">range</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacehydra_1_1detail_1_1shared__pointer"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail_1_1shared__pointer.html">shared_pointer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacehydra_1_1detail_1_1spiline"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail_1_1spiline.html">spiline</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacehydra_1_1detail_1_1tbb"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail_1_1tbb.html">tbb</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacehydra_1_1detail_1_1tuple"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail_1_1tuple.html">tuple</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacehydra_1_1detail_1_1tuple__utility"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail_1_1tuple__utility.html">tuple_utility</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacehydra_1_1detail_1_1utils"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail_1_1utils.html">utils</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:structhydra_1_1detail_1_1__merge__and__renumber"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1__merge__and__renumber">_merge_and_renumber</a></td></tr>
<tr class="separator:structhydra_1_1detail_1_1__merge__and__renumber"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1__merge__and__renumber_3_01index__sequence_3_01I1_8_8_8_01_4_00_01index73e1de0a5394a3c55b32c0d1818a4cc9.html">_merge_and_renumber&lt; index_sequence&lt; I1... &gt;, index_sequence&lt; I2... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1detail_1_1AddPdfBase.html">AddPdfBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1detail_1_1AddPdfChecker.html">AddPdfChecker</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1AddPdfFunctor.html">AddPdfFunctor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1AddResultGenzMalikBoxes.html">AddResultGenzMalikBoxes</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1AddStatsPHSP.html">AddStatsPHSP</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1all__true.html">all_true</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1all__true_3_4.html">all_true&lt;&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1detail_1_1append__to__type__seq"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1append__to__type__seq">append_to_type_seq</a></td></tr>
<tr class="separator:structhydra_1_1detail_1_1append__to__type__seq"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1detail_1_1append__to__type__seq_3_01T_00_01TT_3_01Ts_8_8_8_01_4_01_4"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1append__to__type__seq_3_01T_00_01TT_3_01Ts_8_8_8_01_4_01_4">append_to_type_seq&lt; T, TT&lt; Ts... &gt; &gt;</a></td></tr>
<tr class="separator:structhydra_1_1detail_1_1append__to__type__seq_3_01T_00_01TT_3_01Ts_8_8_8_01_4_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1are__base__of.html">are_base_of</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1are__base__of_3_01Base_00_01T_01_4.html">are_base_of&lt; Base, T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1are__iterables.html">are_iterables</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1are__iterators.html">are_iterators</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1AverageMother.html">AverageMother</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1AverageMothers.html">AverageMothers</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1detail_1_1BackendPolicy"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">BackendPolicy</a></td></tr>
<tr class="separator:structhydra_1_1detail_1_1BackendPolicy"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1BackendPolicy_3_01Backend_1_1Cpp_01_4.html">BackendPolicy&lt; Backend::Cpp &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1BackendPolicy_3_01Backend_1_1Cuda_01_4.html">BackendPolicy&lt; Backend::Cuda &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1BackendPolicy_3_01Backend_1_1Device_01_4.html">BackendPolicy&lt; Backend::Device &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1BackendPolicy_3_01Backend_1_1Host_01_4.html">BackendPolicy&lt; Backend::Host &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1BackendPolicy_3_01Backend_1_1Omp_01_4.html">BackendPolicy&lt; Backend::Omp &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1BackendPolicy_3_01Backend_1_1Tbb_01_4.html">BackendPolicy&lt; Backend::Tbb &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1detail_1_1bool__pack"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1bool__pack">bool_pack</a></td></tr>
<tr class="separator:structhydra_1_1detail_1_1bool__pack"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1detail_1_1CanConvert"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1CanConvert">CanConvert</a></td></tr>
<tr class="separator:structhydra_1_1detail_1_1CanConvert"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1Caster.html">Caster</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1CheckEnergy.html">CheckEnergy</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1CompareGenzMalikBoxes.html">CompareGenzMalikBoxes</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1CompareTuples.html">CompareTuples</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1detail_1_1CompositeBase.html">CompositeBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1conditions__and.html">conditions_and</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1conditions__and_3_01Cond_00_01Conds_8_8_8_01_4.html">conditions_and&lt; Cond, Conds... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1CovMatrixBinary.html">CovMatrixBinary</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1CovMatrixUnary.html">CovMatrixUnary</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1DecayMother.html">DecayMother</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1DecayMothers.html">DecayMothers</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1dimensionality.html">dimensionality</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1detail_1_1divide__result"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1divide__result">divide_result</a></td></tr>
<tr class="separator:structhydra_1_1detail_1_1divide__result"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1EvalMother.html">EvalMother</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1EvalMothers.html">EvalMothers</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1EvalOnDaughters.html">EvalOnDaughters</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1EvalOnDaughtersBinary.html">EvalOnDaughtersBinary</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1EvalOnDaugthers.html">EvalOnDaugthers</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1FCNWeightsReducerUnary.html">FCNWeightsReducerUnary</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1detail_1_1FFTPolicy"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1FFTPolicy">FFTPolicy</a></td></tr>
<tr class="separator:structhydra_1_1detail_1_1FFTPolicy"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1detail_1_1FFTPolicy_3_01T_00_01detail_1_1CuFFT_01_4"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1FFTPolicy_3_01T_00_01detail_1_1CuFFT_01_4">FFTPolicy&lt; T, detail::CuFFT &gt;</a></td></tr>
<tr class="separator:structhydra_1_1detail_1_1FFTPolicy_3_01T_00_01detail_1_1CuFFT_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1detail_1_1FFTPolicy_3_01T_00_01detail_1_1FFTW_01_4"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1FFTPolicy_3_01T_00_01detail_1_1FFTW_01_4">FFTPolicy&lt; T, detail::FFTW &gt;</a></td></tr>
<tr class="separator:structhydra_1_1detail_1_1FFTPolicy_3_01T_00_01detail_1_1FFTW_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1find__unique__type.html">find_unique_type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1detail_1_1find__unique__type__impl"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1find__unique__type__impl">find_unique_type_impl</a></td></tr>
<tr class="separator:structhydra_1_1detail_1_1find__unique__type__impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1find__unique__type__impl_3_01I_00_01T_01_4.html">find_unique_type_impl&lt; I, T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1find__unique__type__impl_3_01I_00_01T_00_01T_00_01Types_8_8_8_01_4.html">find_unique_type_impl&lt; I, T, T, Types... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1find__unique__type__impl_3_01I_00_01T_00_01U_00_01Types_8_8_8_01_4.html">find_unique_type_impl&lt; I, T, U, Types... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1FlagAcceptReject.html">FlagAcceptReject</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flags generated events as accepted (1) or rejected (0).  <a href="structhydra_1_1detail_1_1FlagAcceptReject.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1detail_1_1FlagDaugthers.html">FlagDaugthers</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1FlagDaugthers1.html">FlagDaugthers1</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1FlagDaugthers2.html">FlagDaugthers2</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1detail_1_1function__traits"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1function__traits">function_traits</a></td></tr>
<tr class="separator:structhydra_1_1detail_1_1function__traits"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1function__traits_3_01ReturnType_07ClassType_1_1_5_08_07Args_01_6_8_8_8_08_4.html">function_traits&lt; ReturnType(ClassType::*)(Args &amp;...)&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1function__traits_3_01ReturnType_07ClassType_1_1_5_08_07Args_8_8_8_08_01const_01_4.html">function_traits&lt; ReturnType(ClassType::*)(Args...) const &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1FunctionArgument.html">FunctionArgument</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1detail_1_1functor__traits"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1functor__traits">functor_traits</a></td></tr>
<tr class="separator:structhydra_1_1detail_1_1functor__traits"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1detail_1_1functor__traits_3_01ReturnType_07ClassType_1_1_5_08_07Args_8_8_8_08_01_4"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1functor__traits_3_01ReturnType_07ClassType_1_1_5_08_07Args_8_8_8_08_01_4">functor_traits&lt; ReturnType(ClassType::*)(Args...) &gt;</a></td></tr>
<tr class="separator:structhydra_1_1detail_1_1functor__traits_3_01ReturnType_07ClassType_1_1_5_08_07Args_8_8_8_08_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1functor__traits_3_01ReturnType_07ClassType_1_1_5_08_07Args_8_8_8_08_01const_01_4.html">functor_traits&lt; ReturnType(ClassType::*)(Args...) const &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1GenerateDecay.html">GenerateDecay</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1detail_1_1GenzMalikBox.html">GenzMalikBox</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1detail_1_1GenzMalikBoxResult.html">GenzMalikBoxResult</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1GetBinCenter.html">GetBinCenter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1GetBinCenter_3_01T_00_011_01_4.html">GetBinCenter&lt; T, 1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1GetGlobalBin.html">GetGlobalBin</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1GetGlobalBin_3_011_00_01T_01_4.html">GetGlobalBin&lt; 1, T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1GetSWeight.html">GetSWeight</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1detail_1_1gray__code.html">gray_code</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1has__rng__formula.html">has_rng_formula</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1has__rng__formula_3_01Functor_00_01hydra__thrust_1_1void__t_3_01typenam606e1598181acac98a9289f7499aff1a.html">has_rng_formula&lt; Functor, hydra_thrust::void_t&lt; typename hydra::RngFormula&lt; Functor &gt;::value_type &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1high__bit__mask__t.html">high_bit_mask_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1detail_1_1if__then__else"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#classhydra_1_1detail_1_1if__then__else">if_then_else</a></td></tr>
<tr class="separator:classhydra_1_1detail_1_1if__then__else"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1detail_1_1if__then__else_3_01false_00_01T1_00_01T2_01_4"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#classhydra_1_1detail_1_1if__then__else_3_01false_00_01T1_00_01T2_01_4">if_then_else&lt; false, T1, T2 &gt;</a></td></tr>
<tr class="separator:classhydra_1_1detail_1_1if__then__else_3_01false_00_01T1_00_01T2_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1detail_1_1if__then__else_3_01true_00_01T1_00_01T2_01_4"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#classhydra_1_1detail_1_1if__then__else_3_01true_00_01T1_00_01T2_01_4">if_then_else&lt; true, T1, T2 &gt;</a></td></tr>
<tr class="separator:classhydra_1_1detail_1_1if__then__else_3_01true_00_01T1_00_01T2_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1detail_1_1if__then__else__tt"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1if__then__else__tt">if_then_else_tt</a></td></tr>
<tr class="separator:structhydra_1_1detail_1_1if__then__else__tt"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1detail_1_1if__then__else__tt_3_01false_00_01T1_00_01T2_01_4"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1if__then__else__tt_3_01false_00_01T1_00_01T2_01_4">if_then_else_tt&lt; false, T1, T2 &gt;</a></td></tr>
<tr class="separator:structhydra_1_1detail_1_1if__then__else__tt_3_01false_00_01T1_00_01T2_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1detail_1_1if__then__else__tt_3_01true_00_01T1_00_01T2_01_4"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1if__then__else__tt_3_01true_00_01T1_00_01T2_01_4">if_then_else_tt&lt; true, T1, T2 &gt;</a></td></tr>
<tr class="separator:structhydra_1_1detail_1_1if__then__else__tt_3_01true_00_01T1_00_01T2_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1detail_1_1index__in__tuple"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1index__in__tuple">index_in_tuple</a></td></tr>
<tr class="separator:structhydra_1_1detail_1_1index__in__tuple"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1index__in__tuple_3_01Type_00_01hydra__thrust_1_1tuple_3_01Head_00_01Tail_8_8_8_01_4_01_4.html">index_in_tuple&lt; Type, hydra_thrust::tuple&lt; Head, Tail... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1index__sequence.html">index_sequence</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1detail_1_1int__fast__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1int__fast__t">int_fast_t</a></td></tr>
<tr class="separator:structhydra_1_1detail_1_1int__fast__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1int__t.html">int_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1is__device__reference.html">is_device_reference</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1is__device__reference_3_01hydra__thrust_1_1device__reference_3_01T_01_4_01_4.html">is_device_reference&lt; hydra_thrust::device_reference&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1detail_1_1is__function__argument"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1is__function__argument">is_function_argument</a></td></tr>
<tr class="separator:structhydra_1_1detail_1_1is__function__argument"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1is__function__argument_3_01Arg_00_01false_01_4.html">is_function_argument&lt; Arg, false &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1is__function__argument_3_01Arg_00_01true_01_4.html">is_function_argument&lt; Arg, true &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1is__function__argument_3_01hydra__thrust_1_1device__reference_3_01Arg_01_4_00_01true_01_4.html">is_function_argument&lt; hydra_thrust::device_reference&lt; Arg &gt;, true &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1is__function__argument__pack.html">is_function_argument_pack</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1is__homogeneous.html">is_homogeneous</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1is__homogeneous__base.html">is_homogeneous_base</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1is__homogeneous__base_3_01A_00_01Tp_00_010_01_4.html">is_homogeneous_base&lt; A, Tp, 0 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1is__hydra__composite__functor.html">is_hydra_composite_functor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1is__hydra__composite__functor_3_01T_00_01hydra__thrust_1_1void__t_3_01tccab60179542fea9c2cbbbbbcc3f8b21.html">is_hydra_composite_functor&lt; T, hydra_thrust::void_t&lt; typename T::hydra_composed_functor_type &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1is__hydra__convertible__to__tuple.html">is_hydra_convertible_to_tuple</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1is__hydra__convertible__to__tuple_3_01T_00_01typename_01tag__type_3_01ta964df32a5ab9b829e612ce2772ce8f5.html">is_hydra_convertible_to_tuple&lt; T, typename tag_type&lt; typename T::hydra_convertible_to_tuple_tag &gt;::type &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1is__hydra__dense__histogram.html">is_hydra_dense_histogram</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1is__hydra__dense__histogram_3_01hydra_1_1DenseHistogram_3_01T_00_01N_00fc4864555721ec45e62403c36aadd8e3.html">is_hydra_dense_histogram&lt; hydra::DenseHistogram&lt; T, N, detail::BackendPolicy&lt; BACKEND &gt;, D &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1is__hydra__estimator.html">is_hydra_estimator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1is__hydra__estimator_3_01T_00_01hydra__thrust_1_1void__t_3_01typename_059bbb4e55e19bf7af0b6163360b46c0a.html">is_hydra_estimator&lt; T, hydra_thrust::void_t&lt; typename T::likelihood_estimator_type &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">is_hydra_functor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1is__hydra__functor_3_01Functor_00_01hydra__thrust_1_1void__t_3_01typenafbfefa5d76b2127163526825f05d98e1.html">is_hydra_functor&lt; Functor, hydra_thrust::void_t&lt; typename Functor::hydra_functor_type, typename Functor::argument_type, typename Functor::return_type &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1is__hydra__integrator.html">is_hydra_integrator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1is__hydra__integrator_3_01T_00_01hydra__thrust_1_1void__t_3_01typename_d2c71af43dd28e3c447ac2b25385ae94.html">is_hydra_integrator&lt; T, hydra_thrust::void_t&lt; typename T::hydra_integrator_type &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1is__hydra__lambda.html">is_hydra_lambda</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1is__hydra__lambda_3_01Functor_00_01hydra__thrust_1_1void__t_3_01typenam8750428a194d261b5eb6c32cc8b2c44f.html">is_hydra_lambda&lt; Functor, hydra_thrust::void_t&lt; typename Functor::hydra_lambda_type, typename Functor::argument_type, typename Functor::return_type &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1is__hydra__pdf.html">is_hydra_pdf</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1is__hydra__pdf_3_01T_00_01hydra__thrust_1_1void__t_3_01typename_01T_1_1hydra__pdf__type_01_4_01_4.html">is_hydra_pdf&lt; T, hydra_thrust::void_t&lt; typename T::hydra_pdf_type &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1is__hydra__sparse__histogram.html">is_hydra_sparse_histogram</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1is__hydra__sparse__histogram_3_01hydra_1_1SparseHistogram_3_01T_00_01N_f0e8aca59eda1633a4e7f9f8573f0524.html">is_hydra_sparse_histogram&lt; hydra::SparseHistogram&lt; T, N, detail::BackendPolicy&lt; BACKEND &gt;, D &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1is__hydra__sum__pdf.html">is_hydra_sum_pdf</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1is__hydra__sum__pdf_3_01T_00_01typename_01tag__type_3_01typename_01T_1_cd81614c45a8283de0a328bd93194fef.html">is_hydra_sum_pdf&lt; T, typename tag_type&lt; typename T::hydra_sum_pdf_tag &gt;::type &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1is__instantiation__of.html">is_instantiation_of</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1is__instantiation__of_3_01Template_00_01Template_3_01Args_8_8_8_01_4_01_4.html">is_instantiation_of&lt; Template, Template&lt; Args... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1is__iterable.html">is_iterable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1is__iterable_3_01T_00_01hydra__thrust_1_1void__t_3_01decltype_07std_1_1dad664b788647f8b21c40fec4ff3be60.html">is_iterable&lt; T, hydra_thrust::void_t&lt; decltype(std::declval&lt; T &gt;().begin()), decltype(std::declval&lt; T &gt;().end()), decltype(++std::declval&lt; decltype(hydra::begin(std::declval&lt; T &gt;()))&amp; &gt;()), decltype(*hydra::begin(std::declval&lt; T &gt;())) &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1is__iterator.html">is_iterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1is__iterator_3_01T_00_01hydra__thrust_1_1void__t_3_01typename_01std_1_1f4f8f83b484a6990de5649c5e71c7fc4.html">is_iterator&lt; T, hydra_thrust::void_t&lt; typename std::enable_if&lt; std::is_default_constructible&lt; T &gt;::value, void &gt;::type, typename std::enable_if&lt; std::is_copy_constructible&lt; T &gt;::value, void &gt;::type, typename std::enable_if&lt; std::is_destructible&lt; T &gt;::value, void &gt;::type, decltype(std::declval&lt; T &amp; &gt;()[0]), decltype(std::declval&lt; T &amp; &gt;() -std::declval&lt; T &amp; &gt;()), decltype(++std::declval&lt; T &amp; &gt;()), decltype(*std::declval&lt; T &amp; &gt;()), decltype(std::declval&lt; T &amp; &gt;()==std::declval&lt; T &amp; &gt;()), decltype(std::declval&lt; T &amp; &gt;() !=std::declval&lt; T &amp; &gt;())&gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1is__reverse__iterable.html">is_reverse_iterable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1is__reverse__iterable_3_01T_00_01hydra__thrust_1_1void__t_3_01decltype_b769c76123d67ea846790a713f37cb2b.html">is_reverse_iterable&lt; T, hydra_thrust::void_t&lt; decltype(std::declval&lt; T &gt;().rbegin()), decltype(std::declval&lt; T &gt;().rend()), decltype(++std::declval&lt; decltype(hydra::rbegin(std::declval&lt; T &gt;()))&amp; &gt;()), decltype(*hydra::rbegin(std::declval&lt; T &gt;())) &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1is__rng__formula.html">is_rng_formula</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1is__rng__formula_3_01hydra_1_1RngFormula_3_01Formula_01_4_01_4.html">is_rng_formula&lt; hydra::RngFormula&lt; Formula &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1is__specialization.html">is_specialization</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1is__specialization_3_01REF_3_01Args_8_8_8_01_4_00_01REF_01_4.html">is_specialization&lt; REF&lt; Args... &gt;, REF &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1is__tuple.html">is_tuple</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1is__tuple_3_01hydra_1_1tuple_3_01T_8_8_8_01_4_01_4.html">is_tuple&lt; hydra::tuple&lt; T... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1is__tuple__of__function__arguments.html">is_tuple_of_function_arguments</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1is__tuple__of__function__arguments_3_01hydra__thrust_1_1detail_1_1tuple91678faffaaaeae4ffb8187c2b42b734.html">is_tuple_of_function_arguments&lt; hydra_thrust::detail::tuple_of_iterator_references&lt; ArgTypes &amp;... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1is__tuple__of__function__arguments_3_01hydra__thrust_1_1detail_1_1tuple91dbb50ce69fee5b9cbe82c5a46c3272.html">is_tuple_of_function_arguments&lt; hydra_thrust::detail::tuple_of_iterator_references&lt; hydra_thrust::device_reference&lt; ArgTypes &gt;... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1is__tuple__of__function__arguments_3_01hydra__thrust_1_1tuple_3_01ArgTypes_8_8_8_01_4_01_4.html">is_tuple_of_function_arguments&lt; hydra_thrust::tuple&lt; ArgTypes... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1is__tuple__type.html">is_tuple_type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1is__tuple__type_3_01hydra__thrust_1_1detail_1_1tuple__of__iterator__ref918b4c0478eb726f13586ea6416d2daf.html">is_tuple_type&lt; hydra_thrust::detail::tuple_of_iterator_references&lt; ArgTypes... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1is__tuple__type_3_01hydra__thrust_1_1tuple_3_01ArgTypes_8_8_8_01_4_01_4.html">is_tuple_type&lt; hydra_thrust::tuple&lt; ArgTypes... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1detail_1_1is__valid__type__pack"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1is__valid__type__pack">is_valid_type_pack</a></td></tr>
<tr class="separator:structhydra_1_1detail_1_1is__valid__type__pack"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1is__valid__type__pack_3_01hydra__thrust_1_1tuple_3_01RefT_8_8_8_01_4_0070324e2e3d0bd6246752982b430a02d8.html">is_valid_type_pack&lt; hydra_thrust::tuple&lt; RefT... &gt;, hydra_thrust::device_reference&lt; T &gt;... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1is__valid__type__pack_3_01hydra__thrust_1_1tuple_3_01RefT_8_8_8_01_4_00_01T_8_8_8_01_4.html">is_valid_type_pack&lt; hydra_thrust::tuple&lt; RefT... &gt;, T... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1is__zip__iterator.html">is_zip_iterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1is__zip__iterator_3_01hydra__thrust_1_1zip__iterator_3_01T_8_8_8_01_4_01_4.html">is_zip_iterator&lt; hydra_thrust::zip_iterator&lt; T... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1isAccepted.html">isAccepted</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1IteratorTraits.html">IteratorTraits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1lambda__traits.html">lambda_traits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1LogLikelihood1.html">LogLikelihood1</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1LogLikelihood2.html">LogLikelihood2</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1low__bits__mask__t.html">low_bits_mask_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1low__bits__mask__t_3_01std_1_1numeric__limits_3_01unsigned_01char_01_4_1_1digits_01_4.html">low_bits_mask_t&lt; std::numeric_limits&lt; unsigned char &gt;::digits &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1make__index__sequence.html">make_index_sequence</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1make__index__sequence_3_010_01_4.html">make_index_sequence&lt; 0 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1make__index__sequence_3_011_01_4.html">make_index_sequence&lt; 1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1detail_1_1merged__tuple"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1merged__tuple">merged_tuple</a></td></tr>
<tr class="separator:structhydra_1_1detail_1_1merged__tuple"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1detail_1_1merged__tuple_3_01hydra_1_1tuple_3_01T_8_8_8_01_4_01_4"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1merged__tuple_3_01hydra_1_1tuple_3_01T_8_8_8_01_4_01_4">merged_tuple&lt; hydra::tuple&lt; T... &gt; &gt;</a></td></tr>
<tr class="separator:structhydra_1_1detail_1_1merged__tuple_3_01hydra_1_1tuple_3_01T_8_8_8_01_4_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1merged__tuple_3_01hydra_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1tuple_3_01U_8_8_8_01_4_01_4.html">merged_tuple&lt; hydra::tuple&lt; T... &gt;, hydra::tuple&lt; U... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1merged__tuple_3_01hydra_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1tuple_3a2087d7aa1d7d8255c2c776843f52d86.html">merged_tuple&lt; hydra::tuple&lt; T... &gt;, hydra::tuple&lt; U... &gt;, Z... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1detail_1_1merged__zip__iterator"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1merged__zip__iterator">merged_zip_iterator</a></td></tr>
<tr class="separator:structhydra_1_1detail_1_1merged__zip__iterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1detail_1_1merged__zip__iterator_3_01hydra__thrust_1_1zip__iterator_3_01T_8_8_8_01_4_01_4"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1merged__zip__iterator_3_01hydra__thrust_1_1zip__iterator_3_01T_8_8_8_01_4_01_4">merged_zip_iterator&lt; hydra_thrust::zip_iterator&lt; T... &gt; &gt;</a></td></tr>
<tr class="separator:structhydra_1_1detail_1_1merged__zip__iterator_3_01hydra__thrust_1_1zip__iterator_3_01T_8_8_8_01_4_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1merged__zip__iterator_3_01hydra__thrust_1_1zip__iterator_3_01T_8_8_8_016973f0f6130f6e1af26c5686a622f7bf.html">merged_zip_iterator&lt; hydra_thrust::zip_iterator&lt; T... &gt;, hydra_thrust::zip_iterator&lt; U... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1merged__zip__iterator_3_01hydra__thrust_1_1zip__iterator_3_01T_8_8_8_01b17a1799aa4eacc3fd1750ecaa85140d.html">merged_zip_iterator&lt; hydra_thrust::zip_iterator&lt; T... &gt;, hydra_thrust::zip_iterator&lt; U... &gt;, Z... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1detail_1_1minus__result"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1minus__result">minus_result</a></td></tr>
<tr class="separator:structhydra_1_1detail_1_1minus__result"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1detail_1_1multidimensional"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1multidimensional">multidimensional</a></td></tr>
<tr class="separator:structhydra_1_1detail_1_1multidimensional"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1detail_1_1multiply__result"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1multiply__result">multiply_result</a></td></tr>
<tr class="separator:structhydra_1_1detail_1_1multiply__result"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1nearest__int.html">nearest_int</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Round to nearest integer at compile time.  <a href="structhydra_1_1detail_1_1nearest__int.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1detail_1_1ObjSelector"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1ObjSelector">ObjSelector</a></td></tr>
<tr class="separator:structhydra_1_1detail_1_1ObjSelector"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1ObjSelector_3_01false_01_4.html">ObjSelector&lt; false &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1ObjSelector_3_01true_01_4.html">ObjSelector&lt; true &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1detail_1_1Parameters.html">Parameters</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1detail_1_1Parameters_3_010_01_4.html">Parameters&lt; 0 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">specialization for no-parametrized functor  <a href="classhydra_1_1detail_1_1Parameters_3_010_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1detail_1_1ParametersCompositeFunctor.html">ParametersCompositeFunctor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1power.html">power</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1power_3_01B_00_010_01_4.html">power&lt; B, 0 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1ProcessBoxesVegas.html">ProcessBoxesVegas</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1ProcessCallsPlainBinary.html">ProcessCallsPlainBinary</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1ProcessCallsPlainUnary.html">ProcessCallsPlainUnary</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1ProcessCallsVegas.html">ProcessCallsVegas</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1ProcessCallsVegas_3_01FUNCTOR_00_01NDimensions_00_01hydra_1_1detail_1_1d02dd45e61a2dbf17b7be7b9bd27e346.html">ProcessCallsVegas&lt; FUNCTOR, NDimensions, hydra::detail::BackendPolicy&lt; BACKEND &gt;, IteratorBackendReal, IteratorBackendUInt, GRND &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1ProcessGenzMalikBinaryCall.html">ProcessGenzMalikBinaryCall</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1ProcessGenzMalikBox.html">ProcessGenzMalikBox</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1ProcessGenzMalikUnaryCall.html">ProcessGenzMalikUnaryCall</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1detail_1_1quasi__random__base.html">quasi_random_base</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1detail_1_1references__tuple__type"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1references__tuple__type">references_tuple_type</a></td></tr>
<tr class="separator:structhydra_1_1detail_1_1references__tuple__type"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1detail_1_1remove__device__reference"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1remove__device__reference">remove_device_reference</a></td></tr>
<tr class="separator:structhydra_1_1detail_1_1remove__device__reference"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1detail_1_1remove__device__reference_3_01hydra__thrust_1_1device__reference_3_01T_01_4_01_4"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1remove__device__reference_3_01hydra__thrust_1_1device__reference_3_01T_01_4_01_4">remove_device_reference&lt; hydra_thrust::device_reference&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:structhydra_1_1detail_1_1remove__device__reference_3_01hydra__thrust_1_1device__reference_3_01T_01_4_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1detail_1_1repeat"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1repeat">repeat</a></td></tr>
<tr class="separator:structhydra_1_1detail_1_1repeat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1detail_1_1repeat_3_01T_00_010_00_01TT_01_4"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1repeat_3_01T_00_010_00_01TT_01_4">repeat&lt; T, 0, TT &gt;</a></td></tr>
<tr class="separator:structhydra_1_1detail_1_1repeat_3_01T_00_010_00_01TT_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1detail_1_1ResultPHSP"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1ResultPHSP">ResultPHSP</a></td></tr>
<tr class="separator:structhydra_1_1detail_1_1ResultPHSP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1detail_1_1ResultVegas"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1ResultVegas">ResultVegas</a></td></tr>
<tr class="separator:structhydra_1_1detail_1_1ResultVegas"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1RndBreitWigner.html">RndBreitWigner</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1RndCDF.html">RndCDF</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1RndExp.html">RndExp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1RndFlag.html">RndFlag</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1RndGauss.html">RndGauss</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1RndTrial.html">RndTrial</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1RndTrial_3_01T_00_01GRND_00_01FUNCTOR_00_011_01_4.html">RndTrial&lt; T, GRND, FUNCTOR, 1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1RndUniform.html">RndUniform</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1Sampler.html">Sampler</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1detail_1_1selected__indices__tuple"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1selected__indices__tuple">selected_indices_tuple</a></td></tr>
<tr class="separator:structhydra_1_1detail_1_1selected__indices__tuple"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1detail_1_1selected__indices__tuple_3_01Selector_00_01hydra_1_1tuple_3_01Head_00_01Tail_8_8_8_01_4_00_01I_01_4"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1selected__indices__tuple_3_01Selector_00_01hydra_1_1tuple_3_01Head_00_01Tail_8_8_8_01_4_00_01I_01_4">selected_indices_tuple&lt; Selector, hydra::tuple&lt; Head, Tail... &gt;, I &gt;</a></td></tr>
<tr class="separator:structhydra_1_1detail_1_1selected__indices__tuple_3_01Selector_00_01hydra_1_1tuple_3_01Head_00_01Tail_8_8_8_01_4_00_01I_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1detail_1_1selected__indices__tuple_3_01Selector_00_01hydra_1_1tuple_3_01Type_01_4_00_01I_01_4"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1selected__indices__tuple_3_01Selector_00_01hydra_1_1tuple_3_01Type_01_4_00_01I_01_4">selected_indices_tuple&lt; Selector, hydra::tuple&lt; Type &gt;, I &gt;</a></td></tr>
<tr class="separator:structhydra_1_1detail_1_1selected__indices__tuple_3_01Selector_00_01hydra_1_1tuple_3_01Type_01_4_00_01I_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1detail_1_1selected__tuple"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1selected__tuple">selected_tuple</a></td></tr>
<tr class="separator:structhydra_1_1detail_1_1selected__tuple"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1detail_1_1selected__tuple_3_01Selector_00_01hydra_1_1tuple_3_01Head_00_01Tail_8_8_8_01_4_01_4"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1selected__tuple_3_01Selector_00_01hydra_1_1tuple_3_01Head_00_01Tail_8_8_8_01_4_01_4">selected_tuple&lt; Selector, hydra::tuple&lt; Head, Tail... &gt; &gt;</a></td></tr>
<tr class="separator:structhydra_1_1detail_1_1selected__tuple_3_01Selector_00_01hydra_1_1tuple_3_01Head_00_01Tail_8_8_8_01_4_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1detail_1_1selected__tuple_3_01Selector_00_01hydra_1_1tuple_3_01Type_01_4_01_4"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1selected__tuple_3_01Selector_00_01hydra_1_1tuple_3_01Type_01_4_01_4">selected_tuple&lt; Selector, hydra::tuple&lt; Type &gt; &gt;</a></td></tr>
<tr class="separator:structhydra_1_1detail_1_1selected__tuple_3_01Selector_00_01hydra_1_1tuple_3_01Type_01_4_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1detail_1_1signature__traits"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1signature__traits">signature_traits</a></td></tr>
<tr class="separator:structhydra_1_1detail_1_1signature__traits"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1signature__traits_3_01R_07Args_8_8_8_08_4.html">signature_traits&lt; R(Args...)&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1detail_1_1signature__type"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1signature__type">signature_type</a></td></tr>
<tr class="separator:structhydra_1_1detail_1_1signature__type"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1detail_1_1signature__type__impl"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1signature__type__impl">signature_type_impl</a></td></tr>
<tr class="separator:structhydra_1_1detail_1_1signature__type__impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1sobol__lattice.html">sobol_lattice</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1SobolTable.html">SobolTable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1StatsPHSP.html">StatsPHSP</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1detail_1_1stripped__type"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1stripped__type">stripped_type</a></td></tr>
<tr class="separator:structhydra_1_1detail_1_1stripped__type"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1detail_1_1stripped__type_3_01Arg_00_01false_01_4"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1stripped__type_3_01Arg_00_01false_01_4">stripped_type&lt; Arg, false &gt;</a></td></tr>
<tr class="separator:structhydra_1_1detail_1_1stripped__type_3_01Arg_00_01false_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1detail_1_1stripped__type_3_01Arg_00_01true_01_4"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1stripped__type_3_01Arg_00_01true_01_4">stripped_type&lt; Arg, true &gt;</a></td></tr>
<tr class="separator:structhydra_1_1detail_1_1stripped__type_3_01Arg_00_01true_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1detail_1_1sum__result"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1sum__result">sum_result</a></td></tr>
<tr class="separator:structhydra_1_1detail_1_1sum__result"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1SWeights.html">SWeights</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1detail_1_1tag__type"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1tag__type">tag_type</a></td></tr>
<tr class="separator:structhydra_1_1detail_1_1tag__type"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1detail_1_1tuple__cat__type"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1tuple__cat__type">tuple_cat_type</a></td></tr>
<tr class="separator:structhydra_1_1detail_1_1tuple__cat__type"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1detail_1_1tuple__cat__type_3_01hydra__thrust_1_1detail_1_1tuple__of__iterator__re5bb9ebd0e2b48fed7e7ce237c7799785"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1tuple__cat__type_3_01hydra__thrust_1_1detail_1_1tuple__of__iterator__re5bb9ebd0e2b48fed7e7ce237c7799785">tuple_cat_type&lt; hydra_thrust::detail::tuple_of_iterator_references&lt; T1... &gt;, hydra_thrust::detail::tuple_of_iterator_references&lt; T2... &gt; &gt;</a></td></tr>
<tr class="separator:structhydra_1_1detail_1_1tuple__cat__type_3_01hydra__thrust_1_1detail_1_1tuple__of__iterator__re5bb9ebd0e2b48fed7e7ce237c7799785"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1detail_1_1tuple__cat__type_3_01hydra__thrust_1_1tuple_3_01T1_8_8_8_01_4_00_01hydrfed0294bfa8beb4efb8ca45fc614f789"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1tuple__cat__type_3_01hydra__thrust_1_1tuple_3_01T1_8_8_8_01_4_00_01hydrfed0294bfa8beb4efb8ca45fc614f789">tuple_cat_type&lt; hydra_thrust::tuple&lt; T1... &gt;, hydra_thrust::tuple&lt; T2... &gt; &gt;</a></td></tr>
<tr class="separator:structhydra_1_1detail_1_1tuple__cat__type_3_01hydra__thrust_1_1tuple_3_01T1_8_8_8_01_4_00_01hydrfed0294bfa8beb4efb8ca45fc614f789"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1detail_1_1tuple__type"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1tuple__type">tuple_type</a></td></tr>
<tr class="separator:structhydra_1_1detail_1_1tuple__type"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1TypeTraits.html">TypeTraits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1TypeTraits_3_01hydra__thrust_1_1complex_3_01T_01_4_01_4.html">TypeTraits&lt; hydra_thrust::complex&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1uint__t.html">uint_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1detail_1_1unidimensional"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1unidimensional">unidimensional</a></td></tr>
<tr class="separator:structhydra_1_1detail_1_1unidimensional"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a3c72e1aed3a4538dac06a7e816543c23"><td class="memTemplParams" colspan="2">template&lt;class R , class... Ts&gt; </td></tr>
<tr class="memitem:a3c72e1aed3a4538dac06a7e816543c23"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a3c72e1aed3a4538dac06a7e816543c23">are_all_same</a> = <a class="el" href="structhydra_1_1detail_1_1all__true.html">all_true</a>&lt; std::is_same&lt; Ts, R &gt;::value... &gt;</td></tr>
<tr class="separator:a3c72e1aed3a4538dac06a7e816543c23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee93c31c37a22c22c49c73483cfd0f91"><td class="memTemplParams" colspan="2">template&lt;class... T&gt; </td></tr>
<tr class="memitem:aee93c31c37a22c22c49c73483cfd0f91"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#aee93c31c37a22c22c49c73483cfd0f91">common_type_t</a> = typename std::common_type&lt; T... &gt;::type</td></tr>
<tr class="separator:aee93c31c37a22c22c49c73483cfd0f91"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a21eef8c0671371274978fac6d9b44180"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="namespacehydra_1_1detail.html#a21eef8c0671371274978fac6d9b44180aea9c72bdee6f384d88af4eab49530ea8">kInvalidNumber</a> = -111
 }</td></tr>
<tr class="separator:a21eef8c0671371274978fac6d9b44180"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1461b18b118ced9f91233acbe90fd897"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a1461b18b118ced9f91233acbe90fd897">Backend</a> { <br />
&#160;&#160;<a class="el" href="namespacehydra_1_1detail.html#a1461b18b118ced9f91233acbe90fd897a394a4eccb0e1634ec1294f902f5439e2">Host</a>, 
<a class="el" href="namespacehydra_1_1detail.html#a1461b18b118ced9f91233acbe90fd897ad7a51d196c98a1057d741a6ebd3d84db">Device</a>, 
<a class="el" href="namespacehydra_1_1detail.html#a1461b18b118ced9f91233acbe90fd897a0fb8e6fb3bd5e20cae92bc309106fae4">Cpp</a>, 
<a class="el" href="namespacehydra_1_1detail.html#a1461b18b118ced9f91233acbe90fd897a1b83f5e80dc60afdb33987f3d9ce20bf">Omp</a>, 
<br />
&#160;&#160;<a class="el" href="namespacehydra_1_1detail.html#a1461b18b118ced9f91233acbe90fd897a0346e63703cdc5752878c4e0623ace64">Tbb</a>, 
<a class="el" href="namespacehydra_1_1detail.html#a1461b18b118ced9f91233acbe90fd897a3ef47f45ff0de8694163bcfe498e4a89">Cuda</a>
<br />
 }</td></tr>
<tr class="separator:a1461b18b118ced9f91233acbe90fd897"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa817d51dec8ff2c9ad9eeaf1f91bc6e4"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#aa817d51dec8ff2c9ad9eeaf1f91bc6e4">FFTCalculator</a> { <a class="el" href="namespacehydra_1_1detail.html#aa817d51dec8ff2c9ad9eeaf1f91bc6e4a2dcac3babe9917463a1823b4fc97d989">CuFFT</a>, 
<a class="el" href="namespacehydra_1_1detail.html#aa817d51dec8ff2c9ad9eeaf1f91bc6e4ac7647480fd178ef276ec77e4830704b3">FFTW</a>
 }</td></tr>
<tr class="separator:aa817d51dec8ff2c9ad9eeaf1f91bc6e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a02f4955fdb3b1d3d98c25b46369edbeb"><td class="memTemplParams" colspan="2">template&lt;typename R , typename T , size_t I&gt; </td></tr>
<tr class="memitem:a02f4955fdb3b1d3d98c25b46369edbeb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::detail::enable_if&lt;(I==hydra_thrust::tuple_size&lt; T &gt;::value), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a02f4955fdb3b1d3d98c25b46369edbeb">_get_element</a> (const size_t, T &amp;, R *&amp;)</td></tr>
<tr class="separator:a02f4955fdb3b1d3d98c25b46369edbeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56f1616d93ab32d59a37fbb6b88c2eda"><td class="memTemplParams" colspan="2">template&lt;typename R , typename T , size_t I = 0&gt; </td></tr>
<tr class="memitem:a56f1616d93ab32d59a37fbb6b88c2eda"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::detail::enable_if&lt;(I&lt; hydra_thrust::tuple_size&lt; T &gt;::value), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a56f1616d93ab32d59a37fbb6b88c2eda">_get_element</a> (const size_t index, T &amp;t, R *&amp;ptr)</td></tr>
<tr class="separator:a56f1616d93ab32d59a37fbb6b88c2eda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a498be0db424a8fb9eb104c824560c620"><td class="memTemplParams" colspan="2">template&lt;typename Return_Type , typename ArgType , typename ... Tp, typename  = typename hydra_thrust::detail::enable_if&lt;std::is_convertible&lt;Return_Type, double&gt;::value || std::is_constructible&lt;hydra_thrust::complex&lt;double&gt;,Return_Type&gt;::value &gt;::type&gt; </td></tr>
<tr class="memitem:a498be0db424a8fb9eb104c824560c620"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> Return_Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a498be0db424a8fb9eb104c824560c620">accumulate</a> (ArgType &amp;x, hydra_thrust::tuple&lt; Tp... &gt; &amp;t)</td></tr>
<tr class="separator:a498be0db424a8fb9eb104c824560c620"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ad8b6c8a043ca17c3c6571487a00af3"><td class="memTemplParams" colspan="2">template&lt;typename Return_Type , typename ArgType , typename ... Tp, typename  = typename hydra_thrust::detail::enable_if&lt;std::is_convertible&lt;Return_Type, double&gt;::value || std::is_constructible&lt;hydra_thrust::complex&lt;double&gt;,Return_Type&gt;::value &gt;::type&gt; </td></tr>
<tr class="memitem:a6ad8b6c8a043ca17c3c6571487a00af3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> Return_Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a6ad8b6c8a043ca17c3c6571487a00af3">accumulate</a> (ArgType const &amp;x, hydra_thrust::tuple&lt; Tp... &gt; const &amp;t)</td></tr>
<tr class="separator:a6ad8b6c8a043ca17c3c6571487a00af3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab89cdc62576c0e346bbbf0e86c517e06"><td class="memTemplParams" colspan="2">template&lt;typename Return_Type , typename ArgType1 , typename ArgType2 , typename ... Tp, typename  = typename hydra_thrust::detail::enable_if&lt;std::is_convertible&lt;Return_Type, double&gt;::value || std::is_constructible&lt;hydra_thrust::complex&lt;double&gt;,Return_Type&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:ab89cdc62576c0e346bbbf0e86c517e06"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> Return_Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#ab89cdc62576c0e346bbbf0e86c517e06">accumulate2</a> (ArgType1 &amp;x, ArgType2 &amp;y, hydra_thrust::tuple&lt; Tp... &gt; &amp;t)</td></tr>
<tr class="separator:ab89cdc62576c0e346bbbf0e86c517e06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7d3ac2f47956b582edbf82881afccb6"><td class="memTemplParams" colspan="2">template&lt;typename Return_Type , typename ArgType1 , typename ArgType2 , typename ... Tp, typename  = typename hydra_thrust::detail::enable_if&lt;std::is_convertible&lt;Return_Type, double&gt;::value || std::is_constructible&lt;hydra_thrust::complex&lt;double&gt;,Return_Type&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:ad7d3ac2f47956b582edbf82881afccb6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> Return_Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#ad7d3ac2f47956b582edbf82881afccb6">accumulate2</a> (ArgType1 const &amp;x, ArgType2 const &amp;y, hydra_thrust::tuple&lt; Tp... &gt; const &amp;t)</td></tr>
<tr class="separator:ad7d3ac2f47956b582edbf82881afccb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4a03e1acf7793aeeb625d420ac67e23"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename ... Tp&gt; </td></tr>
<tr class="memitem:aa4a03e1acf7793aeeb625d420ac67e23"><td class="memTemplItemLeft" align="right" valign="top">hydra_thrust::detail::enable_if&lt; I==sizeof...(Tp), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#aa4a03e1acf7793aeeb625d420ac67e23">add_parameters_in_tuple</a> (std::vector&lt; <a class="el" href="group__fit.html#structhydra_1_1Parameter">hydra::Parameter</a> *&gt; &amp;, hydra_thrust::tuple&lt; Tp... &gt; &amp;)</td></tr>
<tr class="separator:aa4a03e1acf7793aeeb625d420ac67e23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2194b2d6ba44a6a6a85ac0ffca19339c"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename ... Tp&gt; </td></tr>
<tr class="memitem:a2194b2d6ba44a6a6a85ac0ffca19339c"><td class="memTemplItemLeft" align="right" valign="top">hydra_thrust::detail::enable_if&lt;(I&lt; sizeof...(Tp)), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a2194b2d6ba44a6a6a85ac0ffca19339c">add_parameters_in_tuple</a> (std::vector&lt; <a class="el" href="group__fit.html#structhydra_1_1Parameter">hydra::Parameter</a> *&gt; &amp;user_parameters, hydra_thrust::tuple&lt; Tp... &gt; &amp;t)</td></tr>
<tr class="separator:a2194b2d6ba44a6a6a85ac0ffca19339c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2df93ef3f457f1eb6f203758033350df"><td class="memTemplParams" colspan="2">template&lt;size_t I, typename ... T&gt; </td></tr>
<tr class="memitem:a2df93ef3f457f1eb6f203758033350df"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::detail::enable_if&lt;(I==sizeof...(T)), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a2df93ef3f457f1eb6f203758033350df">add_tuple_values</a> (<a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> &amp;, hydra_thrust::tuple&lt; T... &gt; const &amp;)</td></tr>
<tr class="separator:a2df93ef3f457f1eb6f203758033350df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a438dc9b0660d0be705cd74a24bb75055"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename ... T&gt; </td></tr>
<tr class="memitem:a438dc9b0660d0be705cd74a24bb75055"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::detail::enable_if&lt;(I&lt; sizeof...(T)), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a438dc9b0660d0be705cd74a24bb75055">add_tuple_values</a> (<a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> &amp;result, hydra_thrust::tuple&lt; T... &gt; const &amp;tpl)</td></tr>
<tr class="separator:a438dc9b0660d0be705cd74a24bb75055"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2bcf09451ea3c99060645b5332cf540"><td class="memTemplParams" colspan="2">template&lt;typename ... T, size_t ... I&gt; </td></tr>
<tr class="memitem:ab2bcf09451ea3c99060645b5332cf540"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::tuple&lt; T... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#ab2bcf09451ea3c99060645b5332cf540">addTuples</a> (const hydra_thrust::tuple&lt; T... &gt; &amp;a, const hydra_thrust::tuple&lt; T... &gt; &amp;b, <a class="el" href="structhydra_1_1detail_1_1index__sequence.html">index_sequence</a>&lt; I... &gt;)</td></tr>
<tr class="separator:ab2bcf09451ea3c99060645b5332cf540"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b556152a6d0f6477b1622231aa0a32f"><td class="memTemplParams" colspan="2">template&lt;typename ... T&gt; </td></tr>
<tr class="memitem:a7b556152a6d0f6477b1622231aa0a32f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::tuple&lt; T... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a7b556152a6d0f6477b1622231aa0a32f">addTuples</a> (const hydra_thrust::tuple&lt; T... &gt; &amp;a, const hydra_thrust::tuple&lt; T... &gt; &amp;b)</td></tr>
<tr class="separator:a7b556152a6d0f6477b1622231aa0a32f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaea8534bb7462e49893de47801d285a0"><td class="memTemplParams" colspan="2">template&lt;size_t I, typename ... T&gt; </td></tr>
<tr class="memitem:aaea8534bb7462e49893de47801d285a0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::tuple_element&lt; I, hydra_thrust::tuple&lt; T... &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#aaea8534bb7462e49893de47801d285a0">addTuplesHelper</a> (const hydra_thrust::tuple&lt; T... &gt; &amp;a, const hydra_thrust::tuple&lt; T... &gt; &amp;b)</td></tr>
<tr class="separator:aaea8534bb7462e49893de47801d285a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3be119e15f0b9be4173ba8268a66b71"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa3be119e15f0b9be4173ba8268a66b71"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#aa3be119e15f0b9be4173ba8268a66b71">ApproximatelyEqual</a> (T a, T b, T tolerance=<a class="el" href="namespacehydra_1_1detail.html#af60fc3e60cc10bd79092ca02c8e8b84c">machine_eps_f64</a>())</td></tr>
<tr class="separator:aa3be119e15f0b9be4173ba8268a66b71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc4a7a3b4f3c2827fd0eaff57e0b300c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:acc4a7a3b4f3c2827fd0eaff57e0b300c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#acc4a7a3b4f3c2827fd0eaff57e0b300c">ApproximatelyZero</a> (T a, T tolerance=<a class="el" href="namespacehydra_1_1detail.html#af60fc3e60cc10bd79092ca02c8e8b84c">machine_eps_f64</a>())</td></tr>
<tr class="separator:acc4a7a3b4f3c2827fd0eaff57e0b300c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fb09f08e05c59f9cb8f7810677b0a35"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N&gt; </td></tr>
<tr class="memitem:a2fb09f08e05c59f9cb8f7810677b0a35"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a2fb09f08e05c59f9cb8f7810677b0a35">arrayToTuple</a> (std::array&lt; T, N &gt;const &amp;Array) -&gt; decltype(<a class="el" href="namespacehydra_1_1detail.html#a45da45c4361e4fa7183b32d72d5441af">arrayToTupleHelper</a>(Array, <a class="el" href="structhydra_1_1detail_1_1make__index__sequence.html">make_index_sequence</a>&lt; N &gt;</td></tr>
<tr class="separator:a2fb09f08e05c59f9cb8f7810677b0a35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d0da29f0be34c5fe0f79e47b6963340"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N&gt; </td></tr>
<tr class="memitem:a9d0da29f0be34c5fe0f79e47b6963340"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a9d0da29f0be34c5fe0f79e47b6963340">arrayToTuple</a> (T *Array) -&gt; decltype(<a class="el" href="namespacehydra_1_1detail.html#a45da45c4361e4fa7183b32d72d5441af">arrayToTupleHelper</a>(Array, <a class="el" href="structhydra_1_1detail_1_1make__index__sequence.html">make_index_sequence</a>&lt; N &gt;</td></tr>
<tr class="separator:a9d0da29f0be34c5fe0f79e47b6963340"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45da45c4361e4fa7183b32d72d5441af"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t... Is&gt; </td></tr>
<tr class="memitem:a45da45c4361e4fa7183b32d72d5441af"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a45da45c4361e4fa7183b32d72d5441af">arrayToTupleHelper</a> (std::array&lt; T, sizeof...(Is)&gt;const &amp;Array, <a class="el" href="structhydra_1_1detail_1_1index__sequence.html">index_sequence</a>&lt; Is... &gt;) -&gt; decltype(hydra_thrust::make_tuple(Array[Is]...))</td></tr>
<tr class="separator:a45da45c4361e4fa7183b32d72d5441af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0f469856dbd0bb5e87f5c012efae2b0"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t... Indices&gt; </td></tr>
<tr class="memitem:aa0f469856dbd0bb5e87f5c012efae2b0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#aa0f469856dbd0bb5e87f5c012efae2b0">arrayToTupleHelper</a> (T *Array, <a class="el" href="structhydra_1_1detail_1_1index__sequence.html">index_sequence</a>&lt; Indices... &gt;) -&gt; decltype(hydra_thrust::make_tuple(Array[Indices]...))</td></tr>
<tr class="separator:aa0f469856dbd0bb5e87f5c012efae2b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d10110b86c5d6e45099e126e5c54fb7"><td class="memTemplParams" colspan="2">template&lt;size_t I, typename ArrayType , typename FistType , typename ... OtherTypes&gt; </td></tr>
<tr class="memitem:a2d10110b86c5d6e45099e126e5c54fb7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::detail::enable_if&lt; I==(sizeof...(OtherTypes)+1) &amp;&amp;std::is_convertible&lt; FistType, ArrayType &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1all__true.html">all_true</a>&lt; std::is_convertible&lt; OtherTypes, ArrayType &gt;::value... &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a2d10110b86c5d6e45099e126e5c54fb7">assignArrayToTuple</a> (hydra_thrust::tuple&lt; FistType, OtherTypes... &gt; &amp;, ArrayType const *)</td></tr>
<tr class="separator:a2d10110b86c5d6e45099e126e5c54fb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08b60bbd48640f46836c018a4e685b70"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename ArrayType , typename FistType , typename ... OtherTypes&gt; </td></tr>
<tr class="memitem:a08b60bbd48640f46836c018a4e685b70"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::detail::enable_if&lt;(I&lt; sizeof...(OtherTypes)+1) &amp;&amp;std::is_convertible&lt; FistType, ArrayType &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1all__true.html">all_true</a>&lt; std::is_convertible&lt; OtherTypes, ArrayType &gt;::value... &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a08b60bbd48640f46836c018a4e685b70">assignArrayToTuple</a> (hydra_thrust::tuple&lt; FistType, OtherTypes... &gt; &amp;t, ArrayType const *Array)</td></tr>
<tr class="separator:a08b60bbd48640f46836c018a4e685b70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09d65a22cd08900bb301cfa560cab50f"><td class="memTemplParams" colspan="2">template&lt;size_t I, typename ArrayType , typename FistType , typename ... OtherTypes&gt; </td></tr>
<tr class="memitem:a09d65a22cd08900bb301cfa560cab50f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::detail::enable_if&lt; I==(sizeof...(OtherTypes)+1) &amp;&amp;std::is_convertible&lt; FistType, ArrayType &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1all__true.html">all_true</a>&lt; std::is_convertible&lt; OtherTypes, ArrayType &gt;::value... &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a09d65a22cd08900bb301cfa560cab50f">assignArrayToTuple</a> (hydra_thrust::detail::tuple_of_iterator_references&lt; FistType, OtherTypes... &gt; &amp;, ArrayType const *)</td></tr>
<tr class="separator:a09d65a22cd08900bb301cfa560cab50f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a94b4c8a4f17b2014c79be1a2f05f6a"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename ArrayType , typename FistType , typename ... OtherTypes&gt; </td></tr>
<tr class="memitem:a7a94b4c8a4f17b2014c79be1a2f05f6a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::detail::enable_if&lt;(I&lt; sizeof...(OtherTypes)+1) &amp;&amp;std::is_convertible&lt; FistType, ArrayType &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1all__true.html">all_true</a>&lt; std::is_convertible&lt; OtherTypes, ArrayType &gt;::value... &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a7a94b4c8a4f17b2014c79be1a2f05f6a">assignArrayToTuple</a> (hydra_thrust::detail::tuple_of_iterator_references&lt; FistType, OtherTypes... &gt; &amp;t, ArrayType const *Array)</td></tr>
<tr class="separator:a7a94b4c8a4f17b2014c79be1a2f05f6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8824f1c8bee0a4b09bfc0eff093dd14f"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename ArrayType , typename FistType , typename ... OtherTypes&gt; </td></tr>
<tr class="memitem:a8824f1c8bee0a4b09bfc0eff093dd14f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::detail::enable_if&lt; I==(sizeof...(OtherTypes)+1) &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1is__hydra__convertible__to__tuple.html">is_hydra_convertible_to_tuple</a>&lt; ArrayType &gt;::value &amp;&amp;<a class="el" href="namespacehydra_1_1detail.html#a3c72e1aed3a4538dac06a7e816543c23">are_all_same</a>&lt; FistType, OtherTypes... &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a8824f1c8bee0a4b09bfc0eff093dd14f">assignTupleToArray</a> (hydra_thrust::tuple&lt; FistType, OtherTypes... &gt; const &amp;, ArrayType(&amp;)[sizeof...(OtherTypes)+1])</td></tr>
<tr class="separator:a8824f1c8bee0a4b09bfc0eff093dd14f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72efcb430e2aea2171eba70f81cb08b8"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename ArrayType , typename FistType , typename ... OtherTypes&gt; </td></tr>
<tr class="memitem:a72efcb430e2aea2171eba70f81cb08b8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::detail::enable_if&lt;(I&lt; sizeof...(OtherTypes)+1) &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1is__hydra__convertible__to__tuple.html">is_hydra_convertible_to_tuple</a>&lt; ArrayType &gt;::value &amp;&amp;<a class="el" href="namespacehydra_1_1detail.html#a3c72e1aed3a4538dac06a7e816543c23">are_all_same</a>&lt; FistType, OtherTypes... &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a72efcb430e2aea2171eba70f81cb08b8">assignTupleToArray</a> (hydra_thrust::tuple&lt; FistType, OtherTypes... &gt; const &amp;t, ArrayType(&amp;Array)[sizeof...(OtherTypes)+1])</td></tr>
<tr class="separator:a72efcb430e2aea2171eba70f81cb08b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85d6c644fd94e7d86174c9da15486ca3"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename ArrayType , typename FistType , typename ... OtherTypes&gt; </td></tr>
<tr class="memitem:a85d6c644fd94e7d86174c9da15486ca3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::detail::enable_if&lt; I==(sizeof...(OtherTypes)+1) &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1is__hydra__convertible__to__tuple.html">is_hydra_convertible_to_tuple</a>&lt; ArrayType &gt;::value &amp;&amp;<a class="el" href="namespacehydra_1_1detail.html#a3c72e1aed3a4538dac06a7e816543c23">are_all_same</a>&lt; FistType, OtherTypes... &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a85d6c644fd94e7d86174c9da15486ca3">assignTupleToArray</a> (hydra_thrust::tuple&lt; FistType &amp;, OtherTypes &amp;... &gt; const &amp;, ArrayType(&amp;)[sizeof...(OtherTypes)+1])</td></tr>
<tr class="separator:a85d6c644fd94e7d86174c9da15486ca3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac32dd708dfece676fb655b6600946ebe"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename ArrayType , typename FistType , typename ... OtherTypes&gt; </td></tr>
<tr class="memitem:ac32dd708dfece676fb655b6600946ebe"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::detail::enable_if&lt;(I&lt; sizeof...(OtherTypes)+1) &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1is__hydra__convertible__to__tuple.html">is_hydra_convertible_to_tuple</a>&lt; ArrayType &gt;::value &amp;&amp;<a class="el" href="namespacehydra_1_1detail.html#a3c72e1aed3a4538dac06a7e816543c23">are_all_same</a>&lt; FistType, OtherTypes... &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#ac32dd708dfece676fb655b6600946ebe">assignTupleToArray</a> (hydra_thrust::tuple&lt; FistType &amp;, OtherTypes &amp;... &gt; const &amp;t, ArrayType(&amp;Array)[sizeof...(OtherTypes)+1])</td></tr>
<tr class="separator:ac32dd708dfece676fb655b6600946ebe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a370d1378b3bf83ff0976dc85cb97a559"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename ArrayType , typename FistType , typename ... OtherTypes&gt; </td></tr>
<tr class="memitem:a370d1378b3bf83ff0976dc85cb97a559"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::detail::enable_if&lt; I==(sizeof...(OtherTypes)+1) &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1is__hydra__convertible__to__tuple.html">is_hydra_convertible_to_tuple</a>&lt; ArrayType &gt;::value &amp;&amp;<a class="el" href="namespacehydra_1_1detail.html#a3c72e1aed3a4538dac06a7e816543c23">are_all_same</a>&lt; FistType, OtherTypes... &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a370d1378b3bf83ff0976dc85cb97a559">assignTupleToArray</a> (hydra_thrust::detail::tuple_of_iterator_references&lt; FistType, OtherTypes... &gt; const &amp;, ArrayType(&amp;)[sizeof...(OtherTypes)+1])</td></tr>
<tr class="separator:a370d1378b3bf83ff0976dc85cb97a559"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7600f26d1540ce89d073e564d97909ab"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename ArrayType , typename FistType , typename ... OtherTypes&gt; </td></tr>
<tr class="memitem:a7600f26d1540ce89d073e564d97909ab"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::detail::enable_if&lt;(I&lt; sizeof...(OtherTypes)+1) &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1is__hydra__convertible__to__tuple.html">is_hydra_convertible_to_tuple</a>&lt; ArrayType &gt;::value &amp;&amp;<a class="el" href="namespacehydra_1_1detail.html#a3c72e1aed3a4538dac06a7e816543c23">are_all_same</a>&lt; FistType, OtherTypes... &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a7600f26d1540ce89d073e564d97909ab">assignTupleToArray</a> (hydra_thrust::detail::tuple_of_iterator_references&lt; FistType, OtherTypes... &gt; const &amp;t, ArrayType(&amp;Array)[sizeof...(OtherTypes)+1])</td></tr>
<tr class="separator:a7600f26d1540ce89d073e564d97909ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82f8b5cc4c258c0b78743536023d080e"><td class="memTemplParams" colspan="2">template&lt;typename F , typename ... T&gt; </td></tr>
<tr class="memitem:a82f8b5cc4c258c0b78743536023d080e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::tuple&lt; T... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a82f8b5cc4c258c0b78743536023d080e">callOnTuple</a> (F const &amp;f, const hydra_thrust::tuple&lt; T... &gt; &amp;<a class="el" href="namespacehydra.html#a717fc4e6b10453164099beade13d0226">tuple</a>)</td></tr>
<tr class="separator:a82f8b5cc4c258c0b78743536023d080e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a046148d4f1af6d6e26a4615a84e4bbaa"><td class="memTemplParams" colspan="2">template&lt;typename F , typename ... T, size_t ... I&gt; </td></tr>
<tr class="memitem:a046148d4f1af6d6e26a4615a84e4bbaa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::tuple&lt; T... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a046148d4f1af6d6e26a4615a84e4bbaa">callOnTupleHelper</a> (F const &amp;f, const hydra_thrust::tuple&lt; T... &gt; &amp;<a class="el" href="namespacehydra.html#a717fc4e6b10453164099beade13d0226">tuple</a>, <a class="el" href="structhydra_1_1detail_1_1index__sequence.html">index_sequence</a>&lt; I... &gt;)</td></tr>
<tr class="separator:a046148d4f1af6d6e26a4615a84e4bbaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeccac2b5a421cca43286e9717d251c69"><td class="memTemplParams" colspan="2">template&lt;typename T , typename ... Ts&gt; </td></tr>
<tr class="memitem:aeccac2b5a421cca43286e9717d251c69"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#aeccac2b5a421cca43286e9717d251c69">CheckValue</a> (T &amp;&amp;x, char const *fmt, char const *file, char const *function, <a class="el" href="namespace_3globalScope_4.html#classunsigned">unsigned</a> <a class="el" href="namespace_3globalScope_4.html#classint">int</a> line, Ts &amp;&amp;...par)</td></tr>
<tr class="separator:aeccac2b5a421cca43286e9717d251c69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24033eefbdb1401523f0c4936e05da28"><td class="memTemplParams" colspan="2">template&lt;typename ... T, size_t ... I&gt; </td></tr>
<tr class="memitem:a24033eefbdb1401523f0c4936e05da28"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::tuple&lt; T... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a24033eefbdb1401523f0c4936e05da28">divideTuples</a> (const hydra_thrust::tuple&lt; T... &gt; &amp;a, const hydra_thrust::tuple&lt; T... &gt; &amp;b, <a class="el" href="structhydra_1_1detail_1_1index__sequence.html">index_sequence</a>&lt; I... &gt;)</td></tr>
<tr class="separator:a24033eefbdb1401523f0c4936e05da28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf108707b80a851bd097ee8e3a5afcdf"><td class="memTemplParams" colspan="2">template&lt;typename ... T&gt; </td></tr>
<tr class="memitem:aaf108707b80a851bd097ee8e3a5afcdf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::tuple&lt; T... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#aaf108707b80a851bd097ee8e3a5afcdf">divideTuples</a> (const hydra_thrust::tuple&lt; T... &gt; &amp;a, const hydra_thrust::tuple&lt; T... &gt; &amp;b)</td></tr>
<tr class="separator:aaf108707b80a851bd097ee8e3a5afcdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2632a763908afba57fcbc5e8d7a09f0a"><td class="memTemplParams" colspan="2">template&lt;size_t I, typename ... T&gt; </td></tr>
<tr class="memitem:a2632a763908afba57fcbc5e8d7a09f0a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::tuple_element&lt; I, hydra_thrust::tuple&lt; T... &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a2632a763908afba57fcbc5e8d7a09f0a">divideTuplesHelper</a> (const hydra_thrust::tuple&lt; T... &gt; &amp;a, const hydra_thrust::tuple&lt; T... &gt; &amp;b)</td></tr>
<tr class="separator:a2632a763908afba57fcbc5e8d7a09f0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03b17f9b7b0e39924e0819250d04ea85"><td class="memTemplParams" colspan="2">template&lt;unsigned int I = 0, typename FuncT , typename ... Tp&gt; </td></tr>
<tr class="memitem:a03b17f9b7b0e39924e0819250d04ea85"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::detail::enable_if&lt; I==sizeof...(Tp), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a03b17f9b7b0e39924e0819250d04ea85">eval_on_tuple_element</a> (<a class="el" href="namespace_3globalScope_4.html#classint">int</a>, hydra_thrust::tuple&lt; Tp... &gt; const &amp;, FuncT const &amp;)</td></tr>
<tr class="separator:a03b17f9b7b0e39924e0819250d04ea85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe7c19041604f8d2835e030454b95d0f"><td class="memTemplParams" colspan="2">template&lt;unsigned int I = 0, typename FuncT , typename ... Tp&gt; </td></tr>
<tr class="memitem:afe7c19041604f8d2835e030454b95d0f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::detail::enable_if&lt;(I&lt; sizeof...(Tp)), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#afe7c19041604f8d2835e030454b95d0f">eval_on_tuple_element</a> (<a class="el" href="namespace_3globalScope_4.html#classint">int</a> index, hydra_thrust::tuple&lt; Tp... &gt; const &amp;t, FuncT const &amp;f)</td></tr>
<tr class="separator:afe7c19041604f8d2835e030454b95d0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45910f4522df506c9e510219a2327e96"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename Return_Type , typename ArgType , typename ... Tp&gt; </td></tr>
<tr class="memitem:a45910f4522df506c9e510219a2327e96"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::detail::enable_if&lt; I==sizeof...(Tp), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a45910f4522df506c9e510219a2327e96">eval_tuple_element</a> (Return_Type &amp;, <a class="el" href="namespace_3globalScope_4.html#classint">int</a>, hydra_thrust::tuple&lt; Tp... &gt; const &amp;, ArgType const &amp;)</td></tr>
<tr class="separator:a45910f4522df506c9e510219a2327e96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5059b569131e6db6c738eb807e743c25"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename Return_Type , typename ArgType , typename ... Tp&gt; </td></tr>
<tr class="memitem:a5059b569131e6db6c738eb807e743c25"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::detail::enable_if&lt;(I&lt; sizeof...(Tp)), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a5059b569131e6db6c738eb807e743c25">eval_tuple_element</a> (Return_Type &amp;r, <a class="el" href="namespace_3globalScope_4.html#classint">int</a> index, hydra_thrust::tuple&lt; Tp... &gt; const &amp;t, ArgType const &amp;<a class="el" href="namespacehydra.html#ae96191cbaa62c58f63b7e58924362c24">arg</a>)</td></tr>
<tr class="separator:a5059b569131e6db6c738eb807e743c25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96a946dad2a4b9f834836d9b954ad8b6"><td class="memTemplParams" colspan="2">template&lt;typename Type , typename Tuple &gt; </td></tr>
<tr class="memitem:a96a946dad2a4b9f834836d9b954ad8b6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a96a946dad2a4b9f834836d9b954ad8b6">extract</a> (const <a class="el" href="namespace_3globalScope_4.html#classint">int</a> idx, const Tuple &amp;t)</td></tr>
<tr class="separator:a96a946dad2a4b9f834836d9b954ad8b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add5147a947f0edd769e9fc10f7a65759"><td class="memTemplParams" colspan="2">template&lt;typename R , typename ... T&gt; </td></tr>
<tr class="memitem:add5147a947f0edd769e9fc10f7a65759"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> R &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#add5147a947f0edd769e9fc10f7a65759">get_element</a> (const size_t index, hydra_thrust::tuple&lt; T... &gt; &amp;t)</td></tr>
<tr class="separator:add5147a947f0edd769e9fc10f7a65759"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cb37313145410697a80a4a7786a1712"><td class="memTemplParams" colspan="2">template&lt;typename Tup &gt; </td></tr>
<tr class="memitem:a8cb37313145410697a80a4a7786a1712"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a8cb37313145410697a80a4a7786a1712">get_functor_tuple</a> (Tup &amp;pdfs) -&gt; decltype(<a class="el" href="namespacehydra_1_1detail.html#a500db4ea93e7304d994ed97337f1c479">get_functor_tuple_helper</a>(pdfs, <a class="el" href="structhydra_1_1detail_1_1make__index__sequence.html">make_index_sequence</a>&lt; hydra_thrust::tuple_size&lt; Tup &gt;::value &gt;</td></tr>
<tr class="separator:a8cb37313145410697a80a4a7786a1712"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a500db4ea93e7304d994ed97337f1c479"><td class="memTemplParams" colspan="2">template&lt;typename Tup , size_t ... index&gt; </td></tr>
<tr class="memitem:a500db4ea93e7304d994ed97337f1c479"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a500db4ea93e7304d994ed97337f1c479">get_functor_tuple_helper</a> (Tup &amp;pdfs, <a class="el" href="structhydra_1_1detail_1_1index__sequence.html">index_sequence</a>&lt; index... &gt;) -&gt; decltype(hydra_thrust::make_tuple(hydra_thrust::get&lt; index &gt;(pdfs).GetFunctor()...))</td></tr>
<tr class="separator:a500db4ea93e7304d994ed97337f1c479"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c688d5b722922805a5837cac93a6411"><td class="memItemLeft" align="right" valign="top"><a class="el" href="basic__distributions_8inl.html#a9717e7bbecb906637e86cef6da3d83c2">return</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a7c688d5b722922805a5837cac93a6411">get_functor_tuple_helper</a> (pdfs, <a class="el" href="structhydra_1_1detail_1_1make__index__sequence.html">make_index_sequence</a>&lt; Size &gt; { })</td></tr>
<tr class="separator:a7c688d5b722922805a5837cac93a6411"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a325f4c7bd791f8e4c8e7777fd1004e6a"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t DIM, size_t I&gt; </td></tr>
<tr class="memitem:a325f4c7bd791f8e4c8e7777fd1004e6a"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;(I==DIM) &amp;&amp;(std::is_integral&lt; T &gt;::value), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a325f4c7bd791f8e4c8e7777fd1004e6a">get_indexes</a> (size_t, std::array&lt; T, DIM &gt; const &amp;, std::array&lt; T, DIM &gt; &amp;)</td></tr>
<tr class="separator:a325f4c7bd791f8e4c8e7777fd1004e6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ba59a3eeef51673f8abf850370c9d55"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t DIM, size_t I = 0&gt; </td></tr>
<tr class="memitem:a7ba59a3eeef51673f8abf850370c9d55"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;(I&lt; DIM) &amp;&amp;(std::is_integral&lt; T &gt;::value), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a7ba59a3eeef51673f8abf850370c9d55">get_indexes</a> (size_t index, std::array&lt; T, DIM &gt; const &amp;depths, std::array&lt; T, DIM &gt; &amp;indexes)</td></tr>
<tr class="separator:a7ba59a3eeef51673f8abf850370c9d55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25ee93686d2834f2c81bbc9ca75340b3"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t DIM, size_t I&gt; </td></tr>
<tr class="memitem:a25ee93686d2834f2c81bbc9ca75340b3"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;(I==DIM) &amp;&amp;(std::is_integral&lt; T &gt;::value), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a25ee93686d2834f2c81bbc9ca75340b3">get_indexes</a> (size_t, const T(&amp;)[DIM], T(&amp;)[DIM])</td></tr>
<tr class="separator:a25ee93686d2834f2c81bbc9ca75340b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab08843425e05190a4baeb424c9da09a9"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t DIM, size_t I = 0&gt; </td></tr>
<tr class="memitem:ab08843425e05190a4baeb424c9da09a9"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;(I&lt; DIM) &amp;&amp;(std::is_integral&lt; T &gt;::value), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#ab08843425e05190a4baeb424c9da09a9">get_indexes</a> (size_t index, const T(&amp;depths)[DIM], T(&amp;indexes)[DIM])</td></tr>
<tr class="separator:ab08843425e05190a4baeb424c9da09a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81cfdb5fabf173a3f07608e3c8d46deb"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Types&gt; </td></tr>
<tr class="memitem:a81cfdb5fabf173a3f07608e3c8d46deb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a81cfdb5fabf173a3f07608e3c8d46deb">get_tuple_element</a> (hydra_thrust::tuple&lt; Types... &gt; &amp;t)</td></tr>
<tr class="separator:a81cfdb5fabf173a3f07608e3c8d46deb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3f6b46b33c605d2cec7605fb5bd8661"><td class="memTemplParams" colspan="2">template&lt;class T , class... Types&gt; </td></tr>
<tr class="memitem:af3f6b46b33c605d2cec7605fb5bd8661"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#af3f6b46b33c605d2cec7605fb5bd8661">get_tuple_element</a> (const hydra_thrust::tuple&lt; Types... &gt; &amp;t)</td></tr>
<tr class="separator:af3f6b46b33c605d2cec7605fb5bd8661"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0415b176fc2467d2d59b0258d8f0078"><td class="memTemplParams" colspan="2">template&lt;class T , class... Types&gt; </td></tr>
<tr class="memitem:ad0415b176fc2467d2d59b0258d8f0078"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> T &amp;&amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#ad0415b176fc2467d2d59b0258d8f0078">get_tuple_element</a> (hydra_thrust::tuple&lt; Types... &gt; &amp;&amp;t)</td></tr>
<tr class="separator:ad0415b176fc2467d2d59b0258d8f0078"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6c2f7bef9f3b69d9e87ad1f8a156ac9"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Types&gt; </td></tr>
<tr class="memitem:ab6c2f7bef9f3b69d9e87ad1f8a156ac9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::device_reference&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#ab6c2f7bef9f3b69d9e87ad1f8a156ac9">get_tuple_element</a> (hydra_thrust::tuple&lt; hydra_thrust::device_reference&lt; Types &gt;... &gt; &amp;t)</td></tr>
<tr class="separator:ab6c2f7bef9f3b69d9e87ad1f8a156ac9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79277e2a97c4ebc035e38a9f84eef76e"><td class="memTemplParams" colspan="2">template&lt;class T , class... Types&gt; </td></tr>
<tr class="memitem:a79277e2a97c4ebc035e38a9f84eef76e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> const hydra_thrust::device_reference&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a79277e2a97c4ebc035e38a9f84eef76e">get_tuple_element</a> (const hydra_thrust::tuple&lt; hydra_thrust::device_reference&lt; Types &gt;... &gt; &amp;t)</td></tr>
<tr class="separator:a79277e2a97c4ebc035e38a9f84eef76e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a885cfb94fba2e2aebc1e092fea2cf939"><td class="memTemplParams" colspan="2">template&lt;class T , class... Types&gt; </td></tr>
<tr class="memitem:a885cfb94fba2e2aebc1e092fea2cf939"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::device_reference&lt; T &gt; &amp;&amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a885cfb94fba2e2aebc1e092fea2cf939">get_tuple_element</a> (hydra_thrust::tuple&lt; hydra_thrust::device_reference&lt; Types &gt;... &gt; &amp;&amp;t)</td></tr>
<tr class="separator:a885cfb94fba2e2aebc1e092fea2cf939"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17e36369eb43435874bb774de93bd563"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Types&gt; </td></tr>
<tr class="memitem:a17e36369eb43435874bb774de93bd563"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::device_reference&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a17e36369eb43435874bb774de93bd563">get_tuple_element</a> (hydra_thrust::detail::tuple_of_iterator_references&lt; hydra_thrust::device_reference&lt; Types &gt;... &gt; &amp;t)</td></tr>
<tr class="separator:a17e36369eb43435874bb774de93bd563"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33e2e586f14706e98c469ea12d0f8119"><td class="memTemplParams" colspan="2">template&lt;class T , class... Types&gt; </td></tr>
<tr class="memitem:a33e2e586f14706e98c469ea12d0f8119"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> const hydra_thrust::device_reference&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a33e2e586f14706e98c469ea12d0f8119">get_tuple_element</a> (const hydra_thrust::detail::tuple_of_iterator_references&lt; hydra_thrust::device_reference&lt; Types &gt;... &gt; &amp;t)</td></tr>
<tr class="separator:a33e2e586f14706e98c469ea12d0f8119"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd899f8898ce87464b9003d72ffdedc1"><td class="memTemplParams" colspan="2">template&lt;class T , class... Types&gt; </td></tr>
<tr class="memitem:afd899f8898ce87464b9003d72ffdedc1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::device_reference&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#afd899f8898ce87464b9003d72ffdedc1">get_tuple_element</a> (hydra_thrust::detail::tuple_of_iterator_references&lt; hydra_thrust::device_reference&lt; Types &gt;... &gt; &amp;&amp;t)</td></tr>
<tr class="separator:afd899f8898ce87464b9003d72ffdedc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6edb844108024e669c32dad4c1246c8"><td class="memTemplParams" colspan="2">template&lt;unsigned int I = 0, typename T , typename ... Tp&gt; </td></tr>
<tr class="memitem:ab6edb844108024e669c32dad4c1246c8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::detail::enable_if&lt; I==sizeof...(Tp), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#ab6edb844108024e669c32dad4c1246c8">get_tuple_element</a> (const <a class="el" href="namespace_3globalScope_4.html#classint">int</a>, hydra_thrust::tuple&lt; Tp... &gt; const &amp;, T &amp;)</td></tr>
<tr class="separator:ab6edb844108024e669c32dad4c1246c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17fb31790c0652edefd8e9438fa69103"><td class="memTemplParams" colspan="2">template&lt;unsigned int I = 0, typename T , typename ... Tp&gt; </td></tr>
<tr class="memitem:a17fb31790c0652edefd8e9438fa69103"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::detail::enable_if&lt;(I&lt; sizeof...(Tp)), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a17fb31790c0652edefd8e9438fa69103">get_tuple_element</a> (const <a class="el" href="namespace_3globalScope_4.html#classint">int</a> index, hydra_thrust::tuple&lt; Tp... &gt; const &amp;t, T &amp;x)</td></tr>
<tr class="separator:a17fb31790c0652edefd8e9438fa69103"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a227e0b524804a0ceef56b4a1da1953d4"><td class="memTemplParams" colspan="2">template&lt;typename Iterator , size_t N&gt; </td></tr>
<tr class="memitem:a227e0b524804a0ceef56b4a1da1953d4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a227e0b524804a0ceef56b4a1da1953d4">get_zip_iterator</a> (std::array&lt; Iterator, N &gt;const &amp;array_of_iterators) -&gt; decltype(<a class="el" href="namespacehydra_1_1detail.html#a0e7ac2e75fefa5d9a41daa1d7279c8c5">get_zip_iterator_helper</a>(array_of_iterators, <a class="el" href="structhydra_1_1detail_1_1make__index__sequence.html">make_index_sequence</a>&lt; N &gt;</td></tr>
<tr class="separator:a227e0b524804a0ceef56b4a1da1953d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9da0535b5305aaf5cfe698c42ebc8d6"><td class="memTemplParams" colspan="2">template&lt;typename IteratorHead , typename IteratorTail , size_t N&gt; </td></tr>
<tr class="memitem:ae9da0535b5305aaf5cfe698c42ebc8d6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#ae9da0535b5305aaf5cfe698c42ebc8d6">get_zip_iterator</a> (IteratorHead head, std::array&lt; IteratorTail, N &gt;const &amp;array_of_iterators) -&gt; decltype(<a class="el" href="namespacehydra_1_1detail.html#a0e7ac2e75fefa5d9a41daa1d7279c8c5">get_zip_iterator_helper</a>(head, array_of_iterators, <a class="el" href="structhydra_1_1detail_1_1make__index__sequence.html">make_index_sequence</a>&lt; N &gt;</td></tr>
<tr class="separator:ae9da0535b5305aaf5cfe698c42ebc8d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e7ac2e75fefa5d9a41daa1d7279c8c5"><td class="memTemplParams" colspan="2">template&lt;typename Iterator , size_t ... Index&gt; </td></tr>
<tr class="memitem:a0e7ac2e75fefa5d9a41daa1d7279c8c5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a0e7ac2e75fefa5d9a41daa1d7279c8c5">get_zip_iterator_helper</a> (std::array&lt; Iterator, sizeof ...(Index)&gt;const &amp;array_of_iterators, <a class="el" href="structhydra_1_1detail_1_1index__sequence.html">index_sequence</a>&lt; Index... &gt;) -&gt; decltype(hydra_thrust::make_zip_iterator(hydra_thrust::make_tuple(array_of_iterators[Index]...)))</td></tr>
<tr class="separator:a0e7ac2e75fefa5d9a41daa1d7279c8c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8087253280ceed0580f29a1688f385e9"><td class="memTemplParams" colspan="2">template&lt;typename IteratorHead , typename IteratorTail , size_t ... Index&gt; </td></tr>
<tr class="memitem:a8087253280ceed0580f29a1688f385e9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a8087253280ceed0580f29a1688f385e9">get_zip_iterator_helper</a> (IteratorHead head, std::array&lt; IteratorTail, sizeof ...(Index)&gt;const &amp;array_of_iterators, <a class="el" href="structhydra_1_1detail_1_1index__sequence.html">index_sequence</a>&lt; Index... &gt;) -&gt; decltype(hydra_thrust::make_zip_iterator(hydra_thrust::make_tuple(head, array_of_iterators[Index]...)))</td></tr>
<tr class="separator:a8087253280ceed0580f29a1688f385e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a618d244958e2ded8465ae85756a011cd"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a618d244958e2ded8465ae85756a011cd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a618d244958e2ded8465ae85756a011cd">hash_combine</a> (std::size_t &amp;seed, T const &amp;v)</td></tr>
<tr class="separator:a618d244958e2ded8465ae85756a011cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0be774a301b3817c97d58c61aa08ba85"><td class="memTemplParams" colspan="2">template&lt;class It &gt; </td></tr>
<tr class="memitem:a0be774a301b3817c97d58c61aa08ba85"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a0be774a301b3817c97d58c61aa08ba85">hash_range</a> (It first, It last)</td></tr>
<tr class="separator:a0be774a301b3817c97d58c61aa08ba85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abda9a4b4ec271e3f6c5adf9bc93a3173"><td class="memTemplParams" colspan="2">template&lt;class It &gt; </td></tr>
<tr class="memitem:abda9a4b4ec271e3f6c5adf9bc93a3173"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#abda9a4b4ec271e3f6c5adf9bc93a3173">hash_range</a> (std::size_t &amp;seed, It first, It last)</td></tr>
<tr class="separator:abda9a4b4ec271e3f6c5adf9bc93a3173"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a256df6594bc88c80701d99622515c875"><td class="memTemplParams" colspan="2">template&lt;typename ... T&gt; </td></tr>
<tr class="memitem:a256df6594bc88c80701d99622515c875"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a256df6594bc88c80701d99622515c875">hash_tuple</a> (std::size_t &amp;seed, <a class="el" href="namespacehydra.html#a717fc4e6b10453164099beade13d0226">hydra::tuple</a>&lt; T... &gt; const &amp;_tuple)</td></tr>
<tr class="separator:a256df6594bc88c80701d99622515c875"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a425bb4f65a43d822ba80ebdbca5b8b74"><td class="memTemplParams" colspan="2">template&lt;typename ... T&gt; </td></tr>
<tr class="memitem:a425bb4f65a43d822ba80ebdbca5b8b74"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a425bb4f65a43d822ba80ebdbca5b8b74">hash_tuple</a> (<a class="el" href="namespacehydra.html#a717fc4e6b10453164099beade13d0226">hydra::tuple</a>&lt; T... &gt; const &amp;_tuple)</td></tr>
<tr class="separator:a425bb4f65a43d822ba80ebdbca5b8b74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b30f3961b7f4ed7c28a4e1373281c1c"><td class="memTemplParams" colspan="2">template&lt;typename Tup , typename ArgType , size_t N = hydra_thrust::tuple_size&lt;typename hydra_thrust::detail::remove_reference&lt;Tup&gt;::type&gt;::value&gt; </td></tr>
<tr class="memitem:a0b30f3961b7f4ed7c28a4e1373281c1c"><td class="memTemplItemLeft" align="right" valign="top">__hydra_thrust_exec_check_disable__ <a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a0b30f3961b7f4ed7c28a4e1373281c1c">invoke</a> (ArgType &amp;&amp;x, Tup &amp;&amp;tup) -&gt; decltype(<a class="el" href="namespacehydra_1_1detail.html#a4a70502ee212958c154c2ea97c1047ab">invoke_helper</a>(std::forward&lt; ArgType &gt;(x), std::forward&lt; Tup &gt;(tup), <a class="el" href="structhydra_1_1detail_1_1make__index__sequence.html">make_index_sequence</a>&lt; N &gt;</td></tr>
<tr class="separator:a0b30f3961b7f4ed7c28a4e1373281c1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad31b6d1499b5a6b2d77c015a71385a6e"><td class="memTemplParams" colspan="2">template&lt;typename Tup , typename ArgType , size_t N = hydra_thrust::tuple_size&lt;typename hydra_thrust::detail::remove_reference&lt;Tup&gt;::type&gt;::value&gt; </td></tr>
<tr class="memitem:ad31b6d1499b5a6b2d77c015a71385a6e"><td class="memTemplItemLeft" align="right" valign="top">__hydra_thrust_exec_check_disable__ <a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#ad31b6d1499b5a6b2d77c015a71385a6e">invoke</a> (ArgType const &amp;x, Tup const &amp;tup) -&gt; decltype(<a class="el" href="namespacehydra_1_1detail.html#a4a70502ee212958c154c2ea97c1047ab">invoke_helper</a>(x, tup, <a class="el" href="structhydra_1_1detail_1_1make__index__sequence.html">make_index_sequence</a>&lt; N &gt;</td></tr>
<tr class="separator:ad31b6d1499b5a6b2d77c015a71385a6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c6414446d272ca304b39b9d9b7b0c35"><td class="memTemplParams" colspan="2">template&lt;typename Tup , typename ArgType1 , typename ArgType2 , size_t N = hydra_thrust::tuple_size&lt;typename hydra_thrust::detail::remove_reference&lt;Tup&gt;::type&gt;::value&gt; </td></tr>
<tr class="memitem:a3c6414446d272ca304b39b9d9b7b0c35"><td class="memTemplItemLeft" align="right" valign="top">__hydra_thrust_exec_check_disable__ <a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a3c6414446d272ca304b39b9d9b7b0c35">invoke</a> (ArgType1 &amp;&amp;x, ArgType2 &amp;&amp;y, Tup &amp;&amp;tup) -&gt; decltype(<a class="el" href="namespacehydra_1_1detail.html#a4a70502ee212958c154c2ea97c1047ab">invoke_helper</a>(std::forward&lt; ArgType1 &gt;(x), std::forward&lt; ArgType2 &gt;(y), std::forward&lt; Tup &gt;(tup), <a class="el" href="structhydra_1_1detail_1_1make__index__sequence.html">make_index_sequence</a>&lt; hydra_thrust::tuple_size&lt; Tup &gt;::value &gt;</td></tr>
<tr class="separator:a3c6414446d272ca304b39b9d9b7b0c35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af119ddecbbdf7e22bde76370b3b28f0c"><td class="memTemplParams" colspan="2">template&lt;typename Tup , typename ArgType1 , typename ArgType2 &gt; </td></tr>
<tr class="memitem:af119ddecbbdf7e22bde76370b3b28f0c"><td class="memTemplItemLeft" align="right" valign="top">__hydra_thrust_exec_check_disable__ <a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#af119ddecbbdf7e22bde76370b3b28f0c">invoke</a> (ArgType1 const &amp;x, ArgType2 const &amp;y, Tup const &amp;tup) -&gt; decltype(<a class="el" href="namespacehydra_1_1detail.html#a4a70502ee212958c154c2ea97c1047ab">invoke_helper</a>(x, y, tup, <a class="el" href="structhydra_1_1detail_1_1make__index__sequence.html">make_index_sequence</a>&lt; hydra_thrust::tuple_size&lt; Tup &gt;::value &gt;</td></tr>
<tr class="separator:af119ddecbbdf7e22bde76370b3b28f0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a70502ee212958c154c2ea97c1047ab"><td class="memTemplParams" colspan="2">template&lt;typename Tup , typename ArgType , size_t ... index&gt; </td></tr>
<tr class="memitem:a4a70502ee212958c154c2ea97c1047ab"><td class="memTemplItemLeft" align="right" valign="top">__hydra_thrust_exec_check_disable__ <a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a4a70502ee212958c154c2ea97c1047ab">invoke_helper</a> (ArgType &amp;&amp;x, Tup &amp;&amp;tup, <a class="el" href="structhydra_1_1detail_1_1index__sequence.html">index_sequence</a>&lt; index... &gt;) -&gt; decltype(hydra_thrust::make_tuple(hydra_thrust::get&lt; index &gt;(std::forward&lt; Tup &gt;(tup))(std::forward&lt; ArgType &gt;(x))...))</td></tr>
<tr class="separator:a4a70502ee212958c154c2ea97c1047ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeba5bf60f8de619daa3665ab1a5c088d"><td class="memTemplParams" colspan="2">template&lt;typename Tup , typename ArgType , size_t ... index&gt; </td></tr>
<tr class="memitem:aeba5bf60f8de619daa3665ab1a5c088d"><td class="memTemplItemLeft" align="right" valign="top">__hydra_thrust_exec_check_disable__ <a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#aeba5bf60f8de619daa3665ab1a5c088d">invoke_helper</a> (ArgType const &amp;x, Tup const &amp;tup, <a class="el" href="structhydra_1_1detail_1_1index__sequence.html">index_sequence</a>&lt; index... &gt;) -&gt; decltype(hydra_thrust::make_tuple(hydra_thrust::get&lt; index &gt;(tup)(x)...))</td></tr>
<tr class="separator:aeba5bf60f8de619daa3665ab1a5c088d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90c0d2110813667cce17c16fcf21cdd2"><td class="memTemplParams" colspan="2">template&lt;typename Tup , typename ArgType1 , typename ArgType2 , size_t ... index&gt; </td></tr>
<tr class="memitem:a90c0d2110813667cce17c16fcf21cdd2"><td class="memTemplItemLeft" align="right" valign="top">__hydra_thrust_exec_check_disable__ <a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a90c0d2110813667cce17c16fcf21cdd2">invoke_helper</a> (ArgType1 &amp;&amp;x, ArgType2 &amp;&amp;y, Tup &amp;&amp;tup, <a class="el" href="structhydra_1_1detail_1_1index__sequence.html">index_sequence</a>&lt; index... &gt;) -&gt; decltype(hydra_thrust::make_tuple(hydra_thrust::get&lt; index &gt;(std::forward&lt; Tup &gt;(tup))(std::forward&lt; ArgType1 &gt;(x), std::forward&lt; ArgType2 &gt;(y))...))</td></tr>
<tr class="separator:a90c0d2110813667cce17c16fcf21cdd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7bfae6e91a367c89f0bd5d905237f16"><td class="memTemplParams" colspan="2">template&lt;typename Tup , typename ArgType1 , typename ArgType2 , size_t ... index&gt; </td></tr>
<tr class="memitem:aa7bfae6e91a367c89f0bd5d905237f16"><td class="memTemplItemLeft" align="right" valign="top">__hydra_thrust_exec_check_disable__ <a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#aa7bfae6e91a367c89f0bd5d905237f16">invoke_helper</a> (ArgType1 const &amp;x, ArgType2 const &amp;y, Tup const &amp;tup, <a class="el" href="structhydra_1_1detail_1_1index__sequence.html">index_sequence</a>&lt; index... &gt;) -&gt; decltype(hydra_thrust::make_tuple(hydra_thrust::get&lt; index &gt;(tup)(x, y)...))</td></tr>
<tr class="separator:aa7bfae6e91a367c89f0bd5d905237f16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9360a30d9cffc4d39b34187a56f0bb92"><td class="memItemLeft" align="right" valign="top"><a class="el" href="basic__distributions_8inl.html#a9717e7bbecb906637e86cef6da3d83c2">return</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a9360a30d9cffc4d39b34187a56f0bb92">invoke_helper</a> (x, y, tup, <a class="el" href="structhydra_1_1detail_1_1make__index__sequence.html">make_index_sequence</a>&lt; Size &gt; { })</td></tr>
<tr class="separator:a9360a30d9cffc4d39b34187a56f0bb92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af991f6032453407f65f584508d2f776d"><td class="memTemplParams" colspan="2">template&lt;typename Tup , typename ArgType &gt; </td></tr>
<tr class="memitem:af991f6032453407f65f584508d2f776d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#af991f6032453407f65f584508d2f776d">invoke_normalized</a> (ArgType const &amp;x, Tup const &amp;tup) -&gt; decltype(<a class="el" href="namespacehydra_1_1detail.html#a4a70502ee212958c154c2ea97c1047ab">invoke_helper</a>(x, tup, <a class="el" href="structhydra_1_1detail_1_1make__index__sequence.html">make_index_sequence</a>&lt; hydra_thrust::tuple_size&lt; Tup &gt;::value &gt;</td></tr>
<tr class="separator:af991f6032453407f65f584508d2f776d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4c0051b20d34181994aa5560387054e"><td class="memTemplParams" colspan="2">template&lt;typename Tup , typename ArgType , size_t N = hydra_thrust::tuple_size&lt;typename hydra_thrust::detail::remove_reference&lt;Tup&gt;::type&gt;::value&gt; </td></tr>
<tr class="memitem:af4c0051b20d34181994aa5560387054e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#af4c0051b20d34181994aa5560387054e">invoke_normalized</a> (ArgType &amp;&amp;x, Tup &amp;&amp;tup) -&gt; decltype(<a class="el" href="namespacehydra_1_1detail.html#a4a70502ee212958c154c2ea97c1047ab">invoke_helper</a>(std::forward&lt; ArgType &gt;(x), std::forward&lt; Tup &gt;(tup), <a class="el" href="structhydra_1_1detail_1_1make__index__sequence.html">make_index_sequence</a>&lt; N &gt;</td></tr>
<tr class="separator:af4c0051b20d34181994aa5560387054e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51dc6ae31393a420f089ca8fd1207c23"><td class="memTemplParams" colspan="2">template&lt;typename Tup , typename ArgType , size_t ... index&gt; </td></tr>
<tr class="memitem:a51dc6ae31393a420f089ca8fd1207c23"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a51dc6ae31393a420f089ca8fd1207c23">invoke_normalized_helper</a> (ArgType const &amp;x, Tup const &amp;tup, <a class="el" href="structhydra_1_1detail_1_1index__sequence.html">index_sequence</a>&lt; index... &gt;) -&gt; decltype(hydra_thrust::make_tuple(hydra_thrust::get&lt; index &gt;(tup)(x)...))</td></tr>
<tr class="separator:a51dc6ae31393a420f089ca8fd1207c23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a173eb394103a0e94fbf9abbc1918a894"><td class="memItemLeft" align="right" valign="top"><a class="el" href="basic__distributions_8inl.html#a9717e7bbecb906637e86cef6da3d83c2">return</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a173eb394103a0e94fbf9abbc1918a894">invoke_normalized_helper</a> (x, tup, <a class="el" href="structhydra_1_1detail_1_1make__index__sequence.html">make_index_sequence</a>&lt; Size &gt; { })</td></tr>
<tr class="separator:a173eb394103a0e94fbf9abbc1918a894"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a021aed8e1205f3ff6aef35d02065c612"><td class="memTemplParams" colspan="2">template&lt;typename Tup , typename ArgType , size_t ... index&gt; </td></tr>
<tr class="memitem:a021aed8e1205f3ff6aef35d02065c612"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a021aed8e1205f3ff6aef35d02065c612">invoke_normalized_helper</a> (ArgType &amp;&amp;x, Tup &amp;&amp;tup, <a class="el" href="structhydra_1_1detail_1_1index__sequence.html">index_sequence</a>&lt; index... &gt;) -&gt; decltype(hydra_thrust::make_tuple(hydra_thrust::get&lt; index &gt;(std::forward&lt; Tup &gt;(tup))(std::forward&lt; ArgType &gt;(x))...))</td></tr>
<tr class="separator:a021aed8e1205f3ff6aef35d02065c612"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad9d0de301331608aa91ce3589f9c5c1"><td class="memTemplParams" colspan="2">template&lt;class Iterator &gt; </td></tr>
<tr class="memitem:aad9d0de301331608aa91ce3589f9c5c1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#aad9d0de301331608aa91ce3589f9c5c1">iter_swap</a> (Iterator first, Iterator second)</td></tr>
<tr class="separator:aad9d0de301331608aa91ce3589f9c5c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0a8ff71493e18493d9df6b9cfa1a745"><td class="memTemplParams" colspan="2">template&lt;typename T , typename ... Ts&gt; </td></tr>
<tr class="memitem:ad0a8ff71493e18493d9df6b9cfa1a745"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#ad0a8ff71493e18493d9df6b9cfa1a745">kill</a> (T &amp;&amp;x)</td></tr>
<tr class="separator:ad0a8ff71493e18493d9df6b9cfa1a745"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5050bf77c477bccc5db77c507cca743"><td class="memTemplParams" colspan="2">template&lt;size_t N, typename GRND , typename Iterator &gt; </td></tr>
<tr class="memitem:ab5050bf77c477bccc5db77c507cca743"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#ab5050bf77c477bccc5db77c507cca743">launch_decayer</a> (Iterator <a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>, Iterator <a class="el" href="namespacehydra.html#a4274268d147e9a988f379326b73682b0">end</a>, <a class="el" href="structhydra_1_1detail_1_1DecayMother.html">DecayMother</a>&lt; N, GRND &gt; const &amp;decayer)</td></tr>
<tr class="separator:ab5050bf77c477bccc5db77c507cca743"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4695a02794382f4f997052b425413987"><td class="memTemplParams" colspan="2">template&lt;size_t N, typename GRND , typename Iterator , hydra::detail::Backend BACKEND&gt; </td></tr>
<tr class="memitem:a4695a02794382f4f997052b425413987"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a4695a02794382f4f997052b425413987">launch_decayer</a> (<a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; const &amp;exec_policy, Iterator <a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>, Iterator <a class="el" href="namespacehydra.html#a4274268d147e9a988f379326b73682b0">end</a>, <a class="el" href="structhydra_1_1detail_1_1DecayMother.html">DecayMother</a>&lt; N, GRND &gt; const &amp;decayer)</td></tr>
<tr class="separator:a4695a02794382f4f997052b425413987"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a35cdb4fa592a33bba8d836aed248df"><td class="memTemplParams" colspan="2">template&lt;size_t N, typename GRND , typename IteratorMother , typename IteratorDaughter &gt; </td></tr>
<tr class="memitem:a9a35cdb4fa592a33bba8d836aed248df"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a9a35cdb4fa592a33bba8d836aed248df">launch_decayer</a> (IteratorMother begin_mothers, IteratorMother end_mothers, IteratorDaughter begin_daugters, <a class="el" href="structhydra_1_1detail_1_1DecayMothers.html">DecayMothers</a>&lt; N, GRND &gt; const &amp;decayer)</td></tr>
<tr class="separator:a9a35cdb4fa592a33bba8d836aed248df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3482cd2a135b31d8bb68fcd11dcdac8d"><td class="memTemplParams" colspan="2">template&lt;size_t N, typename GRND , typename IteratorMother , typename IteratorDaughter , hydra::detail::Backend BACKEND&gt; </td></tr>
<tr class="memitem:a3482cd2a135b31d8bb68fcd11dcdac8d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a3482cd2a135b31d8bb68fcd11dcdac8d">launch_decayer</a> (<a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; const &amp;exec_policy, IteratorMother begin_mothers, IteratorMother end_mothers, IteratorDaughter begin_daugters, <a class="el" href="structhydra_1_1detail_1_1DecayMothers.html">DecayMothers</a>&lt; N, GRND &gt; const &amp;decayer)</td></tr>
<tr class="separator:a3482cd2a135b31d8bb68fcd11dcdac8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a2cc34389ca89449738a46e209133a8"><td class="memTemplParams" colspan="2">template&lt;size_t N, typename FUNCTOR , typename ... FUNCTORS, typename GRND , typename Iterator &gt; </td></tr>
<tr class="memitem:a9a2cc34389ca89449738a46e209133a8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a9a2cc34389ca89449738a46e209133a8">launch_evaluator</a> (Iterator <a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>, Iterator <a class="el" href="namespacehydra.html#a4274268d147e9a988f379326b73682b0">end</a>, <a class="el" href="structhydra_1_1detail_1_1EvalMother.html">detail::EvalMother</a>&lt; N, GRND, FUNCTOR, FUNCTORS... &gt; const &amp;evaluator)</td></tr>
<tr class="separator:a9a2cc34389ca89449738a46e209133a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a272aed700c4b40bbd2639a84507da00d"><td class="memTemplParams" colspan="2">template&lt;size_t N, typename FUNCTOR , typename ... FUNCTORS, typename GRND , typename IteratorMother , typename Iterator &gt; </td></tr>
<tr class="memitem:a272aed700c4b40bbd2639a84507da00d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a272aed700c4b40bbd2639a84507da00d">launch_evaluator</a> (IteratorMother mbegin, IteratorMother mend, Iterator <a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>, <a class="el" href="structhydra_1_1detail_1_1EvalMothers.html">detail::EvalMothers</a>&lt; N, GRND, FUNCTOR, FUNCTORS... &gt; const &amp;evaluator)</td></tr>
<tr class="separator:a272aed700c4b40bbd2639a84507da00d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dce458532ae6b3d821a91604dad7895"><td class="memTemplParams" colspan="2">template&lt;size_t N, hydra::detail::Backend BACKEND, typename FUNCTOR , typename GRND , typename Iterator &gt; </td></tr>
<tr class="memitem:a8dce458532ae6b3d821a91604dad7895"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structhydra_1_1detail_1_1StatsPHSP.html">StatsPHSP</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a8dce458532ae6b3d821a91604dad7895">launch_reducer</a> (<a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt;const &amp;policy, Iterator <a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>, Iterator <a class="el" href="namespacehydra.html#a4274268d147e9a988f379326b73682b0">end</a>, <a class="el" href="structhydra_1_1detail_1_1AverageMother.html">detail::AverageMother</a>&lt; N, GRND, FUNCTOR &gt; const &amp;evaluator)</td></tr>
<tr class="separator:a8dce458532ae6b3d821a91604dad7895"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8b536e68d5a5831e546272b56c031ee"><td class="memTemplParams" colspan="2">template&lt;size_t N, typename FUNCTOR , typename GRND , typename Iterator &gt; </td></tr>
<tr class="memitem:aa8b536e68d5a5831e546272b56c031ee"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structhydra_1_1detail_1_1StatsPHSP.html">StatsPHSP</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#aa8b536e68d5a5831e546272b56c031ee">launch_reducer</a> (Iterator <a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>, Iterator <a class="el" href="namespacehydra.html#a4274268d147e9a988f379326b73682b0">end</a>, <a class="el" href="structhydra_1_1detail_1_1AverageMothers.html">detail::AverageMothers</a>&lt; N, GRND, FUNCTOR &gt; const &amp;evaluator)</td></tr>
<tr class="separator:aa8b536e68d5a5831e546272b56c031ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a024a15ab3a2da15dc78f090437220dde"><td class="memTemplParams" colspan="2">template&lt;typename Integer &gt; </td></tr>
<tr class="memitem:a024a15ab3a2da15dc78f090437220dde"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> std::enable_if&lt; std::is_integral&lt; Integer &gt;::value &amp;&amp;!(std::is_signed&lt; Integer &gt;::value) &amp;&amp;(sizeof(Integer)==8), <a class="el" href="namespace_3globalScope_4.html#classunsigned">unsigned</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a024a15ab3a2da15dc78f090437220dde">lsb</a> (Integer x)</td></tr>
<tr class="separator:a024a15ab3a2da15dc78f090437220dde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5ba85f2308d53e41bfbd714a2850b3e"><td class="memTemplParams" colspan="2">template&lt;typename Integer &gt; </td></tr>
<tr class="memitem:af5ba85f2308d53e41bfbd714a2850b3e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> std::enable_if&lt; std::is_integral&lt; Integer &gt;::value &amp;&amp;!(std::is_signed&lt; Integer &gt;::value) &amp;&amp;(sizeof(Integer)==4), <a class="el" href="namespace_3globalScope_4.html#classunsigned">unsigned</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#af5ba85f2308d53e41bfbd714a2850b3e">lsb</a> (Integer x)</td></tr>
<tr class="separator:af5ba85f2308d53e41bfbd714a2850b3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afef4bbc17cf6421b0da41b1872dc7781"><td class="memItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#afef4bbc17cf6421b0da41b1872dc7781">machine_eps_f32</a> (float value=1.0)</td></tr>
<tr class="separator:afef4bbc17cf6421b0da41b1872dc7781"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af60fc3e60cc10bd79092ca02c8e8b84c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#af60fc3e60cc10bd79092ca02c8e8b84c">machine_eps_f64</a> (<a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> value=1.0)</td></tr>
<tr class="separator:af60fc3e60cc10bd79092ca02c8e8b84c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a806bd1d429f6b821efb5af237fecaa2f"><td class="memTemplParams" colspan="2">template&lt;typename ... T&gt; </td></tr>
<tr class="memitem:a806bd1d429f6b821efb5af237fecaa2f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a806bd1d429f6b821efb5af237fecaa2f">make_rtuple</a> (hydra_thrust::tuple&lt; T... &gt; &amp;t) -&gt; hydra_thrust::tuple&lt; T &amp;... &gt;</td></tr>
<tr class="separator:a806bd1d429f6b821efb5af237fecaa2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abea7b63acf2a24346dd220c91059e1da"><td class="memTemplParams" colspan="2">template&lt;typename ... T, size_t... I&gt; </td></tr>
<tr class="memitem:abea7b63acf2a24346dd220c91059e1da"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#abea7b63acf2a24346dd220c91059e1da">make_rtuple_helper</a> (hydra_thrust::tuple&lt; T... &gt; &amp;t, <a class="el" href="structhydra_1_1detail_1_1index__sequence.html">index_sequence</a>&lt; I... &gt;) -&gt; hydra_thrust::tuple&lt; T &amp;... &gt;</td></tr>
<tr class="separator:abea7b63acf2a24346dd220c91059e1da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac16e513053ac8d97923ac166db8e6a98"><td class="memItemLeft" align="right" valign="top">T ::type TupleType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#ac16e513053ac8d97923ac166db8e6a98">make_tuple</a> (T &amp;&amp;value)</td></tr>
<tr class="separator:ac16e513053ac8d97923ac166db8e6a98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8df2eb3ba9481fec054318974964ec3d"><td class="memTemplParams" colspan="2">template&lt;typename ... T&gt; </td></tr>
<tr class="memitem:a8df2eb3ba9481fec054318974964ec3d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a8df2eb3ba9481fec054318974964ec3d">max</a> (hydra_thrust::tuple&lt; T... &gt; const &amp;<a class="el" href="namespacehydra.html#a717fc4e6b10453164099beade13d0226">tuple</a>)</td></tr>
<tr class="separator:a8df2eb3ba9481fec054318974964ec3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4140580867ee73e401e1bb1e213548c"><td class="memTemplParams" colspan="2">template&lt;typename T , typename C , size_t N, size_t I&gt; </td></tr>
<tr class="memitem:aa4140580867ee73e401e1bb1e213548c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> std::enable_if&lt; I==N, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#aa4140580867ee73e401e1bb1e213548c">max_helper</a> (T const &amp;, <a class="el" href="basic__distributions_8inl.html#a4900ef306eb9271438791f1a98b8ccba">C</a> &amp;, size_t &amp;)</td></tr>
<tr class="separator:aa4140580867ee73e401e1bb1e213548c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad23b453b58064598dbd7596ffca55422"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#ad23b453b58064598dbd7596ffca55422">max_helper&lt; T, C, N, I+1 &gt;</a> (<a class="el" href="namespacehydra.html#a717fc4e6b10453164099beade13d0226">tuple</a>, <a class="el" href="namespacehydra_1_1detail.html#a6272aac6b63b0ff4f44d2ff9b24716cf">max_value</a>, max_index)</td></tr>
<tr class="separator:ad23b453b58064598dbd7596ffca55422"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac36de892880609f667e4d5cc9718a5e1"><td class="memTemplParams" colspan="2">template&lt;typename ... Iterators&gt; </td></tr>
<tr class="memitem:ac36de892880609f667e4d5cc9718a5e1"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#ac36de892880609f667e4d5cc9718a5e1">meld_iterators</a> (Iterators &amp;&amp;... iterators) -&gt; decltype(hydra_thrust::make_zip_iterator(hydra_thrust::tuple_cat(<a class="el" href="namespacehydra_1_1detail_1_1meld__iterators__ns.html#a6256486a1fd69c4d2df51f9fff3ef3d5">meld_iterators_ns::convert_to_tuple</a>(std::forward&lt; Iterators &gt;(iterators))...)))</td></tr>
<tr class="separator:ac36de892880609f667e4d5cc9718a5e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2273abcb7a8775a09d2d6d7aff1d59ee"><td class="memTemplParams" colspan="2">template&lt;typename Integer &gt; </td></tr>
<tr class="memitem:a2273abcb7a8775a09d2d6d7aff1d59ee"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> std::enable_if&lt; std::is_integral&lt; Integer &gt;::value &amp;&amp;!(std::is_signed&lt; Integer &gt;::value) &amp;&amp;(std::numeric_limits&lt; Integer &gt;::digits==64), <a class="el" href="namespace_3globalScope_4.html#classunsigned">unsigned</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a2273abcb7a8775a09d2d6d7aff1d59ee">msb</a> (Integer const &amp;x)</td></tr>
<tr class="separator:a2273abcb7a8775a09d2d6d7aff1d59ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a476a6db58de25883f66604846f28cc7f"><td class="memTemplParams" colspan="2">template&lt;typename Integer &gt; </td></tr>
<tr class="memitem:a476a6db58de25883f66604846f28cc7f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> std::enable_if&lt; std::is_integral&lt; Integer &gt;::value &amp;&amp;!(std::is_signed&lt; Integer &gt;::value) &amp;&amp;(std::numeric_limits&lt; Integer &gt;::digits&lt;=32), <a class="el" href="namespace_3globalScope_4.html#classunsigned">unsigned</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a476a6db58de25883f66604846f28cc7f">msb</a> (Integer const &amp;x)</td></tr>
<tr class="separator:a476a6db58de25883f66604846f28cc7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2b12c58b82f3d39caa4dffc5ce0faf9"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N, size_t I&gt; </td></tr>
<tr class="memitem:ad2b12c58b82f3d39caa4dffc5ce0faf9"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;(I==N), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#ad2b12c58b82f3d39caa4dffc5ce0faf9">multiply</a> (std::array&lt; T, N &gt; const &amp;, T &amp;)</td></tr>
<tr class="separator:ad2b12c58b82f3d39caa4dffc5ce0faf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52459ef87933d78d5ce88feb998bd8bd"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N, size_t I = 0&gt; </td></tr>
<tr class="memitem:a52459ef87933d78d5ce88feb998bd8bd"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;(I&lt; N), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a52459ef87933d78d5ce88feb998bd8bd">multiply</a> (std::array&lt; T, N &gt; const &amp;obj, T &amp;result)</td></tr>
<tr class="separator:a52459ef87933d78d5ce88feb998bd8bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af73aa95bb4dce5810569f682bb39de27"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N, size_t I&gt; </td></tr>
<tr class="memitem:af73aa95bb4dce5810569f682bb39de27"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;(I==N), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#af73aa95bb4dce5810569f682bb39de27">multiply</a> (const T(&amp;)[N], T &amp;)</td></tr>
<tr class="separator:af73aa95bb4dce5810569f682bb39de27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f767f0131f9a4910ece6f10d1b5a0f2"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N, size_t I = 0&gt; </td></tr>
<tr class="memitem:a4f767f0131f9a4910ece6f10d1b5a0f2"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;(I&lt; N), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a4f767f0131f9a4910ece6f10d1b5a0f2">multiply</a> (const T(&amp;obj)[N], T &amp;result)</td></tr>
<tr class="separator:a4f767f0131f9a4910ece6f10d1b5a0f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab992b62c0923bb8bd2bfd3a1fcc1a706"><td class="memTemplParams" colspan="2">template&lt;typename ... T&gt; </td></tr>
<tr class="memitem:ab992b62c0923bb8bd2bfd3a1fcc1a706"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#ab992b62c0923bb8bd2bfd3a1fcc1a706">multiply_array_tuple</a> (<a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>(&amp;fCoeficients)[sizeof...(T)], hydra_thrust::tuple&lt; T... &gt; const &amp;tpl) -&gt; decltype(<a class="el" href="namespacehydra_1_1detail.html#a643a9cfc48d39212a6856ce4a6458280">multiply_array_tuple_helper</a>(fCoeficients, tpl, <a class="el" href="structhydra_1_1detail_1_1make__index__sequence.html">make_index_sequence</a>&lt; sizeof...(T)&gt;</td></tr>
<tr class="separator:ab992b62c0923bb8bd2bfd3a1fcc1a706"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a643a9cfc48d39212a6856ce4a6458280"><td class="memTemplParams" colspan="2">template&lt;typename Tuple , size_t ... I&gt; </td></tr>
<tr class="memitem:a643a9cfc48d39212a6856ce4a6458280"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1tuple__type">tuple_type</a>&lt; sizeof...(I), <a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a643a9cfc48d39212a6856ce4a6458280">multiply_array_tuple_helper</a> (<a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>(&amp;fCoeficients)[sizeof...(I)], Tuple const &amp;tpl, <a class="el" href="structhydra_1_1detail_1_1index__sequence.html">index_sequence</a>&lt; I... &gt;)</td></tr>
<tr class="separator:a643a9cfc48d39212a6856ce4a6458280"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66bc1bf60cfc95e34f2ede6986e9af98"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename Return_Type , typename ... Tp&gt; </td></tr>
<tr class="memitem:a66bc1bf60cfc95e34f2ede6986e9af98"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::detail::enable_if&lt; I==sizeof...(Tp), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a66bc1bf60cfc95e34f2ede6986e9af98">multiply_tuple</a> (Return_Type &amp;, hydra_thrust::tuple&lt; Tp... &gt; const &amp;)</td></tr>
<tr class="separator:a66bc1bf60cfc95e34f2ede6986e9af98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac33cb24201ebd425c3b2f4c91465aea6"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename Return_Type , typename ... Tp&gt; </td></tr>
<tr class="memitem:ac33cb24201ebd425c3b2f4c91465aea6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::detail::enable_if&lt;(I&lt; sizeof...(Tp)), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#ac33cb24201ebd425c3b2f4c91465aea6">multiply_tuple</a> (Return_Type &amp;r, hydra_thrust::tuple&lt; Tp... &gt;const &amp;t)</td></tr>
<tr class="separator:ac33cb24201ebd425c3b2f4c91465aea6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad363c957681f91b698ac9f5212be47d"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename Return_Type , typename ... Tp&gt; </td></tr>
<tr class="memitem:aad363c957681f91b698ac9f5212be47d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::detail::enable_if&lt; I==sizeof...(Tp), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#aad363c957681f91b698ac9f5212be47d">multiply_tuple</a> (Return_Type &amp;, hydra_thrust::tuple&lt; Tp... &gt; &amp;&amp;)</td></tr>
<tr class="separator:aad363c957681f91b698ac9f5212be47d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b8b89a3ba444d2c8ef1a6ed26985e6d"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename Return_Type , typename ... Tp&gt; </td></tr>
<tr class="memitem:a4b8b89a3ba444d2c8ef1a6ed26985e6d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::detail::enable_if&lt;(I&lt; sizeof...(Tp)), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a4b8b89a3ba444d2c8ef1a6ed26985e6d">multiply_tuple</a> (Return_Type &amp;r, hydra_thrust::tuple&lt; Tp... &gt; &amp;&amp;t)</td></tr>
<tr class="separator:a4b8b89a3ba444d2c8ef1a6ed26985e6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a833faa576c3be31e8c4ad34938b4b948"><td class="memTemplParams" colspan="2">template&lt;typename ... T, size_t ... I&gt; </td></tr>
<tr class="memitem:a833faa576c3be31e8c4ad34938b4b948"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::tuple&lt; T... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a833faa576c3be31e8c4ad34938b4b948">multiplyTuples</a> (const hydra_thrust::tuple&lt; T... &gt; &amp;a, const hydra_thrust::tuple&lt; T... &gt; &amp;b, <a class="el" href="structhydra_1_1detail_1_1index__sequence.html">index_sequence</a>&lt; I... &gt;)</td></tr>
<tr class="separator:a833faa576c3be31e8c4ad34938b4b948"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b3cb8ce552d976fe50342f85d9b5b8d"><td class="memTemplParams" colspan="2">template&lt;typename ... T&gt; </td></tr>
<tr class="memitem:a1b3cb8ce552d976fe50342f85d9b5b8d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::tuple&lt; T... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a1b3cb8ce552d976fe50342f85d9b5b8d">multiplyTuples</a> (const hydra_thrust::tuple&lt; T... &gt; &amp;a, const hydra_thrust::tuple&lt; T... &gt; &amp;b)</td></tr>
<tr class="separator:a1b3cb8ce552d976fe50342f85d9b5b8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5786376f2b71be2e554ba1053899bd9"><td class="memTemplParams" colspan="2">template&lt;size_t I, typename ... T&gt; </td></tr>
<tr class="memitem:af5786376f2b71be2e554ba1053899bd9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::tuple_element&lt; I, hydra_thrust::tuple&lt; T... &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#af5786376f2b71be2e554ba1053899bd9">multiplyTuplesHelper</a> (const hydra_thrust::tuple&lt; T... &gt; &amp;a, const hydra_thrust::tuple&lt; T... &gt; &amp;b)</td></tr>
<tr class="separator:af5786376f2b71be2e554ba1053899bd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63701869476f9138ea31be4ef303e7c1"><td class="memTemplParams" colspan="2">template&lt;class BidirIt &gt; </td></tr>
<tr class="memitem:a63701869476f9138ea31be4ef303e7c1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a63701869476f9138ea31be4ef303e7c1">next_permutation</a> (BidirIt first, BidirIt last)</td></tr>
<tr class="separator:a63701869476f9138ea31be4ef303e7c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b2e7c87a80dcd5015c2a95ca88f67f1"><td class="memTemplParams" colspan="2">template&lt;typename Iterator , typename Integer , typename Comparator &gt; </td></tr>
<tr class="memitem:a0b2e7c87a80dcd5015c2a95ca88f67f1"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_integral&lt; Integer &gt;::value, void &gt;::type <a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a0b2e7c87a80dcd5015c2a95ca88f67f1">nth_permutation</a> (Iterator <a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>, Iterator <a class="el" href="namespacehydra.html#a4274268d147e9a988f379326b73682b0">end</a>, Integer <a class="el" href="crystal__ball__plus__exponential_8inl.html#a21f77208d6bc667560ff8aaf8f943b6a">n</a>, Comparator comp)</td></tr>
<tr class="separator:a0b2e7c87a80dcd5015c2a95ca88f67f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e34df05c3fc32da9e8fe01dddc9fd7e"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:a6e34df05c3fc32da9e8fe01dddc9fd7e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="classhydra_1_1detail_1_1GenzMalikBoxResult.html">GenzMalikBoxResult</a>&lt; Type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a6e34df05c3fc32da9e8fe01dddc9fd7e">operator+</a> (<a class="el" href="classhydra_1_1detail_1_1GenzMalikBoxResult.html">GenzMalikBoxResult</a>&lt; Type &gt; left, <a class="el" href="classhydra_1_1detail_1_1GenzMalikBoxResult.html">GenzMalikBoxResult</a>&lt; Type &gt; const &amp;right)</td></tr>
<tr class="separator:a6e34df05c3fc32da9e8fe01dddc9fd7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25dfa2f5f8cfb6485dba5d2a4611b217"><td class="memTemplParams" colspan="2">template&lt;typename Type , size_t N&gt; </td></tr>
<tr class="memitem:a25dfa2f5f8cfb6485dba5d2a4611b217"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="classhydra_1_1detail_1_1GenzMalikBoxResult.html">GenzMalikBoxResult</a>&lt; Type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a25dfa2f5f8cfb6485dba5d2a4611b217">operator+</a> (<a class="el" href="classhydra_1_1detail_1_1GenzMalikBoxResult.html">GenzMalikBoxResult</a>&lt; Type &gt; left, <a class="el" href="classhydra_1_1detail_1_1GenzMalikBox.html">GenzMalikBox</a>&lt; N &gt; const &amp;right)</td></tr>
<tr class="separator:a25dfa2f5f8cfb6485dba5d2a4611b217"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c794172447148190ddb210dd1db8a83"><td class="memTemplParams" colspan="2">template&lt;typename T , unsigned int N, unsigned int I&gt; </td></tr>
<tr class="memitem:a1c794172447148190ddb210dd1db8a83"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> std::enable_if&lt; I==N, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a1c794172447148190ddb210dd1db8a83">pow_helper</a> (T const, T &amp;)</td></tr>
<tr class="separator:a1c794172447148190ddb210dd1db8a83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f6c0d8fba43367d54ac4e2ce70f8718"><td class="memTemplParams" colspan="2">template&lt;typename T , unsigned int N, unsigned int I&gt; </td></tr>
<tr class="memitem:a8f6c0d8fba43367d54ac4e2ce70f8718"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> std::enable_if&lt;(I&lt; N), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a8f6c0d8fba43367d54ac4e2ce70f8718">pow_helper</a> (T const x, T &amp;r)</td></tr>
<tr class="separator:a8f6c0d8fba43367d54ac4e2ce70f8718"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28280805ea788b6b7ab8eee526b71acc"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename ... Tp&gt; </td></tr>
<tr class="memitem:a28280805ea788b6b7ab8eee526b71acc"><td class="memTemplItemLeft" align="right" valign="top">hydra_thrust::detail::enable_if&lt; I==sizeof...(Tp), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a28280805ea788b6b7ab8eee526b71acc">print_parameters_in_tuple</a> (hydra_thrust::tuple&lt; Tp... &gt; &amp;)</td></tr>
<tr class="separator:a28280805ea788b6b7ab8eee526b71acc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91dd9d1ed9eeac4af4b479d3931b4b3f"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename ... Tp&gt; </td></tr>
<tr class="memitem:a91dd9d1ed9eeac4af4b479d3931b4b3f"><td class="memTemplItemLeft" align="right" valign="top">hydra_thrust::detail::enable_if&lt;(I&lt; sizeof...(Tp)), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a91dd9d1ed9eeac4af4b479d3931b4b3f">print_parameters_in_tuple</a> (hydra_thrust::tuple&lt; Tp... &gt; &amp;t)</td></tr>
<tr class="separator:a91dd9d1ed9eeac4af4b479d3931b4b3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac25504370e97f8483f51b7747a5d062f"><td class="memTemplParams" colspan="2">template&lt;typename Return_Type , typename ArgType , typename ... Tp, typename  = typename hydra_thrust::detail::enable_if&lt;std::is_convertible&lt;Return_Type, double&gt;::value || std::is_constructible&lt;hydra_thrust::complex&lt;double&gt;,Return_Type&gt;::value &gt;::type&gt; </td></tr>
<tr class="memitem:ac25504370e97f8483f51b7747a5d062f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> Return_Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#ac25504370e97f8483f51b7747a5d062f">product</a> (ArgType const &amp;x, hydra_thrust::tuple&lt; Tp... &gt; const &amp;t)</td></tr>
<tr class="separator:ac25504370e97f8483f51b7747a5d062f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f27e0f9d5a5aeb14274d1775739d650"><td class="memTemplParams" colspan="2">template&lt;typename Return_Type , typename ArgType , typename ... Tp, typename  = typename hydra_thrust::detail::enable_if&lt;std::is_convertible&lt;Return_Type, double&gt;::value || std::is_constructible&lt;hydra_thrust::complex&lt;double&gt;,Return_Type&gt;::value &gt;::type&gt; </td></tr>
<tr class="memitem:a4f27e0f9d5a5aeb14274d1775739d650"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> Return_Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a4f27e0f9d5a5aeb14274d1775739d650">product</a> (ArgType &amp;x, hydra_thrust::tuple&lt; Tp... &gt; &amp;t)</td></tr>
<tr class="separator:a4f27e0f9d5a5aeb14274d1775739d650"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade2c50d420b21392eae2bf88ef2f1408"><td class="memTemplParams" colspan="2">template&lt;typename Return_Type , typename ArgType1 , typename ArgType2 , typename ... Tp, typename  = typename hydra_thrust::detail::enable_if&lt;std::is_convertible&lt;Return_Type, double&gt;::value || std::is_constructible&lt;hydra_thrust::complex&lt;double&gt;,Return_Type&gt;::value &gt;::type&gt; </td></tr>
<tr class="memitem:ade2c50d420b21392eae2bf88ef2f1408"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> Return_Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#ade2c50d420b21392eae2bf88ef2f1408">product2</a> (ArgType1 const &amp;x, ArgType2 const &amp;y, hydra_thrust::tuple&lt; Tp... &gt; const &amp;t)</td></tr>
<tr class="separator:ade2c50d420b21392eae2bf88ef2f1408"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a636ac81a76f60f852397b20aa6a5778e"><td class="memTemplParams" colspan="2">template&lt;typename Return_Type , typename ArgType1 , typename ArgType2 , typename ... Tp, typename  = typename hydra_thrust::detail::enable_if&lt;std::is_convertible&lt;Return_Type, double&gt;::value || std::is_constructible&lt;hydra_thrust::complex&lt;double&gt;,Return_Type&gt;::value &gt;::type&gt; </td></tr>
<tr class="memitem:a636ac81a76f60f852397b20aa6a5778e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> Return_Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a636ac81a76f60f852397b20aa6a5778e">product2</a> (ArgType1 &amp;x, ArgType2 &amp;y, hydra_thrust::tuple&lt; Tp... &gt; &amp;t)</td></tr>
<tr class="separator:a636ac81a76f60f852397b20aa6a5778e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01ce8205f2812d6bc1a8395898455bc6"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename Return_Type , typename ArgType , typename ... Tp&gt; </td></tr>
<tr class="memitem:a01ce8205f2812d6bc1a8395898455bc6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::detail::enable_if&lt; I==sizeof...(Tp), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a01ce8205f2812d6bc1a8395898455bc6">product_tuple</a> (Return_Type &amp;, hydra_thrust::tuple&lt; Tp... &gt; const &amp;, ArgType const &amp;)</td></tr>
<tr class="separator:a01ce8205f2812d6bc1a8395898455bc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50192c52e8c65a9e261d18f8d7e260ed"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename Return_Type , typename ArgType , typename ... Tp&gt; </td></tr>
<tr class="memitem:a50192c52e8c65a9e261d18f8d7e260ed"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::detail::enable_if&lt;(I&lt; sizeof...(Tp)), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a50192c52e8c65a9e261d18f8d7e260ed">product_tuple</a> (Return_Type &amp;r, hydra_thrust::tuple&lt; Tp... &gt; const &amp;t, ArgType const &amp;<a class="el" href="namespacehydra.html#ae96191cbaa62c58f63b7e58924362c24">arg</a>)</td></tr>
<tr class="separator:a50192c52e8c65a9e261d18f8d7e260ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fd41b1a175a03273fcc747bf16fa147"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename Return_Type , typename ArgType , typename ... Tp&gt; </td></tr>
<tr class="memitem:a3fd41b1a175a03273fcc747bf16fa147"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::detail::enable_if&lt; I==sizeof...(Tp), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a3fd41b1a175a03273fcc747bf16fa147">product_tuple</a> (Return_Type &amp;, hydra_thrust::tuple&lt; Tp... &gt; &amp;&amp;, ArgType &amp;&amp;)</td></tr>
<tr class="separator:a3fd41b1a175a03273fcc747bf16fa147"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27b437c78f61e1df0c91737e8f7cd8a8"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename Return_Type , typename ArgType , typename ... Tp&gt; </td></tr>
<tr class="memitem:a27b437c78f61e1df0c91737e8f7cd8a8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::detail::enable_if&lt;(I&lt; sizeof...(Tp)), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a27b437c78f61e1df0c91737e8f7cd8a8">product_tuple</a> (Return_Type &amp;r, hydra_thrust::tuple&lt; Tp... &gt; &amp;&amp;t, ArgType &amp;&amp;<a class="el" href="namespacehydra.html#ae96191cbaa62c58f63b7e58924362c24">arg</a>)</td></tr>
<tr class="separator:a27b437c78f61e1df0c91737e8f7cd8a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb6c1af7e7483fbc3b22c7ef63788ce7"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename Return_Type , typename ArgType1 , typename ArgType2 , typename ... Tp&gt; </td></tr>
<tr class="memitem:abb6c1af7e7483fbc3b22c7ef63788ce7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::detail::enable_if&lt; I==sizeof...(Tp), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#abb6c1af7e7483fbc3b22c7ef63788ce7">product_tuple2</a> (Return_Type &amp;, hydra_thrust::tuple&lt; Tp... &gt; const &amp;, ArgType1 const &amp;, ArgType2 const &amp;)</td></tr>
<tr class="separator:abb6c1af7e7483fbc3b22c7ef63788ce7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4517a255a100f22b0f3f962a139426db"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename Return_Type , typename ArgType1 , typename ArgType2 , typename ... Tp&gt; </td></tr>
<tr class="memitem:a4517a255a100f22b0f3f962a139426db"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::detail::enable_if&lt;(I&lt;(sizeof...(Tp))), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a4517a255a100f22b0f3f962a139426db">product_tuple2</a> (Return_Type &amp;r, hydra_thrust::tuple&lt; Tp... &gt; const &amp;t, ArgType1 const &amp;arg1, ArgType2 const &amp;arg2)</td></tr>
<tr class="separator:a4517a255a100f22b0f3f962a139426db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d1f75d3a1f29b97e2470519273a8819"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename Return_Type , typename ArgType1 , typename ArgType2 , typename ... Tp&gt; </td></tr>
<tr class="memitem:a0d1f75d3a1f29b97e2470519273a8819"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::detail::enable_if&lt; I==sizeof...(Tp), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a0d1f75d3a1f29b97e2470519273a8819">product_tuple2</a> (Return_Type &amp;, hydra_thrust::tuple&lt; Tp... &gt; &amp;&amp;, ArgType1 &amp;&amp;, ArgType2 &amp;&amp;)</td></tr>
<tr class="separator:a0d1f75d3a1f29b97e2470519273a8819"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d5b5bfede3e07f333b44254f6904008"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename Return_Type , typename ArgType1 , typename ArgType2 , typename ... Tp&gt; </td></tr>
<tr class="memitem:a0d5b5bfede3e07f333b44254f6904008"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::detail::enable_if&lt;(I&lt;(sizeof...(Tp))), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a0d5b5bfede3e07f333b44254f6904008">product_tuple2</a> (Return_Type &amp;r, hydra_thrust::tuple&lt; Tp... &gt; &amp;&amp;t, ArgType1 &amp;&amp;arg1, ArgType2 &amp;&amp;arg2)</td></tr>
<tr class="separator:a0d5b5bfede3e07f333b44254f6904008"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18996edf882db2f33372691af9cc79d8"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, size_t N, typename Return_Type , typename ArgType1 , typename ArgType2 , typename ... Tp&gt; </td></tr>
<tr class="memitem:a18996edf882db2f33372691af9cc79d8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::detail::enable_if&lt; I==N, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a18996edf882db2f33372691af9cc79d8">product_tuple3</a> (Return_Type &amp;, hydra_thrust::tuple&lt; Tp... &gt; const &amp;, ArgType1 const &amp;, ArgType2 const &amp;)</td></tr>
<tr class="separator:a18996edf882db2f33372691af9cc79d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcfce57c36263805be3cd8cc9d754498"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, size_t N, typename Return_Type , typename ArgType1 , typename ArgType2 , typename ... Tp&gt; </td></tr>
<tr class="memitem:afcfce57c36263805be3cd8cc9d754498"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::detail::enable_if&lt;(I&lt; N), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#afcfce57c36263805be3cd8cc9d754498">product_tuple3</a> (Return_Type &amp;r, hydra_thrust::tuple&lt; Tp... &gt; const &amp;t, ArgType1 const &amp;arg1, ArgType2 const &amp;arg2)</td></tr>
<tr class="separator:afcfce57c36263805be3cd8cc9d754498"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14d9160e903a022678a19946e1082fd3"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, size_t N, typename Return_Type , typename ArgType1 , typename ArgType2 , typename ... Tp&gt; </td></tr>
<tr class="memitem:a14d9160e903a022678a19946e1082fd3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::detail::enable_if&lt; I==N, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a14d9160e903a022678a19946e1082fd3">product_tuple3</a> (Return_Type &amp;, hydra_thrust::tuple&lt; Tp... &gt; &amp;&amp;, ArgType1 &amp;&amp;, ArgType2 &amp;&amp;)</td></tr>
<tr class="separator:a14d9160e903a022678a19946e1082fd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60f6104f2782abaedc08764af74a2513"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, size_t N, typename Return_Type , typename ArgType1 , typename ArgType2 , typename ... Tp&gt; </td></tr>
<tr class="memitem:a60f6104f2782abaedc08764af74a2513"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::detail::enable_if&lt;(I&lt; N), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a60f6104f2782abaedc08764af74a2513">product_tuple3</a> (Return_Type &amp;r, hydra_thrust::tuple&lt; Tp... &gt; &amp;&amp;t, ArgType1 &amp;&amp;arg1, ArgType2 &amp;&amp;arg2)</td></tr>
<tr class="separator:a60f6104f2782abaedc08764af74a2513"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae12a77e6ee2553c9b830aeaa6e7e75e4"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ae12a77e6ee2553c9b830aeaa6e7e75e4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#ae12a77e6ee2553c9b830aeaa6e7e75e4">ptr_setter</a> (T1 *&amp;ptr, typename hydra_thrust::detail::enable_if&lt; hydra_thrust::detail::is_same&lt; T1, T2 &gt;::value, T2 &gt;::type *el)</td></tr>
<tr class="separator:ae12a77e6ee2553c9b830aeaa6e7e75e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0c43562d26a5efbbee3de11d58fb6a0"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:af0c43562d26a5efbbee3de11d58fb6a0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#af0c43562d26a5efbbee3de11d58fb6a0">ptr_setter</a> (T1 *&amp;, typename hydra_thrust::detail::enable_if&lt;!hydra_thrust::detail::is_same&lt; T1, T2 &gt;::value, T2 &gt;::type *)</td></tr>
<tr class="separator:af0c43562d26a5efbbee3de11d58fb6a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab46acd298d2f60edf21c334fa8823d65"><td class="memTemplParams" colspan="2">template&lt;class Iterator &gt; </td></tr>
<tr class="memitem:ab46acd298d2f60edf21c334fa8823d65"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> Iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#ab46acd298d2f60edf21c334fa8823d65">rotate</a> (Iterator first, Iterator n_first, Iterator last)</td></tr>
<tr class="separator:ab46acd298d2f60edf21c334fa8823d65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02aa7a21cd5aca1e6cba7419e0009a9f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a02aa7a21cd5aca1e6cba7419e0009a9f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a02aa7a21cd5aca1e6cba7419e0009a9f">SafeGreaterThan</a> (T a, T b, T tolerance=<a class="el" href="namespacehydra_1_1detail.html#af60fc3e60cc10bd79092ca02c8e8b84c">machine_eps_f64</a>())</td></tr>
<tr class="separator:a02aa7a21cd5aca1e6cba7419e0009a9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b57eb5fbdba90142d2127ab29514de7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8b57eb5fbdba90142d2127ab29514de7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a8b57eb5fbdba90142d2127ab29514de7">SafeLessThan</a> (T a, T b, T tolerance=<a class="el" href="namespacehydra_1_1detail.html#af60fc3e60cc10bd79092ca02c8e8b84c">machine_eps_f64</a>())</td></tr>
<tr class="separator:a8b57eb5fbdba90142d2127ab29514de7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93a05294ac78115df3bf8b54fff5174d"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename ... Tp&gt; </td></tr>
<tr class="memitem:a93a05294ac78115df3bf8b54fff5174d"><td class="memTemplItemLeft" align="right" valign="top">hydra_thrust::detail::enable_if&lt; I==sizeof...(Tp), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a93a05294ac78115df3bf8b54fff5174d">set_functors_in_tuple</a> (hydra_thrust::tuple&lt; Tp... &gt; &amp;, const std::vector&lt; <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt; &amp;)</td></tr>
<tr class="separator:a93a05294ac78115df3bf8b54fff5174d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0efde42488d09f938938e26557b53c05"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename ... Tp&gt; </td></tr>
<tr class="memitem:a0efde42488d09f938938e26557b53c05"><td class="memTemplItemLeft" align="right" valign="top">hydra_thrust::detail::enable_if&lt;(I&lt; sizeof...(Tp)), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a0efde42488d09f938938e26557b53c05">set_functors_in_tuple</a> (hydra_thrust::tuple&lt; Tp... &gt; &amp;t, const std::vector&lt; <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt; &amp;parameters)</td></tr>
<tr class="separator:a0efde42488d09f938938e26557b53c05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa78862e977fa8cce9259242deb36570b"><td class="memTemplParams" colspan="2">template&lt;unsigned int I, typename Ptr , typename ... Tp&gt; </td></tr>
<tr class="memitem:aa78862e977fa8cce9259242deb36570b"><td class="memTemplItemLeft" align="right" valign="top">hydra_thrust::detail::enable_if&lt; I==sizeof...(Tp), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#aa78862e977fa8cce9259242deb36570b">set_ptr_to_tuple_element</a> (const <a class="el" href="namespace_3globalScope_4.html#classint">int</a>, std::tuple&lt; Tp... &gt; &amp;, Ptr *&amp;)</td></tr>
<tr class="separator:aa78862e977fa8cce9259242deb36570b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8e4701c4056cff52653b75e79b6c1b1"><td class="memTemplParams" colspan="2">template&lt;unsigned int I = 0, typename Ptr , typename ... Tp&gt; </td></tr>
<tr class="memitem:ad8e4701c4056cff52653b75e79b6c1b1"><td class="memTemplItemLeft" align="right" valign="top">hydra_thrust::detail::enable_if&lt;(I&lt; sizeof...(Tp)), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#ad8e4701c4056cff52653b75e79b6c1b1">set_ptr_to_tuple_element</a> (const <a class="el" href="namespace_3globalScope_4.html#classint">int</a> index, std::tuple&lt; Tp... &gt; &amp;t, Ptr *&amp;ptr)</td></tr>
<tr class="separator:ad8e4701c4056cff52653b75e79b6c1b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fbd7741e643726fd8ee8295b234586e"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename Array_Type , typename T &gt; </td></tr>
<tr class="memitem:a1fbd7741e643726fd8ee8295b234586e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::detail::enable_if&lt;(I==hydra_thrust::tuple_size&lt; T &gt;::value) &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1is__homogeneous.html">is_homogeneous</a>&lt; Array_Type, T &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a1fbd7741e643726fd8ee8295b234586e">set_ptrs_to_tuple</a> (T &amp;, Array_Type **)</td></tr>
<tr class="separator:a1fbd7741e643726fd8ee8295b234586e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64a1e4a7a30b6daa7e4eaabbfd9aa4a2"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename Array_Type , typename T &gt; </td></tr>
<tr class="memitem:a64a1e4a7a30b6daa7e4eaabbfd9aa4a2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::detail::enable_if&lt;(I&lt; hydra_thrust::tuple_size&lt; T &gt;::value) &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1is__homogeneous.html">is_homogeneous</a>&lt; Array_Type, T &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a64a1e4a7a30b6daa7e4eaabbfd9aa4a2">set_ptrs_to_tuple</a> (T &amp;t, Array_Type **Array)</td></tr>
<tr class="separator:a64a1e4a7a30b6daa7e4eaabbfd9aa4a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90b2bcec3f72d547652f4db3b581e755"><td class="memTemplParams" colspan="2">template&lt;unsigned int I = 0, typename T , typename ... Tp&gt; </td></tr>
<tr class="memitem:a90b2bcec3f72d547652f4db3b581e755"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::detail::enable_if&lt; I==sizeof...(Tp), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a90b2bcec3f72d547652f4db3b581e755">set_tuple_element</a> (const <a class="el" href="namespace_3globalScope_4.html#classint">int</a>, hydra_thrust::tuple&lt; Tp... &gt; const &amp;, T &amp;)</td></tr>
<tr class="separator:a90b2bcec3f72d547652f4db3b581e755"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07d2736316e67ca5010eb45eec285fa2"><td class="memTemplParams" colspan="2">template&lt;unsigned int I = 0, typename T , typename ... Tp&gt; </td></tr>
<tr class="memitem:a07d2736316e67ca5010eb45eec285fa2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::detail::enable_if&lt;(I&lt; sizeof...(Tp)), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a07d2736316e67ca5010eb45eec285fa2">set_tuple_element</a> (const <a class="el" href="namespace_3globalScope_4.html#classint">int</a> index, hydra_thrust::tuple&lt; Tp... &gt; &amp;t, const T &amp;x)</td></tr>
<tr class="separator:a07d2736316e67ca5010eb45eec285fa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d766efc8b57b8ea0808be1a69aec7fc"><td class="memTemplParams" colspan="2">template&lt;typename ... T1, typename ... T2&gt; </td></tr>
<tr class="memitem:a9d766efc8b57b8ea0808be1a69aec7fc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a9d766efc8b57b8ea0808be1a69aec7fc">split_tuple</a> (hydra_thrust::tuple&lt; T1... &gt; &amp;t1, hydra_thrust::tuple&lt; T2... &gt; &amp;t2, hydra_thrust::tuple&lt; T1..., T2... &gt; const &amp;t)</td></tr>
<tr class="separator:a9d766efc8b57b8ea0808be1a69aec7fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f1aa7425652bdb11f578dea52cac883"><td class="memTemplParams" colspan="2">template&lt;size_t N, typename ... T&gt; </td></tr>
<tr class="memitem:a5f1aa7425652bdb11f578dea52cac883"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a5f1aa7425652bdb11f578dea52cac883">split_tuple</a> (hydra_thrust::tuple&lt; T... &gt; &amp;t) -&gt; decltype(<a class="el" href="namespacehydra_1_1detail.html#a7b1b36c840b16da1dc97c8b3729e4c8b">split_tuple_helper</a>(t, <a class="el" href="structhydra_1_1detail_1_1make__index__sequence.html">make_index_sequence</a>&lt; N &gt;</td></tr>
<tr class="separator:a5f1aa7425652bdb11f578dea52cac883"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b1b36c840b16da1dc97c8b3729e4c8b"><td class="memTemplParams" colspan="2">template&lt;typename ... T1, typename ... T2, size_t... I1, size_t... I2&gt; </td></tr>
<tr class="memitem:a7b1b36c840b16da1dc97c8b3729e4c8b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a7b1b36c840b16da1dc97c8b3729e4c8b">split_tuple_helper</a> (hydra_thrust::tuple&lt; T1... &gt; &amp;t1, hydra_thrust::tuple&lt; T2... &gt; &amp;t2, hydra_thrust::tuple&lt; T1..., T2... &gt; const &amp;t, <a class="el" href="structhydra_1_1detail_1_1index__sequence.html">index_sequence</a>&lt; I1... &gt;, <a class="el" href="structhydra_1_1detail_1_1index__sequence.html">index_sequence</a>&lt; I2... &gt;)</td></tr>
<tr class="separator:a7b1b36c840b16da1dc97c8b3729e4c8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac32e9090f5cf5008d6a7abbcd6c6535f"><td class="memTemplParams" colspan="2">template&lt;typename ... T, size_t... I1, size_t... I2&gt; </td></tr>
<tr class="memitem:ac32e9090f5cf5008d6a7abbcd6c6535f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#ac32e9090f5cf5008d6a7abbcd6c6535f">split_tuple_helper</a> (hydra_thrust::tuple&lt; T... &gt; &amp;t, <a class="el" href="structhydra_1_1detail_1_1index__sequence.html">index_sequence</a>&lt; I1... &gt;, <a class="el" href="structhydra_1_1detail_1_1index__sequence.html">index_sequence</a>&lt; I2... &gt;) -&gt; decltype(hydra_thrust::make_pair(hydra_thrust::tie(hydra_thrust::get&lt; I1 &gt;(t)...), hydra_thrust::tie(hydra_thrust::get&lt; I2++sizeof...(I1)&gt;(t)...)))</td></tr>
<tr class="separator:ac32e9090f5cf5008d6a7abbcd6c6535f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ab8a09a6cd57cc724421387891a1b0b"><td class="memTemplParams" colspan="2">template&lt;typename ... T, size_t ... I&gt; </td></tr>
<tr class="memitem:a9ab8a09a6cd57cc724421387891a1b0b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::tuple&lt; T... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a9ab8a09a6cd57cc724421387891a1b0b">subtractTuples</a> (const hydra_thrust::tuple&lt; T... &gt; &amp;a, const hydra_thrust::tuple&lt; T... &gt; &amp;b, <a class="el" href="structhydra_1_1detail_1_1index__sequence.html">index_sequence</a>&lt; I... &gt;)</td></tr>
<tr class="separator:a9ab8a09a6cd57cc724421387891a1b0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85e190342696a87b7a21ea849d89cf43"><td class="memTemplParams" colspan="2">template&lt;typename ... T&gt; </td></tr>
<tr class="memitem:a85e190342696a87b7a21ea849d89cf43"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::tuple&lt; T... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a85e190342696a87b7a21ea849d89cf43">subtractTuples</a> (const hydra_thrust::tuple&lt; T... &gt; &amp;a, const hydra_thrust::tuple&lt; T... &gt; &amp;b)</td></tr>
<tr class="separator:a85e190342696a87b7a21ea849d89cf43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a33f1b7abee68c86f5afee4482c2b29"><td class="memTemplParams" colspan="2">template&lt;size_t I, typename ... T&gt; </td></tr>
<tr class="memitem:a5a33f1b7abee68c86f5afee4482c2b29"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::tuple_element&lt; I, hydra_thrust::tuple&lt; T... &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a5a33f1b7abee68c86f5afee4482c2b29">subtractTuplesHelper</a> (const hydra_thrust::tuple&lt; T... &gt; &amp;a, const hydra_thrust::tuple&lt; T... &gt; &amp;b)</td></tr>
<tr class="separator:a5a33f1b7abee68c86f5afee4482c2b29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3827659803f37e62c150df7e7fabd817"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename Return_Type , typename ArgType , typename ... Tp&gt; </td></tr>
<tr class="memitem:a3827659803f37e62c150df7e7fabd817"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::detail::enable_if&lt; I==sizeof...(Tp), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a3827659803f37e62c150df7e7fabd817">sum_tuple</a> (Return_Type &amp;, hydra_thrust::tuple&lt; Tp... &gt; &amp;&amp;, ArgType &amp;&amp;)</td></tr>
<tr class="separator:a3827659803f37e62c150df7e7fabd817"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f54c7821b0c7c33b7cac8e58c467600"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename Return_Type , typename ArgType , typename ... Tp&gt; </td></tr>
<tr class="memitem:a3f54c7821b0c7c33b7cac8e58c467600"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::detail::enable_if&lt;(I&lt; sizeof...(Tp)), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a3f54c7821b0c7c33b7cac8e58c467600">sum_tuple</a> (Return_Type &amp;r, hydra_thrust::tuple&lt; Tp... &gt; &amp;&amp;t, ArgType &amp;&amp;<a class="el" href="namespacehydra.html#ae96191cbaa62c58f63b7e58924362c24">arg</a>)</td></tr>
<tr class="separator:a3f54c7821b0c7c33b7cac8e58c467600"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84b0195e8b158fb484274604b4add551"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename Return_Type , typename ArgType , typename ... Tp&gt; </td></tr>
<tr class="memitem:a84b0195e8b158fb484274604b4add551"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::detail::enable_if&lt; I==sizeof...(Tp), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a84b0195e8b158fb484274604b4add551">sum_tuple</a> (Return_Type &amp;, hydra_thrust::tuple&lt; Tp... &gt; const &amp;, ArgType const &amp;)</td></tr>
<tr class="separator:a84b0195e8b158fb484274604b4add551"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac201d9fb427d4a329383f1aa86ba9326"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename Return_Type , typename ArgType , typename ... Tp&gt; </td></tr>
<tr class="memitem:ac201d9fb427d4a329383f1aa86ba9326"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::detail::enable_if&lt;(I&lt; sizeof...(Tp)), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#ac201d9fb427d4a329383f1aa86ba9326">sum_tuple</a> (Return_Type &amp;r, hydra_thrust::tuple&lt; Tp... &gt;const &amp;t, ArgType const &amp;<a class="el" href="namespacehydra.html#ae96191cbaa62c58f63b7e58924362c24">arg</a>)</td></tr>
<tr class="separator:ac201d9fb427d4a329383f1aa86ba9326"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60433e0129833261ec019f6d7f907da7"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename Return_Type , typename ArgType1 , typename ArgType2 , typename ... Tp&gt; </td></tr>
<tr class="memitem:a60433e0129833261ec019f6d7f907da7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::detail::enable_if&lt; I==sizeof...(Tp), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a60433e0129833261ec019f6d7f907da7">sum_tuple2</a> (Return_Type &amp;, hydra_thrust::tuple&lt; Tp... &gt; &amp;&amp;, ArgType1 &amp;&amp;, ArgType2 &amp;&amp;)</td></tr>
<tr class="separator:a60433e0129833261ec019f6d7f907da7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefacde8919a6658132ffc081ac40eab8"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename Return_Type , typename ArgType1 , typename ArgType2 , typename ... Tp&gt; </td></tr>
<tr class="memitem:aefacde8919a6658132ffc081ac40eab8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::detail::enable_if&lt;(I&lt; sizeof...(Tp)), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#aefacde8919a6658132ffc081ac40eab8">sum_tuple2</a> (Return_Type &amp;r, hydra_thrust::tuple&lt; Tp... &gt; &amp;&amp;t, ArgType1 &amp;&amp;arg1, ArgType2 &amp;&amp;arg2)</td></tr>
<tr class="separator:aefacde8919a6658132ffc081ac40eab8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71473533019ee4297e16843bbcd5c168"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename Return_Type , typename ArgType1 , typename ArgType2 , typename ... Tp&gt; </td></tr>
<tr class="memitem:a71473533019ee4297e16843bbcd5c168"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::detail::enable_if&lt; I==sizeof...(Tp), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a71473533019ee4297e16843bbcd5c168">sum_tuple2</a> (Return_Type &amp;, hydra_thrust::tuple&lt; Tp... &gt;const &amp;, ArgType1 const &amp;, ArgType2 const &amp;)</td></tr>
<tr class="separator:a71473533019ee4297e16843bbcd5c168"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca4351a6da0a103bc7a12f02e8abb675"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename Return_Type , typename ArgType1 , typename ArgType2 , typename ... Tp&gt; </td></tr>
<tr class="memitem:aca4351a6da0a103bc7a12f02e8abb675"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::detail::enable_if&lt;(I&lt; sizeof...(Tp)), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#aca4351a6da0a103bc7a12f02e8abb675">sum_tuple2</a> (Return_Type &amp;r, hydra_thrust::tuple&lt; Tp... &gt; const &amp;t, ArgType1 const &amp;arg1, ArgType2 const &amp;arg2)</td></tr>
<tr class="separator:aca4351a6da0a103bc7a12f02e8abb675"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75ca12ea02ee1851f4b39008c1e3891f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a75ca12ea02ee1851f4b39008c1e3891f"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__tuple.html">detail::is_tuple</a>&lt; T &gt;::value, T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a75ca12ea02ee1851f4b39008c1e3891f">tupler</a> (T const &amp;<a class="el" href="basic__distributions_8inl.html#a248ea98483ce90baaf65a7682438d72d">data</a>)</td></tr>
<tr class="separator:a75ca12ea02ee1851f4b39008c1e3891f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27e0bac176ee1d54865820690969897c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a27e0bac176ee1d54865820690969897c"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;!<a class="el" href="structhydra_1_1detail_1_1is__tuple.html">detail::is_tuple</a>&lt; T &gt;::value, <a class="el" href="namespacehydra.html#a717fc4e6b10453164099beade13d0226">hydra::tuple</a>&lt; T &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a27e0bac176ee1d54865820690969897c">tupler</a> (T const &amp;<a class="el" href="basic__distributions_8inl.html#a248ea98483ce90baaf65a7682438d72d">data</a>)</td></tr>
<tr class="separator:a27e0bac176ee1d54865820690969897c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61180588ee1d71e4718adf6f8051fd7c"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename FistType , typename ... OtherTypes&gt; </td></tr>
<tr class="memitem:a61180588ee1d71e4718adf6f8051fd7c"><td class="memTemplItemLeft" align="right" valign="top">hydra_thrust::detail::enable_if&lt; I==(sizeof...(OtherTypes)+1) &amp;&amp;<a class="el" href="namespacehydra_1_1detail.html#a3c72e1aed3a4538dac06a7e816543c23">are_all_same</a>&lt; FistType, OtherTypes... &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a61180588ee1d71e4718adf6f8051fd7c">tupleToArray</a> (hydra_thrust::tuple&lt; FistType, OtherTypes... &gt; const &amp;, std::array&lt; FistType, sizeof...(OtherTypes)+1 &gt; &amp;)</td></tr>
<tr class="separator:a61180588ee1d71e4718adf6f8051fd7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08a1c8dabb7a10c7019eae15b9b57396"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename FistType , typename ... OtherTypes&gt; </td></tr>
<tr class="memitem:a08a1c8dabb7a10c7019eae15b9b57396"><td class="memTemplItemLeft" align="right" valign="top">hydra_thrust::detail::enable_if&lt;(I&lt; sizeof...(OtherTypes)+1) &amp;&amp;<a class="el" href="namespacehydra_1_1detail.html#a3c72e1aed3a4538dac06a7e816543c23">are_all_same</a>&lt; FistType, OtherTypes... &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a08a1c8dabb7a10c7019eae15b9b57396">tupleToArray</a> (hydra_thrust::tuple&lt; FistType, OtherTypes... &gt; const &amp;t, std::array&lt; FistType, sizeof...(OtherTypes)+1 &gt; &amp;Array)</td></tr>
<tr class="separator:a08a1c8dabb7a10c7019eae15b9b57396"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d28a90668aa47a0ef0184472165a6eb"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename FistType , typename ... OtherTypes&gt; </td></tr>
<tr class="memitem:a0d28a90668aa47a0ef0184472165a6eb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::detail::enable_if&lt; I==(sizeof...(OtherTypes)+1) &amp;&amp;<a class="el" href="namespacehydra_1_1detail.html#a3c72e1aed3a4538dac06a7e816543c23">are_all_same</a>&lt; FistType, OtherTypes... &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a0d28a90668aa47a0ef0184472165a6eb">tupleToArray</a> (hydra_thrust::tuple&lt; FistType, OtherTypes... &gt; const &amp;, typename std::remove_reference&lt; FistType &gt;::type *)</td></tr>
<tr class="separator:a0d28a90668aa47a0ef0184472165a6eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48b258ba5737f48014fbb26eaba70dc7"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename FistType , typename ... OtherTypes&gt; </td></tr>
<tr class="memitem:a48b258ba5737f48014fbb26eaba70dc7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::detail::enable_if&lt;(I&lt; sizeof...(OtherTypes)+1) &amp;&amp;<a class="el" href="namespacehydra_1_1detail.html#a3c72e1aed3a4538dac06a7e816543c23">are_all_same</a>&lt; FistType, OtherTypes... &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a48b258ba5737f48014fbb26eaba70dc7">tupleToArray</a> (hydra_thrust::tuple&lt; FistType, OtherTypes... &gt; const &amp;t, typename std::remove_reference&lt; FistType &gt;::type *Array)</td></tr>
<tr class="separator:a48b258ba5737f48014fbb26eaba70dc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0241d1e6dda57e0866e3cb2de22199dc"><td class="memTemplParams" colspan="2">template&lt;typename TupleType , typename ArrayType &gt; </td></tr>
<tr class="memitem:a0241d1e6dda57e0866e3cb2de22199dc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::detail::enable_if&lt;(<a class="el" href="structhydra_1_1detail_1_1is__instantiation__of.html">detail::is_instantiation_of</a>&lt; hydra_thrust::tuple, TupleType &gt;::value||<a class="el" href="structhydra_1_1detail_1_1is__instantiation__of.html">detail::is_instantiation_of</a>&lt; hydra_thrust::detail::tuple_of_iterator_references, TupleType &gt;::value), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a0241d1e6dda57e0866e3cb2de22199dc">tupleToArray</a> (TupleType const &amp;_tuple, ArrayType *_array)</td></tr>
<tr class="separator:a0241d1e6dda57e0866e3cb2de22199dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2864aeaf911297306efcc70d9ed617d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab2864aeaf911297306efcc70d9ed617d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#ab2864aeaf911297306efcc70d9ed617d">WithinPrecisionInterval</a> (T b, T a, <a class="el" href="namespace_3globalScope_4.html#classunsigned">unsigned</a> <a class="el" href="namespace_3globalScope_4.html#classint">int</a> interval_size=1)</td></tr>
<tr class="separator:ab2864aeaf911297306efcc70d9ed617d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d803c1c594f979fb4a8f4beae580766"><td class="memTemplParams" colspan="2">template&lt;typename ... T&gt; </td></tr>
<tr class="memitem:a6d803c1c594f979fb4a8f4beae580766"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1all__true.html">all_true</a>&lt; <a class="el" href="structhydra_1_1detail_1_1is__zip__iterator.html">is_zip_iterator</a>&lt; T &gt;::value... &gt;::value, typename <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1merged__zip__iterator">detail::merged_zip_iterator</a>&lt; T... &gt;::type &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a6d803c1c594f979fb4a8f4beae580766">zip_iterator_cat</a> (T const &amp;... zip_iterators)</td></tr>
<tr class="separator:a6d803c1c594f979fb4a8f4beae580766"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a6e5ce23b23364c64166f4c390f0f5f03"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a6e5ce23b23364c64166f4c390f0f5f03">make_index_sequence&lt; sizeof...(T) -N &gt;</a></td></tr>
<tr class="separator:a6e5ce23b23364c64166f4c390f0f5f03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6272aac6b63b0ff4f44d2ff9b24716cf"><td class="memTemplParams" colspan="2">template&lt;typename T , typename C , size_t N, size_t I = 1&gt; </td></tr>
<tr class="memitem:a6272aac6b63b0ff4f44d2ff9b24716cf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> std::enable_if&lt; I&lt; N, void &gt;::type <a class="el" href="namespacehydra_1_1detail.html#aa4140580867ee73e401e1bb1e213548c">max_helper</a>(T const  &amp;<a class="el" href="namespacehydra.html#a717fc4e6b10453164099beade13d0226">tuple</a>, <a class="el" href="basic__distributions_8inl.html#a4900ef306eb9271438791f1a98b8ccba">C</a> &amp;max_value, size_t &amp;max_index){ max_index=max_value &gt; hydra_thrust::get&lt; I &gt;(<a class="el" href="namespacehydra.html#a717fc4e6b10453164099beade13d0226">tuple</a>) ? max_index&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a6272aac6b63b0ff4f44d2ff9b24716cf">max_value</a> = max_value &gt; hydra_thrust::get&lt;I&gt;(<a class="el" href="namespacehydra.html#a717fc4e6b10453164099beade13d0226">tuple</a>) ? max_value : hydra_thrust::get&lt;I&gt;(<a class="el" href="namespacehydra.html#a717fc4e6b10453164099beade13d0226">tuple</a>)</td></tr>
<tr class="separator:a6272aac6b63b0ff4f44d2ff9b24716cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<hr/><h2 class="groupheader">Data Structure Documentation</h2>
<a name="structhydra_1_1detail_1_1__merge__and__renumber" id="structhydra_1_1detail_1_1__merge__and__renumber"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1detail_1_1__merge__and__renumber">&#9670;&nbsp;</a></span>hydra::detail::_merge_and_renumber</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::detail::_merge_and_renumber</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;class Sequence1, class Sequence2&gt;<br />
struct hydra::detail::_merge_and_renumber&lt; Sequence1, Sequence2 &gt;</h3>

</div><div class="dynheader">
Inheritance diagram for hydra::detail::_merge_and_renumber&lt; Sequence1, Sequence2 &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1__merge__and__renumber__inherit__graph.svg" width="284" height="487"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Collaboration diagram for hydra::detail::_merge_and_renumber&lt; Sequence1, Sequence2 &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1__merge__and__renumber__coll__graph.svg" width="203" height="118"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a name="structhydra_1_1detail_1_1append__to__type__seq" id="structhydra_1_1detail_1_1append__to__type__seq"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1detail_1_1append__to__type__seq">&#9670;&nbsp;</a></span>hydra::detail::append_to_type_seq</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::detail::append_to_type_seq</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename, typename&gt;<br />
struct hydra::detail::append_to_type_seq&lt; typename, typename &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::detail::append_to_type_seq&lt; typename, typename &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1append__to__type__seq__coll__graph.svg" width="184" height="118"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a name="structhydra_1_1detail_1_1append__to__type__seq_3_01T_00_01TT_3_01Ts_8_8_8_01_4_01_4" id="structhydra_1_1detail_1_1append__to__type__seq_3_01T_00_01TT_3_01Ts_8_8_8_01_4_01_4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1detail_1_1append__to__type__seq_3_01T_00_01TT_3_01Ts_8_8_8_01_4_01_4">&#9670;&nbsp;</a></span>hydra::detail::append_to_type_seq&lt; T, TT&lt; Ts... &gt; &gt;</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::detail::append_to_type_seq&lt; T, TT&lt; Ts... &gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename T, typename... Ts, template&lt; typename... &gt; class TT&gt;<br />
struct hydra::detail::append_to_type_seq&lt; T, TT&lt; Ts... &gt; &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::detail::append_to_type_seq&lt; T, TT&lt; Ts... &gt; &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1append__to__type__seq_3_01T_00_01TT_3_01Ts_8_8_8_01_4_01_4__coll__graph.svg" width="162" height="118"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a96007bd667e99ae9126cb0378e0ea3d9"></a></td>
<td class="fieldname">
type</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structhydra_1_1detail_1_1BackendPolicy" id="structhydra_1_1detail_1_1BackendPolicy"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1detail_1_1BackendPolicy">&#9670;&nbsp;</a></span>hydra::detail::BackendPolicy</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::detail::BackendPolicy</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;Backend BACKEND&gt;<br />
struct hydra::detail::BackendPolicy&lt; BACKEND &gt;</h3>

<dl><dt><b>Examples: </b></dt><dd><a class="el" href="dalitz_plot_8inl-example.html#_a47">dalitz_plot.inl</a>, <a class="el" href="dense_histogram_8inl-example.html#_a13">dense_histogram.inl</a>, <a class="el" href="multidimensional_fit_8inl-example.html#_a39">multidimensional_fit.inl</a>, <a class="el" href="multivector_container_8inl-example.html#_a7">multivector_container.inl</a>, <a class="el" href="phsp_basic_8inl-example.html#_a22">phsp_basic.inl</a>, <a class="el" href="phsp_chain_8inl-example.html#_a19">phsp_chain.inl</a>, <a class="el" href="phsp_reweighting_8inl-example.html#_a27">phsp_reweighting.inl</a>, <a class="el" href="phsp_unweighting_8inl-example.html#_a22">phsp_unweighting.inl</a>, <a class="el" href="phsp_unweighting_functor_8inl-example.html#_a27">phsp_unweighting_functor.inl</a>, <a class="el" href="pseudo_experiment_8inl-example.html#_a25">pseudo_experiment.inl</a>, <a class="el" href="range_semantics_8inl-example.html#_a9">range_semantics.inl</a>, and <a class="el" href="splot_8inl-example.html#_a27">splot.inl</a>.</dd>
</dl></div><div class="dynheader">
Collaboration diagram for hydra::detail::BackendPolicy&lt; BACKEND &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1BackendPolicy__coll__graph.svg" width="199" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a name="structhydra_1_1detail_1_1bool__pack" id="structhydra_1_1detail_1_1bool__pack"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1detail_1_1bool__pack">&#9670;&nbsp;</a></span>hydra::detail::bool_pack</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::detail::bool_pack</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;bool...&gt;<br />
struct hydra::detail::bool_pack&lt;... &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::detail::bool_pack&lt;... &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1bool__pack__coll__graph.svg" width="136" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a name="structhydra_1_1detail_1_1CanConvert" id="structhydra_1_1detail_1_1CanConvert"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1detail_1_1CanConvert">&#9670;&nbsp;</a></span>hydra::detail::CanConvert</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::detail::CanConvert</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;class ... A&gt;<br />
struct hydra::detail::CanConvert&lt; A &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::detail::CanConvert&lt; A &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1CanConvert__coll__graph.svg" width="212" height="88"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a name="structhydra_1_1detail_1_1divide__result" id="structhydra_1_1detail_1_1divide__result"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1detail_1_1divide__result">&#9670;&nbsp;</a></span>hydra::detail::divide_result</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::detail::divide_result</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename F1, typename F2, typename ... Fs&gt;<br />
struct hydra::detail::divide_result&lt; F1, F2, Fs &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::detail::divide_result&lt; F1, F2, Fs &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1divide__result__coll__graph.svg" width="158" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a11d97c4c8a678e80149749e40e905142"></a></td>
<td class="fieldname">
type</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structhydra_1_1detail_1_1FFTPolicy" id="structhydra_1_1detail_1_1FFTPolicy"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1detail_1_1FFTPolicy">&#9670;&nbsp;</a></span>hydra::detail::FFTPolicy</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::detail::FFTPolicy</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename Precision, FFTCalculator FFTBackend&gt;<br />
struct hydra::detail::FFTPolicy&lt; Precision, FFTBackend &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::detail::FFTPolicy&lt; Precision, FFTBackend &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1FFTPolicy__coll__graph.svg" width="194" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a name="structhydra_1_1detail_1_1FFTPolicy_3_01T_00_01detail_1_1CuFFT_01_4" id="structhydra_1_1detail_1_1FFTPolicy_3_01T_00_01detail_1_1CuFFT_01_4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1detail_1_1FFTPolicy_3_01T_00_01detail_1_1CuFFT_01_4">&#9670;&nbsp;</a></span>hydra::detail::FFTPolicy&lt; T, detail::CuFFT &gt;</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::detail::FFTPolicy&lt; T, detail::CuFFT &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename T&gt;<br />
struct hydra::detail::FFTPolicy&lt; T, detail::CuFFT &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::detail::FFTPolicy&lt; T, detail::CuFFT &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1FFTPolicy_3_01T_00_01detail_1_1CuFFT_01_4__coll__graph.svg" width="172" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a0f3b7a3f7c4406803731416f6d91e306"></a>typedef <a class="el" href="classhydra_1_1ComplexToComplexCuFFT.html">ComplexToComplexCuFFT</a>&lt; T &gt;</td>
<td class="fieldname">
C2C</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="afde9e24c64e161c60811e4f2e3dde32f"></a>typedef <a class="el" href="classhydra_1_1ComplexToRealCuFFT.html">ComplexToRealCuFFT</a>&lt; T &gt;</td>
<td class="fieldname">
C2R</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a0622ac8a1e2f071aae1de916907a33a9"></a>typedef sys_t</td>
<td class="fieldname">
device_backend_type</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a104b4351044b9f8f7d224c9a7e318031"></a>typedef sys_t</td>
<td class="fieldname">
host_backend_type</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a481beb0295a5622b5bb1a34943826894"></a>typedef <a class="el" href="classhydra_1_1RealToComplexCuFFT.html">RealToComplexCuFFT</a>&lt; T &gt;</td>
<td class="fieldname">
R2C</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structhydra_1_1detail_1_1FFTPolicy_3_01T_00_01detail_1_1FFTW_01_4" id="structhydra_1_1detail_1_1FFTPolicy_3_01T_00_01detail_1_1FFTW_01_4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1detail_1_1FFTPolicy_3_01T_00_01detail_1_1FFTW_01_4">&#9670;&nbsp;</a></span>hydra::detail::FFTPolicy&lt; T, detail::FFTW &gt;</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::detail::FFTPolicy&lt; T, detail::FFTW &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename T&gt;<br />
struct hydra::detail::FFTPolicy&lt; T, detail::FFTW &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::detail::FFTPolicy&lt; T, detail::FFTW &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1FFTPolicy_3_01T_00_01detail_1_1FFTW_01_4__coll__graph.svg" width="172" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="ade556a186e98035468da80cc53abdb63"></a>typedef <a class="el" href="classhydra_1_1ComplexToComplexFFTW.html">ComplexToComplexFFTW</a>&lt; T &gt;</td>
<td class="fieldname">
C2C</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="aa4257c468ef1ecd0ddcdbb3887b2fc51"></a>typedef <a class="el" href="classhydra_1_1ComplexToRealFFTW.html">ComplexToRealFFTW</a>&lt; T &gt;</td>
<td class="fieldname">
C2R</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a07f86869d771bddd0f2d0a9772cb370b"></a>typedef sys_t</td>
<td class="fieldname">
device_backend_type</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a59e397b257e2684bc9e1d77a250b55bc"></a>typedef sys_t</td>
<td class="fieldname">
host_backend_type</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a8518989b6fcc217a7cd34406f7ce6ad1"></a>typedef <a class="el" href="classhydra_1_1RealToComplexFFTW.html">RealToComplexFFTW</a>&lt; T &gt;</td>
<td class="fieldname">
R2C</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structhydra_1_1detail_1_1find__unique__type__impl" id="structhydra_1_1detail_1_1find__unique__type__impl"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1detail_1_1find__unique__type__impl">&#9670;&nbsp;</a></span>hydra::detail::find_unique_type_impl</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::detail::find_unique_type_impl</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;size_t I, class T, class... Types&gt;<br />
struct hydra::detail::find_unique_type_impl&lt; I, T, Types &gt;</h3>

</div><div class="dynheader">
Inheritance diagram for hydra::detail::find_unique_type_impl&lt; I, T, Types &gt;:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1find__unique__type__impl__inherit__graph.svg" width="100%" height="600"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</div>
<div class="dynheader">
Collaboration diagram for hydra::detail::find_unique_type_impl&lt; I, T, Types &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1find__unique__type__impl__coll__graph.svg" width="162" height="118"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a name="structhydra_1_1detail_1_1function__traits" id="structhydra_1_1detail_1_1function__traits"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1detail_1_1function__traits">&#9670;&nbsp;</a></span>hydra::detail::function_traits</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::detail::function_traits</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename T&gt;<br />
struct hydra::detail::function_traits&lt; T &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::detail::function_traits&lt; T &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1function__traits__coll__graph.svg" width="158" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a name="structhydra_1_1detail_1_1functor__traits" id="structhydra_1_1detail_1_1functor__traits"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1detail_1_1functor__traits">&#9670;&nbsp;</a></span>hydra::detail::functor_traits</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::detail::functor_traits</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename T&gt;<br />
struct hydra::detail::functor_traits&lt; T &gt;</h3>

</div><div class="dynheader">
Inheritance diagram for hydra::detail::functor_traits&lt; T &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1functor__traits__inherit__graph.svg" width="244" height="414"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Collaboration diagram for hydra::detail::functor_traits&lt; T &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1functor__traits__coll__graph.svg" width="152" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a name="structhydra_1_1detail_1_1functor__traits_3_01ReturnType_07ClassType_1_1_5_08_07Args_8_8_8_08_01_4" id="structhydra_1_1detail_1_1functor__traits_3_01ReturnType_07ClassType_1_1_5_08_07Args_8_8_8_08_01_4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1detail_1_1functor__traits_3_01ReturnType_07ClassType_1_1_5_08_07Args_8_8_8_08_01_4">&#9670;&nbsp;</a></span>hydra::detail::functor_traits&lt; ReturnType(ClassType::*)(Args...) &gt;</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::detail::functor_traits&lt; ReturnType(ClassType::*)(Args...) &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename ClassType, typename ReturnType, typename... Args&gt;<br />
struct hydra::detail::functor_traits&lt; ReturnType(ClassType::*)(Args...) &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::detail::functor_traits&lt; ReturnType(ClassType::*)(Args...) &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1functor__traits_3_01ReturnType_07ClassType_1_1_5_08_07Args_8_8_8_08_01_4__coll__graph.svg" width="214" height="118"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a name="classhydra_1_1detail_1_1if__then__else" id="classhydra_1_1detail_1_1if__then__else"></a>
<h2 class="memtitle"><span class="permalink"><a href="#classhydra_1_1detail_1_1if__then__else">&#9670;&nbsp;</a></span>hydra::detail::if_then_else</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class hydra::detail::if_then_else</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;bool C, typename T1, typename T2&gt;<br />
class hydra::detail::if_then_else&lt; C, T1, T2 &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::detail::if_then_else&lt; C, T1, T2 &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classhydra_1_1detail_1_1if__then__else__coll__graph.svg" width="151" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a name="classhydra_1_1detail_1_1if__then__else_3_01false_00_01T1_00_01T2_01_4" id="classhydra_1_1detail_1_1if__then__else_3_01false_00_01T1_00_01T2_01_4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#classhydra_1_1detail_1_1if__then__else_3_01false_00_01T1_00_01T2_01_4">&#9670;&nbsp;</a></span>hydra::detail::if_then_else&lt; false, T1, T2 &gt;</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class hydra::detail::if_then_else&lt; false, T1, T2 &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename T1, typename T2&gt;<br />
class hydra::detail::if_then_else&lt; false, T1, T2 &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::detail::if_then_else&lt; false, T1, T2 &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classhydra_1_1detail_1_1if__then__else_3_01false_00_01T1_00_01T2_01_4__coll__graph.svg" width="162" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a9ccbe22c7f1cb3f5c1a2d408bed944a8"></a>typedef T2</td>
<td class="fieldname">
type</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="classhydra_1_1detail_1_1if__then__else_3_01true_00_01T1_00_01T2_01_4" id="classhydra_1_1detail_1_1if__then__else_3_01true_00_01T1_00_01T2_01_4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#classhydra_1_1detail_1_1if__then__else_3_01true_00_01T1_00_01T2_01_4">&#9670;&nbsp;</a></span>hydra::detail::if_then_else&lt; true, T1, T2 &gt;</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class hydra::detail::if_then_else&lt; true, T1, T2 &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename T1, typename T2&gt;<br />
class hydra::detail::if_then_else&lt; true, T1, T2 &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::detail::if_then_else&lt; true, T1, T2 &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classhydra_1_1detail_1_1if__then__else_3_01true_00_01T1_00_01T2_01_4__coll__graph.svg" width="156" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a34c5da7d250feff5bad076f085abf67b"></a>typedef T1</td>
<td class="fieldname">
type</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structhydra_1_1detail_1_1if__then__else__tt" id="structhydra_1_1detail_1_1if__then__else__tt"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1detail_1_1if__then__else__tt">&#9670;&nbsp;</a></span>hydra::detail::if_then_else_tt</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::detail::if_then_else_tt</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;bool Condition, template&lt; typename ... &gt; class T1, template&lt; typename ... &gt; class T2&gt;<br />
struct hydra::detail::if_then_else_tt&lt; Condition, T1, T2 &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::detail::if_then_else_tt&lt; Condition, T1, T2 &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1if__then__else__tt__coll__graph.svg" width="204" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a name="structhydra_1_1detail_1_1if__then__else__tt_3_01false_00_01T1_00_01T2_01_4" id="structhydra_1_1detail_1_1if__then__else__tt_3_01false_00_01T1_00_01T2_01_4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1detail_1_1if__then__else__tt_3_01false_00_01T1_00_01T2_01_4">&#9670;&nbsp;</a></span>hydra::detail::if_then_else_tt&lt; false, T1, T2 &gt;</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::detail::if_then_else_tt&lt; false, T1, T2 &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;template&lt; typename ... &gt; class T1, template&lt; typename ... &gt; class T2&gt;<br />
struct hydra::detail::if_then_else_tt&lt; false, T1, T2 &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::detail::if_then_else_tt&lt; false, T1, T2 &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1if__then__else__tt_3_01false_00_01T1_00_01T2_01_4__coll__graph.svg" width="178" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="ad720270512c28116871b746b1e11686e"></a></td>
<td class="fieldname">
type</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structhydra_1_1detail_1_1if__then__else__tt_3_01true_00_01T1_00_01T2_01_4" id="structhydra_1_1detail_1_1if__then__else__tt_3_01true_00_01T1_00_01T2_01_4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1detail_1_1if__then__else__tt_3_01true_00_01T1_00_01T2_01_4">&#9670;&nbsp;</a></span>hydra::detail::if_then_else_tt&lt; true, T1, T2 &gt;</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::detail::if_then_else_tt&lt; true, T1, T2 &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;template&lt; typename ... &gt; class T1, template&lt; typename ... &gt; class T2&gt;<br />
struct hydra::detail::if_then_else_tt&lt; true, T1, T2 &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::detail::if_then_else_tt&lt; true, T1, T2 &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1if__then__else__tt_3_01true_00_01T1_00_01T2_01_4__coll__graph.svg" width="171" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a6a09c2f0ef798cfca4abdfb2ab115c25"></a></td>
<td class="fieldname">
type</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structhydra_1_1detail_1_1index__in__tuple" id="structhydra_1_1detail_1_1index__in__tuple"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1detail_1_1index__in__tuple">&#9670;&nbsp;</a></span>hydra::detail::index_in_tuple</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::detail::index_in_tuple</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename Type, typename Tuple&gt;<br />
struct hydra::detail::index_in_tuple&lt; Type, Tuple &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::detail::index_in_tuple&lt; Type, Tuple &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1index__in__tuple__coll__graph.svg" width="178" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a name="structhydra_1_1detail_1_1int__fast__t" id="structhydra_1_1detail_1_1int__fast__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1detail_1_1int__fast__t">&#9670;&nbsp;</a></span>hydra::detail::int_fast_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::detail::int_fast_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename LeastInt&gt;<br />
struct hydra::detail::int_fast_t&lt; LeastInt &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::detail::int_fast_t&lt; LeastInt &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1int__fast__t__coll__graph.svg" width="144" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="af2ec5c2bfd6190ea9c89130bdccc8bf5"></a>typedef LeastInt</td>
<td class="fieldname">
fast</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="acde5af648678420102bf2fb887859be8"></a>typedef <a class="el" href="namespacehydra_1_1detail.html#af2ec5c2bfd6190ea9c89130bdccc8bf5">fast</a></td>
<td class="fieldname">
type</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structhydra_1_1detail_1_1is__function__argument" id="structhydra_1_1detail_1_1is__function__argument"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1detail_1_1is__function__argument">&#9670;&nbsp;</a></span>hydra::detail::is_function_argument</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::detail::is_function_argument</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename Arg, bool B = fa_impl::_is_function_argument&lt;Arg&gt;::value&gt;<br />
struct hydra::detail::is_function_argument&lt; Arg, B &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::detail::is_function_argument&lt; Arg, B &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1is__function__argument__coll__graph.svg" width="175" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a name="structhydra_1_1detail_1_1is__valid__type__pack" id="structhydra_1_1detail_1_1is__valid__type__pack"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1detail_1_1is__valid__type__pack">&#9670;&nbsp;</a></span>hydra::detail::is_valid_type_pack</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::detail::is_valid_type_pack</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename RefT, typename ... T&gt;<br />
struct hydra::detail::is_valid_type_pack&lt; RefT, T &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::detail::is_valid_type_pack&lt; RefT, T &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1is__valid__type__pack__coll__graph.svg" width="167" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a name="structhydra_1_1detail_1_1merged__tuple" id="structhydra_1_1detail_1_1merged__tuple"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1detail_1_1merged__tuple">&#9670;&nbsp;</a></span>hydra::detail::merged_tuple</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::detail::merged_tuple</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename ... T&gt;<br />
struct hydra::detail::merged_tuple&lt; T &gt;</h3>

</div><div class="dynheader">
Inheritance diagram for hydra::detail::merged_tuple&lt; T &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1merged__tuple__inherit__graph.svg" width="542" height="458"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Collaboration diagram for hydra::detail::merged_tuple&lt; T &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1merged__tuple__coll__graph.svg" width="155" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a name="structhydra_1_1detail_1_1merged__tuple_3_01hydra_1_1tuple_3_01T_8_8_8_01_4_01_4" id="structhydra_1_1detail_1_1merged__tuple_3_01hydra_1_1tuple_3_01T_8_8_8_01_4_01_4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1detail_1_1merged__tuple_3_01hydra_1_1tuple_3_01T_8_8_8_01_4_01_4">&#9670;&nbsp;</a></span>hydra::detail::merged_tuple&lt; hydra::tuple&lt; T... &gt; &gt;</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::detail::merged_tuple&lt; hydra::tuple&lt; T... &gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename ... T&gt;<br />
struct hydra::detail::merged_tuple&lt; hydra::tuple&lt; T... &gt; &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::detail::merged_tuple&lt; hydra::tuple&lt; T... &gt; &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1merged__tuple_3_01hydra_1_1tuple_3_01T_8_8_8_01_4_01_4__coll__graph.svg" width="155" height="118"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a15786b8d6c6a219b01b74cf9fdb3f92d"></a></td>
<td class="fieldname">
type</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structhydra_1_1detail_1_1merged__zip__iterator" id="structhydra_1_1detail_1_1merged__zip__iterator"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1detail_1_1merged__zip__iterator">&#9670;&nbsp;</a></span>hydra::detail::merged_zip_iterator</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::detail::merged_zip_iterator</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename ... T&gt;<br />
struct hydra::detail::merged_zip_iterator&lt; T &gt;</h3>

</div><div class="dynheader">
Inheritance diagram for hydra::detail::merged_zip_iterator&lt; T &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1merged__zip__iterator__inherit__graph.svg" width="391" height="502"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Collaboration diagram for hydra::detail::merged_zip_iterator&lt; T &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1merged__zip__iterator__coll__graph.svg" width="155" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a name="structhydra_1_1detail_1_1merged__zip__iterator_3_01hydra__thrust_1_1zip__iterator_3_01T_8_8_8_01_4_01_4" id="structhydra_1_1detail_1_1merged__zip__iterator_3_01hydra__thrust_1_1zip__iterator_3_01T_8_8_8_01_4_01_4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1detail_1_1merged__zip__iterator_3_01hydra__thrust_1_1zip__iterator_3_01T_8_8_8_01_4_01_4">&#9670;&nbsp;</a></span>hydra::detail::merged_zip_iterator&lt; hydra_thrust::zip_iterator&lt; T... &gt; &gt;</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::detail::merged_zip_iterator&lt; hydra_thrust::zip_iterator&lt; T... &gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename ... T&gt;<br />
struct hydra::detail::merged_zip_iterator&lt; hydra_thrust::zip_iterator&lt; T... &gt; &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::detail::merged_zip_iterator&lt; hydra_thrust::zip_iterator&lt; T... &gt; &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1merged__zip__iterator_3_01hydra__thrust_1_1zip__iterator_3_01T_8_8_8_01_4_01_4__coll__graph.svg" width="155" height="132"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="aa1e335e0be35b2b38c8482ec0e45ef55"></a></td>
<td class="fieldname">
type</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structhydra_1_1detail_1_1minus__result" id="structhydra_1_1detail_1_1minus__result"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1detail_1_1minus__result">&#9670;&nbsp;</a></span>hydra::detail::minus_result</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::detail::minus_result</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename F1, typename F2, typename ... Fs&gt;<br />
struct hydra::detail::minus_result&lt; F1, F2, Fs &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::detail::minus_result&lt; F1, F2, Fs &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1minus__result__coll__graph.svg" width="158" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="add29ddc4b8fac81ed38f877959086d79"></a></td>
<td class="fieldname">
type</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structhydra_1_1detail_1_1multidimensional" id="structhydra_1_1detail_1_1multidimensional"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1detail_1_1multidimensional">&#9670;&nbsp;</a></span>hydra::detail::multidimensional</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::detail::multidimensional</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"></div><div class="dynheader">
Collaboration diagram for hydra::detail::multidimensional:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1multidimensional__coll__graph.svg" width="210" height="88"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a name="structhydra_1_1detail_1_1multiply__result" id="structhydra_1_1detail_1_1multiply__result"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1detail_1_1multiply__result">&#9670;&nbsp;</a></span>hydra::detail::multiply_result</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::detail::multiply_result</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename F1, typename F2, typename ... Fs&gt;<br />
struct hydra::detail::multiply_result&lt; F1, F2, Fs &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::detail::multiply_result&lt; F1, F2, Fs &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1multiply__result__coll__graph.svg" width="158" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a9f322e4e5accd44a6a804994aca86b7b"></a></td>
<td class="fieldname">
type</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structhydra_1_1detail_1_1ObjSelector" id="structhydra_1_1detail_1_1ObjSelector"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1detail_1_1ObjSelector">&#9670;&nbsp;</a></span>hydra::detail::ObjSelector</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::detail::ObjSelector</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;bool FLAG&gt;<br />
struct hydra::detail::ObjSelector&lt; FLAG &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::detail::ObjSelector&lt; FLAG &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1ObjSelector__coll__graph.svg" width="180" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a name="structhydra_1_1detail_1_1references__tuple__type" id="structhydra_1_1detail_1_1references__tuple__type"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1detail_1_1references__tuple__type">&#9670;&nbsp;</a></span>hydra::detail::references_tuple_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::detail::references_tuple_type</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;size_t N, typename T&gt;<br />
struct hydra::detail::references_tuple_type&lt; N, T &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::detail::references_tuple_type&lt; N, T &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1references__tuple__type__coll__graph.svg" width="174" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a8c899abc24c3172b67847bc3adba0bd6"></a>typedef <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1repeat">repeat</a>&lt; T, N, tuple_of_iterator_references &gt;::<a class="el" href="namespacehydra_1_1detail.html#a8c899abc24c3172b67847bc3adba0bd6">type</a></td>
<td class="fieldname">
type</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structhydra_1_1detail_1_1remove__device__reference" id="structhydra_1_1detail_1_1remove__device__reference"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1detail_1_1remove__device__reference">&#9670;&nbsp;</a></span>hydra::detail::remove_device_reference</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::detail::remove_device_reference</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename T&gt;<br />
struct hydra::detail::remove_device_reference&lt; T &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::detail::remove_device_reference&lt; T &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1remove__device__reference__coll__graph.svg" width="171" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a3369bac6ca9a2ac5bfac3d6641551ecb"></a>typedef T</td>
<td class="fieldname">
type</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structhydra_1_1detail_1_1remove__device__reference_3_01hydra__thrust_1_1device__reference_3_01T_01_4_01_4" id="structhydra_1_1detail_1_1remove__device__reference_3_01hydra__thrust_1_1device__reference_3_01T_01_4_01_4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1detail_1_1remove__device__reference_3_01hydra__thrust_1_1device__reference_3_01T_01_4_01_4">&#9670;&nbsp;</a></span>hydra::detail::remove_device_reference&lt; hydra_thrust::device_reference&lt; T &gt; &gt;</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::detail::remove_device_reference&lt; hydra_thrust::device_reference&lt; T &gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename T&gt;<br />
struct hydra::detail::remove_device_reference&lt; hydra_thrust::device_reference&lt; T &gt; &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::detail::remove_device_reference&lt; hydra_thrust::device_reference&lt; T &gt; &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1remove__device__reference_3_01hydra__thrust_1_1device__reference_3_01T_01_4_01_4__coll__graph.svg" width="224" height="118"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="ace604cd82481d3586736efe022ca568b"></a>typedef T</td>
<td class="fieldname">
type</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structhydra_1_1detail_1_1repeat" id="structhydra_1_1detail_1_1repeat"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1detail_1_1repeat">&#9670;&nbsp;</a></span>hydra::detail::repeat</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::detail::repeat</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename T, unsigned int N, template&lt; typename... &gt; class TT&gt;<br />
struct hydra::detail::repeat&lt; T, N, TT &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::detail::repeat&lt; T, N, TT &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1repeat__coll__graph.svg" width="148" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a3c8492545a2a08149cff4a2b065d2b6f"></a>typedef typename <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1append__to__type__seq">append_to_type_seq</a>&lt; T, typename <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1repeat">repeat</a>&lt; T, N-1, TT &gt;::<a class="el" href="namespacehydra_1_1detail.html#a3c8492545a2a08149cff4a2b065d2b6f">type</a> &gt;::<a class="el" href="namespacehydra_1_1detail.html#a3c8492545a2a08149cff4a2b065d2b6f">type</a></td>
<td class="fieldname">
type</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structhydra_1_1detail_1_1repeat_3_01T_00_010_00_01TT_01_4" id="structhydra_1_1detail_1_1repeat_3_01T_00_010_00_01TT_01_4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1detail_1_1repeat_3_01T_00_010_00_01TT_01_4">&#9670;&nbsp;</a></span>hydra::detail::repeat&lt; T, 0, TT &gt;</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::detail::repeat&lt; T, 0, TT &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename T, template&lt; typename... &gt; class TT&gt;<br />
struct hydra::detail::repeat&lt; T, 0, TT &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::detail::repeat&lt; T, 0, TT &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1repeat_3_01T_00_010_00_01TT_01_4__coll__graph.svg" width="148" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a7e12a8d9a98e19982fedf2fc1b7f207a"></a>typedef TT&lt;&gt;</td>
<td class="fieldname">
type</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structhydra_1_1detail_1_1ResultPHSP" id="structhydra_1_1detail_1_1ResultPHSP"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1detail_1_1ResultPHSP">&#9670;&nbsp;</a></span>hydra::detail::ResultPHSP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::detail::ResultPHSP</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"></div><div class="dynheader">
Collaboration diagram for hydra::detail::ResultPHSP:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1ResultPHSP__coll__graph.svg" width="187" height="258"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a8d19e0d65eaa393fe0d5f2d578675900"></a><a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a></td>
<td class="fieldname">
fM2</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a9c02ae737d47a9ae27842532c81c07bf"></a><a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a></td>
<td class="fieldname">
fMean</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a99c4af82a39dec887b1718c445d47ecd"></a><a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a></td>
<td class="fieldname">
fW</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structhydra_1_1detail_1_1ResultVegas" id="structhydra_1_1detail_1_1ResultVegas"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1detail_1_1ResultVegas">&#9670;&nbsp;</a></span>hydra::detail::ResultVegas</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::detail::ResultVegas</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"></div><div class="dynheader">
Collaboration diagram for hydra::detail::ResultVegas:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1ResultVegas__coll__graph.svg" width="187" height="258"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="addf467fb4f6b03675952501e353748e7"></a><a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a></td>
<td class="fieldname">
fM2</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a4d239d7f5d0d7b5335cec859fbb263c8"></a><a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a></td>
<td class="fieldname">
fMean</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="aeac7d6d40e06471c8713e6f589e3d15b"></a><a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a></td>
<td class="fieldname">
fN</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structhydra_1_1detail_1_1selected__indices__tuple" id="structhydra_1_1detail_1_1selected__indices__tuple"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1detail_1_1selected__indices__tuple">&#9670;&nbsp;</a></span>hydra::detail::selected_indices_tuple</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::detail::selected_indices_tuple</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;template&lt; typename Type &gt; class Selector, typename TypeList, unsigned I = 0&gt;<br />
struct hydra::detail::selected_indices_tuple&lt; Selector, TypeList, I &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::detail::selected_indices_tuple&lt; Selector, TypeList, I &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1selected__indices__tuple__coll__graph.svg" width="179" height="118"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a name="structhydra_1_1detail_1_1selected__indices__tuple_3_01Selector_00_01hydra_1_1tuple_3_01Head_00_01Tail_8_8_8_01_4_00_01I_01_4" id="structhydra_1_1detail_1_1selected__indices__tuple_3_01Selector_00_01hydra_1_1tuple_3_01Head_00_01Tail_8_8_8_01_4_00_01I_01_4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1detail_1_1selected__indices__tuple_3_01Selector_00_01hydra_1_1tuple_3_01Head_00_01Tail_8_8_8_01_4_00_01I_01_4">&#9670;&nbsp;</a></span>hydra::detail::selected_indices_tuple&lt; Selector, hydra::tuple&lt; Head, Tail... &gt;, I &gt;</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::detail::selected_indices_tuple&lt; Selector, hydra::tuple&lt; Head, Tail... &gt;, I &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;template&lt; typename T &gt; class Selector, typename Head, typename ... Tail, unsigned I&gt;<br />
struct hydra::detail::selected_indices_tuple&lt; Selector, hydra::tuple&lt; Head, Tail... &gt;, I &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::detail::selected_indices_tuple&lt; Selector, hydra::tuple&lt; Head, Tail... &gt;, I &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1selected__indices__tuple_3_01Selector_00_01hydra_1_1tuple_3_01Head_00_03260dfeb0693bd2d495b9977fce440e8.svg" width="224" height="118"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a7ce0e2bd52dd5e094739ed19e38a0730"></a></td>
<td class="fieldname">
type</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structhydra_1_1detail_1_1selected__indices__tuple_3_01Selector_00_01hydra_1_1tuple_3_01Type_01_4_00_01I_01_4" id="structhydra_1_1detail_1_1selected__indices__tuple_3_01Selector_00_01hydra_1_1tuple_3_01Type_01_4_00_01I_01_4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1detail_1_1selected__indices__tuple_3_01Selector_00_01hydra_1_1tuple_3_01Type_01_4_00_01I_01_4">&#9670;&nbsp;</a></span>hydra::detail::selected_indices_tuple&lt; Selector, hydra::tuple&lt; Type &gt;, I &gt;</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::detail::selected_indices_tuple&lt; Selector, hydra::tuple&lt; Type &gt;, I &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;template&lt; typename T &gt; class Selector, typename Type, unsigned I&gt;<br />
struct hydra::detail::selected_indices_tuple&lt; Selector, hydra::tuple&lt; Type &gt;, I &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::detail::selected_indices_tuple&lt; Selector, hydra::tuple&lt; Type &gt;, I &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1selected__indices__tuple_3_01Selector_00_01hydra_1_1tuple_3_01Type_01_4_00_01I_01_4__coll__graph.svg" width="182" height="118"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a828b820911b6a54af2c11d25c60340f4"></a>typedef conditional&lt; Selector&lt; Type &gt;::value, <a class="el" href="namespacehydra.html#a717fc4e6b10453164099beade13d0226">tuple</a>&lt; integral_constant&lt; <a class="el" href="namespace_3globalScope_4.html#classunsigned">unsigned</a>, I &gt; &gt;, <a class="el" href="namespacehydra.html#a717fc4e6b10453164099beade13d0226">tuple</a>&lt;&gt; &gt;::<a class="el" href="namespacehydra_1_1detail.html#a828b820911b6a54af2c11d25c60340f4">type</a></td>
<td class="fieldname">
type</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structhydra_1_1detail_1_1selected__tuple" id="structhydra_1_1detail_1_1selected__tuple"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1detail_1_1selected__tuple">&#9670;&nbsp;</a></span>hydra::detail::selected_tuple</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::detail::selected_tuple</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;template&lt; typename Type &gt; class Selector, typename TypeList&gt;<br />
struct hydra::detail::selected_tuple&lt; Selector, TypeList &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::detail::selected_tuple&lt; Selector, TypeList &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1selected__tuple__coll__graph.svg" width="196" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a name="structhydra_1_1detail_1_1selected__tuple_3_01Selector_00_01hydra_1_1tuple_3_01Head_00_01Tail_8_8_8_01_4_01_4" id="structhydra_1_1detail_1_1selected__tuple_3_01Selector_00_01hydra_1_1tuple_3_01Head_00_01Tail_8_8_8_01_4_01_4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1detail_1_1selected__tuple_3_01Selector_00_01hydra_1_1tuple_3_01Head_00_01Tail_8_8_8_01_4_01_4">&#9670;&nbsp;</a></span>hydra::detail::selected_tuple&lt; Selector, hydra::tuple&lt; Head, Tail... &gt; &gt;</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::detail::selected_tuple&lt; Selector, hydra::tuple&lt; Head, Tail... &gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;template&lt; typename T &gt; class Selector, typename Head, typename ... Tail&gt;<br />
struct hydra::detail::selected_tuple&lt; Selector, hydra::tuple&lt; Head, Tail... &gt; &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::detail::selected_tuple&lt; Selector, hydra::tuple&lt; Head, Tail... &gt; &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1selected__tuple_3_01Selector_00_01hydra_1_1tuple_3_01Head_00_01Tail_8_8_8_01_4_01_4__coll__graph.svg" width="176" height="118"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a3634476cb5c5bbc96e3b9f4325781f4c"></a></td>
<td class="fieldname">
type</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structhydra_1_1detail_1_1selected__tuple_3_01Selector_00_01hydra_1_1tuple_3_01Type_01_4_01_4" id="structhydra_1_1detail_1_1selected__tuple_3_01Selector_00_01hydra_1_1tuple_3_01Type_01_4_01_4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1detail_1_1selected__tuple_3_01Selector_00_01hydra_1_1tuple_3_01Type_01_4_01_4">&#9670;&nbsp;</a></span>hydra::detail::selected_tuple&lt; Selector, hydra::tuple&lt; Type &gt; &gt;</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::detail::selected_tuple&lt; Selector, hydra::tuple&lt; Type &gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;template&lt; typename T &gt; class Selector, typename Type&gt;<br />
struct hydra::detail::selected_tuple&lt; Selector, hydra::tuple&lt; Type &gt; &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::detail::selected_tuple&lt; Selector, hydra::tuple&lt; Type &gt; &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1selected__tuple_3_01Selector_00_01hydra_1_1tuple_3_01Type_01_4_01_4__coll__graph.svg" width="167" height="118"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a67fca6b4069494d78deca8280a754cf8"></a>typedef conditional&lt; Selector&lt; Type &gt;::value, <a class="el" href="namespacehydra.html#a717fc4e6b10453164099beade13d0226">tuple</a>&lt; Type &gt;, <a class="el" href="namespacehydra.html#a717fc4e6b10453164099beade13d0226">tuple</a>&lt;&gt; &gt;::<a class="el" href="namespacehydra_1_1detail.html#a67fca6b4069494d78deca8280a754cf8">type</a></td>
<td class="fieldname">
type</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structhydra_1_1detail_1_1signature__traits" id="structhydra_1_1detail_1_1signature__traits"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1detail_1_1signature__traits">&#9670;&nbsp;</a></span>hydra::detail::signature_traits</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::detail::signature_traits</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename S&gt;<br />
struct hydra::detail::signature_traits&lt; S &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::detail::signature_traits&lt; S &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1signature__traits__coll__graph.svg" width="166" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a name="structhydra_1_1detail_1_1signature__type" id="structhydra_1_1detail_1_1signature__type"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1detail_1_1signature__type">&#9670;&nbsp;</a></span>hydra::detail::signature_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::detail::signature_type</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename R, typename ... A&gt;<br />
struct hydra::detail::signature_type&lt; R, A &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::detail::signature_type&lt; R, A &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1signature__type__coll__graph.svg" width="166" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="ac3018bd6f66064373ef1765d808e847c"></a></td>
<td class="fieldname">
type</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structhydra_1_1detail_1_1signature__type__impl" id="structhydra_1_1detail_1_1signature__type__impl"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1detail_1_1signature__type__impl">&#9670;&nbsp;</a></span>hydra::detail::signature_type_impl</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::detail::signature_type_impl</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename T&gt;<br />
struct hydra::detail::signature_type_impl&lt; T &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::detail::signature_type_impl&lt; T &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1signature__type__impl__coll__graph.svg" width="166" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a5f6aacb86130478ef997463d0aeb58c3"></a>typedef T</td>
<td class="fieldname">
type</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structhydra_1_1detail_1_1stripped__type" id="structhydra_1_1detail_1_1stripped__type"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1detail_1_1stripped__type">&#9670;&nbsp;</a></span>hydra::detail::stripped_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::detail::stripped_type</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename Arg, bool T = is_function_argument&lt;Arg&gt;::value&gt;<br />
struct hydra::detail::stripped_type&lt; Arg, T &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::detail::stripped_type&lt; Arg, T &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1stripped__type__coll__graph.svg" width="158" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a name="structhydra_1_1detail_1_1stripped__type_3_01Arg_00_01false_01_4" id="structhydra_1_1detail_1_1stripped__type_3_01Arg_00_01false_01_4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1detail_1_1stripped__type_3_01Arg_00_01false_01_4">&#9670;&nbsp;</a></span>hydra::detail::stripped_type&lt; Arg, false &gt;</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::detail::stripped_type&lt; Arg, false &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename Arg&gt;<br />
struct hydra::detail::stripped_type&lt; Arg, false &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::detail::stripped_type&lt; Arg, false &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1stripped__type_3_01Arg_00_01false_01_4__coll__graph.svg" width="158" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a978c54faaef382347c9dd413a45ebd83"></a>typedef Arg</td>
<td class="fieldname">
type</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structhydra_1_1detail_1_1stripped__type_3_01Arg_00_01true_01_4" id="structhydra_1_1detail_1_1stripped__type_3_01Arg_00_01true_01_4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1detail_1_1stripped__type_3_01Arg_00_01true_01_4">&#9670;&nbsp;</a></span>hydra::detail::stripped_type&lt; Arg, true &gt;</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::detail::stripped_type&lt; Arg, true &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename Arg&gt;<br />
struct hydra::detail::stripped_type&lt; Arg, true &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::detail::stripped_type&lt; Arg, true &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1stripped__type_3_01Arg_00_01true_01_4__coll__graph.svg" width="158" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="ac3d1aeb85f09983419859baacc8d801d"></a>typedef value_type</td>
<td class="fieldname">
type</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structhydra_1_1detail_1_1sum__result" id="structhydra_1_1detail_1_1sum__result"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1detail_1_1sum__result">&#9670;&nbsp;</a></span>hydra::detail::sum_result</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::detail::sum_result</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename F1, typename F2, typename ... Fs&gt;<br />
struct hydra::detail::sum_result&lt; F1, F2, Fs &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::detail::sum_result&lt; F1, F2, Fs &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1sum__result__coll__graph.svg" width="158" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a574a0cf3739a23e067ea7e3b1acc7592"></a></td>
<td class="fieldname">
type</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structhydra_1_1detail_1_1tag__type" id="structhydra_1_1detail_1_1tag__type"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1detail_1_1tag__type">&#9670;&nbsp;</a></span>hydra::detail::tag_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::detail::tag_type</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;class T, class R = void&gt;<br />
struct hydra::detail::tag_type&lt; T, R &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::detail::tag_type&lt; T, R &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1tag__type__coll__graph.svg" width="130" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a559de10d2ff5e2db2754adf86b3840ec"></a>typedef R</td>
<td class="fieldname">
type</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structhydra_1_1detail_1_1tuple__cat__type" id="structhydra_1_1detail_1_1tuple__cat__type"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1detail_1_1tuple__cat__type">&#9670;&nbsp;</a></span>hydra::detail::tuple_cat_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::detail::tuple_cat_type</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename Tuple1, typename Tuple2&gt;<br />
struct hydra::detail::tuple_cat_type&lt; Tuple1, Tuple2 &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::detail::tuple_cat_type&lt; Tuple1, Tuple2 &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1tuple__cat__type__coll__graph.svg" width="200" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a name="structhydra_1_1detail_1_1tuple__cat__type_3_01hydra__thrust_1_1detail_1_1tuple__of__iterator__re5bb9ebd0e2b48fed7e7ce237c7799785" id="structhydra_1_1detail_1_1tuple__cat__type_3_01hydra__thrust_1_1detail_1_1tuple__of__iterator__re5bb9ebd0e2b48fed7e7ce237c7799785"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1detail_1_1tuple__cat__type_3_01hydra__thrust_1_1detail_1_1tuple__of__iterator__re5bb9ebd0e2b48fed7e7ce237c7799785">&#9670;&nbsp;</a></span>hydra::detail::tuple_cat_type&lt; hydra_thrust::detail::tuple_of_iterator_references&lt; T1... &gt;, hydra_thrust::detail::tuple_of_iterator_references&lt; T2... &gt; &gt;</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::detail::tuple_cat_type&lt; hydra_thrust::detail::tuple_of_iterator_references&lt; T1... &gt;, hydra_thrust::detail::tuple_of_iterator_references&lt; T2... &gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename ... T1, typename ... T2&gt;<br />
struct hydra::detail::tuple_cat_type&lt; hydra_thrust::detail::tuple_of_iterator_references&lt; T1... &gt;, hydra_thrust::detail::tuple_of_iterator_references&lt; T2... &gt; &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::detail::tuple_cat_type&lt; hydra_thrust::detail::tuple_of_iterator_references&lt; T1... &gt;, hydra_thrust::detail::tuple_of_iterator_references&lt; T2... &gt; &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1tuple__cat__type_3_01hydra__thrust_1_1detail_1_1tuple__of__iterator__re2741fd8e8c86ddfd555d0733f8d5b654.svg" width="214" height="162"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a729b1dea3e61359b87ebf9395e4e06b9"></a></td>
<td class="fieldname">
type</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structhydra_1_1detail_1_1tuple__cat__type_3_01hydra__thrust_1_1tuple_3_01T1_8_8_8_01_4_00_01hydrfed0294bfa8beb4efb8ca45fc614f789" id="structhydra_1_1detail_1_1tuple__cat__type_3_01hydra__thrust_1_1tuple_3_01T1_8_8_8_01_4_00_01hydrfed0294bfa8beb4efb8ca45fc614f789"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1detail_1_1tuple__cat__type_3_01hydra__thrust_1_1tuple_3_01T1_8_8_8_01_4_00_01hydrfed0294bfa8beb4efb8ca45fc614f789">&#9670;&nbsp;</a></span>hydra::detail::tuple_cat_type&lt; hydra_thrust::tuple&lt; T1... &gt;, hydra_thrust::tuple&lt; T2... &gt; &gt;</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::detail::tuple_cat_type&lt; hydra_thrust::tuple&lt; T1... &gt;, hydra_thrust::tuple&lt; T2... &gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename ... T1, typename ... T2&gt;<br />
struct hydra::detail::tuple_cat_type&lt; hydra_thrust::tuple&lt; T1... &gt;, hydra_thrust::tuple&lt; T2... &gt; &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::detail::tuple_cat_type&lt; hydra_thrust::tuple&lt; T1... &gt;, hydra_thrust::tuple&lt; T2... &gt; &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1tuple__cat__type_3_01hydra__thrust_1_1tuple_3_01T1_8_8_8_01_4_00_01hydr3f2b365811d881a839bc249fef69b76b.svg" width="174" height="132"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="adf0c360dd1cf05db7e5aa1568276c182"></a></td>
<td class="fieldname">
type</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structhydra_1_1detail_1_1tuple__type" id="structhydra_1_1detail_1_1tuple__type"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1detail_1_1tuple__type">&#9670;&nbsp;</a></span>hydra::detail::tuple_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::detail::tuple_type</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;size_t N, typename T&gt;<br />
struct hydra::detail::tuple_type&lt; N, T &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::detail::tuple_type&lt; N, T &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1tuple__type__coll__graph.svg" width="140" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a22e38393ea5d639e178949f9e3093076"></a>typedef <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1repeat">repeat</a>&lt; T, N, <a class="el" href="namespacehydra.html#a717fc4e6b10453164099beade13d0226">tuple</a> &gt;::<a class="el" href="namespacehydra_1_1detail.html#a22e38393ea5d639e178949f9e3093076">type</a></td>
<td class="fieldname">
type</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structhydra_1_1detail_1_1unidimensional" id="structhydra_1_1detail_1_1unidimensional"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1detail_1_1unidimensional">&#9670;&nbsp;</a></span>hydra::detail::unidimensional</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::detail::unidimensional</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"></div><div class="dynheader">
Collaboration diagram for hydra::detail::unidimensional:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1unidimensional__coll__graph.svg" width="198" height="88"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a3c72e1aed3a4538dac06a7e816543c23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c72e1aed3a4538dac06a7e816543c23">&#9670;&nbsp;</a></span>are_all_same</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R , class... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacehydra_1_1detail.html#a3c72e1aed3a4538dac06a7e816543c23">hydra::detail::are_all_same</a> = typedef <a class="el" href="structhydra_1_1detail_1_1all__true.html">all_true</a>&lt;std::is_same&lt;Ts, R&gt;::value...&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aee93c31c37a22c22c49c73483cfd0f91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee93c31c37a22c22c49c73483cfd0f91">&#9670;&nbsp;</a></span>common_type_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class... T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacehydra_1_1detail.html#aee93c31c37a22c22c49c73483cfd0f91">hydra::detail::common_type_t</a> = typedef typename std::common_type&lt;T...&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a21eef8c0671371274978fac6d9b44180"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21eef8c0671371274978fac6d9b44180">&#9670;&nbsp;</a></span>anonymous enum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a21eef8c0671371274978fac6d9b44180aea9c72bdee6f384d88af4eab49530ea8"></a>kInvalidNumber&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a1461b18b118ced9f91233acbe90fd897"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1461b18b118ced9f91233acbe90fd897">&#9670;&nbsp;</a></span>Backend</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacehydra_1_1detail.html#a1461b18b118ced9f91233acbe90fd897">hydra::detail::Backend</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a1461b18b118ced9f91233acbe90fd897a394a4eccb0e1634ec1294f902f5439e2"></a>Host&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1461b18b118ced9f91233acbe90fd897ad7a51d196c98a1057d741a6ebd3d84db"></a>Device&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1461b18b118ced9f91233acbe90fd897a0fb8e6fb3bd5e20cae92bc309106fae4"></a>Cpp&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1461b18b118ced9f91233acbe90fd897a1b83f5e80dc60afdb33987f3d9ce20bf"></a>Omp&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1461b18b118ced9f91233acbe90fd897a0346e63703cdc5752878c4e0623ace64"></a>Tbb&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1461b18b118ced9f91233acbe90fd897a3ef47f45ff0de8694163bcfe498e4a89"></a>Cuda&#160;</td><td class="fielddoc"></td></tr>
</table>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="dalitz_plot_8C-example.html#a21">dalitz_plot.C</a>, and <a class="el" href="dalitz_plot_8inl-example.html#a27">dalitz_plot.inl</a>.</dd>
</dl>
</div>
</div>
<a id="aa817d51dec8ff2c9ad9eeaf1f91bc6e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa817d51dec8ff2c9ad9eeaf1f91bc6e4">&#9670;&nbsp;</a></span>FFTCalculator</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacehydra_1_1detail.html#aa817d51dec8ff2c9ad9eeaf1f91bc6e4">hydra::detail::FFTCalculator</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aa817d51dec8ff2c9ad9eeaf1f91bc6e4a2dcac3babe9917463a1823b4fc97d989"></a>CuFFT&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa817d51dec8ff2c9ad9eeaf1f91bc6e4ac7647480fd178ef276ec77e4830704b3"></a>FFTW&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a02f4955fdb3b1d3d98c25b46369edbeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02f4955fdb3b1d3d98c25b46369edbeb">&#9670;&nbsp;</a></span>_get_element() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename T , size_t I&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::detail::enable_if&lt;(I == hydra_thrust::tuple_size&lt;T&gt;::value), void&gt;::type hydra::detail::_get_element </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R *&amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a56f1616d93ab32d59a37fbb6b88c2eda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56f1616d93ab32d59a37fbb6b88c2eda">&#9670;&nbsp;</a></span>_get_element() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename T , size_t I = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::detail::enable_if&lt;( I &lt; hydra_thrust::tuple_size&lt;T&gt;::value), void&gt;::type hydra::detail::_get_element </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R *&amp;&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a498be0db424a8fb9eb104c824560c620"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a498be0db424a8fb9eb104c824560c620">&#9670;&nbsp;</a></span>accumulate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Return_Type , typename ArgType , typename ... Tp, typename  = typename hydra_thrust::detail::enable_if&lt;std::is_convertible&lt;Return_Type, double&gt;::value || std::is_constructible&lt;hydra_thrust::complex&lt;double&gt;,Return_Type&gt;::value &gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> Return_Type hydra::detail::accumulate </td>
          <td>(</td>
          <td class="paramtype">ArgType &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hydra_thrust::tuple&lt; Tp... &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6ad8b6c8a043ca17c3c6571487a00af3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ad8b6c8a043ca17c3c6571487a00af3">&#9670;&nbsp;</a></span>accumulate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Return_Type , typename ArgType , typename ... Tp, typename  = typename hydra_thrust::detail::enable_if&lt;std::is_convertible&lt;Return_Type, double&gt;::value || std::is_constructible&lt;hydra_thrust::complex&lt;double&gt;,Return_Type&gt;::value &gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> Return_Type hydra::detail::accumulate </td>
          <td>(</td>
          <td class="paramtype">ArgType const &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hydra_thrust::tuple&lt; Tp... &gt; const &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab89cdc62576c0e346bbbf0e86c517e06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab89cdc62576c0e346bbbf0e86c517e06">&#9670;&nbsp;</a></span>accumulate2() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Return_Type , typename ArgType1 , typename ArgType2 , typename ... Tp, typename  = typename hydra_thrust::detail::enable_if&lt;std::is_convertible&lt;Return_Type, double&gt;::value || std::is_constructible&lt;hydra_thrust::complex&lt;double&gt;,Return_Type&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> Return_Type hydra::detail::accumulate2 </td>
          <td>(</td>
          <td class="paramtype">ArgType1 &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArgType2 &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hydra_thrust::tuple&lt; Tp... &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad7d3ac2f47956b582edbf82881afccb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7d3ac2f47956b582edbf82881afccb6">&#9670;&nbsp;</a></span>accumulate2() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Return_Type , typename ArgType1 , typename ArgType2 , typename ... Tp, typename  = typename hydra_thrust::detail::enable_if&lt;std::is_convertible&lt;Return_Type, double&gt;::value || std::is_constructible&lt;hydra_thrust::complex&lt;double&gt;,Return_Type&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> Return_Type hydra::detail::accumulate2 </td>
          <td>(</td>
          <td class="paramtype">ArgType1 const &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArgType2 const &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hydra_thrust::tuple&lt; Tp... &gt; const &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa4a03e1acf7793aeeb625d420ac67e23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4a03e1acf7793aeeb625d420ac67e23">&#9670;&nbsp;</a></span>add_parameters_in_tuple() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I = 0, typename ... Tp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">hydra_thrust::detail::enable_if&lt;I == sizeof...(Tp), void&gt;::type hydra::detail::add_parameters_in_tuple </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="group__fit.html#structhydra_1_1Parameter">hydra::Parameter</a> *&gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hydra_thrust::tuple&lt; Tp... &gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2194b2d6ba44a6a6a85ac0ffca19339c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2194b2d6ba44a6a6a85ac0ffca19339c">&#9670;&nbsp;</a></span>add_parameters_in_tuple() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I = 0, typename ... Tp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">hydra_thrust::detail::enable_if&lt;(I &lt; sizeof...(Tp)),void &gt;::type hydra::detail::add_parameters_in_tuple </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="group__fit.html#structhydra_1_1Parameter">hydra::Parameter</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>user_parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hydra_thrust::tuple&lt; Tp... &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2df93ef3f457f1eb6f203758033350df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2df93ef3f457f1eb6f203758033350df">&#9670;&nbsp;</a></span>add_tuple_values() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I, typename ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::detail::enable_if&lt;(I == sizeof...(T)),void &gt;::type hydra::detail::add_tuple_values </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hydra_thrust::tuple&lt; T... &gt; const &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a438dc9b0660d0be705cd74a24bb75055"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a438dc9b0660d0be705cd74a24bb75055">&#9670;&nbsp;</a></span>add_tuple_values() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I = 0, typename ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::detail::enable_if&lt;(I &lt; sizeof...(T)),void &gt;::type hydra::detail::add_tuple_values </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hydra_thrust::tuple&lt; T... &gt; const &amp;&#160;</td>
          <td class="paramname"><em>tpl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab2bcf09451ea3c99060645b5332cf540"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2bcf09451ea3c99060645b5332cf540">&#9670;&nbsp;</a></span>addTuples() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, size_t ... I&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::tuple&lt;T...&gt; hydra::detail::addTuples </td>
          <td>(</td>
          <td class="paramtype">const hydra_thrust::tuple&lt; T... &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const hydra_thrust::tuple&lt; T... &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1detail_1_1index__sequence.html">index_sequence</a>&lt; I... &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7b556152a6d0f6477b1622231aa0a32f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b556152a6d0f6477b1622231aa0a32f">&#9670;&nbsp;</a></span>addTuples() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::tuple&lt;T...&gt; hydra::detail::addTuples </td>
          <td>(</td>
          <td class="paramtype">const hydra_thrust::tuple&lt; T... &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const hydra_thrust::tuple&lt; T... &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aaea8534bb7462e49893de47801d285a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaea8534bb7462e49893de47801d285a0">&#9670;&nbsp;</a></span>addTuplesHelper()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I, typename ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::tuple_element&lt;I, hydra_thrust::tuple&lt;T...&gt; &gt;::type hydra::detail::addTuplesHelper </td>
          <td>(</td>
          <td class="paramtype">const hydra_thrust::tuple&lt; T... &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const hydra_thrust::tuple&lt; T... &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa3be119e15f0b9be4173ba8268a66b71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3be119e15f0b9be4173ba8268a66b71">&#9670;&nbsp;</a></span>ApproximatelyEqual()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> bool hydra::detail::ApproximatelyEqual </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code><a class="el" href="namespacehydra_1_1detail.html#af60fc3e60cc10bd79092ca02c8e8b84c">machine_eps_f64</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="acc4a7a3b4f3c2827fd0eaff57e0b300c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc4a7a3b4f3c2827fd0eaff57e0b300c">&#9670;&nbsp;</a></span>ApproximatelyZero()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> bool hydra::detail::ApproximatelyZero </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code><a class="el" href="namespacehydra_1_1detail.html#af60fc3e60cc10bd79092ca02c8e8b84c">machine_eps_f64</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2fb09f08e05c59f9cb8f7810677b0a35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fb09f08e05c59f9cb8f7810677b0a35">&#9670;&nbsp;</a></span>arrayToTuple() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::detail::arrayToTuple </td>
          <td>(</td>
          <td class="paramtype">std::array&lt; T, N &gt;const &amp;&#160;</td>
          <td class="paramname"><em>Array</em></td><td>)</td>
          <td> -&gt; decltype(<a class="el" href="namespacehydra_1_1detail.html#a45da45c4361e4fa7183b32d72d5441af">arrayToTupleHelper</a>(Array, <a class="el" href="structhydra_1_1detail_1_1make__index__sequence.html">make_index_sequence</a>&lt;N&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9d0da29f0be34c5fe0f79e47b6963340"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d0da29f0be34c5fe0f79e47b6963340">&#9670;&nbsp;</a></span>arrayToTuple() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> auto hydra::detail::arrayToTuple </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>Array</em></td><td>)</td>
          <td> -&gt; decltype( <a class="el" href="namespacehydra_1_1detail.html#a45da45c4361e4fa7183b32d72d5441af">arrayToTupleHelper</a>(Array, <a class="el" href="structhydra_1_1detail_1_1make__index__sequence.html">make_index_sequence</a>&lt;N&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a45da45c4361e4fa7183b32d72d5441af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45da45c4361e4fa7183b32d72d5441af">&#9670;&nbsp;</a></span>arrayToTupleHelper() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t... Is&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::detail::arrayToTupleHelper </td>
          <td>(</td>
          <td class="paramtype">std::array&lt; T, sizeof...(Is)&gt;const &amp;&#160;</td>
          <td class="paramname"><em>Array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1detail_1_1index__sequence.html">index_sequence</a>&lt; Is... &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(hydra_thrust::make_tuple(Array[Is]...))
	</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa0f469856dbd0bb5e87f5c012efae2b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0f469856dbd0bb5e87f5c012efae2b0">&#9670;&nbsp;</a></span>arrayToTupleHelper() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t... Indices&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> auto hydra::detail::arrayToTupleHelper </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>Array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1detail_1_1index__sequence.html">index_sequence</a>&lt; Indices... &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(hydra_thrust::make_tuple(Array[Indices]...))
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2d10110b86c5d6e45099e126e5c54fb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d10110b86c5d6e45099e126e5c54fb7">&#9670;&nbsp;</a></span>assignArrayToTuple() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I, typename ArrayType , typename FistType , typename ... OtherTypes&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::detail::enable_if&lt; I == (sizeof...(OtherTypes) + 1) &amp;&amp; std::is_convertible&lt;FistType, ArrayType&gt;::value &amp;&amp; <a class="el" href="structhydra_1_1detail_1_1all__true.html">all_true</a>&lt; std::is_convertible&lt;OtherTypes,ArrayType&gt;::value...&gt;::value, void &gt;::type hydra::detail::assignArrayToTuple </td>
          <td>(</td>
          <td class="paramtype">hydra_thrust::tuple&lt; FistType, OtherTypes... &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArrayType const *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a08b60bbd48640f46836c018a4e685b70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08b60bbd48640f46836c018a4e685b70">&#9670;&nbsp;</a></span>assignArrayToTuple() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I = 0, typename ArrayType , typename FistType , typename ... OtherTypes&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::detail::enable_if&lt; (I &lt; sizeof...(OtherTypes)+1) &amp;&amp; std::is_convertible&lt;FistType, ArrayType&gt;::value &amp;&amp; <a class="el" href="structhydra_1_1detail_1_1all__true.html">all_true</a>&lt; std::is_convertible&lt;OtherTypes,ArrayType&gt;::value...&gt;::value, void &gt;::type hydra::detail::assignArrayToTuple </td>
          <td>(</td>
          <td class="paramtype">hydra_thrust::tuple&lt; FistType, OtherTypes... &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArrayType const *&#160;</td>
          <td class="paramname"><em>Array</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a09d65a22cd08900bb301cfa560cab50f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09d65a22cd08900bb301cfa560cab50f">&#9670;&nbsp;</a></span>assignArrayToTuple() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I, typename ArrayType , typename FistType , typename ... OtherTypes&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::detail::enable_if&lt; I == (sizeof...(OtherTypes) + 1) &amp;&amp; std::is_convertible&lt;FistType,ArrayType &gt;::value &amp;&amp; <a class="el" href="structhydra_1_1detail_1_1all__true.html">all_true</a>&lt;std::is_convertible&lt;OtherTypes,ArrayType&gt;::value...&gt;::value, void&gt;::type hydra::detail::assignArrayToTuple </td>
          <td>(</td>
          <td class="paramtype">hydra_thrust::detail::tuple_of_iterator_references&lt; FistType, OtherTypes... &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArrayType const *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7a94b4c8a4f17b2014c79be1a2f05f6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a94b4c8a4f17b2014c79be1a2f05f6a">&#9670;&nbsp;</a></span>assignArrayToTuple() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I = 0, typename ArrayType , typename FistType , typename ... OtherTypes&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::detail::enable_if&lt; (I &lt; sizeof...(OtherTypes)+1) &amp;&amp; std::is_convertible&lt;FistType,ArrayType &gt;::value &amp;&amp; <a class="el" href="structhydra_1_1detail_1_1all__true.html">all_true</a>&lt;std::is_convertible&lt;OtherTypes,ArrayType&gt;::value...&gt;::value, void &gt;::type hydra::detail::assignArrayToTuple </td>
          <td>(</td>
          <td class="paramtype">hydra_thrust::detail::tuple_of_iterator_references&lt; FistType, OtherTypes... &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArrayType const *&#160;</td>
          <td class="paramname"><em>Array</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8824f1c8bee0a4b09bfc0eff093dd14f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8824f1c8bee0a4b09bfc0eff093dd14f">&#9670;&nbsp;</a></span>assignTupleToArray() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I = 0, typename ArrayType , typename FistType , typename ... OtherTypes&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::detail::enable_if&lt;I == (sizeof...(OtherTypes) + 1) &amp;&amp; <a class="el" href="structhydra_1_1detail_1_1is__hydra__convertible__to__tuple.html">is_hydra_convertible_to_tuple</a>&lt;ArrayType&gt;::value &amp;&amp; <a class="el" href="namespacehydra_1_1detail.html#a3c72e1aed3a4538dac06a7e816543c23">are_all_same</a>&lt;FistType,OtherTypes...&gt;::value, void&gt;::type hydra::detail::assignTupleToArray </td>
          <td>(</td>
          <td class="paramtype">hydra_thrust::tuple&lt; FistType, OtherTypes... &gt; const &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArrayType(&amp;)&#160;</td>
          <td class="paramname">[sizeof...(OtherTypes)+1]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a72efcb430e2aea2171eba70f81cb08b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72efcb430e2aea2171eba70f81cb08b8">&#9670;&nbsp;</a></span>assignTupleToArray() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I = 0, typename ArrayType , typename FistType , typename ... OtherTypes&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::detail::enable_if&lt;(I &lt; sizeof...(OtherTypes)+1) &amp;&amp; <a class="el" href="structhydra_1_1detail_1_1is__hydra__convertible__to__tuple.html">is_hydra_convertible_to_tuple</a>&lt;ArrayType&gt;::value &amp;&amp; <a class="el" href="namespacehydra_1_1detail.html#a3c72e1aed3a4538dac06a7e816543c23">are_all_same</a>&lt;FistType,OtherTypes...&gt;::value, void &gt;::type hydra::detail::assignTupleToArray </td>
          <td>(</td>
          <td class="paramtype">hydra_thrust::tuple&lt; FistType, OtherTypes... &gt; const &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArrayType(&amp;)&#160;</td>
          <td class="paramname"><em>Array</em>[sizeof...(OtherTypes)+1]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a85d6c644fd94e7d86174c9da15486ca3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85d6c644fd94e7d86174c9da15486ca3">&#9670;&nbsp;</a></span>assignTupleToArray() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I = 0, typename ArrayType , typename FistType , typename ... OtherTypes&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::detail::enable_if&lt;I == (sizeof...(OtherTypes) + 1) &amp;&amp; <a class="el" href="structhydra_1_1detail_1_1is__hydra__convertible__to__tuple.html">is_hydra_convertible_to_tuple</a>&lt;ArrayType&gt;::value &amp;&amp; <a class="el" href="namespacehydra_1_1detail.html#a3c72e1aed3a4538dac06a7e816543c23">are_all_same</a>&lt;FistType,OtherTypes...&gt;::value, void&gt;::type hydra::detail::assignTupleToArray </td>
          <td>(</td>
          <td class="paramtype">hydra_thrust::tuple&lt; FistType &amp;, OtherTypes &amp;... &gt; const &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArrayType(&amp;)&#160;</td>
          <td class="paramname">[sizeof...(OtherTypes)+1]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac32dd708dfece676fb655b6600946ebe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac32dd708dfece676fb655b6600946ebe">&#9670;&nbsp;</a></span>assignTupleToArray() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I = 0, typename ArrayType , typename FistType , typename ... OtherTypes&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::detail::enable_if&lt;(I &lt; sizeof...(OtherTypes)+1) &amp;&amp; <a class="el" href="structhydra_1_1detail_1_1is__hydra__convertible__to__tuple.html">is_hydra_convertible_to_tuple</a>&lt;ArrayType&gt;::value &amp;&amp; <a class="el" href="namespacehydra_1_1detail.html#a3c72e1aed3a4538dac06a7e816543c23">are_all_same</a>&lt;FistType,OtherTypes...&gt;::value, void &gt;::type hydra::detail::assignTupleToArray </td>
          <td>(</td>
          <td class="paramtype">hydra_thrust::tuple&lt; FistType &amp;, OtherTypes &amp;... &gt; const &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArrayType(&amp;)&#160;</td>
          <td class="paramname"><em>Array</em>[sizeof...(OtherTypes)+1]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a370d1378b3bf83ff0976dc85cb97a559"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a370d1378b3bf83ff0976dc85cb97a559">&#9670;&nbsp;</a></span>assignTupleToArray() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I = 0, typename ArrayType , typename FistType , typename ... OtherTypes&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::detail::enable_if&lt;I == (sizeof...(OtherTypes) + 1) &amp;&amp; <a class="el" href="structhydra_1_1detail_1_1is__hydra__convertible__to__tuple.html">is_hydra_convertible_to_tuple</a>&lt;ArrayType&gt;::value &amp;&amp; <a class="el" href="namespacehydra_1_1detail.html#a3c72e1aed3a4538dac06a7e816543c23">are_all_same</a>&lt;FistType,OtherTypes...&gt;::value, void&gt;::type hydra::detail::assignTupleToArray </td>
          <td>(</td>
          <td class="paramtype">hydra_thrust::detail::tuple_of_iterator_references&lt; FistType, OtherTypes... &gt; const &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArrayType(&amp;)&#160;</td>
          <td class="paramname">[sizeof...(OtherTypes)+1]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7600f26d1540ce89d073e564d97909ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7600f26d1540ce89d073e564d97909ab">&#9670;&nbsp;</a></span>assignTupleToArray() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I = 0, typename ArrayType , typename FistType , typename ... OtherTypes&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::detail::enable_if&lt;(I &lt; sizeof...(OtherTypes)+1) &amp;&amp; <a class="el" href="structhydra_1_1detail_1_1is__hydra__convertible__to__tuple.html">is_hydra_convertible_to_tuple</a>&lt;ArrayType&gt;::value &amp;&amp; <a class="el" href="namespacehydra_1_1detail.html#a3c72e1aed3a4538dac06a7e816543c23">are_all_same</a>&lt;FistType,OtherTypes...&gt;::value, void &gt;::type hydra::detail::assignTupleToArray </td>
          <td>(</td>
          <td class="paramtype">hydra_thrust::detail::tuple_of_iterator_references&lt; FistType, OtherTypes... &gt; const &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArrayType(&amp;)&#160;</td>
          <td class="paramname"><em>Array</em>[sizeof...(OtherTypes)+1]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a82f8b5cc4c258c0b78743536023d080e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82f8b5cc4c258c0b78743536023d080e">&#9670;&nbsp;</a></span>callOnTuple()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F , typename ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::tuple&lt;T...&gt; hydra::detail::callOnTuple </td>
          <td>(</td>
          <td class="paramtype">F const &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const hydra_thrust::tuple&lt; T... &gt; &amp;&#160;</td>
          <td class="paramname"><em>tuple</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a046148d4f1af6d6e26a4615a84e4bbaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a046148d4f1af6d6e26a4615a84e4bbaa">&#9670;&nbsp;</a></span>callOnTupleHelper()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F , typename ... T, size_t ... I&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::tuple&lt;T...&gt; hydra::detail::callOnTupleHelper </td>
          <td>(</td>
          <td class="paramtype">F const &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const hydra_thrust::tuple&lt; T... &gt; &amp;&#160;</td>
          <td class="paramname"><em>tuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1detail_1_1index__sequence.html">index_sequence</a>&lt; I... &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aeccac2b5a421cca43286e9717d251c69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeccac2b5a421cca43286e9717d251c69">&#9670;&nbsp;</a></span>CheckValue()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename ... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> T hydra::detail::CheckValue </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_3globalScope_4.html#classunsigned">unsigned</a> <a class="el" href="namespace_3globalScope_4.html#classint">int</a>&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ts &amp;&amp;...&#160;</td>
          <td class="paramname"><em>par</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a24033eefbdb1401523f0c4936e05da28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24033eefbdb1401523f0c4936e05da28">&#9670;&nbsp;</a></span>divideTuples() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, size_t ... I&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::tuple&lt;T...&gt; hydra::detail::divideTuples </td>
          <td>(</td>
          <td class="paramtype">const hydra_thrust::tuple&lt; T... &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const hydra_thrust::tuple&lt; T... &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1detail_1_1index__sequence.html">index_sequence</a>&lt; I... &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aaf108707b80a851bd097ee8e3a5afcdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf108707b80a851bd097ee8e3a5afcdf">&#9670;&nbsp;</a></span>divideTuples() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::tuple&lt;T...&gt; hydra::detail::divideTuples </td>
          <td>(</td>
          <td class="paramtype">const hydra_thrust::tuple&lt; T... &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const hydra_thrust::tuple&lt; T... &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2632a763908afba57fcbc5e8d7a09f0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2632a763908afba57fcbc5e8d7a09f0a">&#9670;&nbsp;</a></span>divideTuplesHelper()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I, typename ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::tuple_element&lt;I, hydra_thrust::tuple&lt;T...&gt; &gt;::type hydra::detail::divideTuplesHelper </td>
          <td>(</td>
          <td class="paramtype">const hydra_thrust::tuple&lt; T... &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const hydra_thrust::tuple&lt; T... &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a03b17f9b7b0e39924e0819250d04ea85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03b17f9b7b0e39924e0819250d04ea85">&#9670;&nbsp;</a></span>eval_on_tuple_element() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int I = 0, typename FuncT , typename ... Tp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::detail::enable_if&lt;I == sizeof...(Tp), void&gt;::type hydra::detail::eval_on_tuple_element </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_3globalScope_4.html#classint">int</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hydra_thrust::tuple&lt; Tp... &gt; const &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FuncT const &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afe7c19041604f8d2835e030454b95d0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe7c19041604f8d2835e030454b95d0f">&#9670;&nbsp;</a></span>eval_on_tuple_element() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int I = 0, typename FuncT , typename ... Tp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::detail::enable_if&lt;(I &lt; sizeof...(Tp)), void &gt;::type hydra::detail::eval_on_tuple_element </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_3globalScope_4.html#classint">int</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hydra_thrust::tuple&lt; Tp... &gt; const &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FuncT const &amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a45910f4522df506c9e510219a2327e96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45910f4522df506c9e510219a2327e96">&#9670;&nbsp;</a></span>eval_tuple_element() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I = 0, typename Return_Type , typename ArgType , typename ... Tp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::detail::enable_if&lt;I == sizeof...(Tp), void&gt;::type hydra::detail::eval_tuple_element </td>
          <td>(</td>
          <td class="paramtype">Return_Type &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_3globalScope_4.html#classint">int</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hydra_thrust::tuple&lt; Tp... &gt; const &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArgType const &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5059b569131e6db6c738eb807e743c25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5059b569131e6db6c738eb807e743c25">&#9670;&nbsp;</a></span>eval_tuple_element() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I = 0, typename Return_Type , typename ArgType , typename ... Tp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::detail::enable_if&lt;(I &lt; sizeof...(Tp)), void &gt;::type hydra::detail::eval_tuple_element </td>
          <td>(</td>
          <td class="paramtype">Return_Type &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_3globalScope_4.html#classint">int</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hydra_thrust::tuple&lt; Tp... &gt; const &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArgType const &amp;&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a96a946dad2a4b9f834836d9b954ad8b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96a946dad2a4b9f834836d9b954ad8b6">&#9670;&nbsp;</a></span>extract()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , typename Tuple &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> Type hydra::detail::extract </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_3globalScope_4.html#classint">int</a>&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Tuple &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="add5147a947f0edd769e9fc10f7a65759"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add5147a947f0edd769e9fc10f7a65759">&#9670;&nbsp;</a></span>get_element()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> R&amp; hydra::detail::get_element </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hydra_thrust::tuple&lt; T... &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8cb37313145410697a80a4a7786a1712"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cb37313145410697a80a4a7786a1712">&#9670;&nbsp;</a></span>get_functor_tuple()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tup &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::detail::get_functor_tuple </td>
          <td>(</td>
          <td class="paramtype">Tup &amp;&#160;</td>
          <td class="paramname"><em>pdfs</em></td><td>)</td>
          <td> -&gt; decltype(<a class="el" href="namespacehydra_1_1detail.html#a500db4ea93e7304d994ed97337f1c479">get_functor_tuple_helper</a>(pdfs, <a class="el" href="structhydra_1_1detail_1_1make__index__sequence.html">make_index_sequence</a>&lt; hydra_thrust::tuple_size&lt;Tup&gt;::value&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a500db4ea93e7304d994ed97337f1c479"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a500db4ea93e7304d994ed97337f1c479">&#9670;&nbsp;</a></span>get_functor_tuple_helper() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tup , size_t ... index&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::detail::get_functor_tuple_helper </td>
          <td>(</td>
          <td class="paramtype">Tup &amp;&#160;</td>
          <td class="paramname"><em>pdfs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1detail_1_1index__sequence.html">index_sequence</a>&lt; index... &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(hydra_thrust::make_tuple(hydra_thrust::get&lt;index&gt;(pdfs).GetFunctor()...))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7c688d5b722922805a5837cac93a6411"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c688d5b722922805a5837cac93a6411">&#9670;&nbsp;</a></span>get_functor_tuple_helper() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="basic__distributions_8inl.html#a9717e7bbecb906637e86cef6da3d83c2">return</a> hydra::detail::get_functor_tuple_helper </td>
          <td>(</td>
          <td class="paramtype">pdfs&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1detail_1_1make__index__sequence.html">make_index_sequence</a>&lt; Size &gt; { }&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a325f4c7bd791f8e4c8e7777fd1004e6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a325f4c7bd791f8e4c8e7777fd1004e6a">&#9670;&nbsp;</a></span>get_indexes() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t DIM, size_t I&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; (I==DIM) &amp;&amp; (std::is_integral&lt;T&gt;::value), void &gt;::type hydra::detail::get_indexes </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; T, DIM &gt; const &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; T, DIM &gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7ba59a3eeef51673f8abf850370c9d55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ba59a3eeef51673f8abf850370c9d55">&#9670;&nbsp;</a></span>get_indexes() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t DIM, size_t I = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; (I&lt;DIM) &amp;&amp; (std::is_integral&lt;T&gt;::value), void &gt;::type hydra::detail::get_indexes </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; T, DIM &gt; const &amp;&#160;</td>
          <td class="paramname"><em>depths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; T, DIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>indexes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a25ee93686d2834f2c81bbc9ca75340b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25ee93686d2834f2c81bbc9ca75340b3">&#9670;&nbsp;</a></span>get_indexes() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t DIM, size_t I&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; (I==DIM) &amp;&amp; (std::is_integral&lt;T&gt;::value), void &gt;::type hydra::detail::get_indexes </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const &#160;</td>
          <td class="paramname"><em>T</em>(&amp;)[DIM], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T(&amp;)&#160;</td>
          <td class="paramname">[DIM]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab08843425e05190a4baeb424c9da09a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab08843425e05190a4baeb424c9da09a9">&#9670;&nbsp;</a></span>get_indexes() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t DIM, size_t I = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; (I&lt;DIM) &amp;&amp; (std::is_integral&lt;T&gt;::value), void &gt;::type hydra::detail::get_indexes </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T(&amp;)&#160;</td>
          <td class="paramname"><em>depths</em>[DIM], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T(&amp;)&#160;</td>
          <td class="paramname"><em>indexes</em>[DIM]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a81cfdb5fabf173a3f07608e3c8d46deb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81cfdb5fabf173a3f07608e3c8d46deb">&#9670;&nbsp;</a></span>get_tuple_element() <span class="overload">[1/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Types&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> T&amp; hydra::detail::get_tuple_element </td>
          <td>(</td>
          <td class="paramtype">hydra_thrust::tuple&lt; Types... &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af3f6b46b33c605d2cec7605fb5bd8661"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3f6b46b33c605d2cec7605fb5bd8661">&#9670;&nbsp;</a></span>get_tuple_element() <span class="overload">[2/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class... Types&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> const T&amp; hydra::detail::get_tuple_element </td>
          <td>(</td>
          <td class="paramtype">const hydra_thrust::tuple&lt; Types... &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad0415b176fc2467d2d59b0258d8f0078"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0415b176fc2467d2d59b0258d8f0078">&#9670;&nbsp;</a></span>get_tuple_element() <span class="overload">[3/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class... Types&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> T&amp;&amp; hydra::detail::get_tuple_element </td>
          <td>(</td>
          <td class="paramtype">hydra_thrust::tuple&lt; Types... &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab6c2f7bef9f3b69d9e87ad1f8a156ac9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6c2f7bef9f3b69d9e87ad1f8a156ac9">&#9670;&nbsp;</a></span>get_tuple_element() <span class="overload">[4/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Types&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::device_reference&lt;T&gt; hydra::detail::get_tuple_element </td>
          <td>(</td>
          <td class="paramtype">hydra_thrust::tuple&lt; hydra_thrust::device_reference&lt; Types &gt;... &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a79277e2a97c4ebc035e38a9f84eef76e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79277e2a97c4ebc035e38a9f84eef76e">&#9670;&nbsp;</a></span>get_tuple_element() <span class="overload">[5/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class... Types&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> const hydra_thrust::device_reference&lt;T&gt; hydra::detail::get_tuple_element </td>
          <td>(</td>
          <td class="paramtype">const hydra_thrust::tuple&lt; hydra_thrust::device_reference&lt; Types &gt;... &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a885cfb94fba2e2aebc1e092fea2cf939"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a885cfb94fba2e2aebc1e092fea2cf939">&#9670;&nbsp;</a></span>get_tuple_element() <span class="overload">[6/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class... Types&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::device_reference&lt;T&gt;&amp;&amp; hydra::detail::get_tuple_element </td>
          <td>(</td>
          <td class="paramtype">hydra_thrust::tuple&lt; hydra_thrust::device_reference&lt; Types &gt;... &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a17e36369eb43435874bb774de93bd563"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17e36369eb43435874bb774de93bd563">&#9670;&nbsp;</a></span>get_tuple_element() <span class="overload">[7/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Types&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::device_reference&lt;T&gt; hydra::detail::get_tuple_element </td>
          <td>(</td>
          <td class="paramtype">hydra_thrust::detail::tuple_of_iterator_references&lt; hydra_thrust::device_reference&lt; Types &gt;... &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a33e2e586f14706e98c469ea12d0f8119"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33e2e586f14706e98c469ea12d0f8119">&#9670;&nbsp;</a></span>get_tuple_element() <span class="overload">[8/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class... Types&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> const hydra_thrust::device_reference&lt;T&gt; hydra::detail::get_tuple_element </td>
          <td>(</td>
          <td class="paramtype">const hydra_thrust::detail::tuple_of_iterator_references&lt; hydra_thrust::device_reference&lt; Types &gt;... &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afd899f8898ce87464b9003d72ffdedc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd899f8898ce87464b9003d72ffdedc1">&#9670;&nbsp;</a></span>get_tuple_element() <span class="overload">[9/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class... Types&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::device_reference&lt;T&gt; hydra::detail::get_tuple_element </td>
          <td>(</td>
          <td class="paramtype">hydra_thrust::detail::tuple_of_iterator_references&lt; hydra_thrust::device_reference&lt; Types &gt;... &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab6edb844108024e669c32dad4c1246c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6edb844108024e669c32dad4c1246c8">&#9670;&nbsp;</a></span>get_tuple_element() <span class="overload">[10/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int I = 0, typename T , typename ... Tp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::detail::enable_if&lt;I == sizeof...(Tp), void&gt;::type hydra::detail::get_tuple_element </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_3globalScope_4.html#classint">int</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hydra_thrust::tuple&lt; Tp... &gt; const &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a17fb31790c0652edefd8e9438fa69103"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17fb31790c0652edefd8e9438fa69103">&#9670;&nbsp;</a></span>get_tuple_element() <span class="overload">[11/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int I = 0, typename T , typename ... Tp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::detail::enable_if&lt;(I &lt; sizeof...(Tp)), void &gt;::type hydra::detail::get_tuple_element </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_3globalScope_4.html#classint">int</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hydra_thrust::tuple&lt; Tp... &gt; const &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a227e0b524804a0ceef56b4a1da1953d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a227e0b524804a0ceef56b4a1da1953d4">&#9670;&nbsp;</a></span>get_zip_iterator() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator , size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> auto hydra::detail::get_zip_iterator </td>
          <td>(</td>
          <td class="paramtype">std::array&lt; Iterator, N &gt;const &amp;&#160;</td>
          <td class="paramname"><em>array_of_iterators</em></td><td>)</td>
          <td> -&gt; decltype( <a class="el" href="namespacehydra_1_1detail.html#a0e7ac2e75fefa5d9a41daa1d7279c8c5">get_zip_iterator_helper</a>( array_of_iterators , <a class="el" href="structhydra_1_1detail_1_1make__index__sequence.html">make_index_sequence</a>&lt;N&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae9da0535b5305aaf5cfe698c42ebc8d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9da0535b5305aaf5cfe698c42ebc8d6">&#9670;&nbsp;</a></span>get_zip_iterator() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IteratorHead , typename IteratorTail , size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> auto hydra::detail::get_zip_iterator </td>
          <td>(</td>
          <td class="paramtype">IteratorHead&#160;</td>
          <td class="paramname"><em>head</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; IteratorTail, N &gt;const &amp;&#160;</td>
          <td class="paramname"><em>array_of_iterators</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype( <a class="el" href="namespacehydra_1_1detail.html#a0e7ac2e75fefa5d9a41daa1d7279c8c5">get_zip_iterator_helper</a>(head, array_of_iterators , <a class="el" href="structhydra_1_1detail_1_1make__index__sequence.html">make_index_sequence</a>&lt;N&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0e7ac2e75fefa5d9a41daa1d7279c8c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e7ac2e75fefa5d9a41daa1d7279c8c5">&#9670;&nbsp;</a></span>get_zip_iterator_helper() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator , size_t ... Index&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> auto hydra::detail::get_zip_iterator_helper </td>
          <td>(</td>
          <td class="paramtype">std::array&lt; Iterator, sizeof ...(Index)&gt;const &amp;&#160;</td>
          <td class="paramname"><em>array_of_iterators</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1detail_1_1index__sequence.html">index_sequence</a>&lt; Index... &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype( hydra_thrust::make_zip_iterator( hydra_thrust::make_tuple( array_of_iterators[Index]...)) )
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8087253280ceed0580f29a1688f385e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8087253280ceed0580f29a1688f385e9">&#9670;&nbsp;</a></span>get_zip_iterator_helper() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IteratorHead , typename IteratorTail , size_t ... Index&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> auto hydra::detail::get_zip_iterator_helper </td>
          <td>(</td>
          <td class="paramtype">IteratorHead&#160;</td>
          <td class="paramname"><em>head</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; IteratorTail, sizeof ...(Index)&gt;const &amp;&#160;</td>
          <td class="paramname"><em>array_of_iterators</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1detail_1_1index__sequence.html">index_sequence</a>&lt; Index... &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype( hydra_thrust::make_zip_iterator( hydra_thrust::make_tuple(head, array_of_iterators[Index]...)) )
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a618d244958e2ded8465ae85756a011cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a618d244958e2ded8465ae85756a011cd">&#9670;&nbsp;</a></span>hash_combine()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void hydra::detail::hash_combine </td>
          <td>(</td>
          <td class="paramtype">std::size_t &amp;&#160;</td>
          <td class="paramname"><em>seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0be774a301b3817c97d58c61aa08ba85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0be774a301b3817c97d58c61aa08ba85">&#9670;&nbsp;</a></span>hash_range() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class It &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t hydra::detail::hash_range </td>
          <td>(</td>
          <td class="paramtype">It&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">It&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abda9a4b4ec271e3f6c5adf9bc93a3173"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abda9a4b4ec271e3f6c5adf9bc93a3173">&#9670;&nbsp;</a></span>hash_range() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class It &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void hydra::detail::hash_range </td>
          <td>(</td>
          <td class="paramtype">std::size_t &amp;&#160;</td>
          <td class="paramname"><em>seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">It&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">It&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a256df6594bc88c80701d99622515c875"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a256df6594bc88c80701d99622515c875">&#9670;&nbsp;</a></span>hash_tuple() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void hydra::detail::hash_tuple </td>
          <td>(</td>
          <td class="paramtype">std::size_t &amp;&#160;</td>
          <td class="paramname"><em>seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#a717fc4e6b10453164099beade13d0226">hydra::tuple</a>&lt; T... &gt; const &amp;&#160;</td>
          <td class="paramname"><em>_tuple</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a425bb4f65a43d822ba80ebdbca5b8b74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a425bb4f65a43d822ba80ebdbca5b8b74">&#9670;&nbsp;</a></span>hash_tuple() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t hydra::detail::hash_tuple </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#a717fc4e6b10453164099beade13d0226">hydra::tuple</a>&lt; T... &gt; const &amp;&#160;</td>
          <td class="paramname"><em>_tuple</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0b30f3961b7f4ed7c28a4e1373281c1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b30f3961b7f4ed7c28a4e1373281c1c">&#9670;&nbsp;</a></span>invoke() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tup , typename ArgType , size_t N = hydra_thrust::tuple_size&lt;typename hydra_thrust::detail::remove_reference&lt;Tup&gt;::type&gt;::value&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_thrust_exec_check_disable__ <a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> auto hydra::detail::invoke </td>
          <td>(</td>
          <td class="paramtype">ArgType &amp;&amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tup &amp;&amp;&#160;</td>
          <td class="paramname"><em>tup</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(<a class="el" href="namespacehydra_1_1detail.html#a4a70502ee212958c154c2ea97c1047ab">invoke_helper</a>(std::forward&lt;ArgType&gt;(x), std::forward&lt;Tup&gt;(tup), <a class="el" href="structhydra_1_1detail_1_1make__index__sequence.html">make_index_sequence</a>&lt;N&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad31b6d1499b5a6b2d77c015a71385a6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad31b6d1499b5a6b2d77c015a71385a6e">&#9670;&nbsp;</a></span>invoke() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tup , typename ArgType , size_t N = hydra_thrust::tuple_size&lt;typename hydra_thrust::detail::remove_reference&lt;Tup&gt;::type&gt;::value&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_thrust_exec_check_disable__ <a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> auto hydra::detail::invoke </td>
          <td>(</td>
          <td class="paramtype">ArgType const &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tup const &amp;&#160;</td>
          <td class="paramname"><em>tup</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(<a class="el" href="namespacehydra_1_1detail.html#a4a70502ee212958c154c2ea97c1047ab">invoke_helper</a>(x, tup, <a class="el" href="structhydra_1_1detail_1_1make__index__sequence.html">make_index_sequence</a>&lt;N&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3c6414446d272ca304b39b9d9b7b0c35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c6414446d272ca304b39b9d9b7b0c35">&#9670;&nbsp;</a></span>invoke() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tup , typename ArgType1 , typename ArgType2 , size_t N = hydra_thrust::tuple_size&lt;typename hydra_thrust::detail::remove_reference&lt;Tup&gt;::type&gt;::value&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_thrust_exec_check_disable__ <a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> auto hydra::detail::invoke </td>
          <td>(</td>
          <td class="paramtype">ArgType1 &amp;&amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArgType2 &amp;&amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tup &amp;&amp;&#160;</td>
          <td class="paramname"><em>tup</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(<a class="el" href="namespacehydra_1_1detail.html#a4a70502ee212958c154c2ea97c1047ab">invoke_helper</a>( std::forward&lt;ArgType1&gt;(x), std::forward&lt;ArgType2&gt;(y),  std::forward&lt;Tup&gt;(tup), <a class="el" href="structhydra_1_1detail_1_1make__index__sequence.html">make_index_sequence</a>&lt; hydra_thrust::tuple_size&lt;Tup&gt;::value&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af119ddecbbdf7e22bde76370b3b28f0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af119ddecbbdf7e22bde76370b3b28f0c">&#9670;&nbsp;</a></span>invoke() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tup , typename ArgType1 , typename ArgType2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_thrust_exec_check_disable__ <a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> auto hydra::detail::invoke </td>
          <td>(</td>
          <td class="paramtype">ArgType1 const &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArgType2 const &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tup const &amp;&#160;</td>
          <td class="paramname"><em>tup</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(<a class="el" href="namespacehydra_1_1detail.html#a4a70502ee212958c154c2ea97c1047ab">invoke_helper</a>( x, y, tup, <a class="el" href="structhydra_1_1detail_1_1make__index__sequence.html">make_index_sequence</a>&lt; hydra_thrust::tuple_size&lt;Tup&gt;::value&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4a70502ee212958c154c2ea97c1047ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a70502ee212958c154c2ea97c1047ab">&#9670;&nbsp;</a></span>invoke_helper() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tup , typename ArgType , size_t ... index&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_thrust_exec_check_disable__ <a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> auto hydra::detail::invoke_helper </td>
          <td>(</td>
          <td class="paramtype">ArgType &amp;&amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tup &amp;&amp;&#160;</td>
          <td class="paramname"><em>tup</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1detail_1_1index__sequence.html">index_sequence</a>&lt; index... &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(hydra_thrust::make_tuple(hydra_thrust::get&lt;index&gt;(std::forward&lt;Tup&gt;(tup))(std::forward&lt;ArgType&gt;(x))...))
	 </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aeba5bf60f8de619daa3665ab1a5c088d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeba5bf60f8de619daa3665ab1a5c088d">&#9670;&nbsp;</a></span>invoke_helper() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tup , typename ArgType , size_t ... index&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_thrust_exec_check_disable__ <a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> auto hydra::detail::invoke_helper </td>
          <td>(</td>
          <td class="paramtype">ArgType const &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tup const &amp;&#160;</td>
          <td class="paramname"><em>tup</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1detail_1_1index__sequence.html">index_sequence</a>&lt; index... &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(hydra_thrust::make_tuple(hydra_thrust::get&lt;index&gt;(tup)(x)...))
	 </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a90c0d2110813667cce17c16fcf21cdd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90c0d2110813667cce17c16fcf21cdd2">&#9670;&nbsp;</a></span>invoke_helper() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tup , typename ArgType1 , typename ArgType2 , size_t ... index&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_thrust_exec_check_disable__ <a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> auto hydra::detail::invoke_helper </td>
          <td>(</td>
          <td class="paramtype">ArgType1 &amp;&amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArgType2 &amp;&amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tup &amp;&amp;&#160;</td>
          <td class="paramname"><em>tup</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1detail_1_1index__sequence.html">index_sequence</a>&lt; index... &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype( hydra_thrust::make_tuple(hydra_thrust::get&lt;index&gt;( std::forward&lt;Tup&gt;(tup))(std::forward&lt;ArgType1&gt;(x), std::forward&lt;ArgType2&gt;(y))...) )
	 </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa7bfae6e91a367c89f0bd5d905237f16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7bfae6e91a367c89f0bd5d905237f16">&#9670;&nbsp;</a></span>invoke_helper() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tup , typename ArgType1 , typename ArgType2 , size_t ... index&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__hydra_thrust_exec_check_disable__ <a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> auto hydra::detail::invoke_helper </td>
          <td>(</td>
          <td class="paramtype">ArgType1 const &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArgType2 const &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tup const &amp;&#160;</td>
          <td class="paramname"><em>tup</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1detail_1_1index__sequence.html">index_sequence</a>&lt; index... &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype( hydra_thrust::make_tuple(hydra_thrust::get&lt;index&gt;(tup)(x,y)...) )
	 </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9360a30d9cffc4d39b34187a56f0bb92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9360a30d9cffc4d39b34187a56f0bb92">&#9670;&nbsp;</a></span>invoke_helper() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="basic__distributions_8inl.html#a9717e7bbecb906637e86cef6da3d83c2">return</a> hydra::detail::invoke_helper </td>
          <td>(</td>
          <td class="paramtype">x&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">y&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tup&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1detail_1_1make__index__sequence.html">make_index_sequence</a>&lt; Size &gt; { }&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af991f6032453407f65f584508d2f776d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af991f6032453407f65f584508d2f776d">&#9670;&nbsp;</a></span>invoke_normalized() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tup , typename ArgType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> auto hydra::detail::invoke_normalized </td>
          <td>(</td>
          <td class="paramtype">ArgType const &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tup const &amp;&#160;</td>
          <td class="paramname"><em>tup</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(<a class="el" href="namespacehydra_1_1detail.html#a4a70502ee212958c154c2ea97c1047ab">invoke_helper</a>(x, tup, <a class="el" href="structhydra_1_1detail_1_1make__index__sequence.html">make_index_sequence</a>&lt; hydra_thrust::tuple_size&lt;Tup&gt;::value&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af4c0051b20d34181994aa5560387054e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4c0051b20d34181994aa5560387054e">&#9670;&nbsp;</a></span>invoke_normalized() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tup , typename ArgType , size_t N = hydra_thrust::tuple_size&lt;typename hydra_thrust::detail::remove_reference&lt;Tup&gt;::type&gt;::value&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> auto hydra::detail::invoke_normalized </td>
          <td>(</td>
          <td class="paramtype">ArgType &amp;&amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tup &amp;&amp;&#160;</td>
          <td class="paramname"><em>tup</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(<a class="el" href="namespacehydra_1_1detail.html#a4a70502ee212958c154c2ea97c1047ab">invoke_helper</a>(std::forward&lt;ArgType&gt;(x), std::forward&lt;Tup&gt;(tup), <a class="el" href="structhydra_1_1detail_1_1make__index__sequence.html">make_index_sequence</a>&lt;N&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a51dc6ae31393a420f089ca8fd1207c23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51dc6ae31393a420f089ca8fd1207c23">&#9670;&nbsp;</a></span>invoke_normalized_helper() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tup , typename ArgType , size_t ... index&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> auto hydra::detail::invoke_normalized_helper </td>
          <td>(</td>
          <td class="paramtype">ArgType const &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tup const &amp;&#160;</td>
          <td class="paramname"><em>tup</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1detail_1_1index__sequence.html">index_sequence</a>&lt; index... &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(hydra_thrust::make_tuple(hydra_thrust::get&lt;index&gt;(tup)(x)...))
	 </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a173eb394103a0e94fbf9abbc1918a894"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a173eb394103a0e94fbf9abbc1918a894">&#9670;&nbsp;</a></span>invoke_normalized_helper() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="basic__distributions_8inl.html#a9717e7bbecb906637e86cef6da3d83c2">return</a> hydra::detail::invoke_normalized_helper </td>
          <td>(</td>
          <td class="paramtype">x&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tup&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1detail_1_1make__index__sequence.html">make_index_sequence</a>&lt; Size &gt; { }&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a021aed8e1205f3ff6aef35d02065c612"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a021aed8e1205f3ff6aef35d02065c612">&#9670;&nbsp;</a></span>invoke_normalized_helper() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tup , typename ArgType , size_t ... index&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> auto hydra::detail::invoke_normalized_helper </td>
          <td>(</td>
          <td class="paramtype">ArgType &amp;&amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tup &amp;&amp;&#160;</td>
          <td class="paramname"><em>tup</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1detail_1_1index__sequence.html">index_sequence</a>&lt; index... &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(hydra_thrust::make_tuple(hydra_thrust::get&lt;index&gt;(std::forward&lt;Tup&gt;(tup))(std::forward&lt;ArgType&gt;(x))...))
	 </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aad9d0de301331608aa91ce3589f9c5c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad9d0de301331608aa91ce3589f9c5c1">&#9670;&nbsp;</a></span>iter_swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Iterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> void hydra::detail::iter_swap </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>second</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad0a8ff71493e18493d9df6b9cfa1a745"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0a8ff71493e18493d9df6b9cfa1a745">&#9670;&nbsp;</a></span>kill()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename ... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> T hydra::detail::kill </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab5050bf77c477bccc5db77c507cca743"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5050bf77c477bccc5db77c507cca743">&#9670;&nbsp;</a></span>launch_decayer() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t N, typename GRND , typename Iterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void hydra::detail::launch_decayer </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1detail_1_1DecayMother.html">DecayMother</a>&lt; N, GRND &gt; const &amp;&#160;</td>
          <td class="paramname"><em>decayer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4695a02794382f4f997052b425413987"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4695a02794382f4f997052b425413987">&#9670;&nbsp;</a></span>launch_decayer() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t N, typename GRND , typename Iterator , hydra::detail::Backend BACKEND&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void hydra::detail::launch_decayer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; const &amp;&#160;</td>
          <td class="paramname"><em>exec_policy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1detail_1_1DecayMother.html">DecayMother</a>&lt; N, GRND &gt; const &amp;&#160;</td>
          <td class="paramname"><em>decayer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9a35cdb4fa592a33bba8d836aed248df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a35cdb4fa592a33bba8d836aed248df">&#9670;&nbsp;</a></span>launch_decayer() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t N, typename GRND , typename IteratorMother , typename IteratorDaughter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void hydra::detail::launch_decayer </td>
          <td>(</td>
          <td class="paramtype">IteratorMother&#160;</td>
          <td class="paramname"><em>begin_mothers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorMother&#160;</td>
          <td class="paramname"><em>end_mothers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorDaughter&#160;</td>
          <td class="paramname"><em>begin_daugters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1detail_1_1DecayMothers.html">DecayMothers</a>&lt; N, GRND &gt; const &amp;&#160;</td>
          <td class="paramname"><em>decayer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3482cd2a135b31d8bb68fcd11dcdac8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3482cd2a135b31d8bb68fcd11dcdac8d">&#9670;&nbsp;</a></span>launch_decayer() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t N, typename GRND , typename IteratorMother , typename IteratorDaughter , hydra::detail::Backend BACKEND&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void hydra::detail::launch_decayer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; const &amp;&#160;</td>
          <td class="paramname"><em>exec_policy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorMother&#160;</td>
          <td class="paramname"><em>begin_mothers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorMother&#160;</td>
          <td class="paramname"><em>end_mothers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorDaughter&#160;</td>
          <td class="paramname"><em>begin_daugters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1detail_1_1DecayMothers.html">DecayMothers</a>&lt; N, GRND &gt; const &amp;&#160;</td>
          <td class="paramname"><em>decayer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9a2cc34389ca89449738a46e209133a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a2cc34389ca89449738a46e209133a8">&#9670;&nbsp;</a></span>launch_evaluator() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t N, typename FUNCTOR , typename ... FUNCTORS, typename GRND , typename Iterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void hydra::detail::launch_evaluator </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1detail_1_1EvalMother.html">detail::EvalMother</a>&lt; N, GRND, FUNCTOR, FUNCTORS... &gt; const &amp;&#160;</td>
          <td class="paramname"><em>evaluator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a272aed700c4b40bbd2639a84507da00d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a272aed700c4b40bbd2639a84507da00d">&#9670;&nbsp;</a></span>launch_evaluator() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t N, typename FUNCTOR , typename ... FUNCTORS, typename GRND , typename IteratorMother , typename Iterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void hydra::detail::launch_evaluator </td>
          <td>(</td>
          <td class="paramtype">IteratorMother&#160;</td>
          <td class="paramname"><em>mbegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorMother&#160;</td>
          <td class="paramname"><em>mend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1detail_1_1EvalMothers.html">detail::EvalMothers</a>&lt; N, GRND, FUNCTOR, FUNCTORS... &gt; const &amp;&#160;</td>
          <td class="paramname"><em>evaluator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8dce458532ae6b3d821a91604dad7895"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dce458532ae6b3d821a91604dad7895">&#9670;&nbsp;</a></span>launch_reducer() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t N, hydra::detail::Backend BACKEND, typename FUNCTOR , typename GRND , typename Iterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhydra_1_1detail_1_1StatsPHSP.html">StatsPHSP</a> hydra::detail::launch_reducer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt;const &amp;&#160;</td>
          <td class="paramname"><em>policy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1detail_1_1AverageMother.html">detail::AverageMother</a>&lt; N, GRND, FUNCTOR &gt; const &amp;&#160;</td>
          <td class="paramname"><em>evaluator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa8b536e68d5a5831e546272b56c031ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8b536e68d5a5831e546272b56c031ee">&#9670;&nbsp;</a></span>launch_reducer() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t N, typename FUNCTOR , typename GRND , typename Iterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhydra_1_1detail_1_1StatsPHSP.html">StatsPHSP</a> hydra::detail::launch_reducer </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1detail_1_1AverageMothers.html">detail::AverageMothers</a>&lt; N, GRND, FUNCTOR &gt; const &amp;&#160;</td>
          <td class="paramname"><em>evaluator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a024a15ab3a2da15dc78f090437220dde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a024a15ab3a2da15dc78f090437220dde">&#9670;&nbsp;</a></span>lsb() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Integer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> std::enable_if&lt; std::is_integral&lt;Integer&gt;::value &amp;&amp; !(std::is_signed&lt;Integer&gt;::value) &amp;&amp; (sizeof(Integer)==8) , <a class="el" href="namespace_3globalScope_4.html#classunsigned">unsigned</a>&gt;::type hydra::detail::lsb </td>
          <td>(</td>
          <td class="paramtype">Integer&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af5ba85f2308d53e41bfbd714a2850b3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5ba85f2308d53e41bfbd714a2850b3e">&#9670;&nbsp;</a></span>lsb() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Integer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> std::enable_if&lt; std::is_integral&lt;Integer&gt;::value &amp;&amp; !(std::is_signed&lt;Integer&gt;::value) &amp;&amp; (sizeof(Integer)==4) , <a class="el" href="namespace_3globalScope_4.html#classunsigned">unsigned</a>&gt;::type hydra::detail::lsb </td>
          <td>(</td>
          <td class="paramtype">Integer&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afef4bbc17cf6421b0da41b1872dc7781"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afef4bbc17cf6421b0da41b1872dc7781">&#9670;&nbsp;</a></span>machine_eps_f32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> float hydra::detail::machine_eps_f32 </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>value</em> = <code>1.0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af60fc3e60cc10bd79092ca02c8e8b84c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af60fc3e60cc10bd79092ca02c8e8b84c">&#9670;&nbsp;</a></span>machine_eps_f64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> hydra::detail::machine_eps_f64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td>
          <td class="paramname"><em>value</em> = <code>1.0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a806bd1d429f6b821efb5af237fecaa2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a806bd1d429f6b821efb5af237fecaa2f">&#9670;&nbsp;</a></span>make_rtuple()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::detail::make_rtuple </td>
          <td>(</td>
          <td class="paramtype">hydra_thrust::tuple&lt; T... &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td> -&gt; hydra_thrust::tuple&lt;T&amp;...&gt;
	</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abea7b63acf2a24346dd220c91059e1da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abea7b63acf2a24346dd220c91059e1da">&#9670;&nbsp;</a></span>make_rtuple_helper()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, size_t... I&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::detail::make_rtuple_helper </td>
          <td>(</td>
          <td class="paramtype">hydra_thrust::tuple&lt; T... &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1detail_1_1index__sequence.html">index_sequence</a>&lt; I... &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; hydra_thrust::tuple&lt;T&amp;...&gt;
	</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac16e513053ac8d97923ac166db8e6a98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac16e513053ac8d97923ac166db8e6a98">&#9670;&nbsp;</a></span>make_tuple()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">T ::type TupleType hydra::detail::make_tuple </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8df2eb3ba9481fec054318974964ec3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8df2eb3ba9481fec054318974964ec3d">&#9670;&nbsp;</a></span>max()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> size_t hydra::detail::max </td>
          <td>(</td>
          <td class="paramtype">hydra_thrust::tuple&lt; T... &gt; const &amp;&#160;</td>
          <td class="paramname"><em>tuple</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa4140580867ee73e401e1bb1e213548c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4140580867ee73e401e1bb1e213548c">&#9670;&nbsp;</a></span>max_helper()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename C , size_t N, size_t I&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> std::enable_if&lt; I==N,void&gt;::type hydra::detail::max_helper </td>
          <td>(</td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="basic__distributions_8inl.html#a4900ef306eb9271438791f1a98b8ccba">C</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad23b453b58064598dbd7596ffca55422"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad23b453b58064598dbd7596ffca55422">&#9670;&nbsp;</a></span>max_helper&lt; T, C, N, I+1 &gt;()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacehydra_1_1detail.html#aa4140580867ee73e401e1bb1e213548c">hydra::detail::max_helper</a>&lt; T, <a class="el" href="basic__distributions_8inl.html#a4900ef306eb9271438791f1a98b8ccba">C</a>, N, I+1 &gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#a717fc4e6b10453164099beade13d0226">tuple</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehydra_1_1detail.html#a6272aac6b63b0ff4f44d2ff9b24716cf">max_value</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">max_index&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac36de892880609f667e4d5cc9718a5e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac36de892880609f667e4d5cc9718a5e1">&#9670;&nbsp;</a></span>meld_iterators()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... Iterators&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::detail::meld_iterators </td>
          <td>(</td>
          <td class="paramtype">Iterators &amp;&amp;...&#160;</td>
          <td class="paramname"><em>iterators</em></td><td>)</td>
          <td> -&gt; decltype( hydra_thrust::make_zip_iterator(
		hydra_thrust::tuple_cat( <a class="el" href="namespacehydra_1_1detail_1_1meld__iterators__ns.html#a6256486a1fd69c4d2df51f9fff3ef3d5">meld_iterators_ns::convert_to_tuple</a>(std::forward&lt;Iterators&gt;(iterators))... )  ))
</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2273abcb7a8775a09d2d6d7aff1d59ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2273abcb7a8775a09d2d6d7aff1d59ee">&#9670;&nbsp;</a></span>msb() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Integer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> std::enable_if&lt; std::is_integral&lt;Integer&gt;::value &amp;&amp; !(std::is_signed&lt;Integer&gt;::value) &amp;&amp; (std::numeric_limits&lt;Integer&gt;::digits==64) , <a class="el" href="namespace_3globalScope_4.html#classunsigned">unsigned</a>&gt;::type hydra::detail::msb </td>
          <td>(</td>
          <td class="paramtype">Integer const &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a476a6db58de25883f66604846f28cc7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a476a6db58de25883f66604846f28cc7f">&#9670;&nbsp;</a></span>msb() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Integer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> std::enable_if&lt; std::is_integral&lt;Integer&gt;::value &amp;&amp; !(std::is_signed&lt;Integer&gt;::value) &amp;&amp; (std::numeric_limits&lt;Integer&gt;::digits&lt;=32) , <a class="el" href="namespace_3globalScope_4.html#classunsigned">unsigned</a>&gt;::type hydra::detail::msb </td>
          <td>(</td>
          <td class="paramtype">Integer const &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad2b12c58b82f3d39caa4dffc5ce0faf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2b12c58b82f3d39caa4dffc5ce0faf9">&#9670;&nbsp;</a></span>multiply() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t N, size_t I&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; (I==N), void &gt;::type hydra::detail::multiply </td>
          <td>(</td>
          <td class="paramtype">std::array&lt; T, N &gt; const &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a52459ef87933d78d5ce88feb998bd8bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52459ef87933d78d5ce88feb998bd8bd">&#9670;&nbsp;</a></span>multiply() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t N, size_t I = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; (I&lt;N), void &gt;::type hydra::detail::multiply </td>
          <td>(</td>
          <td class="paramtype">std::array&lt; T, N &gt; const &amp;&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af73aa95bb4dce5810569f682bb39de27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af73aa95bb4dce5810569f682bb39de27">&#9670;&nbsp;</a></span>multiply() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t N, size_t I&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; (I==N), void &gt;::type hydra::detail::multiply </td>
          <td>(</td>
          <td class="paramtype">const &#160;</td>
          <td class="paramname"><em>T</em>(&amp;)[N], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4f767f0131f9a4910ece6f10d1b5a0f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f767f0131f9a4910ece6f10d1b5a0f2">&#9670;&nbsp;</a></span>multiply() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t N, size_t I = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; (I&lt;N), void &gt;::type hydra::detail::multiply </td>
          <td>(</td>
          <td class="paramtype">const T(&amp;)&#160;</td>
          <td class="paramname"><em>obj</em>[N], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab992b62c0923bb8bd2bfd3a1fcc1a706"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab992b62c0923bb8bd2bfd3a1fcc1a706">&#9670;&nbsp;</a></span>multiply_array_tuple()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> auto hydra::detail::multiply_array_tuple </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>(&amp;)&#160;</td>
          <td class="paramname"><em>fCoeficients</em>[sizeof...(T)], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hydra_thrust::tuple&lt; T... &gt; const &amp;&#160;</td>
          <td class="paramname"><em>tpl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype( <a class="el" href="namespacehydra_1_1detail.html#a643a9cfc48d39212a6856ce4a6458280">multiply_array_tuple_helper</a>(fCoeficients,tpl,<a class="el" href="structhydra_1_1detail_1_1make__index__sequence.html">make_index_sequence</a>&lt;sizeof...(T)&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a643a9cfc48d39212a6856ce4a6458280"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a643a9cfc48d39212a6856ce4a6458280">&#9670;&nbsp;</a></span>multiply_array_tuple_helper()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tuple , size_t ... I&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1tuple__type">tuple_type</a>&lt;sizeof...(I), <a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>&gt;::type hydra::detail::multiply_array_tuple_helper </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>(&amp;)&#160;</td>
          <td class="paramname"><em>fCoeficients</em>[sizeof...(I)], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tuple const &amp;&#160;</td>
          <td class="paramname"><em>tpl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1detail_1_1index__sequence.html">index_sequence</a>&lt; I... &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a66bc1bf60cfc95e34f2ede6986e9af98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66bc1bf60cfc95e34f2ede6986e9af98">&#9670;&nbsp;</a></span>multiply_tuple() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I = 0, typename Return_Type , typename ... Tp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::detail::enable_if&lt;I == sizeof...(Tp), void&gt;::type hydra::detail::multiply_tuple </td>
          <td>(</td>
          <td class="paramtype">Return_Type &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hydra_thrust::tuple&lt; Tp... &gt; const &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac33cb24201ebd425c3b2f4c91465aea6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac33cb24201ebd425c3b2f4c91465aea6">&#9670;&nbsp;</a></span>multiply_tuple() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I = 0, typename Return_Type , typename ... Tp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::detail::enable_if&lt;(I &lt; sizeof...(Tp)),void &gt;::type hydra::detail::multiply_tuple </td>
          <td>(</td>
          <td class="paramtype">Return_Type &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hydra_thrust::tuple&lt; Tp... &gt;const &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aad363c957681f91b698ac9f5212be47d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad363c957681f91b698ac9f5212be47d">&#9670;&nbsp;</a></span>multiply_tuple() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I = 0, typename Return_Type , typename ... Tp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::detail::enable_if&lt;I == sizeof...(Tp), void&gt;::type hydra::detail::multiply_tuple </td>
          <td>(</td>
          <td class="paramtype">Return_Type &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hydra_thrust::tuple&lt; Tp... &gt; &amp;&amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4b8b89a3ba444d2c8ef1a6ed26985e6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b8b89a3ba444d2c8ef1a6ed26985e6d">&#9670;&nbsp;</a></span>multiply_tuple() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I = 0, typename Return_Type , typename ... Tp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::detail::enable_if&lt;(I &lt; sizeof...(Tp)),void &gt;::type hydra::detail::multiply_tuple </td>
          <td>(</td>
          <td class="paramtype">Return_Type &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hydra_thrust::tuple&lt; Tp... &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a833faa576c3be31e8c4ad34938b4b948"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a833faa576c3be31e8c4ad34938b4b948">&#9670;&nbsp;</a></span>multiplyTuples() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, size_t ... I&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::tuple&lt;T...&gt; hydra::detail::multiplyTuples </td>
          <td>(</td>
          <td class="paramtype">const hydra_thrust::tuple&lt; T... &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const hydra_thrust::tuple&lt; T... &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1detail_1_1index__sequence.html">index_sequence</a>&lt; I... &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1b3cb8ce552d976fe50342f85d9b5b8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b3cb8ce552d976fe50342f85d9b5b8d">&#9670;&nbsp;</a></span>multiplyTuples() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::tuple&lt;T...&gt; hydra::detail::multiplyTuples </td>
          <td>(</td>
          <td class="paramtype">const hydra_thrust::tuple&lt; T... &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const hydra_thrust::tuple&lt; T... &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af5786376f2b71be2e554ba1053899bd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5786376f2b71be2e554ba1053899bd9">&#9670;&nbsp;</a></span>multiplyTuplesHelper()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I, typename ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::tuple_element&lt;I, hydra_thrust::tuple&lt;T...&gt; &gt;::type hydra::detail::multiplyTuplesHelper </td>
          <td>(</td>
          <td class="paramtype">const hydra_thrust::tuple&lt; T... &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const hydra_thrust::tuple&lt; T... &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a63701869476f9138ea31be4ef303e7c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63701869476f9138ea31be4ef303e7c1">&#9670;&nbsp;</a></span>next_permutation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BidirIt &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> bool hydra::detail::next_permutation </td>
          <td>(</td>
          <td class="paramtype">BidirIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BidirIt&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0b2e7c87a80dcd5015c2a95ca88f67f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b2e7c87a80dcd5015c2a95ca88f67f1">&#9670;&nbsp;</a></span>nth_permutation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator , typename Integer , typename Comparator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_integral&lt; Integer &gt;::value, void &gt;::type <a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::detail::nth_permutation </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Integer&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Comparator&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6e34df05c3fc32da9e8fe01dddc9fd7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e34df05c3fc32da9e8fe01dddc9fd7e">&#9670;&nbsp;</a></span>operator+() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="classhydra_1_1detail_1_1GenzMalikBoxResult.html">GenzMalikBoxResult</a>&lt;Type&gt; hydra::detail::operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhydra_1_1detail_1_1GenzMalikBoxResult.html">GenzMalikBoxResult</a>&lt; Type &gt;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhydra_1_1detail_1_1GenzMalikBoxResult.html">GenzMalikBoxResult</a>&lt; Type &gt; const &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a25dfa2f5f8cfb6485dba5d2a4611b217"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25dfa2f5f8cfb6485dba5d2a4611b217">&#9670;&nbsp;</a></span>operator+() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="classhydra_1_1detail_1_1GenzMalikBoxResult.html">GenzMalikBoxResult</a>&lt;Type&gt; hydra::detail::operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhydra_1_1detail_1_1GenzMalikBoxResult.html">GenzMalikBoxResult</a>&lt; Type &gt;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhydra_1_1detail_1_1GenzMalikBox.html">GenzMalikBox</a>&lt; N &gt; const &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1c794172447148190ddb210dd1db8a83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c794172447148190ddb210dd1db8a83">&#9670;&nbsp;</a></span>pow_helper() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , unsigned int N, unsigned int I&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> std::enable_if&lt;I==N, void &gt;::type hydra::detail::pow_helper </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>const</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8f6c0d8fba43367d54ac4e2ce70f8718"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f6c0d8fba43367d54ac4e2ce70f8718">&#9670;&nbsp;</a></span>pow_helper() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , unsigned int N, unsigned int I&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> std::enable_if&lt; (I&lt; N), void &gt;::type hydra::detail::pow_helper </td>
          <td>(</td>
          <td class="paramtype">T const&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a28280805ea788b6b7ab8eee526b71acc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28280805ea788b6b7ab8eee526b71acc">&#9670;&nbsp;</a></span>print_parameters_in_tuple() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I = 0, typename ... Tp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">hydra_thrust::detail::enable_if&lt;I == sizeof...(Tp), void&gt;::type hydra::detail::print_parameters_in_tuple </td>
          <td>(</td>
          <td class="paramtype">hydra_thrust::tuple&lt; Tp... &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a91dd9d1ed9eeac4af4b479d3931b4b3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91dd9d1ed9eeac4af4b479d3931b4b3f">&#9670;&nbsp;</a></span>print_parameters_in_tuple() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I = 0, typename ... Tp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">hydra_thrust::detail::enable_if&lt;(I &lt; sizeof...(Tp)),void &gt;::type hydra::detail::print_parameters_in_tuple </td>
          <td>(</td>
          <td class="paramtype">hydra_thrust::tuple&lt; Tp... &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac25504370e97f8483f51b7747a5d062f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac25504370e97f8483f51b7747a5d062f">&#9670;&nbsp;</a></span>product() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Return_Type , typename ArgType , typename ... Tp, typename  = typename hydra_thrust::detail::enable_if&lt;std::is_convertible&lt;Return_Type, double&gt;::value || std::is_constructible&lt;hydra_thrust::complex&lt;double&gt;,Return_Type&gt;::value &gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> Return_Type hydra::detail::product </td>
          <td>(</td>
          <td class="paramtype">ArgType const &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hydra_thrust::tuple&lt; Tp... &gt; const &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4f27e0f9d5a5aeb14274d1775739d650"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f27e0f9d5a5aeb14274d1775739d650">&#9670;&nbsp;</a></span>product() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Return_Type , typename ArgType , typename ... Tp, typename  = typename hydra_thrust::detail::enable_if&lt;std::is_convertible&lt;Return_Type, double&gt;::value || std::is_constructible&lt;hydra_thrust::complex&lt;double&gt;,Return_Type&gt;::value &gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> Return_Type hydra::detail::product </td>
          <td>(</td>
          <td class="paramtype">ArgType &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hydra_thrust::tuple&lt; Tp... &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ade2c50d420b21392eae2bf88ef2f1408"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade2c50d420b21392eae2bf88ef2f1408">&#9670;&nbsp;</a></span>product2() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Return_Type , typename ArgType1 , typename ArgType2 , typename ... Tp, typename  = typename hydra_thrust::detail::enable_if&lt;std::is_convertible&lt;Return_Type, double&gt;::value || std::is_constructible&lt;hydra_thrust::complex&lt;double&gt;,Return_Type&gt;::value &gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> Return_Type hydra::detail::product2 </td>
          <td>(</td>
          <td class="paramtype">ArgType1 const &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArgType2 const &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hydra_thrust::tuple&lt; Tp... &gt; const &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a636ac81a76f60f852397b20aa6a5778e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a636ac81a76f60f852397b20aa6a5778e">&#9670;&nbsp;</a></span>product2() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Return_Type , typename ArgType1 , typename ArgType2 , typename ... Tp, typename  = typename hydra_thrust::detail::enable_if&lt;std::is_convertible&lt;Return_Type, double&gt;::value || std::is_constructible&lt;hydra_thrust::complex&lt;double&gt;,Return_Type&gt;::value &gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> Return_Type hydra::detail::product2 </td>
          <td>(</td>
          <td class="paramtype">ArgType1 &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArgType2 &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hydra_thrust::tuple&lt; Tp... &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a01ce8205f2812d6bc1a8395898455bc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01ce8205f2812d6bc1a8395898455bc6">&#9670;&nbsp;</a></span>product_tuple() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I = 0, typename Return_Type , typename ArgType , typename ... Tp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::detail::enable_if&lt;I == sizeof...(Tp), void&gt;::type hydra::detail::product_tuple </td>
          <td>(</td>
          <td class="paramtype">Return_Type &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hydra_thrust::tuple&lt; Tp... &gt; const &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArgType const &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a50192c52e8c65a9e261d18f8d7e260ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50192c52e8c65a9e261d18f8d7e260ed">&#9670;&nbsp;</a></span>product_tuple() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I = 0, typename Return_Type , typename ArgType , typename ... Tp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::detail::enable_if&lt;(I &lt; sizeof...(Tp)),void &gt;::type hydra::detail::product_tuple </td>
          <td>(</td>
          <td class="paramtype">Return_Type &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hydra_thrust::tuple&lt; Tp... &gt; const &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArgType const &amp;&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3fd41b1a175a03273fcc747bf16fa147"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fd41b1a175a03273fcc747bf16fa147">&#9670;&nbsp;</a></span>product_tuple() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I = 0, typename Return_Type , typename ArgType , typename ... Tp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::detail::enable_if&lt;I == sizeof...(Tp), void&gt;::type hydra::detail::product_tuple </td>
          <td>(</td>
          <td class="paramtype">Return_Type &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hydra_thrust::tuple&lt; Tp... &gt; &amp;&amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArgType &amp;&amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a27b437c78f61e1df0c91737e8f7cd8a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27b437c78f61e1df0c91737e8f7cd8a8">&#9670;&nbsp;</a></span>product_tuple() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I = 0, typename Return_Type , typename ArgType , typename ... Tp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::detail::enable_if&lt;(I &lt; sizeof...(Tp)),void &gt;::type hydra::detail::product_tuple </td>
          <td>(</td>
          <td class="paramtype">Return_Type &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hydra_thrust::tuple&lt; Tp... &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArgType &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abb6c1af7e7483fbc3b22c7ef63788ce7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb6c1af7e7483fbc3b22c7ef63788ce7">&#9670;&nbsp;</a></span>product_tuple2() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I = 0, typename Return_Type , typename ArgType1 , typename ArgType2 , typename ... Tp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::detail::enable_if&lt;I == sizeof...(Tp), void&gt;::type hydra::detail::product_tuple2 </td>
          <td>(</td>
          <td class="paramtype">Return_Type &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hydra_thrust::tuple&lt; Tp... &gt; const &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArgType1 const &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArgType2 const &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4517a255a100f22b0f3f962a139426db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4517a255a100f22b0f3f962a139426db">&#9670;&nbsp;</a></span>product_tuple2() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I = 0, typename Return_Type , typename ArgType1 , typename ArgType2 , typename ... Tp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::detail::enable_if&lt;(I &lt; (sizeof...(Tp))),void &gt;::type hydra::detail::product_tuple2 </td>
          <td>(</td>
          <td class="paramtype">Return_Type &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hydra_thrust::tuple&lt; Tp... &gt; const &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArgType1 const &amp;&#160;</td>
          <td class="paramname"><em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArgType2 const &amp;&#160;</td>
          <td class="paramname"><em>arg2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0d1f75d3a1f29b97e2470519273a8819"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d1f75d3a1f29b97e2470519273a8819">&#9670;&nbsp;</a></span>product_tuple2() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I = 0, typename Return_Type , typename ArgType1 , typename ArgType2 , typename ... Tp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::detail::enable_if&lt;I == sizeof...(Tp), void&gt;::type hydra::detail::product_tuple2 </td>
          <td>(</td>
          <td class="paramtype">Return_Type &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hydra_thrust::tuple&lt; Tp... &gt; &amp;&amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArgType1 &amp;&amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArgType2 &amp;&amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0d5b5bfede3e07f333b44254f6904008"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d5b5bfede3e07f333b44254f6904008">&#9670;&nbsp;</a></span>product_tuple2() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I = 0, typename Return_Type , typename ArgType1 , typename ArgType2 , typename ... Tp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::detail::enable_if&lt;(I &lt; (sizeof...(Tp))),void &gt;::type hydra::detail::product_tuple2 </td>
          <td>(</td>
          <td class="paramtype">Return_Type &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hydra_thrust::tuple&lt; Tp... &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArgType1 &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArgType2 &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a18996edf882db2f33372691af9cc79d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18996edf882db2f33372691af9cc79d8">&#9670;&nbsp;</a></span>product_tuple3() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I = 0, size_t N, typename Return_Type , typename ArgType1 , typename ArgType2 , typename ... Tp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::detail::enable_if&lt;I == N, void&gt;::type hydra::detail::product_tuple3 </td>
          <td>(</td>
          <td class="paramtype">Return_Type &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hydra_thrust::tuple&lt; Tp... &gt; const &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArgType1 const &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArgType2 const &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afcfce57c36263805be3cd8cc9d754498"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcfce57c36263805be3cd8cc9d754498">&#9670;&nbsp;</a></span>product_tuple3() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I = 0, size_t N, typename Return_Type , typename ArgType1 , typename ArgType2 , typename ... Tp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::detail::enable_if&lt;(I &lt; N),void &gt;::type hydra::detail::product_tuple3 </td>
          <td>(</td>
          <td class="paramtype">Return_Type &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hydra_thrust::tuple&lt; Tp... &gt; const &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArgType1 const &amp;&#160;</td>
          <td class="paramname"><em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArgType2 const &amp;&#160;</td>
          <td class="paramname"><em>arg2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a14d9160e903a022678a19946e1082fd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14d9160e903a022678a19946e1082fd3">&#9670;&nbsp;</a></span>product_tuple3() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I = 0, size_t N, typename Return_Type , typename ArgType1 , typename ArgType2 , typename ... Tp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::detail::enable_if&lt;I == N, void&gt;::type hydra::detail::product_tuple3 </td>
          <td>(</td>
          <td class="paramtype">Return_Type &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hydra_thrust::tuple&lt; Tp... &gt; &amp;&amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArgType1 &amp;&amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArgType2 &amp;&amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a60f6104f2782abaedc08764af74a2513"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60f6104f2782abaedc08764af74a2513">&#9670;&nbsp;</a></span>product_tuple3() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I = 0, size_t N, typename Return_Type , typename ArgType1 , typename ArgType2 , typename ... Tp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::detail::enable_if&lt;(I &lt; N),void &gt;::type hydra::detail::product_tuple3 </td>
          <td>(</td>
          <td class="paramtype">Return_Type &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hydra_thrust::tuple&lt; Tp... &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArgType1 &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArgType2 &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae12a77e6ee2553c9b830aeaa6e7e75e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae12a77e6ee2553c9b830aeaa6e7e75e4">&#9670;&nbsp;</a></span>ptr_setter() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void hydra::detail::ptr_setter </td>
          <td>(</td>
          <td class="paramtype">T1 *&amp;&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename hydra_thrust::detail::enable_if&lt; hydra_thrust::detail::is_same&lt; T1, T2 &gt;::value, T2 &gt;::type *&#160;</td>
          <td class="paramname"><em>el</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af0c43562d26a5efbbee3de11d58fb6a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0c43562d26a5efbbee3de11d58fb6a0">&#9670;&nbsp;</a></span>ptr_setter() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void hydra::detail::ptr_setter </td>
          <td>(</td>
          <td class="paramtype">T1 *&amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename hydra_thrust::detail::enable_if&lt;!hydra_thrust::detail::is_same&lt; T1, T2 &gt;::value, T2 &gt;::type *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab46acd298d2f60edf21c334fa8823d65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab46acd298d2f60edf21c334fa8823d65">&#9670;&nbsp;</a></span>rotate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Iterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> Iterator hydra::detail::rotate </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>n_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a02aa7a21cd5aca1e6cba7419e0009a9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02aa7a21cd5aca1e6cba7419e0009a9f">&#9670;&nbsp;</a></span>SafeGreaterThan()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> bool hydra::detail::SafeGreaterThan </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code><a class="el" href="namespacehydra_1_1detail.html#af60fc3e60cc10bd79092ca02c8e8b84c">machine_eps_f64</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8b57eb5fbdba90142d2127ab29514de7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b57eb5fbdba90142d2127ab29514de7">&#9670;&nbsp;</a></span>SafeLessThan()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> bool hydra::detail::SafeLessThan </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code><a class="el" href="namespacehydra_1_1detail.html#af60fc3e60cc10bd79092ca02c8e8b84c">machine_eps_f64</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a93a05294ac78115df3bf8b54fff5174d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93a05294ac78115df3bf8b54fff5174d">&#9670;&nbsp;</a></span>set_functors_in_tuple() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I = 0, typename ... Tp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">hydra_thrust::detail::enable_if&lt;I == sizeof...(Tp), void&gt;::type hydra::detail::set_functors_in_tuple </td>
          <td>(</td>
          <td class="paramtype">hydra_thrust::tuple&lt; Tp... &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0efde42488d09f938938e26557b53c05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0efde42488d09f938938e26557b53c05">&#9670;&nbsp;</a></span>set_functors_in_tuple() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I = 0, typename ... Tp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">hydra_thrust::detail::enable_if&lt;(I &lt; sizeof...(Tp)),void &gt;::type hydra::detail::set_functors_in_tuple </td>
          <td>(</td>
          <td class="paramtype">hydra_thrust::tuple&lt; Tp... &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>parameters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa78862e977fa8cce9259242deb36570b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa78862e977fa8cce9259242deb36570b">&#9670;&nbsp;</a></span>set_ptr_to_tuple_element() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int I, typename Ptr , typename ... Tp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">hydra_thrust::detail::enable_if&lt;I == sizeof...(Tp), void&gt;::type hydra::detail::set_ptr_to_tuple_element </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_3globalScope_4.html#classint">int</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::tuple&lt; Tp... &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ptr *&amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad8e4701c4056cff52653b75e79b6c1b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8e4701c4056cff52653b75e79b6c1b1">&#9670;&nbsp;</a></span>set_ptr_to_tuple_element() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int I = 0, typename Ptr , typename ... Tp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">hydra_thrust::detail::enable_if&lt;(I &lt; sizeof...(Tp)), void &gt;::type hydra::detail::set_ptr_to_tuple_element </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_3globalScope_4.html#classint">int</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::tuple&lt; Tp... &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ptr *&amp;&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1fbd7741e643726fd8ee8295b234586e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fbd7741e643726fd8ee8295b234586e">&#9670;&nbsp;</a></span>set_ptrs_to_tuple() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I = 0, typename Array_Type , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::detail::enable_if&lt;(I == hydra_thrust::tuple_size&lt;T&gt;::value) &amp;&amp; <a class="el" href="structhydra_1_1detail_1_1is__homogeneous.html">is_homogeneous</a>&lt;Array_Type, T&gt;::value, void&gt;::type hydra::detail::set_ptrs_to_tuple </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array_Type **&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a64a1e4a7a30b6daa7e4eaabbfd9aa4a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64a1e4a7a30b6daa7e4eaabbfd9aa4a2">&#9670;&nbsp;</a></span>set_ptrs_to_tuple() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I = 0, typename Array_Type , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::detail::enable_if&lt;(I &lt; hydra_thrust::tuple_size&lt;T&gt;::value) &amp;&amp; <a class="el" href="structhydra_1_1detail_1_1is__homogeneous.html">is_homogeneous</a>&lt;Array_Type, T&gt;::value, void&gt;::type hydra::detail::set_ptrs_to_tuple </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array_Type **&#160;</td>
          <td class="paramname"><em>Array</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a90b2bcec3f72d547652f4db3b581e755"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90b2bcec3f72d547652f4db3b581e755">&#9670;&nbsp;</a></span>set_tuple_element() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int I = 0, typename T , typename ... Tp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::detail::enable_if&lt;I == sizeof...(Tp), void&gt;::type hydra::detail::set_tuple_element </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_3globalScope_4.html#classint">int</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hydra_thrust::tuple&lt; Tp... &gt; const &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a07d2736316e67ca5010eb45eec285fa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07d2736316e67ca5010eb45eec285fa2">&#9670;&nbsp;</a></span>set_tuple_element() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int I = 0, typename T , typename ... Tp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::detail::enable_if&lt;(I &lt; sizeof...(Tp)), void &gt;::type hydra::detail::set_tuple_element </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_3globalScope_4.html#classint">int</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hydra_thrust::tuple&lt; Tp... &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9d766efc8b57b8ea0808be1a69aec7fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d766efc8b57b8ea0808be1a69aec7fc">&#9670;&nbsp;</a></span>split_tuple() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T1, typename ... T2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> void hydra::detail::split_tuple </td>
          <td>(</td>
          <td class="paramtype">hydra_thrust::tuple&lt; T1... &gt; &amp;&#160;</td>
          <td class="paramname"><em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hydra_thrust::tuple&lt; T2... &gt; &amp;&#160;</td>
          <td class="paramname"><em>t2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hydra_thrust::tuple&lt; T1..., T2... &gt; const &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5f1aa7425652bdb11f578dea52cac883"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f1aa7425652bdb11f578dea52cac883">&#9670;&nbsp;</a></span>split_tuple() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t N, typename ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> auto hydra::detail::split_tuple </td>
          <td>(</td>
          <td class="paramtype">hydra_thrust::tuple&lt; T... &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td> -&gt; decltype( <a class="el" href="namespacehydra_1_1detail.html#a7b1b36c840b16da1dc97c8b3729e4c8b">split_tuple_helper</a>( t, <a class="el" href="structhydra_1_1detail_1_1make__index__sequence.html">make_index_sequence</a>&lt;N&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7b1b36c840b16da1dc97c8b3729e4c8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b1b36c840b16da1dc97c8b3729e4c8b">&#9670;&nbsp;</a></span>split_tuple_helper() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T1, typename ... T2, size_t... I1, size_t... I2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> void hydra::detail::split_tuple_helper </td>
          <td>(</td>
          <td class="paramtype">hydra_thrust::tuple&lt; T1... &gt; &amp;&#160;</td>
          <td class="paramname"><em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hydra_thrust::tuple&lt; T2... &gt; &amp;&#160;</td>
          <td class="paramname"><em>t2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hydra_thrust::tuple&lt; T1..., T2... &gt; const &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1detail_1_1index__sequence.html">index_sequence</a>&lt; I1... &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1detail_1_1index__sequence.html">index_sequence</a>&lt; I2... &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac32e9090f5cf5008d6a7abbcd6c6535f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac32e9090f5cf5008d6a7abbcd6c6535f">&#9670;&nbsp;</a></span>split_tuple_helper() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, size_t... I1, size_t... I2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> auto hydra::detail::split_tuple_helper </td>
          <td>(</td>
          <td class="paramtype">hydra_thrust::tuple&lt; T... &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1detail_1_1index__sequence.html">index_sequence</a>&lt; I1... &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1detail_1_1index__sequence.html">index_sequence</a>&lt; I2... &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype( hydra_thrust::make_pair(hydra_thrust::tie( hydra_thrust::get&lt;I1&gt;(t)... ), hydra_thrust::tie( hydra_thrust::get&lt;I2+ + sizeof...(I1)&gt;(t)... ) ) )
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9ab8a09a6cd57cc724421387891a1b0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ab8a09a6cd57cc724421387891a1b0b">&#9670;&nbsp;</a></span>subtractTuples() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, size_t ... I&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::tuple&lt;T...&gt; hydra::detail::subtractTuples </td>
          <td>(</td>
          <td class="paramtype">const hydra_thrust::tuple&lt; T... &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const hydra_thrust::tuple&lt; T... &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1detail_1_1index__sequence.html">index_sequence</a>&lt; I... &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a85e190342696a87b7a21ea849d89cf43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85e190342696a87b7a21ea849d89cf43">&#9670;&nbsp;</a></span>subtractTuples() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::tuple&lt;T...&gt; hydra::detail::subtractTuples </td>
          <td>(</td>
          <td class="paramtype">const hydra_thrust::tuple&lt; T... &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const hydra_thrust::tuple&lt; T... &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5a33f1b7abee68c86f5afee4482c2b29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a33f1b7abee68c86f5afee4482c2b29">&#9670;&nbsp;</a></span>subtractTuplesHelper()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I, typename ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::tuple_element&lt;I, hydra_thrust::tuple&lt;T...&gt; &gt;::type hydra::detail::subtractTuplesHelper </td>
          <td>(</td>
          <td class="paramtype">const hydra_thrust::tuple&lt; T... &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const hydra_thrust::tuple&lt; T... &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3827659803f37e62c150df7e7fabd817"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3827659803f37e62c150df7e7fabd817">&#9670;&nbsp;</a></span>sum_tuple() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I = 0, typename Return_Type , typename ArgType , typename ... Tp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::detail::enable_if&lt;I == sizeof...(Tp), void&gt;::type hydra::detail::sum_tuple </td>
          <td>(</td>
          <td class="paramtype">Return_Type &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hydra_thrust::tuple&lt; Tp... &gt; &amp;&amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArgType &amp;&amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3f54c7821b0c7c33b7cac8e58c467600"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f54c7821b0c7c33b7cac8e58c467600">&#9670;&nbsp;</a></span>sum_tuple() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I = 0, typename Return_Type , typename ArgType , typename ... Tp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::detail::enable_if&lt;(I &lt; sizeof...(Tp)), void &gt;::type hydra::detail::sum_tuple </td>
          <td>(</td>
          <td class="paramtype">Return_Type &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hydra_thrust::tuple&lt; Tp... &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArgType &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a84b0195e8b158fb484274604b4add551"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84b0195e8b158fb484274604b4add551">&#9670;&nbsp;</a></span>sum_tuple() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I = 0, typename Return_Type , typename ArgType , typename ... Tp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::detail::enable_if&lt;I == sizeof...(Tp), void&gt;::type hydra::detail::sum_tuple </td>
          <td>(</td>
          <td class="paramtype">Return_Type &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hydra_thrust::tuple&lt; Tp... &gt; const &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArgType const &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac201d9fb427d4a329383f1aa86ba9326"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac201d9fb427d4a329383f1aa86ba9326">&#9670;&nbsp;</a></span>sum_tuple() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I = 0, typename Return_Type , typename ArgType , typename ... Tp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::detail::enable_if&lt;(I &lt; sizeof...(Tp)), void &gt;::type hydra::detail::sum_tuple </td>
          <td>(</td>
          <td class="paramtype">Return_Type &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hydra_thrust::tuple&lt; Tp... &gt;const &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArgType const &amp;&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a60433e0129833261ec019f6d7f907da7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60433e0129833261ec019f6d7f907da7">&#9670;&nbsp;</a></span>sum_tuple2() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I = 0, typename Return_Type , typename ArgType1 , typename ArgType2 , typename ... Tp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::detail::enable_if&lt;I == sizeof...(Tp), void&gt;::type hydra::detail::sum_tuple2 </td>
          <td>(</td>
          <td class="paramtype">Return_Type &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hydra_thrust::tuple&lt; Tp... &gt; &amp;&amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArgType1 &amp;&amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArgType2 &amp;&amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aefacde8919a6658132ffc081ac40eab8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefacde8919a6658132ffc081ac40eab8">&#9670;&nbsp;</a></span>sum_tuple2() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I = 0, typename Return_Type , typename ArgType1 , typename ArgType2 , typename ... Tp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::detail::enable_if&lt;(I &lt; sizeof...(Tp)), void &gt;::type hydra::detail::sum_tuple2 </td>
          <td>(</td>
          <td class="paramtype">Return_Type &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hydra_thrust::tuple&lt; Tp... &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArgType1 &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArgType2 &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a71473533019ee4297e16843bbcd5c168"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71473533019ee4297e16843bbcd5c168">&#9670;&nbsp;</a></span>sum_tuple2() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I = 0, typename Return_Type , typename ArgType1 , typename ArgType2 , typename ... Tp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::detail::enable_if&lt;I == sizeof...(Tp), void&gt;::type hydra::detail::sum_tuple2 </td>
          <td>(</td>
          <td class="paramtype">Return_Type &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hydra_thrust::tuple&lt; Tp... &gt;const &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArgType1 const &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArgType2 const &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aca4351a6da0a103bc7a12f02e8abb675"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca4351a6da0a103bc7a12f02e8abb675">&#9670;&nbsp;</a></span>sum_tuple2() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I = 0, typename Return_Type , typename ArgType1 , typename ArgType2 , typename ... Tp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::detail::enable_if&lt;(I &lt; sizeof...(Tp)), void &gt;::type hydra::detail::sum_tuple2 </td>
          <td>(</td>
          <td class="paramtype">Return_Type &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hydra_thrust::tuple&lt; Tp... &gt; const &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArgType1 const &amp;&#160;</td>
          <td class="paramname"><em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArgType2 const &amp;&#160;</td>
          <td class="paramname"><em>arg2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a75ca12ea02ee1851f4b39008c1e3891f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75ca12ea02ee1851f4b39008c1e3891f">&#9670;&nbsp;</a></span>tupler() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__tuple.html">detail::is_tuple</a>&lt;T&gt;::value, T&gt;::type hydra::detail::tupler </td>
          <td>(</td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a27e0bac176ee1d54865820690969897c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27e0bac176ee1d54865820690969897c">&#9670;&nbsp;</a></span>tupler() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;!<a class="el" href="structhydra_1_1detail_1_1is__tuple.html">detail::is_tuple</a>&lt;T&gt;::value, <a class="el" href="namespacehydra.html#a717fc4e6b10453164099beade13d0226">hydra::tuple</a>&lt;T&gt; &gt;::type hydra::detail::tupler </td>
          <td>(</td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a61180588ee1d71e4718adf6f8051fd7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61180588ee1d71e4718adf6f8051fd7c">&#9670;&nbsp;</a></span>tupleToArray() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I = 0, typename FistType , typename ... OtherTypes&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">hydra_thrust::detail::enable_if&lt;I == (sizeof...(OtherTypes) + 1) &amp;&amp; <a class="el" href="namespacehydra_1_1detail.html#a3c72e1aed3a4538dac06a7e816543c23">are_all_same</a>&lt;FistType,OtherTypes...&gt;::value, void&gt;::type hydra::detail::tupleToArray </td>
          <td>(</td>
          <td class="paramtype">hydra_thrust::tuple&lt; FistType, OtherTypes... &gt; const &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; FistType, sizeof...(OtherTypes)+1 &gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a08a1c8dabb7a10c7019eae15b9b57396"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08a1c8dabb7a10c7019eae15b9b57396">&#9670;&nbsp;</a></span>tupleToArray() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I = 0, typename FistType , typename ... OtherTypes&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">hydra_thrust::detail::enable_if&lt;(I &lt; sizeof...(OtherTypes)+1) &amp;&amp; <a class="el" href="namespacehydra_1_1detail.html#a3c72e1aed3a4538dac06a7e816543c23">are_all_same</a>&lt;FistType,OtherTypes...&gt;::value, void &gt;::type hydra::detail::tupleToArray </td>
          <td>(</td>
          <td class="paramtype">hydra_thrust::tuple&lt; FistType, OtherTypes... &gt; const &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; FistType, sizeof...(OtherTypes)+1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>Array</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0d28a90668aa47a0ef0184472165a6eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d28a90668aa47a0ef0184472165a6eb">&#9670;&nbsp;</a></span>tupleToArray() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I = 0, typename FistType , typename ... OtherTypes&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::detail::enable_if&lt;I == (sizeof...(OtherTypes) + 1) &amp;&amp; <a class="el" href="namespacehydra_1_1detail.html#a3c72e1aed3a4538dac06a7e816543c23">are_all_same</a>&lt;FistType,OtherTypes...&gt;::value, void&gt;::type hydra::detail::tupleToArray </td>
          <td>(</td>
          <td class="paramtype">hydra_thrust::tuple&lt; FistType, OtherTypes... &gt; const &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::remove_reference&lt; FistType &gt;::type *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a48b258ba5737f48014fbb26eaba70dc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48b258ba5737f48014fbb26eaba70dc7">&#9670;&nbsp;</a></span>tupleToArray() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I = 0, typename FistType , typename ... OtherTypes&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::detail::enable_if&lt;(I &lt; sizeof...(OtherTypes)+1) &amp;&amp; <a class="el" href="namespacehydra_1_1detail.html#a3c72e1aed3a4538dac06a7e816543c23">are_all_same</a>&lt;FistType,OtherTypes...&gt;::value, void &gt;::type hydra::detail::tupleToArray </td>
          <td>(</td>
          <td class="paramtype">hydra_thrust::tuple&lt; FistType, OtherTypes... &gt; const &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::remove_reference&lt; FistType &gt;::type *&#160;</td>
          <td class="paramname"><em>Array</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0241d1e6dda57e0866e3cb2de22199dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0241d1e6dda57e0866e3cb2de22199dc">&#9670;&nbsp;</a></span>tupleToArray() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TupleType , typename ArrayType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::detail::enable_if&lt; (<a class="el" href="structhydra_1_1detail_1_1is__instantiation__of.html">detail::is_instantiation_of</a>&lt;hydra_thrust::tuple,TupleType&gt;::value || <a class="el" href="structhydra_1_1detail_1_1is__instantiation__of.html">detail::is_instantiation_of</a>&lt;hydra_thrust::detail::tuple_of_iterator_references, TupleType&gt;::value), void&gt;::type hydra::detail::tupleToArray </td>
          <td>(</td>
          <td class="paramtype">TupleType const &amp;&#160;</td>
          <td class="paramname"><em>_tuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArrayType *&#160;</td>
          <td class="paramname"><em>_array</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab2864aeaf911297306efcc70d9ed617d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2864aeaf911297306efcc70d9ed617d">&#9670;&nbsp;</a></span>WithinPrecisionInterval()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> bool hydra::detail::WithinPrecisionInterval </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_3globalScope_4.html#classunsigned">unsigned</a> <a class="el" href="namespace_3globalScope_4.html#classint">int</a>&#160;</td>
          <td class="paramname"><em>interval_size</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6d803c1c594f979fb4a8f4beae580766"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d803c1c594f979fb4a8f4beae580766">&#9670;&nbsp;</a></span>zip_iterator_cat()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1all__true.html">all_true</a>&lt;<a class="el" href="structhydra_1_1detail_1_1is__zip__iterator.html">is_zip_iterator</a>&lt;T&gt;::value...&gt;::value, typename <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1merged__zip__iterator">detail::merged_zip_iterator</a>&lt;T...&gt;::type &gt;::type hydra::detail::zip_iterator_cat </td>
          <td>(</td>
          <td class="paramtype">T const &amp;...&#160;</td>
          <td class="paramname"><em>zip_iterators</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a6e5ce23b23364c64166f4c390f0f5f03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e5ce23b23364c64166f4c390f0f5f03">&#9670;&nbsp;</a></span>make_index_sequence&lt; sizeof...(T) -N &gt;</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhydra_1_1detail_1_1make__index__sequence.html">hydra::detail::make_index_sequence</a>&lt; sizeof...(T) -N &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6272aac6b63b0ff4f44d2ff9b24716cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6272aac6b63b0ff4f44d2ff9b24716cf">&#9670;&nbsp;</a></span>max_value</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename C , size_t N, size_t I = 1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> std::enable_if&lt; I &lt; N, void&gt;::type <a class="el" href="namespacehydra_1_1detail.html#aa4140580867ee73e401e1bb1e213548c">max_helper</a>( T const&amp; <a class="el" href="namespacehydra.html#a717fc4e6b10453164099beade13d0226">tuple</a>, <a class="el" href="basic__distributions_8inl.html#a4900ef306eb9271438791f1a98b8ccba">C</a>&amp; max_value, size_t&amp; max_index){ max_index = max_value &gt; hydra_thrust::get&lt;I&gt; (<a class="el" href="namespacehydra.html#a717fc4e6b10453164099beade13d0226">tuple</a>) ? max_index hydra::detail::max_value = max_value &gt; hydra_thrust::get&lt;I&gt;(<a class="el" href="namespacehydra.html#a717fc4e6b10453164099beade13d0226">tuple</a>) ? max_value : hydra_thrust::get&lt;I&gt;(<a class="el" href="namespacehydra.html#a717fc4e6b10453164099beade13d0226">tuple</a>)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacehydra.html">hydra</a></li><li class="navelem"><a class="el" href="namespacehydra_1_1detail.html">detail</a></li>
    <li class="footer">Generated on Sun Jun 28 2020 00:00:02 for Hydra by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.14 </li>
  </ul>
</div>
</body>
</html>
