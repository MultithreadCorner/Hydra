<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Hydra: hydra Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo_Hydra2.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Hydra
   &#160;<span id="projectnumber">3.0.0</span>
   </div>
   <div id="projectbrief">A header-only templated C++ framework to perform data analysis on massively parallel platforms.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('namespacehydra.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">hydra Namespace Reference<div class="ingroups"><a class="el" href="group__policy.html">Policy</a> &#124; <a class="el" href="group__common__functions.html">Common functors</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Generic policies definition.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacehydra_1_1arguments"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1arguments.html">arguments</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacehydra_1_1cpp"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1cpp.html">cpp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacehydra_1_1cuda"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1cuda.html">cuda</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacehydra_1_1detail"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html">detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacehydra_1_1device"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1device.html">device</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacehydra_1_1experimental"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1experimental.html">experimental</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacehydra_1_1fft"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1fft.html">fft</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacehydra_1_1host"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1host.html">host</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacehydra_1_1math__constants"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1math__constants.html">math_constants</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacehydra_1_1omp"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1omp.html">omp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacehydra_1_1placeholders"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1placeholders.html">placeholders</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacehydra_1_1tbb"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1tbb.html">tbb</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1AnalyticalIntegral.html">AnalyticalIntegral</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1AnalyticalIntegral_3_01Functor_00_011_01_4.html">AnalyticalIntegral&lt; Functor, 1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1Argument.html">Argument</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1ArgusShape"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common__functions.html#classhydra_1_1ArgusShape">ArgusShape</a></td></tr>
<tr class="memdesc:classhydra_1_1ArgusShape"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation describing the ARGUS background shape.  <a href="group__common__functions.html#classhydra_1_1ArgusShape">More...</a><br /></td></tr>
<tr class="separator:classhydra_1_1ArgusShape"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1BaseCompositeFunctor"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#classhydra_1_1BaseCompositeFunctor">BaseCompositeFunctor</a></td></tr>
<tr class="separator:classhydra_1_1BaseCompositeFunctor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1BaseCompositeFunctor_3_01Composite_00_01hydra__thrust_1_1tuple_3_01F1_00_01F2_00_0863f00b43bfdf79cb6cf50e96bab02ba.html">BaseCompositeFunctor&lt; Composite, hydra_thrust::tuple&lt; F1, F2, Fs... &gt;, Signature &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1BaseCuFFT.html">BaseCuFFT</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1BaseFFTW.html">BaseFFTW</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1BaseFunctor"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__functor.html#classhydra_1_1BaseFunctor">BaseFunctor</a></td></tr>
<tr class="memdesc:classhydra_1_1BaseFunctor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all functors in hydra.  <a href="group__functor.html#classhydra_1_1BaseFunctor">More...</a><br /></td></tr>
<tr class="separator:classhydra_1_1BaseFunctor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1BifurcatedGaussian"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common__functions.html#classhydra_1_1BifurcatedGaussian">BifurcatedGaussian</a></td></tr>
<tr class="separator:classhydra_1_1BifurcatedGaussian"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1BreitWignerLineShape"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common__functions.html#classhydra_1_1BreitWignerLineShape">BreitWignerLineShape</a></td></tr>
<tr class="memdesc:classhydra_1_1BreitWignerLineShape"><td class="mdescLeft">&#160;</td><td class="mdescRight">Breit-Wigner line shape for 3 body resonant decays \( A -&gt; r c , r-&gt; a b\) , where A is a "long-lived" particle and \( a, b\) and \(c\) are the final states.  <a href="group__common__functions.html#classhydra_1_1BreitWignerLineShape">More...</a><br /></td></tr>
<tr class="separator:classhydra_1_1BreitWignerLineShape"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1BreitWignerNR.html">BreitWignerNR</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1Chebychev"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common__functions.html#classhydra_1_1Chebychev">Chebychev</a></td></tr>
<tr class="memdesc:classhydra_1_1Chebychev"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Chebyshev polynomials \( T_n \) (first kind) are polynomials with the largest possible leading coefficient, but subject to the condition that their absolute value on the interval [−1,1] is bounded by 1.  <a href="group__common__functions.html#classhydra_1_1Chebychev">More...</a><br /></td></tr>
<tr class="separator:classhydra_1_1Chebychev"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1ChiSquare"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common__functions.html#classhydra_1_1ChiSquare">ChiSquare</a></td></tr>
<tr class="memdesc:classhydra_1_1ChiSquare"><td class="mdescLeft">&#160;</td><td class="mdescRight">The chi-squared distribution (also chi-square or \( \chi^2 \) -distribution) with \( k \) degrees of freedom is the distribution of a sum of the squares of k independent standard normal random variables.  <a href="group__common__functions.html#classhydra_1_1ChiSquare">More...</a><br /></td></tr>
<tr class="separator:classhydra_1_1ChiSquare"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1ComplexToComplexCuFFT.html">ComplexToComplexCuFFT</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1ComplexToComplexFFTW.html">ComplexToComplexFFTW</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1ComplexToRealCuFFT.html">ComplexToRealCuFFT</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1ComplexToRealFFTW.html">ComplexToRealFFTW</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1Compose.html">Compose</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1Constant.html">Constant</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1ConvolutionFunctor"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#classhydra_1_1ConvolutionFunctor">ConvolutionFunctor</a></td></tr>
<tr class="separator:classhydra_1_1ConvolutionFunctor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1ConvolutionFunctor_3_01Functor_00_01Kernel_00_01detail_1_1BackendPolicy_3_01BACKENb3b342af36a60e84be1085f455499e1d.html">ConvolutionFunctor&lt; Functor, Kernel, detail::BackendPolicy&lt; BACKEND &gt;, detail::FFTPolicy&lt; typename std::common_type&lt; typename Functor::return_type, typename Kernel::return_type &gt;::type, FFT &gt;, ArgType &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1ConvolutionFunctor_3_01Functor_00_01Kernel_00_01detail_1_1FFTPolicy_3_01typename_03c6b7363172ee2275ee995c834cc1e03.html">ConvolutionFunctor&lt; Functor, Kernel, detail::FFTPolicy&lt; typename std::common_type&lt; typename Functor::return_type, typename Kernel::return_type &gt;::type, FFT &gt;, ArgIndex &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1CosHelicityAngle.html">CosHelicityAngle</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1CrystalBallShape.html">CrystalBallShape</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation the Crystal Ball line shape.  <a href="classhydra_1_1CrystalBallShape.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1CubicSpiline.html">CubicSpiline</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><br />
<br />
 A simple method for a one—dimensional interpolation on a given set of data points (xi, yi).  <a href="classhydra_1_1CubicSpiline.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1Decays"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__phsp.html#classhydra_1_1Decays">Decays</a></td></tr>
<tr class="separator:classhydra_1_1Decays"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1Decays_3_01hydra_1_1tuple_3_01Particles_8_8_8_01_4_00_01hydra_1_1detail_1_1BackendPolicy_3_01Backend_01_4_01_4"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__phsp.html#classhydra_1_1Decays_3_01hydra_1_1tuple_3_01Particles_8_8_8_01_4_00_01hydra_1_1detail_1_1BackendPolicy_3_01Backend_01_4_01_4">Decays&lt; hydra::tuple&lt; Particles... &gt;, hydra::detail::BackendPolicy&lt; Backend &gt; &gt;</a></td></tr>
<tr class="memdesc:classhydra_1_1Decays_3_01hydra_1_1tuple_3_01Particles_8_8_8_01_4_00_01hydra_1_1detail_1_1BackendPolicy_3_01Backend_01_4_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides storage for N-particle states.  <a href="group__phsp.html#classhydra_1_1Decays_3_01hydra_1_1tuple_3_01Particles_8_8_8_01_4_00_01hydra_1_1detail_1_1BackendPolicy_3_01Backend_01_4_01_4">More...</a><br /></td></tr>
<tr class="separator:classhydra_1_1Decays_3_01hydra_1_1tuple_3_01Particles_8_8_8_01_4_00_01hydra_1_1detail_1_1BackendPolicy_3_01Backend_01_4_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1DeltaDMassBackground"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common__functions.html#classhydra_1_1DeltaDMassBackground">DeltaDMassBackground</a></td></tr>
<tr class="separator:classhydra_1_1DeltaDMassBackground"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1DenseHistogram"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__histogram.html#classhydra_1_1DenseHistogram">DenseHistogram</a></td></tr>
<tr class="separator:classhydra_1_1DenseHistogram"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1DenseHistogram_3_01T_00_011_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_47e77d3fa69b0393593bb979d3c5f9775"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__histogram.html#classhydra_1_1DenseHistogram_3_01T_00_011_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_47e77d3fa69b0393593bb979d3c5f9775">DenseHistogram&lt; T, 1, hydra::detail::BackendPolicy&lt; BACKEND &gt;, detail::unidimensional &gt;</a></td></tr>
<tr class="memdesc:classhydra_1_1DenseHistogram_3_01T_00_011_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_47e77d3fa69b0393593bb979d3c5f9775"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing one-dimensional dense histogram.  <a href="group__histogram.html#classhydra_1_1DenseHistogram_3_01T_00_011_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_47e77d3fa69b0393593bb979d3c5f9775">More...</a><br /></td></tr>
<tr class="separator:classhydra_1_1DenseHistogram_3_01T_00_011_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_47e77d3fa69b0393593bb979d3c5f9775"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1DenseHistogram_3_01T_00_01N_00_01detail_1_1BackendPolicy_3_01BACKEND_01_4_00_01detail_1_1multidimensional_01_4"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__histogram.html#classhydra_1_1DenseHistogram_3_01T_00_01N_00_01detail_1_1BackendPolicy_3_01BACKEND_01_4_00_01detail_1_1multidimensional_01_4">DenseHistogram&lt; T, N, detail::BackendPolicy&lt; BACKEND &gt;, detail::multidimensional &gt;</a></td></tr>
<tr class="memdesc:classhydra_1_1DenseHistogram_3_01T_00_01N_00_01detail_1_1BackendPolicy_3_01BACKEND_01_4_00_01detail_1_1multidimensional_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing multidimensional dense histograms.  <a href="group__histogram.html#classhydra_1_1DenseHistogram_3_01T_00_01N_00_01detail_1_1BackendPolicy_3_01BACKEND_01_4_00_01detail_1_1multidimensional_01_4">More...</a><br /></td></tr>
<tr class="separator:classhydra_1_1DenseHistogram_3_01T_00_01N_00_01detail_1_1BackendPolicy_3_01BACKEND_01_4_00_01detail_1_1multidimensional_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1Distribution"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#classhydra_1_1Distribution">Distribution</a></td></tr>
<tr class="separator:classhydra_1_1Distribution"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1Distribution_3_01Class_00_01false_01_4"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#structhydra_1_1Distribution_3_01Class_00_01false_01_4">Distribution&lt; Class, false &gt;</a></td></tr>
<tr class="separator:structhydra_1_1Distribution_3_01Class_00_01false_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1Distribution_3_01Functor_00_01true_01_4.html">Distribution&lt; Functor, true &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1Divide.html">Divide</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1DoubleExponential"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common__functions.html#classhydra_1_1DoubleExponential">DoubleExponential</a></td></tr>
<tr class="memdesc:classhydra_1_1DoubleExponential"><td class="mdescLeft">&#160;</td><td class="mdescRight">distribution <a href="https://en.wikipedia.org/wiki/Laplace_distribution">https://en.wikipedia.org/wiki/Laplace_distribution</a>  <a href="group__common__functions.html#classhydra_1_1DoubleExponential">More...</a><br /></td></tr>
<tr class="separator:classhydra_1_1DoubleExponential"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1Exponential"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common__functions.html#classhydra_1_1Exponential">Exponential</a></td></tr>
<tr class="memdesc:classhydra_1_1Exponential"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a href="https://en.wikipedia.org/wiki/Exponential_function">https://en.wikipedia.org/wiki/Exponential_function</a>  <a href="group__common__functions.html#classhydra_1_1Exponential">More...</a><br /></td></tr>
<tr class="separator:classhydra_1_1Exponential"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1FCN"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fit.html#classhydra_1_1FCN">FCN</a></td></tr>
<tr class="memdesc:classhydra_1_1FCN"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="group__fit.html#classhydra_1_1FCN" title="FCN base class. ">FCN</a> base class.  <a href="group__fit.html#classhydra_1_1FCN">More...</a><br /></td></tr>
<tr class="separator:classhydra_1_1FCN"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1FCN_3_01Estimator_3_01PDF_00_01Iterator_01_4_00_01true_01_4"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fit.html#classhydra_1_1FCN_3_01Estimator_3_01PDF_00_01Iterator_01_4_00_01true_01_4">FCN&lt; Estimator&lt; PDF, Iterator &gt;, true &gt;</a></td></tr>
<tr class="separator:classhydra_1_1FCN_3_01Estimator_3_01PDF_00_01Iterator_01_4_00_01true_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1FCN_3_01Estimator_3_01PDF_00_01Iterator_00_01Iterators_8_8_8_01_4_00_01true_01_4"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fit.html#classhydra_1_1FCN_3_01Estimator_3_01PDF_00_01Iterator_00_01Iterators_8_8_8_01_4_00_01true_01_4">FCN&lt; Estimator&lt; PDF, Iterator, Iterators... &gt;, true &gt;</a></td></tr>
<tr class="separator:classhydra_1_1FCN_3_01Estimator_3_01PDF_00_01Iterator_00_01Iterators_8_8_8_01_4_00_01true_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1FCN_3_01hydra__thrust_1_1tuple_3_01FCN_3_01ESTIMATORS_01_4_8_8_8_01_4_00_01false_01_4"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fit.html#classhydra_1_1FCN_3_01hydra__thrust_1_1tuple_3_01FCN_3_01ESTIMATORS_01_4_8_8_8_01_4_00_01false_01_4">FCN&lt; hydra_thrust::tuple&lt; FCN&lt; ESTIMATORS &gt;... &gt;, false &gt;</a></td></tr>
<tr class="separator:classhydra_1_1FCN_3_01hydra__thrust_1_1tuple_3_01FCN_3_01ESTIMATORS_01_4_8_8_8_01_4_00_01false_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1Gaussian"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common__functions.html#classhydra_1_1Gaussian">Gaussian</a></td></tr>
<tr class="memdesc:classhydra_1_1Gaussian"><td class="mdescLeft">&#160;</td><td class="mdescRight"><br />
<br />
 <a class="el" href="group__common__functions.html#classhydra_1_1Gaussian" title="   Gaussian functions are often used to represent the probability density function of a normally dist...">Gaussian</a> functions are often used to represent the probability density function of a normally distributed random variable with expected value \( \mu \) and variance \( \sigma \).  <a href="group__common__functions.html#classhydra_1_1Gaussian">More...</a><br /></td></tr>
<tr class="separator:classhydra_1_1Gaussian"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1GaussianKDE"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common__functions.html#classhydra_1_1GaussianKDE">GaussianKDE</a></td></tr>
<tr class="separator:classhydra_1_1GaussianKDE"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1GaussKronrodAdaptiveQuadrature"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#classhydra_1_1GaussKronrodAdaptiveQuadrature">GaussKronrodAdaptiveQuadrature</a></td></tr>
<tr class="separator:classhydra_1_1GaussKronrodAdaptiveQuadrature"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1GaussKronrodAdaptiveQuadrature_3_01NRULE_00_01NBIN_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_4_01_4.html">GaussKronrodAdaptiveQuadrature&lt; NRULE, NBIN, hydra::detail::BackendPolicy&lt; BACKEND &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1GaussKronrodBinary.html">GaussKronrodBinary</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1GaussKronrodCall.html">GaussKronrodCall</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1GaussKronrodQuadrature"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#classhydra_1_1GaussKronrodQuadrature">GaussKronrodQuadrature</a></td></tr>
<tr class="separator:classhydra_1_1GaussKronrodQuadrature"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1GaussKronrodQuadrature_3_01NRULE_00_01NBIN_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_4_01_4.html">GaussKronrodQuadrature&lt; NRULE, NBIN, hydra::detail::BackendPolicy&lt; BACKEND &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1GaussKronrodRule"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__numerical__integration.html#structhydra_1_1GaussKronrodRule">GaussKronrodRule</a></td></tr>
<tr class="memdesc:structhydra_1_1GaussKronrodRule"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rules for Gauss-Kronrod quadrature.  <a href="group__numerical__integration.html#structhydra_1_1GaussKronrodRule">More...</a><br /></td></tr>
<tr class="separator:structhydra_1_1GaussKronrodRule"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1GaussKronrodRuleSelector"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#structhydra_1_1GaussKronrodRuleSelector">GaussKronrodRuleSelector</a></td></tr>
<tr class="separator:structhydra_1_1GaussKronrodRuleSelector"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1GaussKronrodRuleSelector_3_0115_01_4"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__numerical__integration.html#structhydra_1_1GaussKronrodRuleSelector_3_0115_01_4">GaussKronrodRuleSelector&lt; 15 &gt;</a></td></tr>
<tr class="memdesc:structhydra_1_1GaussKronrodRuleSelector_3_0115_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rules for Gauss-Kronrod quadrature.  <a href="group__numerical__integration.html#structhydra_1_1GaussKronrodRuleSelector_3_0115_01_4">More...</a><br /></td></tr>
<tr class="separator:structhydra_1_1GaussKronrodRuleSelector_3_0115_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1GaussKronrodRuleSelector_3_0121_01_4"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__numerical__integration.html#structhydra_1_1GaussKronrodRuleSelector_3_0121_01_4">GaussKronrodRuleSelector&lt; 21 &gt;</a></td></tr>
<tr class="memdesc:structhydra_1_1GaussKronrodRuleSelector_3_0121_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rules for Gauss-Kronrod quadrature.  <a href="group__numerical__integration.html#structhydra_1_1GaussKronrodRuleSelector_3_0121_01_4">More...</a><br /></td></tr>
<tr class="separator:structhydra_1_1GaussKronrodRuleSelector_3_0121_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1GaussKronrodRuleSelector_3_0131_01_4"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__numerical__integration.html#structhydra_1_1GaussKronrodRuleSelector_3_0131_01_4">GaussKronrodRuleSelector&lt; 31 &gt;</a></td></tr>
<tr class="memdesc:structhydra_1_1GaussKronrodRuleSelector_3_0131_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rules for Gauss-Kronrod quadrature.  <a href="group__numerical__integration.html#structhydra_1_1GaussKronrodRuleSelector_3_0131_01_4">More...</a><br /></td></tr>
<tr class="separator:structhydra_1_1GaussKronrodRuleSelector_3_0131_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1GaussKronrodRuleSelector_3_0141_01_4"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__numerical__integration.html#structhydra_1_1GaussKronrodRuleSelector_3_0141_01_4">GaussKronrodRuleSelector&lt; 41 &gt;</a></td></tr>
<tr class="memdesc:structhydra_1_1GaussKronrodRuleSelector_3_0141_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rules for Gauss-Kronrod quadrature.  <a href="group__numerical__integration.html#structhydra_1_1GaussKronrodRuleSelector_3_0141_01_4">More...</a><br /></td></tr>
<tr class="separator:structhydra_1_1GaussKronrodRuleSelector_3_0141_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1GaussKronrodRuleSelector_3_0151_01_4"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__numerical__integration.html#structhydra_1_1GaussKronrodRuleSelector_3_0151_01_4">GaussKronrodRuleSelector&lt; 51 &gt;</a></td></tr>
<tr class="memdesc:structhydra_1_1GaussKronrodRuleSelector_3_0151_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rules for Gauss-Kronrod quadrature.  <a href="group__numerical__integration.html#structhydra_1_1GaussKronrodRuleSelector_3_0151_01_4">More...</a><br /></td></tr>
<tr class="separator:structhydra_1_1GaussKronrodRuleSelector_3_0151_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1GaussKronrodRuleSelector_3_0161_01_4"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__numerical__integration.html#structhydra_1_1GaussKronrodRuleSelector_3_0161_01_4">GaussKronrodRuleSelector&lt; 61 &gt;</a></td></tr>
<tr class="memdesc:structhydra_1_1GaussKronrodRuleSelector_3_0161_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rules for Gauss-Kronrod quadrature.  <a href="group__numerical__integration.html#structhydra_1_1GaussKronrodRuleSelector_3_0161_01_4">More...</a><br /></td></tr>
<tr class="separator:structhydra_1_1GaussKronrodRuleSelector_3_0161_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1GaussKronrodUnary.html">GaussKronrodUnary</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1GenzMalikQuadrature"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#classhydra_1_1GenzMalikQuadrature">GenzMalikQuadrature</a></td></tr>
<tr class="separator:classhydra_1_1GenzMalikQuadrature"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1GenzMalikQuadrature_3_01N_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_4_01_4"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__numerical__integration.html#classhydra_1_1GenzMalikQuadrature_3_01N_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_4_01_4">GenzMalikQuadrature&lt; N, hydra::detail::BackendPolicy&lt; BACKEND &gt; &gt;</a></td></tr>
<tr class="memdesc:classhydra_1_1GenzMalikQuadrature_3_01N_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_4_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-adaptive Genz-Malik multidimensional quadrature.  <a href="group__numerical__integration.html#classhydra_1_1GenzMalikQuadrature_3_01N_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_4_01_4">More...</a><br /></td></tr>
<tr class="separator:classhydra_1_1GenzMalikQuadrature_3_01N_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_4_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1GenzMalikRule"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#classhydra_1_1GenzMalikRule">GenzMalikRule</a></td></tr>
<tr class="separator:classhydra_1_1GenzMalikRule"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1GenzMalikRule_3_01DIM_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_4_01_4"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__numerical__integration.html#classhydra_1_1GenzMalikRule_3_01DIM_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_4_01_4">GenzMalikRule&lt; DIM, hydra::detail::BackendPolicy&lt; BACKEND &gt; &gt;</a></td></tr>
<tr class="memdesc:classhydra_1_1GenzMalikRule_3_01DIM_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_4_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing Genz-Malik rule.  <a href="group__numerical__integration.html#classhydra_1_1GenzMalikRule_3_01DIM_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_4_01_4">More...</a><br /></td></tr>
<tr class="separator:classhydra_1_1GenzMalikRule_3_01DIM_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_4_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1GenzMalikRuleBase.html">GenzMalikRuleBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1Integral.html">Integral</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1Integral_3_01Algorithm_00_011_01_4.html">Integral&lt; Algorithm, 1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1IntegrationFormula.html">IntegrationFormula</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1IntegrationFormula_3_01ArgusShape_3_01ArgType_01_4_00_011_01_4.html">IntegrationFormula&lt; ArgusShape&lt; ArgType &gt;, 1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1IntegrationFormula_3_01BifurcatedGaussian_3_01ArgType_01_4_00_011_01_4.html">IntegrationFormula&lt; BifurcatedGaussian&lt; ArgType &gt;, 1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1IntegrationFormula_3_01BreitWignerNR_3_01ArgType_01_4_00_011_01_4.html">IntegrationFormula&lt; BreitWignerNR&lt; ArgType &gt;, 1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1IntegrationFormula_3_01Chebychev_3_01Order_00_01ArgType_01_4_00_011_01_4.html">IntegrationFormula&lt; Chebychev&lt; Order, ArgType &gt;, 1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1IntegrationFormula_3_01ChiSquare_3_01ArgType_01_4_00_011_01_4"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common__functions.html#classhydra_1_1IntegrationFormula_3_01ChiSquare_3_01ArgType_01_4_00_011_01_4">IntegrationFormula&lt; ChiSquare&lt; ArgType &gt;, 1 &gt;</a></td></tr>
<tr class="separator:classhydra_1_1IntegrationFormula_3_01ChiSquare_3_01ArgType_01_4_00_011_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1IntegrationFormula_3_01CrystalBallShape_3_01ArgType_01_4_00_011_01_4.html">IntegrationFormula&lt; CrystalBallShape&lt; ArgType &gt;, 1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1IntegrationFormula_3_01DeltaDMassBackground_3_01ArgType_01_4_00_011_01_4.html">IntegrationFormula&lt; DeltaDMassBackground&lt; ArgType &gt;, 1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1IntegrationFormula_3_01DoubleExponential_3_01ArgType_01_4_00_012_01_4.html">IntegrationFormula&lt; DoubleExponential&lt; ArgType &gt;, 2 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1IntegrationFormula_3_01Exponential_3_01ArgType_01_4_00_011_01_4.html">IntegrationFormula&lt; Exponential&lt; ArgType &gt;, 1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1IntegrationFormula_3_01Gaussian_3_01ArgType_01_4_00_011_01_4.html">IntegrationFormula&lt; Gaussian&lt; ArgType &gt;, 1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1IntegrationFormula_3_01Ipatia_3_01ArgType_01_4_00_011_01_4.html">IntegrationFormula&lt; Ipatia&lt; ArgType &gt;, 1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1IntegrationFormula_3_01JohnsonSU_3_01ArgType_01_4_00_011_01_4.html">IntegrationFormula&lt; JohnsonSU&lt; ArgType &gt;, 1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1IntegrationFormula_3_01LogNormal_3_01ArgType_01_4_00_011_01_4.html">IntegrationFormula&lt; LogNormal&lt; ArgType &gt;, 1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1IntegrationFormula_3_01Polynomial_3_01Order_00_01ArgType_01_4_00_011_01_4.html">IntegrationFormula&lt; Polynomial&lt; Order, ArgType &gt;, 1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1IntegrationFormula_3_01TrapezoidalShape_3_01ArgType_01_4_00_011_01_4.html">IntegrationFormula&lt; TrapezoidalShape&lt; ArgType &gt;, 1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1IntegrationFormula_3_01TriangularShape_3_01ArgType_01_4_00_011_01_4.html">IntegrationFormula&lt; TriangularShape&lt; ArgType &gt;, 1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1IntegrationFormula_3_01UniformShape_3_01ArgType_01_4_00_011_01_4.html">IntegrationFormula&lt; UniformShape&lt; ArgType &gt;, 1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1Ipatia"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common__functions.html#classhydra_1_1Ipatia">Ipatia</a></td></tr>
<tr class="memdesc:classhydra_1_1Ipatia"><td class="mdescLeft">&#160;</td><td class="mdescRight">version of the <a class="el" href="group__common__functions.html#classhydra_1_1Ipatia" title="version of the Ipatia distribution as described in the reference https://doi.org/10.1016/j.nima.2014.06.081. ">Ipatia</a> distribution as described in the reference <a href="https://doi.org/10.1016/j.nima.2014.06.081">https://doi.org/10.1016/j.nima.2014.06.081</a>.  <a href="group__common__functions.html#classhydra_1_1Ipatia">More...</a><br /></td></tr>
<tr class="separator:classhydra_1_1Ipatia"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1JohnsonSU.html">JohnsonSU</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1Lambda.html">Lambda</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1Lambda_3_01LambdaType_00_010_01_4.html">Lambda&lt; LambdaType, 0 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1LogLikelihoodFCN"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#classhydra_1_1LogLikelihoodFCN">LogLikelihoodFCN</a></td></tr>
<tr class="separator:classhydra_1_1LogLikelihoodFCN"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1LogLikelihoodFCN_3_01Pdf_3_01Functor_00_01Integrator_01_4_00_01IteratorD_00_01IteratorW_8_8_8_01_4.html">LogLikelihoodFCN&lt; Pdf&lt; Functor, Integrator &gt;, IteratorD, IteratorW... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1LogLikelihoodFCN_3_01PDFSumExtendable_3_01Pdfs_8_8_8_01_4_00_01IteratorD_00_01IteratorW_8_8_8_01_4.html">LogLikelihoodFCN&lt; PDFSumExtendable&lt; Pdfs... &gt;, IteratorD, IteratorW... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1LogLikelihoodFCN_3_01PDFSumNonExtendable_3_01Pdfs_8_8_8_01_4_00_01IteratorD_00_01IteratorW_8_8_8_01_4.html">LogLikelihoodFCN&lt; PDFSumNonExtendable&lt; Pdfs... &gt;, IteratorD, IteratorW... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1LogNormal"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common__functions.html#classhydra_1_1LogNormal">LogNormal</a></td></tr>
<tr class="memdesc:classhydra_1_1LogNormal"><td class="mdescLeft">&#160;</td><td class="mdescRight">In probability theory, a log-normal (or lognormal) distribution is a continuous probability distribution of a random variable whose logarithm is normally distributed.  <a href="group__common__functions.html#classhydra_1_1LogNormal">More...</a><br /></td></tr>
<tr class="separator:classhydra_1_1LogNormal"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1M12PhaseSpaceLineShape"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common__functions.html#classhydra_1_1M12PhaseSpaceLineShape">M12PhaseSpaceLineShape</a></td></tr>
<tr class="memdesc:classhydra_1_1M12PhaseSpaceLineShape"><td class="mdescLeft">&#160;</td><td class="mdescRight">Two-body phase-space distribution for \( m_{12}\): </p><p class="formulaDsp">
\[ \frac{dN}{dm_{m_12}} \propto q.p \]
</p>
<p>.  <a href="group__common__functions.html#classhydra_1_1M12PhaseSpaceLineShape">More...</a><br /></td></tr>
<tr class="separator:classhydra_1_1M12PhaseSpaceLineShape"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1M12SqPhaseSpaceLineShape"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common__functions.html#classhydra_1_1M12SqPhaseSpaceLineShape">M12SqPhaseSpaceLineShape</a></td></tr>
<tr class="memdesc:classhydra_1_1M12SqPhaseSpaceLineShape"><td class="mdescLeft">&#160;</td><td class="mdescRight">Two-body phase-space distribution for \( m_{12}^2\): </p><p class="formulaDsp">
\[ \frac{dN}{dm^2_{12}} \propto q.p/m^2_{12} \]
</p>
<p>.  <a href="group__common__functions.html#classhydra_1_1M12SqPhaseSpaceLineShape">More...</a><br /></td></tr>
<tr class="separator:classhydra_1_1M12SqPhaseSpaceLineShape"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1Minus.html">Minus</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1multiarray"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#classhydra_1_1multiarray">multiarray</a></td></tr>
<tr class="separator:classhydra_1_1multiarray"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multiarray_3_01T_00_01N_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_4_01_4.html">multiarray&lt; T, N, hydra::detail::BackendPolicy&lt; BACKEND &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1Multiply.html">Multiply</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1multivector"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a></td></tr>
<tr class="separator:classhydra_1_1multivector"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html">multivector&lt; hydra_thrust::tuple&lt; T... &gt;, hydra::detail::BackendPolicy&lt; BACKEND &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements storage in SoA layouts for table where all elements have the same type.  <a href="classhydra_1_1multivector_3_01hydra__thrust_1_1tuple_3_01T_8_8_8_01_4_00_01hydra_1_1detail_1_1Baaf5bb9c490efe1cc04683c31129e6041.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1null__type"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#structhydra_1_1null__type">null_type</a></td></tr>
<tr class="separator:structhydra_1_1null__type"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1NumericalIntegral.html">NumericalIntegral</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1Parameter"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a></td></tr>
<tr class="memdesc:structhydra_1_1Parameter"><td class="mdescLeft">&#160;</td><td class="mdescRight"><br />
,  <a href="group__fit.html#structhydra_1_1Parameter">More...</a><br /></td></tr>
<tr class="separator:structhydra_1_1Parameter"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1Pdf"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fit.html#classhydra_1_1Pdf">Pdf</a></td></tr>
<tr class="memdesc:classhydra_1_1Pdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing probability density functions.  <a href="group__fit.html#classhydra_1_1Pdf">More...</a><br /></td></tr>
<tr class="separator:classhydra_1_1Pdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1PDFSumExtendable"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fit.html#classhydra_1_1PDFSumExtendable">PDFSumExtendable</a></td></tr>
<tr class="memdesc:classhydra_1_1PDFSumExtendable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing a pdf object built summing up other pdfs.  <a href="group__fit.html#classhydra_1_1PDFSumExtendable">More...</a><br /></td></tr>
<tr class="separator:classhydra_1_1PDFSumExtendable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1PDFSumNonExtendable"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fit.html#classhydra_1_1PDFSumNonExtendable">PDFSumNonExtendable</a></td></tr>
<tr class="memdesc:classhydra_1_1PDFSumNonExtendable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing a pdf object built summing a pdf adding other pdfs.  <a href="group__fit.html#classhydra_1_1PDFSumNonExtendable">More...</a><br /></td></tr>
<tr class="separator:classhydra_1_1PDFSumNonExtendable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1PhaseSpace"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__phsp.html#classhydra_1_1PhaseSpace">PhaseSpace</a></td></tr>
<tr class="memdesc:classhydra_1_1PhaseSpace"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements phase-space Monte Carlo generation in hydra.  <a href="group__phsp.html#classhydra_1_1PhaseSpace">More...</a><br /></td></tr>
<tr class="separator:classhydra_1_1PhaseSpace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1PhaseSpaceIntegrator"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__phsp.html#classhydra_1_1PhaseSpaceIntegrator">PhaseSpaceIntegrator</a></td></tr>
<tr class="separator:classhydra_1_1PhaseSpaceIntegrator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1PhaseSpaceIntegrator_3_01N_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_4_00_01GRND_01_4"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__phsp.html#classhydra_1_1PhaseSpaceIntegrator_3_01N_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_4_00_01GRND_01_4">PhaseSpaceIntegrator&lt; N, hydra::detail::BackendPolicy&lt; BACKEND &gt;, GRND &gt;</a></td></tr>
<tr class="separator:classhydra_1_1PhaseSpaceIntegrator_3_01N_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_4_00_01GRND_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1PhaseSpaceReweight.html">PhaseSpaceReweight</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1PhaseSpaceWeight.html">PhaseSpaceWeight</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1Plain"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#structhydra_1_1Plain">Plain</a></td></tr>
<tr class="separator:structhydra_1_1Plain"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1Plain_3_01N_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_4_00_01GRND_01_4"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__numerical__integration.html#classhydra_1_1Plain_3_01N_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_4_00_01GRND_01_4">Plain&lt; N, hydra::detail::BackendPolicy&lt; BACKEND &gt;, GRND &gt;</a></td></tr>
<tr class="memdesc:classhydra_1_1Plain_3_01N_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_4_00_01GRND_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements the <a class="el" href="namespacehydra.html#structhydra_1_1Plain">Plain</a> MC numerical integration algorithm in Hydra.  <a href="group__numerical__integration.html#classhydra_1_1Plain_3_01N_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_4_00_01GRND_01_4">More...</a><br /></td></tr>
<tr class="separator:classhydra_1_1Plain_3_01N_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_4_00_01GRND_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1PlainState"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__numerical__integration.html#structhydra_1_1PlainState">PlainState</a></td></tr>
<tr class="memdesc:structhydra_1_1PlainState"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple structure to hold the results of the <a class="el" href="namespacehydra.html#structhydra_1_1Plain">Plain</a> MC numerical integration.  <a href="group__numerical__integration.html#structhydra_1_1PlainState">More...</a><br /></td></tr>
<tr class="separator:structhydra_1_1PlainState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1PlanesDeltaAngle"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common__functions.html#classhydra_1_1PlanesDeltaAngle">PlanesDeltaAngle</a></td></tr>
<tr class="memdesc:classhydra_1_1PlanesDeltaAngle"><td class="mdescLeft">&#160;</td><td class="mdescRight">This functor calculates the delta angle between decay plane of the particle with four-vector d2 and d3 (same plane) and h1 (other plane)  <a href="group__common__functions.html#classhydra_1_1PlanesDeltaAngle">More...</a><br /></td></tr>
<tr class="separator:classhydra_1_1PlanesDeltaAngle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1Polynomial"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common__functions.html#classhydra_1_1Polynomial">Polynomial</a></td></tr>
<tr class="memdesc:classhydra_1_1Polynomial"><td class="mdescLeft">&#160;</td><td class="mdescRight"><br />
<br />
 From : <a href="https://en.wikipedia.org/wiki/Polynomial">https://en.wikipedia.org/wiki/Polynomial</a>  <a href="group__common__functions.html#classhydra_1_1Polynomial">More...</a><br /></td></tr>
<tr class="separator:classhydra_1_1Polynomial"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1Print.html">Print</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1ProcessGaussKronrodAdaptiveQuadrature.html">ProcessGaussKronrodAdaptiveQuadrature</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1Range"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a></td></tr>
<tr class="separator:classhydra_1_1Range"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1Range_3_01Iterator_01_4.html">Range&lt; Iterator &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1Range_3_01Iterator_00_01Functor_01_4.html">Range&lt; Iterator, Functor &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1RealToComplexCuFFT.html">RealToComplexCuFFT</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1RealToComplexFFTW.html">RealToComplexFFTW</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1RngBase.html">RngBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1RngFormula.html">RngFormula</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1RngFormula_3_01BifurcatedGaussian_3_01ArgType_01_4_01_4.html">RngFormula&lt; BifurcatedGaussian&lt; ArgType &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1RngFormula_3_01BreitWignerNR_3_01ArgType_01_4_01_4.html">RngFormula&lt; BreitWignerNR&lt; ArgType &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1RngFormula_3_01ChiSquare_3_01ArgType_01_4_01_4"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common__functions.html#structhydra_1_1RngFormula_3_01ChiSquare_3_01ArgType_01_4_01_4">RngFormula&lt; ChiSquare&lt; ArgType &gt; &gt;</a></td></tr>
<tr class="separator:structhydra_1_1RngFormula_3_01ChiSquare_3_01ArgType_01_4_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1RngFormula_3_01Exponential_3_01ArgType_01_4_01_4.html">RngFormula&lt; Exponential&lt; ArgType &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1RngFormula_3_01Gaussian_3_01ArgType_01_4_01_4.html">RngFormula&lt; Gaussian&lt; ArgType &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1RngFormula_3_01JohnsonSU_3_01ArgType_01_4_01_4.html">RngFormula&lt; JohnsonSU&lt; ArgType &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1RngFormula_3_01LogNormal_3_01ArgType_01_4_01_4.html">RngFormula&lt; LogNormal&lt; ArgType &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1RngFormula_3_01TrapezoidalShape_3_01ArgType_01_4_01_4.html">RngFormula&lt; TrapezoidalShape&lt; ArgType &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1RngFormula_3_01TriangularShape_3_01ArgType_01_4_01_4.html">RngFormula&lt; TriangularShape&lt; ArgType &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1RngFormula_3_01UniformShape_3_01ArgType_01_4_01_4.html">RngFormula&lt; UniformShape&lt; ArgType &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1ScopedBuffer"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#classhydra_1_1ScopedBuffer">ScopedBuffer</a></td></tr>
<tr class="separator:classhydra_1_1ScopedBuffer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1ScopedBuffer_3_01T_00_01detail_1_1BackendPolicy_3_01BACKEND_01_4_01_4.html">ScopedBuffer&lt; T, detail::BackendPolicy&lt; BACKEND &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1SeedRNG.html">SeedRNG</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1sobol__engine.html">sobol_engine</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instantiations of class template sobol. The <a class="el" href="classhydra_1_1sobol__engine.html" title="Instantiations of class template sobol. The sobol_engine uses the algorithm described in  [Bratley+Fo...">sobol_engine</a> uses the algorithm described in  [Bratley+Fox, TOMS 14, 88 (1988)] and [Antonov+Saleev, USSR Comput. Maths. Math. Phys. 19, 252 (1980)] .  <a href="classhydra_1_1sobol__engine.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1SparseHistogram"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__histogram.html#classhydra_1_1SparseHistogram">SparseHistogram</a></td></tr>
<tr class="separator:classhydra_1_1SparseHistogram"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1SparseHistogram_3_01T_00_011_00_01detail_1_1BackendPolicy_3_01BACKEND_01_4_00_01detail_1_1unidimensional_01_4"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__histogram.html#classhydra_1_1SparseHistogram_3_01T_00_011_00_01detail_1_1BackendPolicy_3_01BACKEND_01_4_00_01detail_1_1unidimensional_01_4">SparseHistogram&lt; T, 1, detail::BackendPolicy&lt; BACKEND &gt;, detail::unidimensional &gt;</a></td></tr>
<tr class="memdesc:classhydra_1_1SparseHistogram_3_01T_00_011_00_01detail_1_1BackendPolicy_3_01BACKEND_01_4_00_01detail_1_1unidimensional_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing one-dimensional sparse histogram.  <a href="group__histogram.html#classhydra_1_1SparseHistogram_3_01T_00_011_00_01detail_1_1BackendPolicy_3_01BACKEND_01_4_00_01detail_1_1unidimensional_01_4">More...</a><br /></td></tr>
<tr class="separator:classhydra_1_1SparseHistogram_3_01T_00_011_00_01detail_1_1BackendPolicy_3_01BACKEND_01_4_00_01detail_1_1unidimensional_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1SparseHistogram_3_01T_00_01N_00_01detail_1_1BackendPolicy_3_01BACKEND_01_4_00_01detail_1_1multidimensional_01_4"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__histogram.html#classhydra_1_1SparseHistogram_3_01T_00_01N_00_01detail_1_1BackendPolicy_3_01BACKEND_01_4_00_01detail_1_1multidimensional_01_4">SparseHistogram&lt; T, N, detail::BackendPolicy&lt; BACKEND &gt;, detail::multidimensional &gt;</a></td></tr>
<tr class="memdesc:classhydra_1_1SparseHistogram_3_01T_00_01N_00_01detail_1_1BackendPolicy_3_01BACKEND_01_4_00_01detail_1_1multidimensional_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing multidimensional sparse histogram.  <a href="group__histogram.html#classhydra_1_1SparseHistogram_3_01T_00_01N_00_01detail_1_1BackendPolicy_3_01BACKEND_01_4_00_01detail_1_1multidimensional_01_4">More...</a><br /></td></tr>
<tr class="separator:classhydra_1_1SparseHistogram_3_01T_00_01N_00_01detail_1_1BackendPolicy_3_01BACKEND_01_4_00_01detail_1_1multidimensional_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1SpilineFunctor.html">SpilineFunctor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><br />
<br />
 A simple method for a one—dimensional interpolation on a given set of data points (xi, yi).  <a href="classhydra_1_1SpilineFunctor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1SPlot"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fit.html#classhydra_1_1SPlot">SPlot</a></td></tr>
<tr class="memdesc:classhydra_1_1SPlot"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of {s}_{Plot} technique for statistical unfolding of sample containing events from different sources.  <a href="group__fit.html#classhydra_1_1SPlot">More...</a><br /></td></tr>
<tr class="separator:classhydra_1_1SPlot"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhydra_1_1Sum.html">Sum</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1ThreeBodyMassThresholdBackground"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common__functions.html#classhydra_1_1ThreeBodyMassThresholdBackground">ThreeBodyMassThresholdBackground</a></td></tr>
<tr class="separator:classhydra_1_1ThreeBodyMassThresholdBackground"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1TrapezoidalShape"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common__functions.html#classhydra_1_1TrapezoidalShape">TrapezoidalShape</a></td></tr>
<tr class="memdesc:classhydra_1_1TrapezoidalShape"><td class="mdescLeft">&#160;</td><td class="mdescRight">In probability theory and statistics, the trapezoidal distribution is a continuous probability distribution the graph of whose probability density function resembles a trapezoid.  <a href="group__common__functions.html#classhydra_1_1TrapezoidalShape">More...</a><br /></td></tr>
<tr class="separator:classhydra_1_1TrapezoidalShape"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1TriangularShape"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common__functions.html#classhydra_1_1TriangularShape">TriangularShape</a></td></tr>
<tr class="memdesc:classhydra_1_1TriangularShape"><td class="mdescLeft">&#160;</td><td class="mdescRight">From: <a href="https://en.wikipedia.org/wiki/Triangular_distribution">https://en.wikipedia.org/wiki/Triangular_distribution</a>.  <a href="group__common__functions.html#classhydra_1_1TriangularShape">More...</a><br /></td></tr>
<tr class="separator:classhydra_1_1TriangularShape"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1UniformShape"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common__functions.html#classhydra_1_1UniformShape">UniformShape</a></td></tr>
<tr class="memdesc:classhydra_1_1UniformShape"><td class="mdescLeft">&#160;</td><td class="mdescRight">From: <a href="https://en.wikipedia.org/wiki/Uniform_distribution_(continuous)">https://en.wikipedia.org/wiki/Uniform_distribution_(continuous)</a>  <a href="group__common__functions.html#classhydra_1_1UniformShape">More...</a><br /></td></tr>
<tr class="separator:classhydra_1_1UniformShape"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1UserParameters"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fit.html#classhydra_1_1UserParameters">UserParameters</a></td></tr>
<tr class="memdesc:classhydra_1_1UserParameters"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class implementing a interface to ROOT::Minuit2::MnUserParameters.  <a href="group__fit.html#classhydra_1_1UserParameters">More...</a><br /></td></tr>
<tr class="separator:classhydra_1_1UserParameters"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1Vegas"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#classhydra_1_1Vegas">Vegas</a></td></tr>
<tr class="separator:classhydra_1_1Vegas"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1Vegas_3_01N_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_4_00_01GRND_01_4"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__numerical__integration.html#classhydra_1_1Vegas_3_01N_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_4_00_01GRND_01_4">Vegas&lt; N, hydra::detail::BackendPolicy&lt; BACKEND &gt;, GRND &gt;</a></td></tr>
<tr class="memdesc:classhydra_1_1Vegas_3_01N_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_4_00_01GRND_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to perform numerical integration using <a class="el" href="namespacehydra.html#classhydra_1_1Vegas">Vegas</a> algorithm.  <a href="group__numerical__integration.html#classhydra_1_1Vegas_3_01N_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_4_00_01GRND_01_4">More...</a><br /></td></tr>
<tr class="separator:classhydra_1_1Vegas_3_01N_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_4_00_01GRND_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1VegasState"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__numerical__integration.html#classhydra_1_1VegasState">VegasState</a></td></tr>
<tr class="memdesc:classhydra_1_1VegasState"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to hold resources and state of <a class="el" href="namespacehydra.html#classhydra_1_1Vegas">hydra::Vegas</a> integration algorithm.  <a href="group__numerical__integration.html#classhydra_1_1VegasState">More...</a><br /></td></tr>
<tr class="separator:classhydra_1_1VegasState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1VegasState_3_01N_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_4_01_4"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__numerical__integration.html#classhydra_1_1VegasState_3_01N_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_4_01_4">VegasState&lt; N, hydra::detail::BackendPolicy&lt; BACKEND &gt; &gt;</a></td></tr>
<tr class="memdesc:classhydra_1_1VegasState_3_01N_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_4_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to hold resources and state of <a class="el" href="namespacehydra.html#classhydra_1_1Vegas">hydra::Vegas</a> integration algorithm.  <a href="group__numerical__integration.html#classhydra_1_1VegasState_3_01N_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_4_01_4">More...</a><br /></td></tr>
<tr class="separator:classhydra_1_1VegasState_3_01N_00_01hydra_1_1detail_1_1BackendPolicy_3_01BACKEND_01_4_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1WignerDMatrix"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common__functions.html#classhydra_1_1WignerDMatrix">WignerDMatrix</a></td></tr>
<tr class="memdesc:classhydra_1_1WignerDMatrix"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the beta-term </p><p class="formulaDsp">
\[ d^j_{mn}(beta) \]
</p>
<p> in the matrix element of the finite rotation operator (Wigner's D-function), according to formula 4.3.4(eq.  <a href="group__common__functions.html#classhydra_1_1WignerDMatrix">More...</a><br /></td></tr>
<tr class="separator:classhydra_1_1WignerDMatrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classhydra_1_1ZemachFunction"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common__functions.html#classhydra_1_1ZemachFunction">ZemachFunction</a></td></tr>
<tr class="memdesc:classhydra_1_1ZemachFunction"><td class="mdescLeft">&#160;</td><td class="mdescRight">Zemach's angular probability distribution for 3-body decays of spinless particle into spinless final states as a function of \(\theta\), the helicity angle:  <a href="group__common__functions.html#classhydra_1_1ZemachFunction">More...</a><br /></td></tr>
<tr class="separator:classhydra_1_1ZemachFunction"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a9be56668c1da1edd25b29c366adf5df9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9be56668c1da1edd25b29c366adf5df9"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a9be56668c1da1edd25b29c366adf5df9">complex</a> = hydra_thrust::complex&lt; T &gt;</td></tr>
<tr class="separator:a9be56668c1da1edd25b29c366adf5df9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e747e9ec41024e3efe0349f8ac10062"><td class="memItemLeft" align="right" valign="top">typedef hydra_thrust::random::default_random_engine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a1e747e9ec41024e3efe0349f8ac10062">default_random_engine</a></td></tr>
<tr class="memdesc:a1e747e9ec41024e3efe0349f8ac10062"><td class="mdescLeft">&#160;</td><td class="mdescRight">An implementation-defined "default" random number engine.  <a href="#a1e747e9ec41024e3efe0349f8ac10062">More...</a><br /></td></tr>
<tr class="separator:a1e747e9ec41024e3efe0349f8ac10062"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad614c0d4d1799d691f39110ece55090c"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structhydra_1_1detail_1_1SobolTable.html">detail::SobolTable</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ad614c0d4d1799d691f39110ece55090c">default_sobol_table</a></td></tr>
<tr class="separator:ad614c0d4d1799d691f39110ece55090c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8c251ed5017d0638da929130062bcad"><td class="memItemLeft" align="right" valign="top">typedef bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#aa8c251ed5017d0638da929130062bcad">GBool_t</a></td></tr>
<tr class="memdesc:aa8c251ed5017d0638da929130062bcad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boolean (0=false, 1=true) (bool)  <a href="#aa8c251ed5017d0638da929130062bcad">More...</a><br /></td></tr>
<tr class="separator:aa8c251ed5017d0638da929130062bcad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2da2ab0037e6bca3cb7c15adc5c4125"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="namespace_3globalScope_4.html#classunsigned">unsigned</a> char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ae2da2ab0037e6bca3cb7c15adc5c4125">GByte_t</a></td></tr>
<tr class="memdesc:ae2da2ab0037e6bca3cb7c15adc5c4125"><td class="mdescLeft">&#160;</td><td class="mdescRight">Byte (8 bits) (unsigned char)  <a href="#ae2da2ab0037e6bca3cb7c15adc5c4125">More...</a><br /></td></tr>
<tr class="separator:ae2da2ab0037e6bca3cb7c15adc5c4125"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ab04a199389c4989174dc115507fa89"><td class="memItemLeft" align="right" valign="top">typedef char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a7ab04a199389c4989174dc115507fa89">GChar_t</a></td></tr>
<tr class="memdesc:a7ab04a199389c4989174dc115507fa89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed Character 1 byte (char)  <a href="#a7ab04a199389c4989174dc115507fa89">More...</a><br /></td></tr>
<tr class="separator:a7ab04a199389c4989174dc115507fa89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af986267d40d932c5cbf0ae874a506f83"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#af986267d40d932c5cbf0ae874a506f83">GDouble_t</a></td></tr>
<tr class="memdesc:af986267d40d932c5cbf0ae874a506f83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Double 8 bytes.  <a href="#af986267d40d932c5cbf0ae874a506f83">More...</a><br /></td></tr>
<tr class="separator:af986267d40d932c5cbf0ae874a506f83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71bab7b854d7b3c3042fe47201b765eb"><td class="memItemLeft" align="right" valign="top">typedef float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a71bab7b854d7b3c3042fe47201b765eb">GFloat_t</a></td></tr>
<tr class="memdesc:a71bab7b854d7b3c3042fe47201b765eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Float 4 bytes (float)  <a href="#a71bab7b854d7b3c3042fe47201b765eb">More...</a><br /></td></tr>
<tr class="separator:a71bab7b854d7b3c3042fe47201b765eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c9fb4d7195ab952da10a82d5c4ad30e"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="namespace_3globalScope_4.html#classint">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a0c9fb4d7195ab952da10a82d5c4ad30e">GInt_t</a></td></tr>
<tr class="memdesc:a0c9fb4d7195ab952da10a82d5c4ad30e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed integer 4 bytes (int)  <a href="#a0c9fb4d7195ab952da10a82d5c4ad30e">More...</a><br /></td></tr>
<tr class="separator:a0c9fb4d7195ab952da10a82d5c4ad30e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d68c21fb715bbfb1edc5b1933b173e9"><td class="memItemLeft" align="right" valign="top">typedef long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a9d68c21fb715bbfb1edc5b1933b173e9">GLong64_t</a></td></tr>
<tr class="memdesc:a9d68c21fb715bbfb1edc5b1933b173e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Portable signed long integer 8 bytes.  <a href="#a9d68c21fb715bbfb1edc5b1933b173e9">More...</a><br /></td></tr>
<tr class="separator:a9d68c21fb715bbfb1edc5b1933b173e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f57a4025b40929c2708cd544c3a1ccd"><td class="memItemLeft" align="right" valign="top">typedef long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a5f57a4025b40929c2708cd544c3a1ccd">GLong_t</a></td></tr>
<tr class="memdesc:a5f57a4025b40929c2708cd544c3a1ccd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed long integer 4 bytes (long)  <a href="#a5f57a4025b40929c2708cd544c3a1ccd">More...</a><br /></td></tr>
<tr class="separator:a5f57a4025b40929c2708cd544c3a1ccd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a751abe69b482cde879c718fd4775733f"><td class="memItemLeft" align="right" valign="top">typedef long <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a751abe69b482cde879c718fd4775733f">GLongDouble_t</a></td></tr>
<tr class="memdesc:a751abe69b482cde879c718fd4775733f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Long Double.  <a href="#a751abe69b482cde879c718fd4775733f">More...</a><br /></td></tr>
<tr class="separator:a751abe69b482cde879c718fd4775733f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a971e94bcb8c43741d11f9d8eb98f5fab"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a></td></tr>
<tr class="memdesc:a971e94bcb8c43741d11f9d8eb98f5fab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Double 16 bytes or float 4 bytes.  <a href="#a971e94bcb8c43741d11f9d8eb98f5fab">More...</a><br /></td></tr>
<tr class="separator:a971e94bcb8c43741d11f9d8eb98f5fab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a589c60d92ba893c28d814edd6e149a9c"><td class="memItemLeft" align="right" valign="top">typedef short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a589c60d92ba893c28d814edd6e149a9c">GShort_t</a></td></tr>
<tr class="memdesc:a589c60d92ba893c28d814edd6e149a9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed Short integer 2 bytes (short)  <a href="#a589c60d92ba893c28d814edd6e149a9c">More...</a><br /></td></tr>
<tr class="separator:a589c60d92ba893c28d814edd6e149a9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc842c1ec8321e9637dee714dcdaebff"><td class="memItemLeft" align="right" valign="top">typedef char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#abc842c1ec8321e9637dee714dcdaebff">GText_t</a></td></tr>
<tr class="memdesc:abc842c1ec8321e9637dee714dcdaebff"><td class="mdescLeft">&#160;</td><td class="mdescRight">General string (char)  <a href="#abc842c1ec8321e9637dee714dcdaebff">More...</a><br /></td></tr>
<tr class="separator:abc842c1ec8321e9637dee714dcdaebff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51ef97faee95aa79f3839eb7abdf5238"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="namespace_3globalScope_4.html#classunsigned">unsigned</a> char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a51ef97faee95aa79f3839eb7abdf5238">GUChar_t</a></td></tr>
<tr class="memdesc:a51ef97faee95aa79f3839eb7abdf5238"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsigned Character 1 byte (unsigned char)  <a href="#a51ef97faee95aa79f3839eb7abdf5238">More...</a><br /></td></tr>
<tr class="separator:a51ef97faee95aa79f3839eb7abdf5238"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a251a7b1f515ac1ed9409afd67252a32b"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="namespace_3globalScope_4.html#classunsigned">unsigned</a> <a class="el" href="namespace_3globalScope_4.html#classint">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a251a7b1f515ac1ed9409afd67252a32b">GUInt_t</a></td></tr>
<tr class="memdesc:a251a7b1f515ac1ed9409afd67252a32b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsigned integer 4 bytes (unsigned int)  <a href="#a251a7b1f515ac1ed9409afd67252a32b">More...</a><br /></td></tr>
<tr class="separator:a251a7b1f515ac1ed9409afd67252a32b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55e8443cd746900da90cb1f77807e7c0"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="namespace_3globalScope_4.html#classunsigned">unsigned</a> long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a55e8443cd746900da90cb1f77807e7c0">GULong64_t</a></td></tr>
<tr class="memdesc:a55e8443cd746900da90cb1f77807e7c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Portable unsigned long integer 8 bytes.  <a href="#a55e8443cd746900da90cb1f77807e7c0">More...</a><br /></td></tr>
<tr class="separator:a55e8443cd746900da90cb1f77807e7c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf9a0d54fd4ed46052939549edd086c5"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="namespace_3globalScope_4.html#classunsigned">unsigned</a> long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#abf9a0d54fd4ed46052939549edd086c5">GULong_t</a></td></tr>
<tr class="separator:abf9a0d54fd4ed46052939549edd086c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a911a3042526fac189d0c87a089f52955"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="namespace_3globalScope_4.html#classunsigned">unsigned</a> short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a911a3042526fac189d0c87a089f52955">GUShort_t</a></td></tr>
<tr class="memdesc:a911a3042526fac189d0c87a089f52955"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsigned Short integer 2 bytes (unsigned short)  <a href="#a911a3042526fac189d0c87a089f52955">More...</a><br /></td></tr>
<tr class="separator:a911a3042526fac189d0c87a089f52955"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a764c9ef4c89f8ff3f6ae5c8c636b5642"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a764c9ef4c89f8ff3f6ae5c8c636b5642"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a764c9ef4c89f8ff3f6ae5c8c636b5642">mc_device_vector</a> = hydra_thrust::device_vector&lt; T &gt;</td></tr>
<tr class="memdesc:a764c9ef4c89f8ff3f6ae5c8c636b5642"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic template typedef for hydra_thrust::host_vector.  <a href="#a764c9ef4c89f8ff3f6ae5c8c636b5642">More...</a><br /></td></tr>
<tr class="separator:a764c9ef4c89f8ff3f6ae5c8c636b5642"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf5afa07506de0eb902a93ff656e8e25"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aaf5afa07506de0eb902a93ff656e8e25"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#aaf5afa07506de0eb902a93ff656e8e25">mc_host_vector</a> = hydra_thrust::host_vector&lt; T, hydra_thrust::system::cuda::experimental::pinned_allocator&lt; T &gt; &gt;</td></tr>
<tr class="memdesc:aaf5afa07506de0eb902a93ff656e8e25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic template typedef for hydra_thrust::host_vector.  <a href="#aaf5afa07506de0eb902a93ff656e8e25">More...</a><br /></td></tr>
<tr class="separator:aaf5afa07506de0eb902a93ff656e8e25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeccdd58e3a4c27246dadd0930e3fb569"><td class="memItemLeft" align="right" valign="top">typedef hydra_thrust::random::minstd_rand&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#aeccdd58e3a4c27246dadd0930e3fb569">minstd_rand</a></td></tr>
<tr class="memdesc:aeccdd58e3a4c27246dadd0930e3fb569"><td class="mdescLeft">&#160;</td><td class="mdescRight">A random number engine with predefined parameters which implements a version of the Minimal Standard random number generation algorithm.  <a href="#aeccdd58e3a4c27246dadd0930e3fb569">More...</a><br /></td></tr>
<tr class="separator:aeccdd58e3a4c27246dadd0930e3fb569"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7c3603cf7a6c467176d8be9dd2c82fd"><td class="memItemLeft" align="right" valign="top">typedef hydra_thrust::random::minstd_rand0&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ab7c3603cf7a6c467176d8be9dd2c82fd">minstd_rand0</a></td></tr>
<tr class="memdesc:ab7c3603cf7a6c467176d8be9dd2c82fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">A random number engine with predefined parameters which implements a version of the Minimal Standard random number generation algorithm.  <a href="#ab7c3603cf7a6c467176d8be9dd2c82fd">More...</a><br /></td></tr>
<tr class="separator:ab7c3603cf7a6c467176d8be9dd2c82fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a412c01a2247e7a463fc693a43310d00e"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a412c01a2247e7a463fc693a43310d00e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a412c01a2247e7a463fc693a43310d00e">pair</a> = hydra_thrust::pair&lt; T1, T2 &gt;</td></tr>
<tr class="memdesc:a412c01a2247e7a463fc693a43310d00e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>pair</code> template is an alias to the hydra_thrust::pair structure.  <a href="#a412c01a2247e7a463fc693a43310d00e">More...</a><br /></td></tr>
<tr class="separator:a412c01a2247e7a463fc693a43310d00e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a943a0571fdadbbb4bc9b17ba7ae4b59b"><td class="memItemLeft" align="right" valign="top">typedef hydra_thrust::random::ranlux24&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a943a0571fdadbbb4bc9b17ba7ae4b59b">ranlux24</a></td></tr>
<tr class="memdesc:a943a0571fdadbbb4bc9b17ba7ae4b59b"><td class="mdescLeft">&#160;</td><td class="mdescRight">A random number engine with predefined parameters which implements the RANLUX level-3 random number generation algorithm.  <a href="#a943a0571fdadbbb4bc9b17ba7ae4b59b">More...</a><br /></td></tr>
<tr class="separator:a943a0571fdadbbb4bc9b17ba7ae4b59b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6950c5abef4e2015f833501684940b5d"><td class="memItemLeft" align="right" valign="top">typedef hydra_thrust::random::ranlux48&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a6950c5abef4e2015f833501684940b5d">ranlux48</a></td></tr>
<tr class="memdesc:a6950c5abef4e2015f833501684940b5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A random number engine with predefined parameters which implements the RANLUX level-4 random number generation algorithm.  <a href="#a6950c5abef4e2015f833501684940b5d">More...</a><br /></td></tr>
<tr class="separator:a6950c5abef4e2015f833501684940b5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27378ecbb012326012d334cf11431549"><td class="memTemplParams" colspan="2">template&lt;unsigned D&gt; </td></tr>
<tr class="memitem:a27378ecbb012326012d334cf11431549"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a27378ecbb012326012d334cf11431549">sobol</a> = <a class="el" href="classhydra_1_1sobol__engine.html">sobol_engine</a>&lt; uint_least64_t, <a class="el" href="basic__distributions_8inl.html#a6f9cfa21f3993da1ed1a77acbc9bd9be">D</a>, 64u, default_sobol_table &gt;</td></tr>
<tr class="separator:a27378ecbb012326012d334cf11431549"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2633cfe1492c02cfb2aef6a79804f191"><td class="memItemLeft" align="right" valign="top">typedef hydra_thrust::random::taus88&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a2633cfe1492c02cfb2aef6a79804f191">taus88</a></td></tr>
<tr class="memdesc:a2633cfe1492c02cfb2aef6a79804f191"><td class="mdescLeft">&#160;</td><td class="mdescRight">A random number engine with predefined parameters which implements L'Ecuyer's 1996 three-component Tausworthe random number generator.  <a href="#a2633cfe1492c02cfb2aef6a79804f191">More...</a><br /></td></tr>
<tr class="separator:a2633cfe1492c02cfb2aef6a79804f191"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a717fc4e6b10453164099beade13d0226"><td class="memTemplParams" colspan="2">template&lt;typename... T&gt; </td></tr>
<tr class="memitem:a717fc4e6b10453164099beade13d0226"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a717fc4e6b10453164099beade13d0226">tuple</a> = hydra_thrust::tuple&lt; T... &gt;</td></tr>
<tr class="memdesc:a717fc4e6b10453164099beade13d0226"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>tuple</code> template is an alias to the variadic version of hydra_thrust::tuple and that can be instantiated with a indefinite number of arguments.  <a href="#a717fc4e6b10453164099beade13d0226">More...</a><br /></td></tr>
<tr class="separator:a717fc4e6b10453164099beade13d0226"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fb67e052a2a37c16a026792014cc585"><td class="memTemplParams" colspan="2">template&lt;int N, class T &gt; </td></tr>
<tr class="memitem:a2fb67e052a2a37c16a026792014cc585"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a2fb67e052a2a37c16a026792014cc585">tuple_element</a> = hydra_thrust::tuple_element&lt; N, T &gt;</td></tr>
<tr class="memdesc:a2fb67e052a2a37c16a026792014cc585"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <code>get</code> function returns a <code>const</code> reference to a <code>tuple</code> element of interest.  <a href="#a2fb67e052a2a37c16a026792014cc585">More...</a><br /></td></tr>
<tr class="separator:a2fb67e052a2a37c16a026792014cc585"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea1e8b0aafd04f1005a05ae93a72bf9b"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:aea1e8b0aafd04f1005a05ae93a72bf9b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#aea1e8b0aafd04f1005a05ae93a72bf9b">tuple_size</a> = hydra_thrust::tuple_size&lt; T &gt;</td></tr>
<tr class="memdesc:aea1e8b0aafd04f1005a05ae93a72bf9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This metafunction returns the number of elements of a <code>tuple</code> type of interest.  <a href="#aea1e8b0aafd04f1005a05ae93a72bf9b">More...</a><br /></td></tr>
<tr class="separator:aea1e8b0aafd04f1005a05ae93a72bf9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ad59ea019090ed4c8a3aa6d8cab9ea696"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="namespacehydra.html#ad59ea019090ed4c8a3aa6d8cab9ea696aae772e8b4c5ada0e1e4c65495702176a">MODE_IMPORTANCE</a> = 1, 
<a class="el" href="namespacehydra.html#ad59ea019090ed4c8a3aa6d8cab9ea696a28550661921a3af1306fa74a26b8569c">MODE_IMPORTANCE_ONLY</a> = 0, 
<a class="el" href="namespacehydra.html#ad59ea019090ed4c8a3aa6d8cab9ea696acb2c0124fecbf6c1182f1cf7cd9bc37a">MODE_STRATIFIED</a> = -1, 
<a class="el" href="namespacehydra.html#ad59ea019090ed4c8a3aa6d8cab9ea696aba2629d0445cc7ef401fd6793f047da0">BINS_MAX</a> = 50
 }</td></tr>
<tr class="separator:ad59ea019090ed4c8a3aa6d8cab9ea696"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad87c68ca6adb981f4c31ae73ef97de3b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="namespacehydra.html#ad87c68ca6adb981f4c31ae73ef97de3ba4517ec382985cb7a39393c0da09e58d5">INFO</a> =0, 
<a class="el" href="namespacehydra.html#ad87c68ca6adb981f4c31ae73ef97de3ba1bf857a06d5b8463494a6fcac6f4ea26">WARNING</a> =1, 
<a class="el" href="namespacehydra.html#ad87c68ca6adb981f4c31ae73ef97de3badbc96f88184ea3a51f68df95e2b44851">ERROR</a> =2
 }</td></tr>
<tr class="separator:ad87c68ca6adb981f4c31ae73ef97de3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0dc858c0fb14ade1e8abc19cdd0959e2"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common__functions.html#ga0dc858c0fb14ade1e8abc19cdd0959e2">Wave</a> { <br />
&#160;&#160;<a class="el" href="group__common__functions.html#gga0dc858c0fb14ade1e8abc19cdd0959e2a4f4fc5545002d4eada7e2a14c27c5dfd">SWave</a> =0, 
<a class="el" href="group__common__functions.html#gga0dc858c0fb14ade1e8abc19cdd0959e2ae382eaafad7afe6dee68693249ff8a45">PWave</a>, 
<a class="el" href="group__common__functions.html#gga0dc858c0fb14ade1e8abc19cdd0959e2a74097dfe50b93307e587c23f9180b6b3">DWave</a>, 
<a class="el" href="group__common__functions.html#gga0dc858c0fb14ade1e8abc19cdd0959e2a82415de987820fb86ab995f1dee87db1">FWave</a>, 
<br />
&#160;&#160;<a class="el" href="group__common__functions.html#gga0dc858c0fb14ade1e8abc19cdd0959e2a113622b6b528bfd4a76d68e9a99ac032">GWave</a>, 
<a class="el" href="group__common__functions.html#gga0dc858c0fb14ade1e8abc19cdd0959e2af168d5a7a174aa70e881f13fdeaf4426">HWave</a>
<br />
 }</td></tr>
<tr class="memdesc:ga0dc858c0fb14ade1e8abc19cdd0959e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Orbital angular momentum tags.  <a href="group__common__functions.html#ga0dc858c0fb14ade1e8abc19cdd0959e2">More...</a><br /></td></tr>
<tr class="separator:ga0dc858c0fb14ade1e8abc19cdd0959e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga315c1e042b983e5b623b5046074b7c56"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__phsp.html#ga315c1e042b983e5b623b5046074b7c56">__hydra_align__</a> (16) Vector3R</td></tr>
<tr class="memdesc:ga315c1e042b983e5b623b5046074b7c56"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents three-dimensional Euclidian vectors and implements common operation performed on it.  <a href="group__phsp.html#ga315c1e042b983e5b623b5046074b7c56">More...</a><br /></td></tr>
<tr class="separator:ga315c1e042b983e5b623b5046074b7c56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e095cca28f6bec603156fd48914aefe"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5e095cca28f6bec603156fd48914aefe"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a5e095cca28f6bec603156fd48914aefe">abs</a> (const <a class="el" href="namespacehydra.html#a9be56668c1da1edd25b29c366adf5df9">complex</a>&lt; T &gt; &amp;z)</td></tr>
<tr class="separator:a5e095cca28f6bec603156fd48914aefe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a256097a85b1ce0eafa6e497f46d87383"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a256097a85b1ce0eafa6e497f46d87383"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespacehydra.html#a9be56668c1da1edd25b29c366adf5df9">complex</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a256097a85b1ce0eafa6e497f46d87383">acos</a> (const <a class="el" href="namespacehydra.html#a9be56668c1da1edd25b29c366adf5df9">complex</a>&lt; T &gt; &amp;z)</td></tr>
<tr class="separator:a256097a85b1ce0eafa6e497f46d87383"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec91f5ec5ff214023b38f72ec4ac1e76"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aec91f5ec5ff214023b38f72ec4ac1e76"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespacehydra.html#a9be56668c1da1edd25b29c366adf5df9">complex</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#aec91f5ec5ff214023b38f72ec4ac1e76">acosh</a> (const <a class="el" href="namespacehydra.html#a9be56668c1da1edd25b29c366adf5df9">complex</a>&lt; T &gt; &amp;z)</td></tr>
<tr class="separator:aec91f5ec5ff214023b38f72ec4ac1e76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5917e6644c8742bd0d3586066ee5de0"><td class="memTemplParams" colspan="2">template&lt;typename PDF1 , typename PDF2 , typename ... PDFs&gt; </td></tr>
<tr class="memitem:gad5917e6644c8742bd0d3586066ee5de0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__fit.html#classhydra_1_1PDFSumNonExtendable">PDFSumNonExtendable</a>&lt; PDF1, PDF2, PDFs... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__fit.html#gad5917e6644c8742bd0d3586066ee5de0">add_pdfs</a> (std::array&lt; <a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a>, sizeof...(PDFs)+1 &gt;const &amp;var_list, PDF1 const &amp;pdf1, PDF2 const &amp;pdf2, PDFs const &amp;...pdfs)</td></tr>
<tr class="memdesc:gad5917e6644c8742bd0d3586066ee5de0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to build up non-extendable pdfs models.  <a href="group__fit.html#gad5917e6644c8742bd0d3586066ee5de0">More...</a><br /></td></tr>
<tr class="separator:gad5917e6644c8742bd0d3586066ee5de0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e7cc3bb04eac1d1350bb41b254fc92b"><td class="memTemplParams" colspan="2">template&lt;typename PDF1 , typename PDF2 , typename ... PDFs&gt; </td></tr>
<tr class="memitem:ga7e7cc3bb04eac1d1350bb41b254fc92b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__fit.html#classhydra_1_1PDFSumExtendable">PDFSumExtendable</a>&lt; PDF1, PDF2, PDFs... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__fit.html#ga7e7cc3bb04eac1d1350bb41b254fc92b">add_pdfs</a> (std::array&lt; <a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a>, sizeof...(PDFs)+2 &gt;const &amp;var_list, PDF1 const &amp;pdf1, PDF2 const &amp;pdf2, PDFs const &amp;...pdfs)</td></tr>
<tr class="memdesc:ga7e7cc3bb04eac1d1350bb41b254fc92b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to build up extendable pdfs models.  <a href="group__fit.html#ga7e7cc3bb04eac1d1350bb41b254fc92b">More...</a><br /></td></tr>
<tr class="separator:ga7e7cc3bb04eac1d1350bb41b254fc92b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae96191cbaa62c58f63b7e58924362c24"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae96191cbaa62c58f63b7e58924362c24"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ae96191cbaa62c58f63b7e58924362c24">arg</a> (const <a class="el" href="namespacehydra.html#a9be56668c1da1edd25b29c366adf5df9">complex</a>&lt; T &gt; &amp;z)</td></tr>
<tr class="separator:ae96191cbaa62c58f63b7e58924362c24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a7e65b9bb4aca1f24356f2d43f91bda"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9a7e65b9bb4aca1f24356f2d43f91bda"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespacehydra.html#a9be56668c1da1edd25b29c366adf5df9">complex</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a9a7e65b9bb4aca1f24356f2d43f91bda">asin</a> (const <a class="el" href="namespacehydra.html#a9be56668c1da1edd25b29c366adf5df9">complex</a>&lt; T &gt; &amp;z)</td></tr>
<tr class="separator:a9a7e65b9bb4aca1f24356f2d43f91bda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd779382ac3242158686664a9a3ca3a0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abd779382ac3242158686664a9a3ca3a0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespacehydra.html#a9be56668c1da1edd25b29c366adf5df9">complex</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#abd779382ac3242158686664a9a3ca3a0">asinh</a> (const <a class="el" href="namespacehydra.html#a9be56668c1da1edd25b29c366adf5df9">complex</a>&lt; T &gt; &amp;z)</td></tr>
<tr class="separator:abd779382ac3242158686664a9a3ca3a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9772b7e92ecdf60524cde428c1670bd4"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9772b7e92ecdf60524cde428c1670bd4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespacehydra.html#a9be56668c1da1edd25b29c366adf5df9">complex</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a9772b7e92ecdf60524cde428c1670bd4">atan</a> (const <a class="el" href="namespacehydra.html#a9be56668c1da1edd25b29c366adf5df9">complex</a>&lt; T &gt; &amp;z)</td></tr>
<tr class="separator:a9772b7e92ecdf60524cde428c1670bd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24b7bc13880335fdf6964df5034ade29"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a24b7bc13880335fdf6964df5034ade29"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespacehydra.html#a9be56668c1da1edd25b29c366adf5df9">complex</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a24b7bc13880335fdf6964df5034ade29">atanh</a> (const <a class="el" href="namespacehydra.html#a9be56668c1da1edd25b29c366adf5df9">complex</a>&lt; T &gt; &amp;z)</td></tr>
<tr class="separator:a24b7bc13880335fdf6964df5034ade29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd995d684b15024c891571fe47518404"><td class="memTemplParams" colspan="2">template&lt;hydra::Wave L&gt; </td></tr>
<tr class="memitem:gacd995d684b15024c891571fe47518404"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__common__functions.html#gacd995d684b15024c891571fe47518404">BarrierFactor</a> (const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> d, const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> p0, const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> p)</td></tr>
<tr class="memdesc:gacd995d684b15024c891571fe47518404"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blatt-Weisskopf B' functions.  <a href="group__common__functions.html#gacd995d684b15024c891571fe47518404">More...</a><br /></td></tr>
<tr class="separator:gacd995d684b15024c891571fe47518404"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03f4e98f986e55037e1a01fe4d9b8fc8"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a03f4e98f986e55037e1a01fe4d9b8fc8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a03f4e98f986e55037e1a01fe4d9b8fc8">BarrierFactor&lt; hydra::DWave &gt;</a> (const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> radi, const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> p0, const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> p)</td></tr>
<tr class="separator:a03f4e98f986e55037e1a01fe4d9b8fc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5a1e302e48427c947ab2084811df1df"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:ac5a1e302e48427c947ab2084811df1df"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ac5a1e302e48427c947ab2084811df1df">BarrierFactor&lt; hydra::FWave &gt;</a> (const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> radi, const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> p0, const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> p)</td></tr>
<tr class="separator:ac5a1e302e48427c947ab2084811df1df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0e0a9c294368d8d5b74fb919e261bef"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:ac0e0a9c294368d8d5b74fb919e261bef"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ac0e0a9c294368d8d5b74fb919e261bef">BarrierFactor&lt; hydra::GWave &gt;</a> (const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> radi, const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> p0, const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> p)</td></tr>
<tr class="separator:ac0e0a9c294368d8d5b74fb919e261bef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae223d417259cf7e660fd89a54438d45b"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:ae223d417259cf7e660fd89a54438d45b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ae223d417259cf7e660fd89a54438d45b">BarrierFactor&lt; hydra::HWave &gt;</a> (const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> radi, const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> p0, const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> p)</td></tr>
<tr class="separator:ae223d417259cf7e660fd89a54438d45b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa78649879f76b3b52249830df2482980"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:aa78649879f76b3b52249830df2482980"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#aa78649879f76b3b52249830df2482980">BarrierFactor&lt; hydra::PWave &gt;</a> (const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> radi, const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> p0, const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> p)</td></tr>
<tr class="separator:aa78649879f76b3b52249830df2482980"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab59597f876fc220d388f5911bb9822c"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:aab59597f876fc220d388f5911bb9822c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#aab59597f876fc220d388f5911bb9822c">BarrierFactor&lt; hydra::SWave &gt;</a> (const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>, const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>, const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>)</td></tr>
<tr class="separator:aab59597f876fc220d388f5911bb9822c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9d562f964ef193664077363da8859e2"><td class="memTemplParams" colspan="2">template&lt;class C &gt; </td></tr>
<tr class="memitem:ab9d562f964ef193664077363da8859e2"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a> (const <a class="el" href="basic__distributions_8inl.html#a4900ef306eb9271438791f1a98b8ccba">C</a> &amp;c) -&gt; decltype(c.begin())</td></tr>
<tr class="separator:ab9d562f964ef193664077363da8859e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e149bee61e4ddabca7fa0aafa121fe1"><td class="memTemplParams" colspan="2">template&lt;class C &gt; </td></tr>
<tr class="memitem:a7e149bee61e4ddabca7fa0aafa121fe1"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a7e149bee61e4ddabca7fa0aafa121fe1">begin</a> (<a class="el" href="basic__distributions_8inl.html#a4900ef306eb9271438791f1a98b8ccba">C</a> &amp;&amp;c) -&gt; decltype(std::forward&lt; <a class="el" href="basic__distributions_8inl.html#a4900ef306eb9271438791f1a98b8ccba">C</a> &gt;(c).begin())</td></tr>
<tr class="separator:a7e149bee61e4ddabca7fa0aafa121fe1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c64031cbdf1765fdf74577297ddb758"><td class="memTemplParams" colspan="2">template&lt;class T , size_t N&gt; </td></tr>
<tr class="memitem:a6c64031cbdf1765fdf74577297ddb758"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a6c64031cbdf1765fdf74577297ddb758">begin</a> (T(&amp;array)[N])</td></tr>
<tr class="separator:a6c64031cbdf1765fdf74577297ddb758"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd4f46840c85ee014f1d237601913ae1"><td class="memTemplParams" colspan="2">template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename T , size_t N&gt; </td></tr>
<tr class="memitem:afd4f46840c85ee014f1d237601913ae1"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#afd4f46840c85ee014f1d237601913ae1">begin</a> (<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;, <a class="el" href="namespacehydra.html#classhydra_1_1multiarray">multiarray</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; const &amp;other) -&gt; decltype(other.begin(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;</td></tr>
<tr class="separator:afd4f46840c85ee014f1d237601913ae1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6483cec578e17112f07ba012a4dc50ed"><td class="memTemplParams" colspan="2">template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename T , size_t N&gt; </td></tr>
<tr class="memitem:a6483cec578e17112f07ba012a4dc50ed"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a6483cec578e17112f07ba012a4dc50ed">begin</a> (<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;, <a class="el" href="namespacehydra.html#classhydra_1_1multiarray">multiarray</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; &amp;other) -&gt; decltype(other.begin(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;</td></tr>
<tr class="separator:a6483cec578e17112f07ba012a4dc50ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20ab2350fcc599675e32aa7226258b22"><td class="memTemplParams" colspan="2">template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename ... T&gt; </td></tr>
<tr class="memitem:a20ab2350fcc599675e32aa7226258b22"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a20ab2350fcc599675e32aa7226258b22">begin</a> (<a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; hydra_thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; const &amp;other) -&gt; decltype(other.begin(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;</td></tr>
<tr class="separator:a20ab2350fcc599675e32aa7226258b22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf567807d28a79686b53c5380afcbbdc"><td class="memTemplParams" colspan="2">template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename ... T&gt; </td></tr>
<tr class="memitem:adf567807d28a79686b53c5380afcbbdc"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#adf567807d28a79686b53c5380afcbbdc">begin</a> (<a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; hydra_thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; &amp;other) -&gt; decltype(other.begin(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;</td></tr>
<tr class="separator:adf567807d28a79686b53c5380afcbbdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a608214dc8fa90b976dc3eb5e7a98327e"><td class="memTemplParams" colspan="2">template&lt;typename Iterable &gt; </td></tr>
<tr class="memitem:a608214dc8fa90b976dc3eb5e7a98327e"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; Iterable &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; hydra_thrust::permutation_iterator&lt; decltype(std::declval&lt; Iterable &amp; &gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()), hydra_thrust::transform_iterator&lt; <a class="el" href="structhydra_1_1detail_1_1RndUniform.html">detail::RndUniform</a>&lt; size_t, hydra_thrust::random::default_random_engine &gt;,hydra_thrust::counting_iterator&lt; size_t &gt;, size_t &gt; &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a608214dc8fa90b976dc3eb5e7a98327e">boost_strapped_range</a> (Iterable &amp;&amp;iterable, size_t seed)</td></tr>
<tr class="separator:a608214dc8fa90b976dc3eb5e7a98327e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39ca77c714b3e8b913c37d323cfd5640"><td class="memItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> Vector4R&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a39ca77c714b3e8b913c37d323cfd5640">boostTo</a> (const Vector4R &amp;rs, const Vector4R &amp;p4, bool inverse=false)</td></tr>
<tr class="separator:a39ca77c714b3e8b913c37d323cfd5640"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c1de9e4fabdb747b9e3352ef6298476"><td class="memItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> Vector4R&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a1c1de9e4fabdb747b9e3352ef6298476">boostTo</a> (const Vector4R &amp;rs, const Vector3R &amp;boost, bool inverse=false)</td></tr>
<tr class="separator:a1c1de9e4fabdb747b9e3352ef6298476"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae19bb84d35c2b4edaea63abe6c1298ef"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae19bb84d35c2b4edaea63abe6c1298ef"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ae19bb84d35c2b4edaea63abe6c1298ef">chebychev_1st_kind</a> (<a class="el" href="namespace_3globalScope_4.html#classunsigned">unsigned</a> <a class="el" href="crystal__ball__plus__exponential_8inl.html#a21f77208d6bc667560ff8aaf8f943b6a">n</a>, const T x)</td></tr>
<tr class="memdesc:ae19bb84d35c2b4edaea63abe6c1298ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of <a class="el" href="group__common__functions.html#classhydra_1_1Chebychev" title="The Chebyshev polynomials  (first kind) are polynomials with the largest possible leading coefficient...">Chebychev</a> polynomials of first kind \( P_n(n) \) using the recursive relation.  <a href="#ae19bb84d35c2b4edaea63abe6c1298ef">More...</a><br /></td></tr>
<tr class="separator:ae19bb84d35c2b4edaea63abe6c1298ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a610d6c3636b0ee33dcebe0f10bb9d7d1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a610d6c3636b0ee33dcebe0f10bb9d7d1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a610d6c3636b0ee33dcebe0f10bb9d7d1">chebychev_2nd_kind</a> (<a class="el" href="namespace_3globalScope_4.html#classunsigned">unsigned</a> <a class="el" href="crystal__ball__plus__exponential_8inl.html#a21f77208d6bc667560ff8aaf8f943b6a">n</a>, const T x)</td></tr>
<tr class="memdesc:a610d6c3636b0ee33dcebe0f10bb9d7d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of <a class="el" href="group__common__functions.html#classhydra_1_1Chebychev" title="The Chebyshev polynomials  (first kind) are polynomials with the largest possible leading coefficient...">Chebychev</a> polynomials of second kind \( P_n(n) \) using the recursive relation.  <a href="#a610d6c3636b0ee33dcebe0f10bb9d7d1">More...</a><br /></td></tr>
<tr class="separator:a610d6c3636b0ee33dcebe0f10bb9d7d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac35031f37b7ebb095def140f0a7b9aef"><td class="memTemplParams" colspan="2">template&lt;typename Iterable_Index , typename Iterable_Values &gt; </td></tr>
<tr class="memitem:ac35031f37b7ebb095def140f0a7b9aef"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ac35031f37b7ebb095def140f0a7b9aef">collect</a> (Iterable_Index &amp;indexing_scheme, Iterable_Values &amp;collected_values) -&gt; typename std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; Iterable_Index &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; Iterable_Values &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; hydra_thrust::permutation_iterator&lt; decltype(std::declval&lt; Iterable_Values &amp;&gt;().<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()), decltype(std::declval&lt; Iterable_Index &amp;&gt;().<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>())&gt; &gt;::type</td></tr>
<tr class="separator:ac35031f37b7ebb095def140f0a7b9aef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec19ef09aa95bbdb2230bd31d879b94d"><td class="memTemplParams" colspan="2">template&lt;hydra::detail::Backend BACKEND, typename T , size_t N, unsigned int... I&gt; </td></tr>
<tr class="memitem:aec19ef09aa95bbdb2230bd31d879b94d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#aec19ef09aa95bbdb2230bd31d879b94d">columns</a> (<a class="el" href="namespacehydra.html#classhydra_1_1multiarray">multiarray</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt;const &amp;other, <a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;...cls) -&gt; <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; decltype(std::declval&lt; <a class="el" href="namespacehydra.html#classhydra_1_1multiarray">multiarray</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt;const &amp;&gt;().<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;</td></tr>
<tr class="separator:aec19ef09aa95bbdb2230bd31d879b94d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac897e7fcbfbb068d5d29122253491201"><td class="memTemplParams" colspan="2">template&lt;hydra::detail::Backend BACKEND, typename T , size_t N, unsigned int... I&gt; </td></tr>
<tr class="memitem:ac897e7fcbfbb068d5d29122253491201"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ac897e7fcbfbb068d5d29122253491201">columns</a> (<a class="el" href="namespacehydra.html#classhydra_1_1multiarray">multiarray</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; &amp;other, <a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;...cls) -&gt; <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; decltype(std::declval&lt; <a class="el" href="namespacehydra.html#classhydra_1_1multiarray">multiarray</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; &amp;&amp;&gt;().<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;</td></tr>
<tr class="separator:ac897e7fcbfbb068d5d29122253491201"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcaf864dba8ea6caf619dfa3887a275c"><td class="memTemplParams" colspan="2">template&lt;hydra::detail::Backend BACKEND, typename ... T, unsigned int... I&gt; </td></tr>
<tr class="memitem:adcaf864dba8ea6caf619dfa3887a275c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#adcaf864dba8ea6caf619dfa3887a275c">columns</a> (<a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; hydra_thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt;&gt;const &amp;other, <a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;...cls) -&gt; <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; decltype(std::declval&lt; <a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; hydra_thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; const &amp;&gt;().<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;</td></tr>
<tr class="separator:adcaf864dba8ea6caf619dfa3887a275c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1944b47c3207786971f8931d6b18c6be"><td class="memTemplParams" colspan="2">template&lt;hydra::detail::Backend BACKEND, typename ... T, unsigned int... I&gt; </td></tr>
<tr class="memitem:a1944b47c3207786971f8931d6b18c6be"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a1944b47c3207786971f8931d6b18c6be">columns</a> (<a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; hydra_thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; &amp;other, <a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;...cls) -&gt; <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; decltype(std::declval&lt; <a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; hydra_thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; &amp;&gt;().<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;</td></tr>
<tr class="separator:a1944b47c3207786971f8931d6b18c6be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a085cd308929f36e2ea3b0c1975ac989f"><td class="memTemplParams" colspan="2">template&lt;typename Type , hydra::detail::Backend BACKEND, typename ... T&gt; </td></tr>
<tr class="memitem:a085cd308929f36e2ea3b0c1975ac989f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a085cd308929f36e2ea3b0c1975ac989f">columns</a> (<a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; hydra_thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; &amp;other) -&gt; <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; decltype(std::declval&lt; <a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; hydra_thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; &amp;&gt;().<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1index__in__tuple">detail::index_in_tuple</a>&lt; Type, hydra_thrust::tuple&lt; T... &gt; &gt;::value &gt;</td></tr>
<tr class="separator:a085cd308929f36e2ea3b0c1975ac989f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae10c8ab337cbc0b309aa95eb345ddc5d"><td class="memTemplParams" colspan="2">template&lt;typename T0 , typename T1 , typename ... Ts&gt; </td></tr>
<tr class="memitem:ae10c8ab337cbc0b309aa95eb345ddc5d"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;(<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt; T0 &gt;::value||<a class="el" href="structhydra_1_1detail_1_1is__hydra__lambda.html">detail::is_hydra_lambda</a>&lt; T0 &gt;::value) &amp;&amp;(<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt; T1 &gt;::value||<a class="el" href="structhydra_1_1detail_1_1is__hydra__lambda.html">detail::is_hydra_lambda</a>&lt; T1 &gt;::value) &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1all__true.html">detail::all_true</a>&lt;(<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt; Ts &gt;::value||<a class="el" href="structhydra_1_1detail_1_1is__hydra__lambda.html">detail::is_hydra_lambda</a>&lt; Ts &gt;::value)... &gt;::value, <a class="el" href="classhydra_1_1Compose.html">Compose</a>&lt; T0, T1, Ts... &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ae10c8ab337cbc0b309aa95eb345ddc5d">compose</a> (T0 const &amp;F0, T1 const &amp;F1, Ts const &amp;...Fs)</td></tr>
<tr class="separator:ae10c8ab337cbc0b309aa95eb345ddc5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2ffe3ace108474a31b8cb84ceae7f14"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad2ffe3ace108474a31b8cb84ceae7f14"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespacehydra.html#a9be56668c1da1edd25b29c366adf5df9">complex</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ad2ffe3ace108474a31b8cb84ceae7f14">conj</a> (const <a class="el" href="namespacehydra.html#a9be56668c1da1edd25b29c366adf5df9">complex</a>&lt; T &gt; &amp;z)</td></tr>
<tr class="separator:ad2ffe3ace108474a31b8cb84ceae7f14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f6311fb715b4a280af3c04790c7b122"><td class="memTemplParams" colspan="2">template&lt;typename Value_Type &gt; </td></tr>
<tr class="memitem:a0f6311fb715b4a280af3c04790c7b122"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; hydra_thrust::constant_iterator&lt; Value_Type &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a0f6311fb715b4a280af3c04790c7b122">constant_range</a> (const Value_Type &amp;value)</td></tr>
<tr class="separator:a0f6311fb715b4a280af3c04790c7b122"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade5b435c4a37bbda1d67cd8fe18b526f"><td class="memTemplParams" colspan="2">template&lt;detail::Backend BACKEND, detail::FFTCalculator FFTBackend, typename Functor , typename Kernel , typename Iterable , typename T  = typename detail::stripped_type&lt;typename hydra_thrust::iterator_traits&lt;decltype(std::declval&lt;Iterable&gt;().begin())&gt;::value_type&gt;::type, typename USING_CUDA_BACKEND  = typename std::conditional&lt; std::is_convertible&lt;detail::BackendPolicy&lt;BACKEND&gt;,hydra_thrust::system::cuda::tag &gt;::value, std::integral_constant&lt;int, 1&gt;,std::integral_constant&lt;int, 0&gt;&gt;::type, typename USING_CUFFT  = typename std::conditional&lt; FFTBackend==detail::CuFFT, std::integral_constant&lt;int, 1&gt;,std::integral_constant&lt;int, 0&gt;&gt;::type, typename GPU_DATA  = typename std::conditional&lt; std::is_convertible&lt;typename hydra_thrust::iterator_system&lt; decltype(std::declval&lt;Iterable&gt;().begin())&gt;::type,                        hydra_thrust::system::cuda::tag&gt;::value         , std::integral_constant&lt;int, 1&gt;, std::integral_constant&lt;int, 0&gt; &gt;::type&gt; </td></tr>
<tr class="memitem:ade5b435c4a37bbda1d67cd8fe18b526f"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_floating_point&lt; T &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; Iterable &gt;::value,void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ade5b435c4a37bbda1d67cd8fe18b526f">convolute</a> (<a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt; policy, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1FFTPolicy">detail::FFTPolicy</a>&lt; T, FFTBackend &gt; fft_policy, Functor const &amp;functor, Kernel const &amp;kernel, T <a class="el" href="particle__mass_8inl.html#aad36546e8175d2922bee165fe028fedc">min</a>, T <a class="el" href="particle__mass_8inl.html#a0b0ede69e8156eb97acc579b88e883de">max</a>, Iterable &amp;&amp;output, bool power_up=true)</td></tr>
<tr class="separator:ade5b435c4a37bbda1d67cd8fe18b526f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b928198a46f83eb9d2793e8e079ba5a"><td class="memTemplParams" colspan="2">template&lt;typename Iterable_Source , typename Iterable_Target &gt; </td></tr>
<tr class="memitem:a0b928198a46f83eb9d2793e8e079ba5a"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; Iterable_Source &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; Iterable_Target &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; decltype(std::declval&lt; Iterable_Target &amp; &gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>())&gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a0b928198a46f83eb9d2793e8e079ba5a">copy</a> (Iterable_Source &amp;&amp;source, Iterable_Target &amp;&amp;destination)</td></tr>
<tr class="separator:a0b928198a46f83eb9d2793e8e079ba5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28aa8ffeea73bf98ccab0fb7cd1c8116"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename OutputIterator &gt; </td></tr>
<tr class="memitem:a28aa8ffeea73bf98ccab0fb7cd1c8116"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a28aa8ffeea73bf98ccab0fb7cd1c8116">copy</a> (InputIterator first, InputIterator last, OutputIterator result)</td></tr>
<tr class="separator:a28aa8ffeea73bf98ccab0fb7cd1c8116"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98b97d9c4a1b0350ef7c2d646c8c504a"><td class="memTemplParams" colspan="2">template&lt;detail::Backend Backend, typename InputIterator , typename OutputIterator &gt; </td></tr>
<tr class="memitem:a98b97d9c4a1b0350ef7c2d646c8c504a"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a98b97d9c4a1b0350ef7c2d646c8c504a">copy</a> (<a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; Backend &gt; const &amp;policy, InputIterator first, InputIterator last, OutputIterator result)</td></tr>
<tr class="separator:a98b97d9c4a1b0350ef7c2d646c8c504a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82497912f037617b630d048bfcc515c0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a82497912f037617b630d048bfcc515c0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespacehydra.html#a9be56668c1da1edd25b29c366adf5df9">complex</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a82497912f037617b630d048bfcc515c0">cos</a> (const <a class="el" href="namespacehydra.html#a9be56668c1da1edd25b29c366adf5df9">complex</a>&lt; T &gt; &amp;z)</td></tr>
<tr class="separator:a82497912f037617b630d048bfcc515c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9aa7456a15f61cd1ed2b5ef7227409e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac9aa7456a15f61cd1ed2b5ef7227409e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespacehydra.html#a9be56668c1da1edd25b29c366adf5df9">complex</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ac9aa7456a15f61cd1ed2b5ef7227409e">cosh</a> (const <a class="el" href="namespacehydra.html#a9be56668c1da1edd25b29c366adf5df9">complex</a>&lt; T &gt; &amp;z)</td></tr>
<tr class="separator:ac9aa7456a15f61cd1ed2b5ef7227409e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d55d71b4eca1da2fac83a615ea4b990"><td class="memItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> Vector3R&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a6d55d71b4eca1da2fac83a615ea4b990">cross</a> (const Vector3R &amp;p1, const Vector3R &amp;p2)</td></tr>
<tr class="separator:a6d55d71b4eca1da2fac83a615ea4b990"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c937d0257bdadba3cfa1983d357f06b"><td class="memTemplParams" colspan="2">template&lt;typename Iterator &gt; </td></tr>
<tr class="memitem:a7c937d0257bdadba3cfa1983d357f06b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a7c937d0257bdadba3cfa1983d357f06b">distance</a> (Iterator first, Iterator last) -&gt; decltype(hydra_thrust::distance&lt; Iterator &gt;(first, last))</td></tr>
<tr class="separator:a7c937d0257bdadba3cfa1983d357f06b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fec57c554e6c86f34145e7aa8845506"><td class="memTemplParams" colspan="2">template&lt;typename F1 , typename F2 , typename ... Fs&gt; </td></tr>
<tr class="memitem:a4fec57c554e6c86f34145e7aa8845506"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;(<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt; F1 &gt;::value||<a class="el" href="structhydra_1_1detail_1_1is__hydra__lambda.html">detail::is_hydra_lambda</a>&lt; F1 &gt;::value) &amp;&amp;(<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt; F2 &gt;::value||<a class="el" href="structhydra_1_1detail_1_1is__hydra__lambda.html">detail::is_hydra_lambda</a>&lt; F2 &gt;::value), <a class="el" href="classhydra_1_1Divide.html">Divide</a>&lt; F1, F2 &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a4fec57c554e6c86f34145e7aa8845506">divide</a> (F1 const &amp;f1, F2 const &amp;f2)</td></tr>
<tr class="separator:a4fec57c554e6c86f34145e7aa8845506"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4274268d147e9a988f379326b73682b0"><td class="memTemplParams" colspan="2">template&lt;class C &gt; </td></tr>
<tr class="memitem:a4274268d147e9a988f379326b73682b0"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a4274268d147e9a988f379326b73682b0">end</a> (const <a class="el" href="basic__distributions_8inl.html#a4900ef306eb9271438791f1a98b8ccba">C</a> &amp;c) -&gt; decltype(c.end())</td></tr>
<tr class="separator:a4274268d147e9a988f379326b73682b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d1cd86c2f2c422730b87a5890dbaee3"><td class="memTemplParams" colspan="2">template&lt;class C &gt; </td></tr>
<tr class="memitem:a1d1cd86c2f2c422730b87a5890dbaee3"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a1d1cd86c2f2c422730b87a5890dbaee3">end</a> (<a class="el" href="basic__distributions_8inl.html#a4900ef306eb9271438791f1a98b8ccba">C</a> &amp;&amp;c) -&gt; decltype(std::forward&lt; <a class="el" href="basic__distributions_8inl.html#a4900ef306eb9271438791f1a98b8ccba">C</a> &gt;(c).end())</td></tr>
<tr class="separator:a1d1cd86c2f2c422730b87a5890dbaee3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e7ed93e81eae920f0c85fea012dc23c"><td class="memTemplParams" colspan="2">template&lt;class T , size_t N&gt; </td></tr>
<tr class="memitem:a3e7ed93e81eae920f0c85fea012dc23c"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a3e7ed93e81eae920f0c85fea012dc23c">end</a> (T(&amp;array)[N])</td></tr>
<tr class="separator:a3e7ed93e81eae920f0c85fea012dc23c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03f64a7db637f2f1865093311d69f0bc"><td class="memTemplParams" colspan="2">template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename T , size_t N&gt; </td></tr>
<tr class="memitem:a03f64a7db637f2f1865093311d69f0bc"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a03f64a7db637f2f1865093311d69f0bc">end</a> (<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;, <a class="el" href="namespacehydra.html#classhydra_1_1multiarray">multiarray</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; const &amp;other) -&gt; decltype(other.end(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;</td></tr>
<tr class="separator:a03f64a7db637f2f1865093311d69f0bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab07ef1a981144fec2ec0227a346bedf8"><td class="memTemplParams" colspan="2">template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename T , size_t N&gt; </td></tr>
<tr class="memitem:ab07ef1a981144fec2ec0227a346bedf8"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ab07ef1a981144fec2ec0227a346bedf8">end</a> (<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;, <a class="el" href="namespacehydra.html#classhydra_1_1multiarray">multiarray</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; &amp;other) -&gt; decltype(other.end(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;</td></tr>
<tr class="separator:ab07ef1a981144fec2ec0227a346bedf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c79b2fbe8baa0770d528d6847ad63fd"><td class="memTemplParams" colspan="2">template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename ... T&gt; </td></tr>
<tr class="memitem:a2c79b2fbe8baa0770d528d6847ad63fd"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a2c79b2fbe8baa0770d528d6847ad63fd">end</a> (<a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; hydra_thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; const &amp;other) -&gt; decltype(other.end(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;</td></tr>
<tr class="separator:a2c79b2fbe8baa0770d528d6847ad63fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4175978e51ef65de39c073ca98ff48a"><td class="memTemplParams" colspan="2">template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename ... T&gt; </td></tr>
<tr class="memitem:ae4175978e51ef65de39c073ca98ff48a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ae4175978e51ef65de39c073ca98ff48a">end</a> (<a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; hydra_thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; &amp;other) -&gt; decltype(other.end(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;</td></tr>
<tr class="separator:ae4175978e51ef65de39c073ca98ff48a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a9d4c5b0ed8b81a1ddc80ac67189b6f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> long <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a5a9d4c5b0ed8b81a1ddc80ac67189b6f">erfinv</a> (<a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> x)</td></tr>
<tr class="separator:a5a9d4c5b0ed8b81a1ddc80ac67189b6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadea4fcd2b0a13095c4408fbee01c2c72"><td class="memTemplParams" colspan="2">template&lt;hydra::detail::Backend BACKEND, typename Iterator , typename Functor &gt; </td></tr>
<tr class="memitem:gadea4fcd2b0a13095c4408fbee01c2c72"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__generic.html#gadea4fcd2b0a13095c4408fbee01c2c72">eval</a> (<a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt;, Functor const  &amp;functor, Iterator <a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>, Iterator <a class="el" href="namespacehydra.html#a4274268d147e9a988f379326b73682b0">end</a>) -&gt; typename <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt;::template container&lt; typename Functor::return_type &gt;</td></tr>
<tr class="memdesc:gadea4fcd2b0a13095c4408fbee01c2c72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate a hydra functor on a range using the parallel policy.  <a href="group__generic.html#gadea4fcd2b0a13095c4408fbee01c2c72">More...</a><br /></td></tr>
<tr class="separator:gadea4fcd2b0a13095c4408fbee01c2c72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3ea8aefb6b4ea0d33078e76114d4446"><td class="memTemplParams" colspan="2">template&lt;hydra::detail::Backend BACKEND, typename Iterator , typename ... Functors&gt; </td></tr>
<tr class="memitem:gad3ea8aefb6b4ea0d33078e76114d4446"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__generic.html#gad3ea8aefb6b4ea0d33078e76114d4446">eval</a> (<a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt;,hydra_thrust::tuple&lt; Functors... &gt; const  &amp;functors, Iterator <a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>, Iterator <a class="el" href="namespacehydra.html#a4274268d147e9a988f379326b73682b0">end</a>) -&gt; <a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; hydra_thrust::tuple&lt; typename Functors::return_type ... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt;&gt;</td></tr>
<tr class="memdesc:gad3ea8aefb6b4ea0d33078e76114d4446"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate a tuple of hydra functors on a range using the parallel policy.  <a href="group__generic.html#gad3ea8aefb6b4ea0d33078e76114d4446">More...</a><br /></td></tr>
<tr class="separator:gad3ea8aefb6b4ea0d33078e76114d4446"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8564abe3d04aa014ba0a6a40e6c5d599"><td class="memTemplParams" colspan="2">template&lt;hydra::detail::Backend BACKEND, typename Functor , typename Iterator , typename ... Iterators&gt; </td></tr>
<tr class="memitem:ga8564abe3d04aa014ba0a6a40e6c5d599"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__generic.html#ga8564abe3d04aa014ba0a6a40e6c5d599">eval</a> (<a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt;, Functor const  &amp;functor, Iterator <a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>, Iterator <a class="el" href="namespacehydra.html#a4274268d147e9a988f379326b73682b0">end</a>, Iterators... begins) -&gt; typename <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt;::template container&lt; typename Functor::return_type &gt;</td></tr>
<tr class="memdesc:ga8564abe3d04aa014ba0a6a40e6c5d599"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate a functor over a list of ranges.  <a href="group__generic.html#ga8564abe3d04aa014ba0a6a40e6c5d599">More...</a><br /></td></tr>
<tr class="separator:ga8564abe3d04aa014ba0a6a40e6c5d599"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6edb3602e25dac1a2653e2ce33450232"><td class="memTemplParams" colspan="2">template&lt;hydra::detail::Backend BACKEND, typename Iterator , typename ... Iterators, typename ... Functors&gt; </td></tr>
<tr class="memitem:ga6edb3602e25dac1a2653e2ce33450232"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__generic.html#ga6edb3602e25dac1a2653e2ce33450232">eval</a> (<a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt;, hydra_thrust::tuple&lt; Functors... &gt; const  &amp;functors, Iterator <a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>, Iterator <a class="el" href="namespacehydra.html#a4274268d147e9a988f379326b73682b0">end</a>, Iterators... begins) -&gt; <a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; hydra_thrust::tuple&lt; typename Functors::return_type ... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;</td></tr>
<tr class="memdesc:ga6edb3602e25dac1a2653e2ce33450232"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate a tuple of functors over a list of ranges.  <a href="group__generic.html#ga6edb3602e25dac1a2653e2ce33450232">More...</a><br /></td></tr>
<tr class="separator:ga6edb3602e25dac1a2653e2ce33450232"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5acb87c4eb594ddbf0c4322a11cf4d8a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5acb87c4eb594ddbf0c4322a11cf4d8a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespacehydra.html#a9be56668c1da1edd25b29c366adf5df9">complex</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a5acb87c4eb594ddbf0c4322a11cf4d8a">exp</a> (const <a class="el" href="namespacehydra.html#a9be56668c1da1edd25b29c366adf5df9">complex</a>&lt; T &gt; &amp;z)</td></tr>
<tr class="separator:a5acb87c4eb594ddbf0c4322a11cf4d8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a512babb40a76dd738ca038f5fa7b1d51"><td class="memTemplParams" colspan="2">template&lt;typename Engine , hydra::detail::Backend BACKEND, typename Iterator , typename FUNCTOR &gt; </td></tr>
<tr class="memitem:a512babb40a76dd738ca038f5fa7b1d51"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1has__rng__formula.html">hydra::detail::has_rng_formula</a>&lt; FUNCTOR &gt;::value &amp;&amp;std::is_convertible&lt; decltype(std::declval&lt; <a class="el" href="classhydra_1_1RngFormula.html">RngFormula</a>&lt; FUNCTOR &gt; &gt;).<a class="el" href="phsp__unweighting_8inl.html#aae0754269ece74173f4afd72643b7e3e">Generate</a>(std::declval&lt; Engine &amp; &gt;), std::declval&lt; FUNCTOR const  &amp; &gt;))), typename hydra_thrust::iterator_traits&lt; Iterator &gt;::value_type &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a512babb40a76dd738ca038f5fa7b1d51">fill_random</a> (<a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; const &amp;policy, Iterator <a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>, Iterator <a class="el" href="namespacehydra.html#a4274268d147e9a988f379326b73682b0">end</a>, FUNCTOR const &amp;functor, size_t seed)</td></tr>
<tr class="memdesc:a512babb40a76dd738ca038f5fa7b1d51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill a range with numbers distributed according a user defined distribution using a RNG analytical formula.  <a href="#a512babb40a76dd738ca038f5fa7b1d51">More...</a><br /></td></tr>
<tr class="separator:a512babb40a76dd738ca038f5fa7b1d51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c8bad583601746518bdf2e8cd07394d"><td class="memTemplParams" colspan="2">template&lt;typename Engine , typename Iterator , typename FUNCTOR &gt; </td></tr>
<tr class="memitem:ga6c8bad583601746518bdf2e8cd07394d"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1has__rng__formula.html">hydra::detail::has_rng_formula</a>&lt; FUNCTOR &gt;::value &amp;&amp;std::is_convertible&lt; decltype(std::declval&lt; <a class="el" href="classhydra_1_1RngFormula.html">RngFormula</a>&lt; FUNCTOR &gt; &gt;).<a class="el" href="phsp__unweighting_8inl.html#aae0754269ece74173f4afd72643b7e3e">Generate</a>(std::declval&lt; Engine &amp; &gt;), std::declval&lt; FUNCTOR const  &amp; &gt;))), typename hydra_thrust::iterator_traits&lt; Iterator &gt;::value_type &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ga6c8bad583601746518bdf2e8cd07394d">fill_random</a> (Iterator <a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>, Iterator <a class="el" href="namespacehydra.html#a4274268d147e9a988f379326b73682b0">end</a>, FUNCTOR const &amp;functor, size_t seed)</td></tr>
<tr class="memdesc:ga6c8bad583601746518bdf2e8cd07394d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill a range with numbers distributed according a user defined distribution using a RNG analytical formula.  <a href="#ga6c8bad583601746518bdf2e8cd07394d">More...</a><br /></td></tr>
<tr class="separator:ga6c8bad583601746518bdf2e8cd07394d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1cc4cdb2d1cef66ec9cd64977d917725"><td class="memTemplParams" colspan="2">template&lt;typename Engine , hydra::detail::Backend BACKEND, typename Iterable , typename FUNCTOR &gt; </td></tr>
<tr class="memitem:ga1cc4cdb2d1cef66ec9cd64977d917725"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; Iterable &gt;::value &amp;&amp;std::is_convertible&lt; decltype(*std::declval&lt; Iterable &gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()), typename FUNCTOR::return_type &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__random.html#ga1cc4cdb2d1cef66ec9cd64977d917725">fill_random</a> (<a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; const &amp;policy, Iterable &amp;&amp;iterable, FUNCTOR const &amp;functor, size_t seed)</td></tr>
<tr class="memdesc:ga1cc4cdb2d1cef66ec9cd64977d917725"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill a range with numbers distributed according a user defined distribution.  <a href="group__random.html#ga1cc4cdb2d1cef66ec9cd64977d917725">More...</a><br /></td></tr>
<tr class="separator:ga1cc4cdb2d1cef66ec9cd64977d917725"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeece1c5ccb29403fd0a8322a37e851d7"><td class="memTemplParams" colspan="2">template&lt;typename Engine , typename Iterable , typename FUNCTOR &gt; </td></tr>
<tr class="memitem:gaeece1c5ccb29403fd0a8322a37e851d7"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; Iterable &gt;::value &amp;&amp;std::is_convertible&lt; decltype(*std::declval&lt; Iterable &gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()), typename FUNCTOR::return_type &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__random.html#gaeece1c5ccb29403fd0a8322a37e851d7">fill_random</a> (Iterable &amp;&amp;iterable, FUNCTOR const &amp;functor, size_t seed)</td></tr>
<tr class="memdesc:gaeece1c5ccb29403fd0a8322a37e851d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill a range with numbers distributed according a user defined distribution.  <a href="group__random.html#gaeece1c5ccb29403fd0a8322a37e851d7">More...</a><br /></td></tr>
<tr class="separator:gaeece1c5ccb29403fd0a8322a37e851d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab04906caf93945fb2c86780c1cea2286"><td class="memTemplParams" colspan="2">template&lt;typename Engine , hydra::detail::Backend BACKEND, typename Iterator , typename FUNCTOR &gt; </td></tr>
<tr class="memitem:gab04906caf93945fb2c86780c1cea2286"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; !<a class="el" href="structhydra_1_1detail_1_1has__rng__formula.html">hydra::detail::has_rng_formula</a>&lt; FUNCTOR &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__random.html#gab04906caf93945fb2c86780c1cea2286">fill_random</a> (<a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; const &amp;policy, Iterator <a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>, Iterator <a class="el" href="namespacehydra.html#a4274268d147e9a988f379326b73682b0">end</a>, FUNCTOR const &amp;functor, size_t seed)</td></tr>
<tr class="memdesc:gab04906caf93945fb2c86780c1cea2286"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fall back function if <a class="el" href="classhydra_1_1RngFormula.html">RngFormula</a> is not implemented for the requested functor.  <a href="group__random.html#gab04906caf93945fb2c86780c1cea2286">More...</a><br /></td></tr>
<tr class="separator:gab04906caf93945fb2c86780c1cea2286"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c8bad583601746518bdf2e8cd07394d"><td class="memTemplParams" colspan="2">template&lt;typename Engine , typename Iterator , typename FUNCTOR &gt; </td></tr>
<tr class="memitem:ga6c8bad583601746518bdf2e8cd07394d"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; !<a class="el" href="structhydra_1_1detail_1_1has__rng__formula.html">hydra::detail::has_rng_formula</a>&lt; FUNCTOR &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__random.html#ga6c8bad583601746518bdf2e8cd07394d">fill_random</a> (Iterator <a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>, Iterator <a class="el" href="namespacehydra.html#a4274268d147e9a988f379326b73682b0">end</a>, FUNCTOR const &amp;functor, size_t seed)</td></tr>
<tr class="memdesc:ga6c8bad583601746518bdf2e8cd07394d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fall back function if <a class="el" href="classhydra_1_1RngFormula.html">RngFormula</a> is not implemented for the requested functor.  <a href="group__random.html#ga6c8bad583601746518bdf2e8cd07394d">More...</a><br /></td></tr>
<tr class="separator:ga6c8bad583601746518bdf2e8cd07394d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab04906caf93945fb2c86780c1cea2286"><td class="memTemplParams" colspan="2">template&lt;typename Engine , hydra::detail::Backend BACKEND, typename Iterator , typename FUNCTOR &gt; </td></tr>
<tr class="memitem:gab04906caf93945fb2c86780c1cea2286"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; !std::is_convertible&lt; decltype(std::declval&lt; <a class="el" href="classhydra_1_1RngFormula.html">RngFormula</a>&lt; FUNCTOR &gt; &gt;).<a class="el" href="phsp__unweighting_8inl.html#aae0754269ece74173f4afd72643b7e3e">Generate</a>(std::declval&lt; Engine &amp; &gt;), std::declval&lt; FUNCTOR const  &amp; &gt;))), typename std::iterator_traits&lt; Iterator &gt;::value_type &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1has__rng__formula.html">hydra::detail::has_rng_formula</a>&lt; FUNCTOR &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#gab04906caf93945fb2c86780c1cea2286">fill_random</a> (<a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; const &amp;policy, Iterator <a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>, Iterator <a class="el" href="namespacehydra.html#a4274268d147e9a988f379326b73682b0">end</a>, FUNCTOR const &amp;funct, size_t seed)</td></tr>
<tr class="memdesc:gab04906caf93945fb2c86780c1cea2286"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fall back function if RngFormula::Generate() return value is not convertible to functor return value.  <a href="#gab04906caf93945fb2c86780c1cea2286">More...</a><br /></td></tr>
<tr class="separator:gab04906caf93945fb2c86780c1cea2286"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c8bad583601746518bdf2e8cd07394d"><td class="memTemplParams" colspan="2">template&lt;typename Engine , typename Iterator , typename FUNCTOR &gt; </td></tr>
<tr class="memitem:ga6c8bad583601746518bdf2e8cd07394d"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; !std::is_convertible&lt; decltype(std::declval&lt; <a class="el" href="classhydra_1_1RngFormula.html">RngFormula</a>&lt; FUNCTOR &gt; &gt;).<a class="el" href="phsp__unweighting_8inl.html#aae0754269ece74173f4afd72643b7e3e">Generate</a>(std::declval&lt; Engine &amp; &gt;), std::declval&lt; FUNCTOR const  &amp; &gt;))), typename std::iterator_traits&lt; Iterator &gt;::value_type &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1has__rng__formula.html">hydra::detail::has_rng_formula</a>&lt; FUNCTOR &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ga6c8bad583601746518bdf2e8cd07394d">fill_random</a> (Iterator <a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>, Iterator <a class="el" href="namespacehydra.html#a4274268d147e9a988f379326b73682b0">end</a>, FUNCTOR const &amp;funct, size_t seed)</td></tr>
<tr class="memdesc:ga6c8bad583601746518bdf2e8cd07394d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fall back function if RngFormula::Generate() return value is not convertible to functor return value.  <a href="#ga6c8bad583601746518bdf2e8cd07394d">More...</a><br /></td></tr>
<tr class="separator:ga6c8bad583601746518bdf2e8cd07394d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1cc4cdb2d1cef66ec9cd64977d917725"><td class="memTemplParams" colspan="2">template&lt;typename Engine , hydra::detail::Backend BACKEND, typename Iterable , typename FUNCTOR &gt; </td></tr>
<tr class="memitem:ga1cc4cdb2d1cef66ec9cd64977d917725"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; !<a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; Iterable &gt;::value||!std::is_convertible&lt; decltype(*std::declval&lt; Iterable &gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()), typename FUNCTOR::return_type &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ga1cc4cdb2d1cef66ec9cd64977d917725">fill_random</a> (<a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; const &amp;policy, Iterable &amp;&amp;iterable, FUNCTOR const &amp;functor, size_t seed)</td></tr>
<tr class="memdesc:ga1cc4cdb2d1cef66ec9cd64977d917725"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fall back function if the argument is not an Iterable or if it is not convertible to the Functor return value.  <a href="#ga1cc4cdb2d1cef66ec9cd64977d917725">More...</a><br /></td></tr>
<tr class="separator:ga1cc4cdb2d1cef66ec9cd64977d917725"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeece1c5ccb29403fd0a8322a37e851d7"><td class="memTemplParams" colspan="2">template&lt;typename Engine , typename Iterable , typename FUNCTOR &gt; </td></tr>
<tr class="memitem:gaeece1c5ccb29403fd0a8322a37e851d7"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; !<a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; Iterable &gt;::value||!std::is_convertible&lt; decltype(*std::declval&lt; Iterable &gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()), typename FUNCTOR::return_type &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#gaeece1c5ccb29403fd0a8322a37e851d7">fill_random</a> (Iterable &amp;&amp;iterable, FUNCTOR const &amp;functor, size_t seed)</td></tr>
<tr class="memdesc:gaeece1c5ccb29403fd0a8322a37e851d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fall back function if the argument is not an Iterable or if it is not convertible to the Functor return value.  <a href="#gaeece1c5ccb29403fd0a8322a37e851d7">More...</a><br /></td></tr>
<tr class="separator:gaeece1c5ccb29403fd0a8322a37e851d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab0cc380e55d7f4d02106a74165f7162"><td class="memTemplParams" colspan="2">template&lt;typename Iterable , typename Functor &gt; </td></tr>
<tr class="memitem:aab0cc380e55d7f4d02106a74165f7162"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; Iterable &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1Range">hydra::Range</a>&lt; decltype(std::declval&lt; Iterable &gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>())&gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#aab0cc380e55d7f4d02106a74165f7162">filter</a> (Iterable &amp;&amp;container, Functor &amp;&amp;filter)</td></tr>
<tr class="separator:aab0cc380e55d7f4d02106a74165f7162"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10d99a671eb993b054706c645b533533"><td class="memTemplParams" colspan="2">template&lt;typename Iterable , typename Functor &gt; </td></tr>
<tr class="memitem:a10d99a671eb993b054706c645b533533"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; Iterable &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1Range">hydra::Range</a>&lt; decltype(std::declval&lt; Iterable &gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>())&gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a10d99a671eb993b054706c645b533533">filter</a> (Iterable &amp;&amp;container, Functor const &amp;filter)</td></tr>
<tr class="memdesc:a10d99a671eb993b054706c645b533533"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a filter to the range [first, last] and return a pair of iterators for the filtered events.  <a href="#a10d99a671eb993b054706c645b533533">More...</a><br /></td></tr>
<tr class="separator:a10d99a671eb993b054706c645b533533"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab056ed3df61b0755f67d96f8537c657f"><td class="memTemplParams" colspan="2">template&lt;typename Iterable , typename Functor &gt; </td></tr>
<tr class="memitem:ab056ed3df61b0755f67d96f8537c657f"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; Iterable &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; decltype(std::declval&lt; Iterable &amp; &gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>())&gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ab056ed3df61b0755f67d96f8537c657f">for_each</a> (Iterable &amp;&amp;iterable, Functor const &amp;functor)</td></tr>
<tr class="separator:ab056ed3df61b0755f67d96f8537c657f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f07a165f21dcc1cbbe1b48fdb609398"><td class="memTemplParams" colspan="2">template&lt;class ... T&gt; </td></tr>
<tr class="memitem:a6f07a165f21dcc1cbbe1b48fdb609398"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a6f07a165f21dcc1cbbe1b48fdb609398">forward_as_tuple</a> (T &amp;&amp;...t) -&gt; decltype(hydra_thrust::forward_as_tuple(std::forward&lt; T &gt;(t)...))</td></tr>
<tr class="memdesc:a6f07a165f21dcc1cbbe1b48fdb609398"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a tuple of references to the arguments in args suitable for forwarding as an argument to a function.  <a href="#a6f07a165f21dcc1cbbe1b48fdb609398">More...</a><br /></td></tr>
<tr class="separator:a6f07a165f21dcc1cbbe1b48fdb609398"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75feeef216747fa3b7c90b590f2761e8"><td class="memTemplParams" colspan="2">template&lt;typename Iterable_Source , typename Iterable_Target , typename Iterable_Map &gt; </td></tr>
<tr class="memitem:a75feeef216747fa3b7c90b590f2761e8"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; Iterable_Source &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; Iterable_Target &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; Iterable_Map &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; decltype(std::declval&lt; Iterable_Target &amp; &gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>())&gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a75feeef216747fa3b7c90b590f2761e8">gather</a> (Iterable_Source &amp;&amp;source, Iterable_Map &amp;&amp;map, Iterable_Target &amp;&amp;target)</td></tr>
<tr class="separator:a75feeef216747fa3b7c90b590f2761e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac71b87e64d6dbb15c41c8f77e95a8072"><td class="memTemplParams" colspan="2">template&lt;int I, int N, typename T &gt; </td></tr>
<tr class="memitem:ac71b87e64d6dbb15c41c8f77e95a8072"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ac71b87e64d6dbb15c41c8f77e95a8072">get</a> (T(&amp;array)[N])</td></tr>
<tr class="separator:ac71b87e64d6dbb15c41c8f77e95a8072"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a048ae1166f9c2988a3d1933b0a3843d7"><td class="memTemplParams" colspan="2">template&lt;int I, typename T &gt; </td></tr>
<tr class="memitem:a048ae1166f9c2988a3d1933b0a3843d7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a048ae1166f9c2988a3d1933b0a3843d7">get</a> (T *array)</td></tr>
<tr class="separator:a048ae1166f9c2988a3d1933b0a3843d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60f5ccfd225166dc9b3d89c0eff5a413"><td class="memTemplParams" colspan="2">template&lt;typename Type , typename ... T&gt; </td></tr>
<tr class="memitem:a60f5ccfd225166dc9b3d89c0eff5a413"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> Type &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a60f5ccfd225166dc9b3d89c0eff5a413">get</a> (hydra_thrust::tuple&lt; T... &gt; const &amp;t)</td></tr>
<tr class="memdesc:a60f5ccfd225166dc9b3d89c0eff5a413"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <code>get</code> function returns a reference to a <code>tuple</code> element of interest.  <a href="#a60f5ccfd225166dc9b3d89c0eff5a413">More...</a><br /></td></tr>
<tr class="separator:a60f5ccfd225166dc9b3d89c0eff5a413"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32d44a759daba901b4cd71a76ca9d86b"><td class="memTemplParams" colspan="2">template&lt;int N, typename ... T&gt; </td></tr>
<tr class="memitem:a32d44a759daba901b4cd71a76ca9d86b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> const hydra_thrust::tuple_element&lt; N, hydra_thrust::tuple&lt; T... &gt; &gt;::type &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a32d44a759daba901b4cd71a76ca9d86b">get</a> (hydra_thrust::tuple&lt; T... &gt; const &amp;t)</td></tr>
<tr class="separator:a32d44a759daba901b4cd71a76ca9d86b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ab8f1851e2270ea973292200068d80c"><td class="memTemplParams" colspan="2">template&lt;typename Type , typename ... T&gt; </td></tr>
<tr class="memitem:a0ab8f1851e2270ea973292200068d80c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> Type &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a0ab8f1851e2270ea973292200068d80c">get</a> (hydra_thrust::tuple&lt; T... &gt; &amp;t)</td></tr>
<tr class="separator:a0ab8f1851e2270ea973292200068d80c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba82a044ff758f7eefe8627efc3a10a2"><td class="memTemplParams" colspan="2">template&lt;int N, typename ... T&gt; </td></tr>
<tr class="memitem:aba82a044ff758f7eefe8627efc3a10a2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::tuple_element&lt; N, hydra_thrust::tuple&lt; T... &gt; &gt;::type &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#aba82a044ff758f7eefe8627efc3a10a2">get</a> (hydra_thrust::tuple&lt; T... &gt; &amp;t)</td></tr>
<tr class="separator:aba82a044ff758f7eefe8627efc3a10a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a267c8e70bcec4d44eb523c0dac39ad"><td class="memTemplParams" colspan="2">template&lt;typename Type , typename ... T&gt; </td></tr>
<tr class="memitem:a4a267c8e70bcec4d44eb523c0dac39ad"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> Type &amp;&amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a4a267c8e70bcec4d44eb523c0dac39ad">get</a> (hydra_thrust::tuple&lt; T... &gt; &amp;&amp;t)</td></tr>
<tr class="separator:a4a267c8e70bcec4d44eb523c0dac39ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a247c447c60ebd2007261398741a274ba"><td class="memTemplParams" colspan="2">template&lt;int N, typename ... T&gt; </td></tr>
<tr class="memitem:a247c447c60ebd2007261398741a274ba"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::tuple_element&lt; N, hydra_thrust::tuple&lt; T... &gt; &gt;::type &amp;&amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a247c447c60ebd2007261398741a274ba">get</a> (hydra_thrust::tuple&lt; T... &gt; &amp;&amp;t)</td></tr>
<tr class="separator:a247c447c60ebd2007261398741a274ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49b811128ade29a492e778eb1a829ba3"><td class="memTemplParams" colspan="2">template&lt;int N, typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a49b811128ade29a492e778eb1a829ba3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::tuple_element&lt; N, hydra_thrust::pair&lt; T1, T2 &gt; &gt;::type &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a49b811128ade29a492e778eb1a829ba3">get</a> (hydra_thrust::pair&lt; T1, T2 &gt; &amp;t)</td></tr>
<tr class="separator:a49b811128ade29a492e778eb1a829ba3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8aefcb814b129eee45f1ec95fdf907a"><td class="memTemplParams" colspan="2">template&lt;int N, typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ad8aefcb814b129eee45f1ec95fdf907a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> const hydra_thrust::tuple_element&lt; N, hydra_thrust::pair&lt; T1, T2 &gt; &gt;::type &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ad8aefcb814b129eee45f1ec95fdf907a">get</a> (hydra_thrust::pair&lt; T1, T2 &gt; const &amp;t)</td></tr>
<tr class="separator:ad8aefcb814b129eee45f1ec95fdf907a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b0f0cce7a103359def82b175c766f9d"><td class="memTemplParams" colspan="2">template&lt;int N, typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a5b0f0cce7a103359def82b175c766f9d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::tuple_element&lt; N, hydra_thrust::pair&lt; T1, T2 &gt; &gt;::type &amp;&amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a5b0f0cce7a103359def82b175c766f9d">get</a> (hydra_thrust::pair&lt; T1, T2 &gt; &amp;&amp;t)</td></tr>
<tr class="separator:a5b0f0cce7a103359def82b175c766f9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2658beb74af1f617373f6f640e2949e4"><td class="memTemplParams" colspan="2">template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename T , size_t N&gt; </td></tr>
<tr class="memitem:a2658beb74af1f617373f6f640e2949e4"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a2658beb74af1f617373f6f640e2949e4">get</a> (<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;, <a class="el" href="namespacehydra.html#classhydra_1_1multiarray">multiarray</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; const &amp;other) -&gt; decltype(other.column(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;</td></tr>
<tr class="memdesc:a2658beb74af1f617373f6f640e2949e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the column <code>_I</code> of the <a class="el" href="namespacehydra.html#classhydra_1_1multiarray">hydra::multiarray</a>.  <a href="#a2658beb74af1f617373f6f640e2949e4">More...</a><br /></td></tr>
<tr class="separator:a2658beb74af1f617373f6f640e2949e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af63079c411073c082f1099994bd539af"><td class="memTemplParams" colspan="2">template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename T , size_t N&gt; </td></tr>
<tr class="memitem:af63079c411073c082f1099994bd539af"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#af63079c411073c082f1099994bd539af">get</a> (<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;, <a class="el" href="namespacehydra.html#classhydra_1_1multiarray">multiarray</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; &amp;other) -&gt; decltype(other.column(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;</td></tr>
<tr class="memdesc:af63079c411073c082f1099994bd539af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the column <code>_I</code> of the <a class="el" href="namespacehydra.html#classhydra_1_1multiarray">hydra::multiarray</a>.  <a href="#af63079c411073c082f1099994bd539af">More...</a><br /></td></tr>
<tr class="separator:af63079c411073c082f1099994bd539af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae440b48ee87508e2b2dadabfc85a9bcc"><td class="memTemplParams" colspan="2">template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename ... T&gt; </td></tr>
<tr class="memitem:ae440b48ee87508e2b2dadabfc85a9bcc"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ae440b48ee87508e2b2dadabfc85a9bcc">get</a> (<a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; hydra_thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; const &amp;other) -&gt; decltype(other.column(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;</td></tr>
<tr class="separator:ae440b48ee87508e2b2dadabfc85a9bcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7db056c1c062f48448f0bfaa0cd1eb32"><td class="memTemplParams" colspan="2">template&lt;typename ... T&gt; </td></tr>
<tr class="memitem:a7db056c1c062f48448f0bfaa0cd1eb32"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structhydra_1_1detail_1_1tuple__utility_1_1flat__tuple.html">detail::tuple_utility::flat_tuple</a>&lt; T... &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a7db056c1c062f48448f0bfaa0cd1eb32">get_flat_tuple</a> (T const &amp;... args)</td></tr>
<tr class="separator:a7db056c1c062f48448f0bfaa0cd1eb32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7582acf570b53c033d52c6ff0fecb43e"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a7582acf570b53c033d52c6ff0fecb43e"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a7582acf570b53c033d52c6ff0fecb43e">GetFormatedString</a> (const char *format, Args... args)</td></tr>
<tr class="separator:a7582acf570b53c033d52c6ff0fecb43e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7640497da0f9e58a93fbb73a130008af"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7640497da0f9e58a93fbb73a130008af"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a7640497da0f9e58a93fbb73a130008af">hermite</a> (<a class="el" href="namespace_3globalScope_4.html#classunsigned">unsigned</a> <a class="el" href="crystal__ball__plus__exponential_8inl.html#a21f77208d6bc667560ff8aaf8f943b6a">n</a>, const T x)</td></tr>
<tr class="memdesc:a7640497da0f9e58a93fbb73a130008af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of Hermite polynomials \( P_n(n) \) using the recursive relation.  <a href="#a7640497da0f9e58a93fbb73a130008af">More...</a><br /></td></tr>
<tr class="separator:a7640497da0f9e58a93fbb73a130008af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae56f5771a38cd48141f2e02712ac025f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae56f5771a38cd48141f2e02712ac025f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ae56f5771a38cd48141f2e02712ac025f">jacobi</a> (<a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> a, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> b, <a class="el" href="namespace_3globalScope_4.html#classunsigned">unsigned</a> <a class="el" href="crystal__ball__plus__exponential_8inl.html#a21f77208d6bc667560ff8aaf8f943b6a">n</a>, const T x)</td></tr>
<tr class="memdesc:ae56f5771a38cd48141f2e02712ac025f"><td class="mdescLeft">&#160;</td><td class="mdescRight">P_{n-1}^{(,)}(z) - 2 (n+ - 1) (n + -1) (2n+ + ) P_{n-2}^{(, )}(z), {align}&lt;/math&gt;  <a href="#ae56f5771a38cd48141f2e02712ac025f">More...</a><br /></td></tr>
<tr class="separator:ae56f5771a38cd48141f2e02712ac025f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fcbd1b972dcec1554ce96916da38a6f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9fcbd1b972dcec1554ce96916da38a6f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a9fcbd1b972dcec1554ce96916da38a6f">laguerre</a> (<a class="el" href="namespace_3globalScope_4.html#classunsigned">unsigned</a> <a class="el" href="crystal__ball__plus__exponential_8inl.html#a21f77208d6bc667560ff8aaf8f943b6a">n</a>, const T x)</td></tr>
<tr class="memdesc:a9fcbd1b972dcec1554ce96916da38a6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of Laguerre polynomials \( P_n(n) \) using the recursive relation.  <a href="#a9fcbd1b972dcec1554ce96916da38a6f">More...</a><br /></td></tr>
<tr class="separator:a9fcbd1b972dcec1554ce96916da38a6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17470c2d2376f96c63d7c89ed6b6cd5c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a17470c2d2376f96c63d7c89ed6b6cd5c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a17470c2d2376f96c63d7c89ed6b6cd5c">legendre</a> (<a class="el" href="namespace_3globalScope_4.html#classunsigned">unsigned</a> <a class="el" href="crystal__ball__plus__exponential_8inl.html#a21f77208d6bc667560ff8aaf8f943b6a">n</a>, const T x)</td></tr>
<tr class="memdesc:a17470c2d2376f96c63d7c89ed6b6cd5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of Legendre polynomials \( P_n(n) \) using the recursive relation.  <a href="#a17470c2d2376f96c63d7c89ed6b6cd5c">More...</a><br /></td></tr>
<tr class="separator:a17470c2d2376f96c63d7c89ed6b6cd5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2725e178af11595cbeba053c1f84dfa8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2725e178af11595cbeba053c1f84dfa8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespacehydra.html#a9be56668c1da1edd25b29c366adf5df9">complex</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a2725e178af11595cbeba053c1f84dfa8">log</a> (const <a class="el" href="namespacehydra.html#a9be56668c1da1edd25b29c366adf5df9">complex</a>&lt; T &gt; &amp;z)</td></tr>
<tr class="separator:a2725e178af11595cbeba053c1f84dfa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64d53a33e43032b9e482284fd1a38b08"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a64d53a33e43032b9e482284fd1a38b08"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespacehydra.html#a9be56668c1da1edd25b29c366adf5df9">complex</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a64d53a33e43032b9e482284fd1a38b08">log10</a> (const <a class="el" href="namespacehydra.html#a9be56668c1da1edd25b29c366adf5df9">complex</a>&lt; T &gt; &amp;z)</td></tr>
<tr class="separator:a64d53a33e43032b9e482284fd1a38b08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18b264f6b9b7f5c64e717b6fdff18a53"><td class="memTemplParams" colspan="2">template&lt;unsigned int ArgIndex, typename Functor , typename Kernel , detail::FFTCalculator FFTBackend, typename T  = typename std::common_type&lt;typename Functor::return_type, typename Kernel::return_type&gt;::type&gt; </td></tr>
<tr class="memitem:a18b264f6b9b7f5c64e717b6fdff18a53"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_floating_point&lt; T &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1ConvolutionFunctor">ConvolutionFunctor</a>&lt; Functor, Kernel, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1FFTPolicy">detail::FFTPolicy</a>&lt; T, FFTBackend &gt;, ArgIndex &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a18b264f6b9b7f5c64e717b6fdff18a53">make_convolution</a> (<a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1FFTPolicy">detail::FFTPolicy</a>&lt; T, FFTBackend &gt; policy, Functor const &amp;functor, Kernel const &amp;kernel, T kmin, T kmax, <a class="el" href="namespace_3globalScope_4.html#classunsigned">unsigned</a> nsamples)</td></tr>
<tr class="separator:a18b264f6b9b7f5c64e717b6fdff18a53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec6434cd5d4090bff5bbac363febb2df"><td class="memTemplParams" colspan="2">template&lt;typename ArgType , typename Functor , typename Kernel , detail::Backend BACKEND, detail::FFTCalculator FFT, typename T  = typename detail::stripped_type&lt;typename std::common_type&lt;typename Functor::return_type, typename Kernel::return_type&gt;::type&gt;::type&gt; </td></tr>
<tr class="memitem:aec6434cd5d4090bff5bbac363febb2df"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_floating_point&lt; T &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1ConvolutionFunctor">ConvolutionFunctor</a>&lt; Functor, Kernel, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1FFTPolicy">detail::FFTPolicy</a>&lt; T, FFT &gt;, ArgType &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#aec6434cd5d4090bff5bbac363febb2df">make_convolution</a> (<a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt; const &amp;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1FFTPolicy">detail::FFTPolicy</a>&lt; T, FFT &gt; const &amp;, Functor const &amp;functor, Kernel const &amp;kernel, T kmin, T kmax, <a class="el" href="namespace_3globalScope_4.html#classunsigned">unsigned</a> nsamples=1024, bool interpolate=true, bool power_up=true)</td></tr>
<tr class="separator:aec6434cd5d4090bff5bbac363febb2df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0a25f4f1f126bf7058fb3db42ff0396"><td class="memTemplParams" colspan="2">template&lt;typename Iterator1 , typename Iterator2 , typename T , size_t N, hydra::detail::Backend BACKEND&gt; </td></tr>
<tr class="memitem:ae0a25f4f1f126bf7058fb3db42ff0396"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__histogram.html#classhydra_1_1DenseHistogram">DenseHistogram</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1multidimensional">detail::multidimensional</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ae0a25f4f1f126bf7058fb3db42ff0396">make_dense_histogram</a> (<a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;, std::array&lt; size_t, N &gt; const &amp;grid, std::array&lt; T, N &gt; const &amp;lowerlimits, std::array&lt; T, N &gt; const &amp;upperlimits, Iterator1 first, Iterator1 <a class="el" href="namespacehydra.html#a4274268d147e9a988f379326b73682b0">end</a>, Iterator2 wfirst)</td></tr>
<tr class="separator:ae0a25f4f1f126bf7058fb3db42ff0396"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e1a3000b4a0d0b0660b52314134c8fa"><td class="memTemplParams" colspan="2">template&lt;typename Iterator , typename T , size_t N, hydra::detail::Backend BACKEND&gt; </td></tr>
<tr class="memitem:ga7e1a3000b4a0d0b0660b52314134c8fa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__histogram.html#classhydra_1_1DenseHistogram">DenseHistogram</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1multidimensional">detail::multidimensional</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__histogram.html#ga7e1a3000b4a0d0b0660b52314134c8fa">make_dense_histogram</a> (<a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt; backend, std::array&lt; size_t, N &gt;const &amp;grid, std::array&lt; T, N &gt; const &amp;lowerlimits, std::array&lt; T, N &gt; const &amp;upperlimits, Iterator first, Iterator <a class="el" href="namespacehydra.html#a4274268d147e9a988f379326b73682b0">end</a>)</td></tr>
<tr class="memdesc:ga7e1a3000b4a0d0b0660b52314134c8fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to make a N-dimensional dense histogram.  <a href="group__histogram.html#ga7e1a3000b4a0d0b0660b52314134c8fa">More...</a><br /></td></tr>
<tr class="separator:ga7e1a3000b4a0d0b0660b52314134c8fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53a84ebf42e3d3aead5a9d0801284a9e"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N, hydra::detail::Backend BACKEND, typename Iterable &gt; </td></tr>
<tr class="memitem:ga53a84ebf42e3d3aead5a9d0801284a9e"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; Iterable &gt;::value, <a class="el" href="group__histogram.html#classhydra_1_1DenseHistogram">DenseHistogram</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1multidimensional">detail::multidimensional</a> &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__histogram.html#ga53a84ebf42e3d3aead5a9d0801284a9e">make_dense_histogram</a> (<a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt; backend, std::array&lt; size_t, N &gt; const &amp;grid, std::array&lt; T, N &gt; const &amp;lowerlimits, std::array&lt; T, N &gt; const &amp;upperlimits, Iterable &amp;&amp;<a class="el" href="basic__distributions_8inl.html#a248ea98483ce90baaf65a7682438d72d">data</a>)</td></tr>
<tr class="memdesc:ga53a84ebf42e3d3aead5a9d0801284a9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to make a N-dimensional dense histogram.  <a href="group__histogram.html#ga53a84ebf42e3d3aead5a9d0801284a9e">More...</a><br /></td></tr>
<tr class="separator:ga53a84ebf42e3d3aead5a9d0801284a9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga425cd2dd0c24aaf04eade2e7b6205fe8"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N, hydra::detail::Backend BACKEND, typename Iterable1 , typename Iterable2 &gt; </td></tr>
<tr class="memitem:ga425cd2dd0c24aaf04eade2e7b6205fe8"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; Iterable1 &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; Iterable2 &gt;::value, <a class="el" href="group__histogram.html#classhydra_1_1DenseHistogram">DenseHistogram</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1multidimensional">detail::multidimensional</a> &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__histogram.html#ga425cd2dd0c24aaf04eade2e7b6205fe8">make_dense_histogram</a> (<a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt; backend, std::array&lt; size_t, N &gt; const &amp;grid, std::array&lt; T, N &gt; const &amp;lowerlimits, std::array&lt; T, N &gt; const &amp;upperlimits, Iterable1 &amp;&amp;<a class="el" href="basic__distributions_8inl.html#a248ea98483ce90baaf65a7682438d72d">data</a>, Iterable2 &amp;&amp;weight)</td></tr>
<tr class="memdesc:ga425cd2dd0c24aaf04eade2e7b6205fe8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to make a N-dimensional dense histogram.  <a href="group__histogram.html#ga425cd2dd0c24aaf04eade2e7b6205fe8">More...</a><br /></td></tr>
<tr class="separator:ga425cd2dd0c24aaf04eade2e7b6205fe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga74d16ad8a015b01bd88bbdea526f5f51"><td class="memTemplParams" colspan="2">template&lt;typename Iterator , typename T , hydra::detail::Backend BACKEND&gt; </td></tr>
<tr class="memitem:ga74d16ad8a015b01bd88bbdea526f5f51"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__histogram.html#classhydra_1_1DenseHistogram">DenseHistogram</a>&lt; T, 1, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1unidimensional">detail::unidimensional</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__histogram.html#ga74d16ad8a015b01bd88bbdea526f5f51">make_dense_histogram</a> (<a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt; backend, size_t nbins, T lowerlimit, T upperlimit, Iterator first, Iterator <a class="el" href="namespacehydra.html#a4274268d147e9a988f379326b73682b0">end</a>)</td></tr>
<tr class="memdesc:ga74d16ad8a015b01bd88bbdea526f5f51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to make a 1-dimensional dense histogram.  <a href="group__histogram.html#ga74d16ad8a015b01bd88bbdea526f5f51">More...</a><br /></td></tr>
<tr class="separator:ga74d16ad8a015b01bd88bbdea526f5f51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5fb0ff39a4c2cce59ab9b88f7289b88"><td class="memTemplParams" colspan="2">template&lt;typename Iterator1 , typename Iterator2 , typename T , hydra::detail::Backend BACKEND&gt; </td></tr>
<tr class="memitem:gaf5fb0ff39a4c2cce59ab9b88f7289b88"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__histogram.html#classhydra_1_1DenseHistogram">DenseHistogram</a>&lt; T, 1, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1unidimensional">detail::unidimensional</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__histogram.html#gaf5fb0ff39a4c2cce59ab9b88f7289b88">make_dense_histogram</a> (<a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt; backend, size_t nbins, T lowerlimit, T upperlimit, Iterator1 first, Iterator1 <a class="el" href="namespacehydra.html#a4274268d147e9a988f379326b73682b0">end</a>, Iterator2 wfirst)</td></tr>
<tr class="memdesc:gaf5fb0ff39a4c2cce59ab9b88f7289b88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to make a 1-dimensional dense histogram.  <a href="group__histogram.html#gaf5fb0ff39a4c2cce59ab9b88f7289b88">More...</a><br /></td></tr>
<tr class="separator:gaf5fb0ff39a4c2cce59ab9b88f7289b88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1050ca55613cd5c79c8f424c329466ad"><td class="memTemplParams" colspan="2">template&lt;typename T , hydra::detail::Backend BACKEND, typename Iterable &gt; </td></tr>
<tr class="memitem:ga1050ca55613cd5c79c8f424c329466ad"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; Iterable &gt;::value, <a class="el" href="group__histogram.html#classhydra_1_1DenseHistogram">DenseHistogram</a>&lt; T, 1, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1unidimensional">detail::unidimensional</a> &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__histogram.html#ga1050ca55613cd5c79c8f424c329466ad">make_dense_histogram</a> (<a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt; backend, size_t nbins, T lowerlimits, T upperlimits, Iterable &amp;&amp;<a class="el" href="basic__distributions_8inl.html#a248ea98483ce90baaf65a7682438d72d">data</a>)</td></tr>
<tr class="memdesc:ga1050ca55613cd5c79c8f424c329466ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to make a N-dimensional dense histogram.  <a href="group__histogram.html#ga1050ca55613cd5c79c8f424c329466ad">More...</a><br /></td></tr>
<tr class="separator:ga1050ca55613cd5c79c8f424c329466ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga867aff975628a4f23c6d5d22bc5baa80"><td class="memTemplParams" colspan="2">template&lt;typename T , hydra::detail::Backend BACKEND, typename Iterable1 , typename Iterable2 &gt; </td></tr>
<tr class="memitem:ga867aff975628a4f23c6d5d22bc5baa80"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; Iterable1 &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; Iterable2 &gt;::value, <a class="el" href="group__histogram.html#classhydra_1_1DenseHistogram">DenseHistogram</a>&lt; T, 1, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1unidimensional">detail::unidimensional</a> &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__histogram.html#ga867aff975628a4f23c6d5d22bc5baa80">make_dense_histogram</a> (<a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt; backend, size_t nbins, T lowerlimits, T upperlimits, Iterable1 &amp;&amp;<a class="el" href="basic__distributions_8inl.html#a248ea98483ce90baaf65a7682438d72d">data</a>, Iterable2 &amp;&amp;weight)</td></tr>
<tr class="memdesc:ga867aff975628a4f23c6d5d22bc5baa80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to make a N-dimensional dense histogram.  <a href="group__histogram.html#ga867aff975628a4f23c6d5d22bc5baa80">More...</a><br /></td></tr>
<tr class="separator:ga867aff975628a4f23c6d5d22bc5baa80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a000e95288951de54d3d420b07d3f13"><td class="memTemplParams" colspan="2">template&lt;typename... Pdfs, typename Iterator , typename ... Iterators&gt; </td></tr>
<tr class="memitem:ga8a000e95288951de54d3d420b07d3f13"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterator.html">detail::is_iterator</a>&lt; Iterator &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1are__iterators.html">detail::are_iterators</a>&lt; Iterators... &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1LogLikelihoodFCN">LogLikelihoodFCN</a>&lt; <a class="el" href="group__fit.html#classhydra_1_1PDFSumExtendable">PDFSumExtendable</a>&lt; Pdfs... &gt;, Iterator, Iterators... &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__fit.html#ga8a000e95288951de54d3d420b07d3f13">make_loglikehood_fcn</a> (<a class="el" href="group__fit.html#classhydra_1_1PDFSumExtendable">PDFSumExtendable</a>&lt; Pdfs... &gt; const &amp;functor, Iterator first, Iterator last, Iterators... weights)</td></tr>
<tr class="memdesc:ga8a000e95288951de54d3d420b07d3f13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conveniency function to build up loglikehood fcns.  <a href="group__fit.html#ga8a000e95288951de54d3d420b07d3f13">More...</a><br /></td></tr>
<tr class="separator:ga8a000e95288951de54d3d420b07d3f13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a000e95288951de54d3d420b07d3f13"><td class="memTemplParams" colspan="2">template&lt;typename... Pdfs, typename Iterator , typename ... Iterators&gt; </td></tr>
<tr class="memitem:ga8a000e95288951de54d3d420b07d3f13"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterator.html">hydra::detail::is_iterator</a>&lt; Iterator &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1are__iterators.html">detail::are_iterators</a>&lt; Iterators... &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1LogLikelihoodFCN">LogLikelihoodFCN</a>&lt; <a class="el" href="group__fit.html#classhydra_1_1PDFSumExtendable">PDFSumExtendable</a>&lt; Pdfs... &gt;, Iterator, Iterators... &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__fit.html#ga8a000e95288951de54d3d420b07d3f13">make_loglikehood_fcn</a> (<a class="el" href="group__fit.html#classhydra_1_1PDFSumExtendable">PDFSumExtendable</a>&lt; Pdfs... &gt; const &amp;functor, Iterator first, Iterator last, Iterators... weights)</td></tr>
<tr class="memdesc:ga8a000e95288951de54d3d420b07d3f13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conveniency function to build up loglikehood fcns.  <a href="group__fit.html#ga8a000e95288951de54d3d420b07d3f13">More...</a><br /></td></tr>
<tr class="separator:ga8a000e95288951de54d3d420b07d3f13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a66809b24de0479eacf80a3fe269c91"><td class="memTemplParams" colspan="2">template&lt;typename Functor , typename Integrator , typename Iterator , typename ... Iterators&gt; </td></tr>
<tr class="memitem:ga9a66809b24de0479eacf80a3fe269c91"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterator.html">detail::is_iterator</a>&lt; Iterator &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1are__iterators.html">detail::are_iterators</a>&lt; Iterators... &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1LogLikelihoodFCN">LogLikelihoodFCN</a>&lt; <a class="el" href="group__fit.html#classhydra_1_1Pdf">Pdf</a>&lt; Functor, <a class="el" href="multidimensional__fit_8inl.html#a6bdffffea16f0dcaa4e4c96eb2c8838f">Integrator</a> &gt;, Iterator, Iterators... &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__fit.html#ga9a66809b24de0479eacf80a3fe269c91">make_loglikehood_fcn</a> (<a class="el" href="group__fit.html#classhydra_1_1Pdf">Pdf</a>&lt; Functor, <a class="el" href="multidimensional__fit_8inl.html#a6bdffffea16f0dcaa4e4c96eb2c8838f">Integrator</a> &gt; const  &amp;pdf, Iterator first, Iterator last, Iterators... weights)</td></tr>
<tr class="memdesc:ga9a66809b24de0479eacf80a3fe269c91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conveniency function to build up loglikehood fcns.  <a href="group__fit.html#ga9a66809b24de0479eacf80a3fe269c91">More...</a><br /></td></tr>
<tr class="separator:ga9a66809b24de0479eacf80a3fe269c91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e01056ba9de1f6dfb8bed2f332a92d1"><td class="memTemplParams" colspan="2">template&lt;typename... Pdfs, typename Iterator , typename ... Iterators&gt; </td></tr>
<tr class="memitem:ga7e01056ba9de1f6dfb8bed2f332a92d1"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterator.html">hydra::detail::is_iterator</a>&lt; Iterator &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1are__iterators.html">detail::are_iterators</a>&lt; Iterators... &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1LogLikelihoodFCN">LogLikelihoodFCN</a>&lt; <a class="el" href="group__fit.html#classhydra_1_1PDFSumNonExtendable">PDFSumNonExtendable</a>&lt; Pdfs... &gt;, Iterator, Iterators... &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__fit.html#ga7e01056ba9de1f6dfb8bed2f332a92d1">make_loglikehood_fcn</a> (<a class="el" href="group__fit.html#classhydra_1_1PDFSumNonExtendable">PDFSumNonExtendable</a>&lt; Pdfs... &gt;const  &amp;pdf, Iterator first, Iterator last, Iterators... weights)</td></tr>
<tr class="memdesc:ga7e01056ba9de1f6dfb8bed2f332a92d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conveniency function to build up loglikehood fcns.  <a href="group__fit.html#ga7e01056ba9de1f6dfb8bed2f332a92d1">More...</a><br /></td></tr>
<tr class="separator:ga7e01056ba9de1f6dfb8bed2f332a92d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad95e718c107a9b491fd272dfd4cd3623"><td class="memTemplParams" colspan="2">template&lt;typename ... Pdfs, typename Iterable , typename ... Iterables&gt; </td></tr>
<tr class="memitem:gad95e718c107a9b491fd272dfd4cd3623"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;(!<a class="el" href="structhydra_1_1detail_1_1is__iterator.html">detail::is_iterator</a>&lt; Iterable &gt;::value) &amp;&amp;((sizeof...(Iterables)==0)||!<a class="el" href="structhydra_1_1detail_1_1are__iterators.html">detail::are_iterators</a>&lt; Iterables... &gt;::value) &amp;&amp;(!<a class="el" href="structhydra_1_1detail_1_1is__hydra__dense__histogram.html">hydra::detail::is_hydra_dense_histogram</a>&lt; typename std::remove_reference&lt; Iterable &gt;::type &gt;::value) &amp;&amp;(!<a class="el" href="structhydra_1_1detail_1_1is__hydra__sparse__histogram.html">hydra::detail::is_hydra_sparse_histogram</a>&lt; typename std::remove_reference&lt; Iterable &gt;::type &gt;::value) &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1is__iterable.html">detail::is_iterable</a>&lt; Iterable &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1are__iterables.html">detail::are_iterables</a>&lt; Iterables... &gt;::value,<a class="el" href="namespacehydra.html#classhydra_1_1LogLikelihoodFCN">LogLikelihoodFCN</a>&lt; <a class="el" href="group__fit.html#classhydra_1_1PDFSumExtendable">PDFSumExtendable</a>&lt; Pdfs... &gt;, decltype(std::declval&lt; Iterable &gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()), decltype(std::declval&lt; Iterables &gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>())... &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__fit.html#gad95e718c107a9b491fd272dfd4cd3623">make_loglikehood_fcn</a> (<a class="el" href="group__fit.html#classhydra_1_1PDFSumExtendable">PDFSumExtendable</a>&lt; Pdfs... &gt; const &amp;functor, Iterable &amp;&amp;points, Iterables &amp;&amp;... weights)</td></tr>
<tr class="memdesc:gad95e718c107a9b491fd272dfd4cd3623"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conveniency function to build up loglikehood fcns.  <a href="group__fit.html#gad95e718c107a9b491fd272dfd4cd3623">More...</a><br /></td></tr>
<tr class="separator:gad95e718c107a9b491fd272dfd4cd3623"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad95e718c107a9b491fd272dfd4cd3623"><td class="memTemplParams" colspan="2">template&lt;typename ... Pdfs, typename Iterable , typename... Iterables&gt; </td></tr>
<tr class="memitem:gad95e718c107a9b491fd272dfd4cd3623"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;(!<a class="el" href="structhydra_1_1detail_1_1is__iterator.html">detail::is_iterator</a>&lt; Iterable &gt;::value) &amp;&amp;((sizeof...(Iterables)==0)||!<a class="el" href="structhydra_1_1detail_1_1are__iterators.html">detail::are_iterators</a>&lt; Iterables... &gt;::value) &amp;&amp;(!<a class="el" href="structhydra_1_1detail_1_1is__hydra__dense__histogram.html">hydra::detail::is_hydra_dense_histogram</a>&lt; typename std::remove_reference&lt; Iterable &gt;::type &gt;::value) &amp;&amp;(!<a class="el" href="structhydra_1_1detail_1_1is__hydra__sparse__histogram.html">hydra::detail::is_hydra_sparse_histogram</a>&lt; typename std::remove_reference&lt; Iterable &gt;::type &gt;::value) &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1is__iterable.html">detail::is_iterable</a>&lt; Iterable &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1are__iterables.html">detail::are_iterables</a>&lt; Iterables... &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1LogLikelihoodFCN">LogLikelihoodFCN</a>&lt; <a class="el" href="group__fit.html#classhydra_1_1PDFSumExtendable">PDFSumExtendable</a>&lt; Pdfs... &gt;, decltype(std::declval&lt; Iterable &gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()), decltype(std::declval&lt; Iterables &gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>())... &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__fit.html#gad95e718c107a9b491fd272dfd4cd3623">make_loglikehood_fcn</a> (<a class="el" href="group__fit.html#classhydra_1_1PDFSumExtendable">PDFSumExtendable</a>&lt; Pdfs... &gt; const &amp;functor, Iterable &amp;&amp;points, Iterables &amp;&amp;...weights)</td></tr>
<tr class="memdesc:gad95e718c107a9b491fd272dfd4cd3623"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conveniency function to build up loglikehood fcns.  <a href="group__fit.html#gad95e718c107a9b491fd272dfd4cd3623">More...</a><br /></td></tr>
<tr class="separator:gad95e718c107a9b491fd272dfd4cd3623"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5da2d6085352cf67cc5d6116fdcf60be"><td class="memTemplParams" colspan="2">template&lt;typename Functor , typename Integrator , typename Iterable , typename ... Iterables&gt; </td></tr>
<tr class="memitem:ga5da2d6085352cf67cc5d6116fdcf60be"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;(!<a class="el" href="structhydra_1_1detail_1_1is__iterator.html">detail::is_iterator</a>&lt; Iterable &gt;::value) &amp;&amp;((sizeof...(Iterables)==0)||!<a class="el" href="structhydra_1_1detail_1_1are__iterators.html">detail::are_iterators</a>&lt; Iterables... &gt;::value) &amp;&amp;(!<a class="el" href="structhydra_1_1detail_1_1is__hydra__dense__histogram.html">hydra::detail::is_hydra_dense_histogram</a>&lt; typename std::remove_reference&lt; Iterable &gt;::type &gt;::value) &amp;&amp;(!<a class="el" href="structhydra_1_1detail_1_1is__hydra__sparse__histogram.html">hydra::detail::is_hydra_sparse_histogram</a>&lt; typename std::remove_reference&lt; Iterable &gt;::type &gt;::value) &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1is__iterable.html">detail::is_iterable</a>&lt; Iterable &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1are__iterables.html">detail::are_iterables</a>&lt; Iterables... &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1LogLikelihoodFCN">LogLikelihoodFCN</a>&lt; <a class="el" href="group__fit.html#classhydra_1_1Pdf">Pdf</a>&lt; Functor, <a class="el" href="multidimensional__fit_8inl.html#a6bdffffea16f0dcaa4e4c96eb2c8838f">Integrator</a> &gt;, decltype(std::declval&lt; Iterable &gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()), decltype(std::declval&lt; Iterables &gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>())... &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__fit.html#ga5da2d6085352cf67cc5d6116fdcf60be">make_loglikehood_fcn</a> (<a class="el" href="group__fit.html#classhydra_1_1Pdf">Pdf</a>&lt; Functor, <a class="el" href="multidimensional__fit_8inl.html#a6bdffffea16f0dcaa4e4c96eb2c8838f">Integrator</a> &gt; const  &amp;pdf, Iterable &amp;&amp;points, Iterables &amp;&amp;... weights)</td></tr>
<tr class="memdesc:ga5da2d6085352cf67cc5d6116fdcf60be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conveniency function to build up loglikehood fcns.  <a href="group__fit.html#ga5da2d6085352cf67cc5d6116fdcf60be">More...</a><br /></td></tr>
<tr class="separator:ga5da2d6085352cf67cc5d6116fdcf60be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab40d1c176811fa708505bbb08326c97d"><td class="memTemplParams" colspan="2">template&lt;typename ... Pdfs, typename Iterable , typename ... Iterables&gt; </td></tr>
<tr class="memitem:gab40d1c176811fa708505bbb08326c97d"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;(!<a class="el" href="structhydra_1_1detail_1_1is__iterator.html">detail::is_iterator</a>&lt; Iterable &gt;::value) &amp;&amp;((sizeof...(Iterables)==0)||!<a class="el" href="structhydra_1_1detail_1_1are__iterators.html">detail::are_iterators</a>&lt; Iterables... &gt;::value) &amp;&amp;(!<a class="el" href="structhydra_1_1detail_1_1is__hydra__dense__histogram.html">hydra::detail::is_hydra_dense_histogram</a>&lt; typename std::remove_reference&lt; Iterable &gt;::type &gt;::value) &amp;&amp;(!<a class="el" href="structhydra_1_1detail_1_1is__hydra__sparse__histogram.html">hydra::detail::is_hydra_sparse_histogram</a>&lt; typename std::remove_reference&lt; Iterable &gt;::type &gt;::value) &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; Iterable &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1are__iterables.html">detail::are_iterables</a>&lt; Iterables... &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1LogLikelihoodFCN">LogLikelihoodFCN</a>&lt; <a class="el" href="group__fit.html#classhydra_1_1PDFSumNonExtendable">PDFSumNonExtendable</a>&lt; Pdfs... &gt;, decltype(std::declval&lt; Iterable &gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()), decltype(std::declval&lt; Iterables &gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>())... &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__fit.html#gab40d1c176811fa708505bbb08326c97d">make_loglikehood_fcn</a> (<a class="el" href="group__fit.html#classhydra_1_1PDFSumNonExtendable">PDFSumNonExtendable</a>&lt; Pdfs... &gt; const  &amp;functor, Iterable &amp;&amp;points, Iterables &amp;&amp;... weights)</td></tr>
<tr class="memdesc:gab40d1c176811fa708505bbb08326c97d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conveniency function to build up loglikehood fcns.  <a href="group__fit.html#gab40d1c176811fa708505bbb08326c97d">More...</a><br /></td></tr>
<tr class="separator:gab40d1c176811fa708505bbb08326c97d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a820a933e48fa338a812a9f88bfb18e56"><td class="memTemplParams" colspan="2">template&lt;typename ... Pdfs, typename Histogram &gt; </td></tr>
<tr class="memitem:a820a933e48fa338a812a9f88bfb18e56"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__hydra__dense__histogram.html">detail::is_hydra_dense_histogram</a>&lt; Histogram &gt;::value||<a class="el" href="structhydra_1_1detail_1_1is__hydra__sparse__histogram.html">detail::is_hydra_sparse_histogram</a>&lt; Histogram &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1LogLikelihoodFCN">LogLikelihoodFCN</a>&lt; <a class="el" href="group__fit.html#classhydra_1_1PDFSumExtendable">PDFSumExtendable</a>&lt; Pdfs... &gt;, decltype(std::declval&lt; const Histogram &amp; &gt;).GetBinsCenters().<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()), decltype(std::declval&lt; const Histogram &amp; &gt;).GetBinsContents().<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()) &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a820a933e48fa338a812a9f88bfb18e56">make_loglikehood_fcn</a> (<a class="el" href="group__fit.html#classhydra_1_1PDFSumExtendable">PDFSumExtendable</a>&lt; Pdfs... &gt; const &amp;functor, Histogram const &amp;points)</td></tr>
<tr class="separator:a820a933e48fa338a812a9f88bfb18e56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga013d425d98994f7a1288f69915d30381"><td class="memTemplParams" colspan="2">template&lt;typename ... Pdfs, typename Histogram &gt; </td></tr>
<tr class="memitem:ga013d425d98994f7a1288f69915d30381"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__hydra__dense__histogram.html">detail::is_hydra_dense_histogram</a>&lt; Histogram &gt;::value||<a class="el" href="structhydra_1_1detail_1_1is__hydra__sparse__histogram.html">detail::is_hydra_sparse_histogram</a>&lt; Histogram &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1LogLikelihoodFCN">LogLikelihoodFCN</a>&lt; <a class="el" href="group__fit.html#classhydra_1_1PDFSumNonExtendable">PDFSumNonExtendable</a>&lt; Pdfs... &gt;, decltype(std::declval&lt; const Histogram &amp; &gt;).GetBinsCenters().<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()), decltype(std::declval&lt; const Histogram &amp; &gt;).GetBinsContents().<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()) &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__fit.html#ga013d425d98994f7a1288f69915d30381">make_loglikehood_fcn</a> (<a class="el" href="group__fit.html#classhydra_1_1PDFSumNonExtendable">PDFSumNonExtendable</a>&lt; Pdfs... &gt; const &amp;functor, Histogram const &amp;points)</td></tr>
<tr class="memdesc:ga013d425d98994f7a1288f69915d30381"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function to build up loglikehood fcns for densely and sparsely binned datasets.  <a href="group__fit.html#ga013d425d98994f7a1288f69915d30381">More...</a><br /></td></tr>
<tr class="separator:ga013d425d98994f7a1288f69915d30381"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabec44b969b69228eb8f17fa82ec96df0"><td class="memTemplParams" colspan="2">template&lt;typename Functor , typename Integrator , typename Histogram &gt; </td></tr>
<tr class="memitem:gabec44b969b69228eb8f17fa82ec96df0"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__hydra__dense__histogram.html">detail::is_hydra_dense_histogram</a>&lt; Histogram &gt;::value||<a class="el" href="structhydra_1_1detail_1_1is__hydra__sparse__histogram.html">detail::is_hydra_sparse_histogram</a>&lt; Histogram &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1LogLikelihoodFCN">LogLikelihoodFCN</a>&lt; <a class="el" href="group__fit.html#classhydra_1_1Pdf">Pdf</a>&lt; Functor, <a class="el" href="multidimensional__fit_8inl.html#a6bdffffea16f0dcaa4e4c96eb2c8838f">Integrator</a> &gt;, decltype(std::declval&lt; const Histogram &amp; &gt;).GetBinsCenters().<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()), decltype(std::declval&lt; const Histogram &amp; &gt;).GetBinsContents().<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>())&gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__fit.html#gabec44b969b69228eb8f17fa82ec96df0">make_loglikehood_fcn</a> (<a class="el" href="group__fit.html#classhydra_1_1Pdf">Pdf</a>&lt; Functor, <a class="el" href="multidimensional__fit_8inl.html#a6bdffffea16f0dcaa4e4c96eb2c8838f">Integrator</a> &gt; const &amp;pdf, Histogram const &amp;points)</td></tr>
<tr class="memdesc:gabec44b969b69228eb8f17fa82ec96df0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function to build up loglikehood fcns for densely and sparsely binned datasets.  <a href="group__fit.html#gabec44b969b69228eb8f17fa82ec96df0">More...</a><br /></td></tr>
<tr class="separator:gabec44b969b69228eb8f17fa82ec96df0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabec44b969b69228eb8f17fa82ec96df0"><td class="memTemplParams" colspan="2">template&lt;typename Functor , typename Integrator , typename Histogram &gt; </td></tr>
<tr class="memitem:gabec44b969b69228eb8f17fa82ec96df0"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__hydra__dense__histogram.html">detail::is_hydra_dense_histogram</a>&lt; Histogram &gt;::value||<a class="el" href="structhydra_1_1detail_1_1is__hydra__sparse__histogram.html">detail::is_hydra_sparse_histogram</a>&lt; Histogram &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1LogLikelihoodFCN">LogLikelihoodFCN</a>&lt; <a class="el" href="group__fit.html#classhydra_1_1Pdf">Pdf</a>&lt; Functor, <a class="el" href="multidimensional__fit_8inl.html#a6bdffffea16f0dcaa4e4c96eb2c8838f">Integrator</a> &gt;, decltype(std::declval&lt; const Histogram &gt;).GetBinsCenters().<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()), decltype(std::declval&lt; const Histogram &gt;).GetBinsContents().<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>())&gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__fit.html#gabec44b969b69228eb8f17fa82ec96df0">make_loglikehood_fcn</a> (<a class="el" href="group__fit.html#classhydra_1_1Pdf">Pdf</a>&lt; Functor, <a class="el" href="multidimensional__fit_8inl.html#a6bdffffea16f0dcaa4e4c96eb2c8838f">Integrator</a> &gt; const &amp;pdf, Histogram const &amp;points)</td></tr>
<tr class="memdesc:gabec44b969b69228eb8f17fa82ec96df0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function to build up loglikehood fcns for densely and sparsely binned datasets.  <a href="group__fit.html#gabec44b969b69228eb8f17fa82ec96df0">More...</a><br /></td></tr>
<tr class="separator:gabec44b969b69228eb8f17fa82ec96df0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc64c5495b930568c11a5c29bd553e4d"><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 &gt; </td></tr>
<tr class="memitem:acc64c5495b930568c11a5c29bd553e4d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#acc64c5495b930568c11a5c29bd553e4d">make_pair</a> (T1 &amp;&amp;t1, T2 &amp;&amp;t2) -&gt; decltype(hydra_thrust::make_pair(std::forward&lt; T1 &gt;(t1), std::forward&lt; T2 &gt;(t2)))</td></tr>
<tr class="memdesc:acc64c5495b930568c11a5c29bd553e4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This version of <code>make_pair</code> creates a new <code>pair</code> object from a list of objects.  <a href="#acc64c5495b930568c11a5c29bd553e4d">More...</a><br /></td></tr>
<tr class="separator:acc64c5495b930568c11a5c29bd553e4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d468a0d98a74f41479f8ccb95f5533e"><td class="memTemplParams" colspan="2">template&lt;typename FUNCTOR , typename INTEGRATOR &gt; </td></tr>
<tr class="memitem:ga2d468a0d98a74f41479f8ccb95f5533e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__fit.html#classhydra_1_1Pdf">Pdf</a>&lt; FUNCTOR, INTEGRATOR &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__fit.html#ga2d468a0d98a74f41479f8ccb95f5533e">make_pdf</a> (FUNCTOR const &amp;functor, INTEGRATOR integrator)</td></tr>
<tr class="memdesc:ga2d468a0d98a74f41479f8ccb95f5533e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a <a class="el" href="group__fit.html#classhydra_1_1Pdf" title="Class representing probability density functions. ">hydra::Pdf</a> given a shape described by a functor and a integrator (algorithm or functor).  <a href="group__fit.html#ga2d468a0d98a74f41479f8ccb95f5533e">More...</a><br /></td></tr>
<tr class="separator:ga2d468a0d98a74f41479f8ccb95f5533e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77c630f8a750d37a4644fc0be2f98c8c"><td class="memTemplParams" colspan="2">template&lt;typename Iterator , typename Functor &gt; </td></tr>
<tr class="memitem:a77c630f8a750d37a4644fc0be2f98c8c"><td class="memTemplItemLeft" align="right" valign="top">hydra_thrust::detail::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt; Functor &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; Iterator, Functor &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a77c630f8a750d37a4644fc0be2f98c8c">make_range</a> (Iterator <a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>, Iterator <a class="el" href="namespacehydra.html#a4274268d147e9a988f379326b73682b0">end</a>, Functor const &amp;functor)</td></tr>
<tr class="separator:a77c630f8a750d37a4644fc0be2f98c8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed731c061feb7b22667628e351da610b"><td class="memTemplParams" colspan="2">template&lt;typename Iterator &gt; </td></tr>
<tr class="memitem:aed731c061feb7b22667628e351da610b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; Iterator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#aed731c061feb7b22667628e351da610b">make_range</a> (Iterator <a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>, Iterator <a class="el" href="namespacehydra.html#a4274268d147e9a988f379326b73682b0">end</a>)</td></tr>
<tr class="separator:aed731c061feb7b22667628e351da610b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb94a482290a0c2c1764865e7d16dcf8"><td class="memTemplParams" colspan="2">template&lt;typename Iterable &gt; </td></tr>
<tr class="memitem:aeb94a482290a0c2c1764865e7d16dcf8"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; Iterable &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; decltype(std::declval&lt; Iterable &gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>())&gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#aeb94a482290a0c2c1764865e7d16dcf8">make_range</a> (Iterable const &amp;container)</td></tr>
<tr class="separator:aeb94a482290a0c2c1764865e7d16dcf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21c52c12d57be6225d5a286890b7def5"><td class="memTemplParams" colspan="2">template&lt;typename Iterable , typename Functor &gt; </td></tr>
<tr class="memitem:a21c52c12d57be6225d5a286890b7def5"><td class="memTemplItemLeft" align="right" valign="top">hydra_thrust::detail::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">detail::is_iterable</a>&lt; Iterable &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt; Functor &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; decltype(std::declval&lt; Iterable &gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()), Functor &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a21c52c12d57be6225d5a286890b7def5">make_range</a> (Iterable const &amp;iterable, Functor const &amp;functor)</td></tr>
<tr class="separator:a21c52c12d57be6225d5a286890b7def5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a997423cc7da26ee78b795e07a6910c29"><td class="memTemplParams" colspan="2">template&lt;typename Iterable &gt; </td></tr>
<tr class="memitem:a997423cc7da26ee78b795e07a6910c29"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; Iterable &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; decltype(std::declval&lt; Iterable &gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>())&gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a997423cc7da26ee78b795e07a6910c29">make_range</a> (Iterable &amp;&amp;container)</td></tr>
<tr class="separator:a997423cc7da26ee78b795e07a6910c29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac03229293f965b9aeb8704c32b0fa8bb"><td class="memTemplParams" colspan="2">template&lt;typename Iterable , typename Functor &gt; </td></tr>
<tr class="memitem:ac03229293f965b9aeb8704c32b0fa8bb"><td class="memTemplItemLeft" align="right" valign="top">hydra_thrust::detail::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">detail::is_iterable</a>&lt; Iterable &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt; Functor &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; decltype(std::declval&lt; Iterable &gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()), Functor &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ac03229293f965b9aeb8704c32b0fa8bb">make_range</a> (Iterable &amp;&amp;iterable, Functor const &amp;functor)</td></tr>
<tr class="separator:ac03229293f965b9aeb8704c32b0fa8bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e767e7adf0e19fd813cba22bf470f27"><td class="memTemplParams" colspan="2">template&lt;typename Iterator , typename Functor &gt; </td></tr>
<tr class="memitem:a4e767e7adf0e19fd813cba22bf470f27"><td class="memTemplItemLeft" align="right" valign="top">hydra_thrust::detail::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt; Functor &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; hydra_thrust::reverse_iterator&lt; Iterator &gt;, Functor &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a4e767e7adf0e19fd813cba22bf470f27">make_reverse_range</a> (Iterator <a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>, Iterator <a class="el" href="namespacehydra.html#a4274268d147e9a988f379326b73682b0">end</a>, Functor const &amp;functor)</td></tr>
<tr class="separator:a4e767e7adf0e19fd813cba22bf470f27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ba38bc66af36e3e6f949fcb49ac78d4"><td class="memTemplParams" colspan="2">template&lt;typename Iterator &gt; </td></tr>
<tr class="memitem:a8ba38bc66af36e3e6f949fcb49ac78d4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; hydra_thrust::reverse_iterator&lt; Iterator &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a8ba38bc66af36e3e6f949fcb49ac78d4">make_reverse_range</a> (Iterator <a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>, Iterator <a class="el" href="namespacehydra.html#a4274268d147e9a988f379326b73682b0">end</a>)</td></tr>
<tr class="separator:a8ba38bc66af36e3e6f949fcb49ac78d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8be66889f53db6bbae8365d509c13cd1"><td class="memTemplParams" colspan="2">template&lt;typename Iterable &gt; </td></tr>
<tr class="memitem:a8be66889f53db6bbae8365d509c13cd1"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__reverse__iterable.html">hydra::detail::is_reverse_iterable</a>&lt; Iterable &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; decltype(std::declval&lt; Iterable &gt;).<a class="el" href="namespacehydra.html#aadcca49207bf7ab79088f28cddb8f21d">rbegin</a>())&gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a8be66889f53db6bbae8365d509c13cd1">make_reverse_range</a> (Iterable const &amp;container)</td></tr>
<tr class="separator:a8be66889f53db6bbae8365d509c13cd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2416806c69de19541c8156b9e060dda"><td class="memTemplParams" colspan="2">template&lt;typename Iterable , typename Functor &gt; </td></tr>
<tr class="memitem:ae2416806c69de19541c8156b9e060dda"><td class="memTemplItemLeft" align="right" valign="top">hydra_thrust::detail::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__reverse__iterable.html">detail::is_reverse_iterable</a>&lt; Iterable &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt; Functor &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; decltype(std::declval&lt; Iterable &gt;).<a class="el" href="namespacehydra.html#aadcca49207bf7ab79088f28cddb8f21d">rbegin</a>()), Functor &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ae2416806c69de19541c8156b9e060dda">make_reverse_range</a> (Iterable const &amp;iterable, Functor const &amp;functor)</td></tr>
<tr class="separator:ae2416806c69de19541c8156b9e060dda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdb731a7ec634ab03b448a6cc6230d68"><td class="memTemplParams" colspan="2">template&lt;typename Iterable &gt; </td></tr>
<tr class="memitem:abdb731a7ec634ab03b448a6cc6230d68"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__reverse__iterable.html">hydra::detail::is_reverse_iterable</a>&lt; Iterable &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; decltype(std::declval&lt; Iterable &gt;).<a class="el" href="namespacehydra.html#aadcca49207bf7ab79088f28cddb8f21d">rbegin</a>())&gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#abdb731a7ec634ab03b448a6cc6230d68">make_reverse_range</a> (Iterable &amp;&amp;container)</td></tr>
<tr class="separator:abdb731a7ec634ab03b448a6cc6230d68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c9ee9245860252a898f227d242011f2"><td class="memTemplParams" colspan="2">template&lt;typename Iterable , typename Functor &gt; </td></tr>
<tr class="memitem:a8c9ee9245860252a898f227d242011f2"><td class="memTemplItemLeft" align="right" valign="top">hydra_thrust::detail::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__reverse__iterable.html">detail::is_reverse_iterable</a>&lt; Iterable &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt; Functor &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; decltype(std::declval&lt; Iterable &gt;).<a class="el" href="namespacehydra.html#aadcca49207bf7ab79088f28cddb8f21d">rbegin</a>()), Functor &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a8c9ee9245860252a898f227d242011f2">make_reverse_range</a> (Iterable &amp;&amp;iterable, Functor const &amp;functor)</td></tr>
<tr class="separator:a8c9ee9245860252a898f227d242011f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5516efc965b0602c90c67a6d831db1f"><td class="memTemplParams" colspan="2">template&lt;typename ... ESTIMATORS&gt; </td></tr>
<tr class="memitem:gac5516efc965b0602c90c67a6d831db1f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__fit.html#classhydra_1_1FCN">FCN</a>&lt; hydra_thrust::tuple&lt; <a class="el" href="group__fit.html#classhydra_1_1FCN">FCN</a>&lt; ESTIMATORS &gt;... &gt;, false &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__fit.html#gac5516efc965b0602c90c67a6d831db1f">make_simultaneous_fcn</a> (<a class="el" href="group__fit.html#classhydra_1_1FCN">FCN</a>&lt; ESTIMATORS &gt;const  &amp;... fcns)</td></tr>
<tr class="memdesc:gac5516efc965b0602c90c67a6d831db1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function to build up simultaneous fcn simultaneous.  <a href="group__fit.html#gac5516efc965b0602c90c67a6d831db1f">More...</a><br /></td></tr>
<tr class="separator:gac5516efc965b0602c90c67a6d831db1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2cea405a4f933f25af1f2afe7e67c381"><td class="memTemplParams" colspan="2">template&lt;typename Iterator , typename T , size_t N, hydra::detail::Backend BACKEND&gt; </td></tr>
<tr class="memitem:ga2cea405a4f933f25af1f2afe7e67c381"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__histogram.html#classhydra_1_1SparseHistogram">SparseHistogram</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1multidimensional">detail::multidimensional</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__histogram.html#ga2cea405a4f933f25af1f2afe7e67c381">make_sparse_histogram</a> (<a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt; backend, std::array&lt; size_t, N &gt; grid, std::array&lt; T, N &gt; const  &amp;lowerlimits, std::array&lt; T, N &gt; const  &amp;upperlimits, Iterator first, Iterator <a class="el" href="namespacehydra.html#a4274268d147e9a988f379326b73682b0">end</a>)</td></tr>
<tr class="memdesc:ga2cea405a4f933f25af1f2afe7e67c381"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to make a N-dimensional sparse histogram.  <a href="group__histogram.html#ga2cea405a4f933f25af1f2afe7e67c381">More...</a><br /></td></tr>
<tr class="separator:ga2cea405a4f933f25af1f2afe7e67c381"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace1d4a9273d0e841aa7aa81da8706684"><td class="memTemplParams" colspan="2">template&lt;typename Iterator1 , typename Iterator2 , typename T , size_t N, hydra::detail::Backend BACKEND&gt; </td></tr>
<tr class="memitem:gace1d4a9273d0e841aa7aa81da8706684"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__histogram.html#classhydra_1_1SparseHistogram">SparseHistogram</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1multidimensional">detail::multidimensional</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__histogram.html#gace1d4a9273d0e841aa7aa81da8706684">make_sparse_histogram</a> (<a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;, std::array&lt; size_t, N &gt; grid, std::array&lt; T, N &gt; const  &amp;lowerlimits, std::array&lt; T, N &gt; const  &amp;upperlimits, Iterator1 first, Iterator1 <a class="el" href="namespacehydra.html#a4274268d147e9a988f379326b73682b0">end</a>, Iterator2 wfirst)</td></tr>
<tr class="memdesc:gace1d4a9273d0e841aa7aa81da8706684"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to make a N-dimensional sparse histogram.  <a href="group__histogram.html#gace1d4a9273d0e841aa7aa81da8706684">More...</a><br /></td></tr>
<tr class="separator:gace1d4a9273d0e841aa7aa81da8706684"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaa5d26dd9be08404491e90f3848fc7d"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N, hydra::detail::Backend BACKEND, typename Iterable &gt; </td></tr>
<tr class="memitem:adaa5d26dd9be08404491e90f3848fc7d"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; Iterable &gt;::value, <a class="el" href="group__histogram.html#classhydra_1_1SparseHistogram">SparseHistogram</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1multidimensional">detail::multidimensional</a> &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#adaa5d26dd9be08404491e90f3848fc7d">make_sparse_histogram</a> (<a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt; backend, std::array&lt; size_t, N &gt; grid, std::array&lt; T, N &gt;lowerlimits, std::array&lt; T, N &gt; upperlimits, Iterable &amp;&amp;<a class="el" href="basic__distributions_8inl.html#a248ea98483ce90baaf65a7682438d72d">data</a>)</td></tr>
<tr class="separator:adaa5d26dd9be08404491e90f3848fc7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae548b2f803d456afc6b24b44dd78ef4f"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N, hydra::detail::Backend BACKEND, typename Iterable1 , typename Iterable2 &gt; </td></tr>
<tr class="memitem:ae548b2f803d456afc6b24b44dd78ef4f"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; Iterable1 &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; Iterable2 &gt;::value, <a class="el" href="group__histogram.html#classhydra_1_1SparseHistogram">SparseHistogram</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1multidimensional">detail::multidimensional</a> &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ae548b2f803d456afc6b24b44dd78ef4f">make_sparse_histogram</a> (<a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt; backend, std::array&lt; size_t, N &gt; grid, std::array&lt; T, N &gt;lowerlimits, std::array&lt; T, N &gt; upperlimits, Iterable1 &amp;&amp;<a class="el" href="basic__distributions_8inl.html#a248ea98483ce90baaf65a7682438d72d">data</a>, Iterable2 &amp;&amp;weights)</td></tr>
<tr class="separator:ae548b2f803d456afc6b24b44dd78ef4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab6e3d78381f90c669fa336097d09d5c0"><td class="memTemplParams" colspan="2">template&lt;typename Iterator , typename T , hydra::detail::Backend BACKEND&gt; </td></tr>
<tr class="memitem:gab6e3d78381f90c669fa336097d09d5c0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__histogram.html#classhydra_1_1SparseHistogram">SparseHistogram</a>&lt; T, 1, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1unidimensional">detail::unidimensional</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__histogram.html#gab6e3d78381f90c669fa336097d09d5c0">make_sparse_histogram</a> (<a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;, size_t grid, T lowerlimits, T upperlimits, Iterator first, Iterator <a class="el" href="namespacehydra.html#a4274268d147e9a988f379326b73682b0">end</a>)</td></tr>
<tr class="memdesc:gab6e3d78381f90c669fa336097d09d5c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to make a 1-dimensional sparse histogram.  <a href="group__histogram.html#gab6e3d78381f90c669fa336097d09d5c0">More...</a><br /></td></tr>
<tr class="separator:gab6e3d78381f90c669fa336097d09d5c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga72325d25e7c0db406f56f0ed37d9cb16"><td class="memTemplParams" colspan="2">template&lt;typename Iterator1 , typename Iterator2 , typename T , hydra::detail::Backend BACKEND&gt; </td></tr>
<tr class="memitem:ga72325d25e7c0db406f56f0ed37d9cb16"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__histogram.html#classhydra_1_1SparseHistogram">SparseHistogram</a>&lt; T, 1, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1unidimensional">detail::unidimensional</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__histogram.html#ga72325d25e7c0db406f56f0ed37d9cb16">make_sparse_histogram</a> (<a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;, size_t nbins, T lowerlimit, T upperlimit, Iterator1 first, Iterator1 <a class="el" href="namespacehydra.html#a4274268d147e9a988f379326b73682b0">end</a>, Iterator2 wfirst)</td></tr>
<tr class="memdesc:ga72325d25e7c0db406f56f0ed37d9cb16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to make a 1-dimensional sparse histogram.  <a href="group__histogram.html#ga72325d25e7c0db406f56f0ed37d9cb16">More...</a><br /></td></tr>
<tr class="separator:ga72325d25e7c0db406f56f0ed37d9cb16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf772e19944f8c86035f04729984ea5b3"><td class="memTemplParams" colspan="2">template&lt;typename T , hydra::detail::Backend BACKEND, typename Iterable &gt; </td></tr>
<tr class="memitem:gaf772e19944f8c86035f04729984ea5b3"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; Iterable &gt;::value, <a class="el" href="group__histogram.html#classhydra_1_1SparseHistogram">SparseHistogram</a>&lt; T, 1, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1unidimensional">detail::unidimensional</a> &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__histogram.html#gaf772e19944f8c86035f04729984ea5b3">make_sparse_histogram</a> (<a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt; backend, size_t nbins, T lowerlimit, T upperlimit, Iterable &amp;&amp;<a class="el" href="basic__distributions_8inl.html#a248ea98483ce90baaf65a7682438d72d">data</a>)</td></tr>
<tr class="memdesc:gaf772e19944f8c86035f04729984ea5b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to make a 1-dimensional sparse histogram.  <a href="group__histogram.html#gaf772e19944f8c86035f04729984ea5b3">More...</a><br /></td></tr>
<tr class="separator:gaf772e19944f8c86035f04729984ea5b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53da08c8853c06a09296703de19fcfcd"><td class="memTemplParams" colspan="2">template&lt;typename T , hydra::detail::Backend BACKEND, typename Iterable1 , typename Iterable2 &gt; </td></tr>
<tr class="memitem:ga53da08c8853c06a09296703de19fcfcd"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; Iterable1 &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; Iterable2 &gt;::value, <a class="el" href="group__histogram.html#classhydra_1_1SparseHistogram">SparseHistogram</a>&lt; T, 1, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1unidimensional">detail::unidimensional</a> &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__histogram.html#ga53da08c8853c06a09296703de19fcfcd">make_sparse_histogram</a> (<a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt; backend, size_t nbins, T lowerlimit, T upperlimit, Iterable1 &amp;&amp;<a class="el" href="basic__distributions_8inl.html#a248ea98483ce90baaf65a7682438d72d">data</a>, Iterable2 &amp;&amp;weights)</td></tr>
<tr class="memdesc:ga53da08c8853c06a09296703de19fcfcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to make a 1-dimensional sparse histogram.  <a href="group__histogram.html#ga53da08c8853c06a09296703de19fcfcd">More...</a><br /></td></tr>
<tr class="separator:ga53da08c8853c06a09296703de19fcfcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44b5da88b7e3276c71f2873d8f52c8e8"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N, hydra::detail::Backend BACKEND, typename Iterable &gt; </td></tr>
<tr class="memitem:ga44b5da88b7e3276c71f2873d8f52c8e8"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; Iterable &gt;::value, <a class="el" href="group__histogram.html#classhydra_1_1SparseHistogram">SparseHistogram</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1multidimensional">detail::multidimensional</a> &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__histogram.html#ga44b5da88b7e3276c71f2873d8f52c8e8">make_sparse_histogram</a> (<a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt; backend, std::array&lt; size_t, N &gt;const &amp;grid, std::array&lt; T, N &gt;const &amp;lowerlimits, std::array&lt; T, N &gt;const &amp;upperlimits, Iterable &amp;&amp;<a class="el" href="basic__distributions_8inl.html#a248ea98483ce90baaf65a7682438d72d">data</a>)</td></tr>
<tr class="memdesc:ga44b5da88b7e3276c71f2873d8f52c8e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to make a N-dimensional sparse histogram.  <a href="group__histogram.html#ga44b5da88b7e3276c71f2873d8f52c8e8">More...</a><br /></td></tr>
<tr class="separator:ga44b5da88b7e3276c71f2873d8f52c8e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac4d47defbb724b2a445de5bc66df2eff"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N, hydra::detail::Backend BACKEND, typename Iterable1 , typename Iterable2 &gt; </td></tr>
<tr class="memitem:gac4d47defbb724b2a445de5bc66df2eff"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; Iterable1 &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; Iterable2 &gt;::value, <a class="el" href="group__histogram.html#classhydra_1_1SparseHistogram">SparseHistogram</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1multidimensional">detail::multidimensional</a> &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__histogram.html#gac4d47defbb724b2a445de5bc66df2eff">make_sparse_histogram</a> (<a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt; backend, std::array&lt; size_t, N &gt;const &amp;grid, std::array&lt; T, N &gt;const &amp;lowerlimits, std::array&lt; T, N &gt;const &amp;upperlimits, Iterable1 &amp;&amp;<a class="el" href="basic__distributions_8inl.html#a248ea98483ce90baaf65a7682438d72d">data</a>, Iterable2 &amp;&amp;weights)</td></tr>
<tr class="memdesc:gac4d47defbb724b2a445de5bc66df2eff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to make a N-dimensional sparse histogram.  <a href="group__histogram.html#gac4d47defbb724b2a445de5bc66df2eff">More...</a><br /></td></tr>
<tr class="separator:gac4d47defbb724b2a445de5bc66df2eff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab6e3d78381f90c669fa336097d09d5c0"><td class="memTemplParams" colspan="2">template&lt;typename Iterator , typename T , hydra::detail::Backend BACKEND&gt; </td></tr>
<tr class="memitem:gab6e3d78381f90c669fa336097d09d5c0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__histogram.html#classhydra_1_1SparseHistogram">SparseHistogram</a>&lt; T, 1, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1multidimensional">detail::multidimensional</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__histogram.html#gab6e3d78381f90c669fa336097d09d5c0">make_sparse_histogram</a> (<a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt; backend, size_t nbins, T lowerlimit, T upperlimit, Iterator first, Iterator <a class="el" href="namespacehydra.html#a4274268d147e9a988f379326b73682b0">end</a>)</td></tr>
<tr class="memdesc:gab6e3d78381f90c669fa336097d09d5c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to make a 1-dimensional sparse histogram.  <a href="group__histogram.html#gab6e3d78381f90c669fa336097d09d5c0">More...</a><br /></td></tr>
<tr class="separator:gab6e3d78381f90c669fa336097d09d5c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a195ab6db84a5d1df9b9df6a21cce73e5"><td class="memTemplParams" colspan="2">template&lt;typename ArgType , typename Iterator1 , typename Iterator2 &gt; </td></tr>
<tr class="memitem:a195ab6db84a5d1df9b9df6a21cce73e5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classhydra_1_1SpilineFunctor.html">SpilineFunctor</a>&lt; Iterator1, Iterator2, ArgType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a195ab6db84a5d1df9b9df6a21cce73e5">make_spiline</a> (Iterator1 firstX, Iterator1 lastX, Iterator2 firstY)</td></tr>
<tr class="separator:a195ab6db84a5d1df9b9df6a21cce73e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae425b2f411e337b0606f465e115aec69"><td class="memTemplParams" colspan="2">template&lt;typename ArgType , typename Iterable1 , typename Iterable2 &gt; </td></tr>
<tr class="memitem:ae425b2f411e337b0606f465e115aec69"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; Iterable1 &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; Iterable2 &gt;::value, <a class="el" href="classhydra_1_1SpilineFunctor.html">SpilineFunctor</a>&lt; decltype(std::declval&lt; Iterable1 &gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()), decltype(std::declval&lt; Iterable2 &gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()), ArgType &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ae425b2f411e337b0606f465e115aec69">make_spiline</a> (Iterable1 &amp;&amp;x, Iterable2 &amp;&amp;y)</td></tr>
<tr class="separator:ae425b2f411e337b0606f465e115aec69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f74fb09a286265393fbce752c0c32cb"><td class="memTemplParams" colspan="2">template&lt;typename Iterator , typename PDF1 , typename PDF2 , typename ... PDFs&gt; </td></tr>
<tr class="memitem:a7f74fb09a286265393fbce752c0c32cb"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterator.html">detail::is_iterator</a>&lt; Iterator &gt;::value, <a class="el" href="group__fit.html#classhydra_1_1SPlot">SPlot</a>&lt; Iterator, PDF1, PDF2, PDFs... &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a7f74fb09a286265393fbce752c0c32cb">make_splot</a> (<a class="el" href="group__fit.html#classhydra_1_1PDFSumExtendable">PDFSumExtendable</a>&lt; PDF1, PDF2, PDFs... &gt; const &amp;pdf, Iterator first, Iterator last)</td></tr>
<tr class="memdesc:a7f74fb09a286265393fbce752c0c32cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function for instantiating <a class="el" href="group__fit.html#classhydra_1_1SPlot" title="Implementation of {s}_{Plot} technique for statistical unfolding of sample containing events from dif...">SPlot</a> objects using type deduction.  <a href="#a7f74fb09a286265393fbce752c0c32cb">More...</a><br /></td></tr>
<tr class="separator:a7f74fb09a286265393fbce752c0c32cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5ead3609a0334574dba725caebf656b"><td class="memTemplParams" colspan="2">template&lt;typename Iterable , typename PDF1 , typename PDF2 , typename ... PDFs&gt; </td></tr>
<tr class="memitem:ac5ead3609a0334574dba725caebf656b"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">detail::is_iterable</a>&lt; Iterable &gt;::value, <a class="el" href="group__fit.html#classhydra_1_1SPlot">SPlot</a>&lt; decltype(std::declval&lt; Iterable &gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()), PDF1, PDF2, PDFs... &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ac5ead3609a0334574dba725caebf656b">make_splot</a> (<a class="el" href="group__fit.html#classhydra_1_1PDFSumExtendable">PDFSumExtendable</a>&lt; PDF1, PDF2, PDFs... &gt; const &amp;pdf, Iterable &amp;&amp;<a class="el" href="basic__distributions_8inl.html#a248ea98483ce90baaf65a7682438d72d">data</a>)</td></tr>
<tr class="memdesc:ac5ead3609a0334574dba725caebf656b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function for instantiating <a class="el" href="group__fit.html#classhydra_1_1SPlot" title="Implementation of {s}_{Plot} technique for statistical unfolding of sample containing events from dif...">SPlot</a> objects using type deduction.  <a href="#ac5ead3609a0334574dba725caebf656b">More...</a><br /></td></tr>
<tr class="separator:ac5ead3609a0334574dba725caebf656b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1db1d8c170d119e8a99389cf5eb0b5d5"><td class="memTemplParams" colspan="2">template&lt;class ... T&gt; </td></tr>
<tr class="memitem:a1db1d8c170d119e8a99389cf5eb0b5d5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a1db1d8c170d119e8a99389cf5eb0b5d5">make_tuple</a> (T &amp;&amp;... t) -&gt; decltype(hydra_thrust::make_tuple(std::forward&lt; T &gt;(t)...))</td></tr>
<tr class="memdesc:a1db1d8c170d119e8a99389cf5eb0b5d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This version of <code>make_tuple</code> creates a new <code>tuple</code> object from a list of objects.  <a href="#a1db1d8c170d119e8a99389cf5eb0b5d5">More...</a><br /></td></tr>
<tr class="separator:a1db1d8c170d119e8a99389cf5eb0b5d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c4bda231cb9e6f06a12f2740f976009"><td class="memTemplParams" colspan="2">template&lt;hydra::detail::Backend BACKEND, typename ... T, typename ... U&gt; </td></tr>
<tr class="memitem:a4c4bda231cb9e6f06a12f2740f976009"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacehydra.html#classhydra_1_1Range">hydra::Range</a>&lt; hydra_thrust::zip_iterator&lt; typename <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1tuple__cat__type">detail::tuple_cat_type</a>&lt; typename <a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; hydra_thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::iterator_tuple, typename <a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; hydra_thrust::tuple&lt; U... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt; &gt;::iterator_tuple &gt;::type &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a4c4bda231cb9e6f06a12f2740f976009">meld</a> (<a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; hydra_thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; &amp;left, <a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; hydra_thrust::tuple&lt; U... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; &amp;right)</td></tr>
<tr class="separator:a4c4bda231cb9e6f06a12f2740f976009"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a141f2382a6bd83a2c71c886c5b687d"><td class="memTemplParams" colspan="2">template&lt;typename F1 , typename F2 &gt; </td></tr>
<tr class="memitem:a2a141f2382a6bd83a2c71c886c5b687d"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;(<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt; F1 &gt;::value||<a class="el" href="structhydra_1_1detail_1_1is__hydra__lambda.html">detail::is_hydra_lambda</a>&lt; F1 &gt;::value) &amp;&amp;(<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt; F2 &gt;::value||<a class="el" href="structhydra_1_1detail_1_1is__hydra__lambda.html">detail::is_hydra_lambda</a>&lt; F2 &gt;::value), <a class="el" href="classhydra_1_1Minus.html">Minus</a>&lt; F1, F2 &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a2a141f2382a6bd83a2c71c886c5b687d">minus</a> (F1 const &amp;f1, F2 const &amp;f2)</td></tr>
<tr class="separator:a2a141f2382a6bd83a2c71c886c5b687d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ecc65021a3e485b3ae047da8bcd1025"><td class="memTemplParams" colspan="2">template&lt;typename F1 , typename F2 , typename ... Fs&gt; </td></tr>
<tr class="memitem:a7ecc65021a3e485b3ae047da8bcd1025"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;(<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt; F1 &gt;::value||<a class="el" href="structhydra_1_1detail_1_1is__hydra__lambda.html">detail::is_hydra_lambda</a>&lt; F1 &gt;::value) &amp;&amp;(<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt; F2 &gt;::value||<a class="el" href="structhydra_1_1detail_1_1is__hydra__lambda.html">detail::is_hydra_lambda</a>&lt; F2 &gt;::value) &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1all__true.html">detail::all_true</a>&lt;(<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt; Fs &gt;::value||<a class="el" href="structhydra_1_1detail_1_1is__hydra__lambda.html">detail::is_hydra_lambda</a>&lt; Fs &gt;::value)... &gt;::value, <a class="el" href="classhydra_1_1Multiply.html">Multiply</a>&lt; F1, F2, Fs... &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a7ecc65021a3e485b3ae047da8bcd1025">multiply</a> (F1 const &amp;f1, F2 const &amp;f2, Fs const &amp;... functors)</td></tr>
<tr class="separator:a7ecc65021a3e485b3ae047da8bcd1025"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f06ee4cd16c4cd697a380053748bf67"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2f06ee4cd16c4cd697a380053748bf67"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespace_3globalScope_4.html#classint">int</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a2f06ee4cd16c4cd697a380053748bf67">nint</a> (const T x)</td></tr>
<tr class="memdesc:a2f06ee4cd16c4cd697a380053748bf67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Round to nearest integer.  <a href="#a2f06ee4cd16c4cd697a380053748bf67">More...</a><br /></td></tr>
<tr class="separator:a2f06ee4cd16c4cd697a380053748bf67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5fd2d8f62c3075ccdd36241e8dc6881"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab5fd2d8f62c3075ccdd36241e8dc6881"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ab5fd2d8f62c3075ccdd36241e8dc6881">norm</a> (const <a class="el" href="namespacehydra.html#a9be56668c1da1edd25b29c366adf5df9">complex</a>&lt; T &gt; &amp;z)</td></tr>
<tr class="separator:ab5fd2d8f62c3075ccdd36241e8dc6881"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74f09f60eaa232f756f2e5ee0ccb5326"><td class="memTemplParams" colspan="2">template&lt;size_t N1, hydra::detail::Backend BACKEND1, size_t N2, hydra::detail::Backend BACKEND2&gt; </td></tr>
<tr class="memitem:a74f09f60eaa232f756f2e5ee0ccb5326"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a74f09f60eaa232f756f2e5ee0ccb5326">operator!=</a> (const <a class="el" href="group__phsp.html#classhydra_1_1Decays">Decays</a>&lt; <a class="el" href="particle__mass_8inl.html#a8106f09b6a7c8282d6f237364a30e5e4">N1</a>, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND1 &gt; &gt; &amp;lhs, const <a class="el" href="group__phsp.html#classhydra_1_1Decays">Decays</a>&lt; <a class="el" href="particle__mass_8inl.html#a5ec56f622b3760c006a55312a610fd3f">N2</a>, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND2 &gt; &gt; &amp;rhs)</td></tr>
<tr class="separator:a74f09f60eaa232f756f2e5ee0ccb5326"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24943c0d2419a40a68f0fb61e0a1b05f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a24943c0d2419a40a68f0fb61e0a1b05f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a24943c0d2419a40a68f0fb61e0a1b05f">operator!=</a> (const <a class="el" href="namespacehydra.html#a9be56668c1da1edd25b29c366adf5df9">complex</a>&lt; T &gt; &amp;lhs, const <a class="el" href="namespacehydra.html#a9be56668c1da1edd25b29c366adf5df9">complex</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="separator:a24943c0d2419a40a68f0fb61e0a1b05f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a716c80436ab96c757325cae3cd517960"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a716c80436ab96c757325cae3cd517960"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a716c80436ab96c757325cae3cd517960">operator!=</a> (const T &amp;lhs, const <a class="el" href="namespacehydra.html#a9be56668c1da1edd25b29c366adf5df9">complex</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="separator:a716c80436ab96c757325cae3cd517960"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91d952f42e31697e4b457b1a58424cb5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a91d952f42e31697e4b457b1a58424cb5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a91d952f42e31697e4b457b1a58424cb5">operator!=</a> (const <a class="el" href="namespacehydra.html#a9be56668c1da1edd25b29c366adf5df9">complex</a>&lt; T &gt; &amp;lhs, const T &amp;rhs)</td></tr>
<tr class="separator:a91d952f42e31697e4b457b1a58424cb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa51499fa04d39681eb6244313d32a16c"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N, hydra::detail::Backend BACKEND1, hydra::detail::Backend BACKEND2&gt; </td></tr>
<tr class="memitem:aa51499fa04d39681eb6244313d32a16c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#aa51499fa04d39681eb6244313d32a16c">operator!=</a> (const <a class="el" href="namespacehydra.html#classhydra_1_1multiarray">multiarray</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND1 &gt;&gt; &amp;lhs, const <a class="el" href="namespacehydra.html#classhydra_1_1multiarray">multiarray</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND2 &gt;&gt; &amp;rhs)</td></tr>
<tr class="separator:aa51499fa04d39681eb6244313d32a16c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66b6224a152f0204d791b66b17502084"><td class="memTemplParams" colspan="2">template&lt;typename ... T, hydra::detail::Backend BACKEND1, hydra::detail::Backend BACKEND2&gt; </td></tr>
<tr class="memitem:a66b6224a152f0204d791b66b17502084"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a66b6224a152f0204d791b66b17502084">operator!=</a> (const <a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; hydra_thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND1 &gt;&gt; &amp;lhs, const <a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; hydra_thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND2 &gt;&gt; &amp;rhs)</td></tr>
<tr class="separator:a66b6224a152f0204d791b66b17502084"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98f5a5475025bc860510c29908fbe528"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a98f5a5475025bc860510c29908fbe528"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;(<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt; T1 &gt;::value||<a class="el" href="structhydra_1_1detail_1_1is__hydra__lambda.html">detail::is_hydra_lambda</a>&lt; T1 &gt;::value) &amp;&amp;(<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt; T2 &gt;::value||<a class="el" href="structhydra_1_1detail_1_1is__hydra__lambda.html">detail::is_hydra_lambda</a>&lt; T2 &gt;::value), <a class="el" href="classhydra_1_1Multiply.html">Multiply</a>&lt; T1, T2 &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a98f5a5475025bc860510c29908fbe528">operator*</a> (T1 const &amp;F1, T2 const &amp;F2)</td></tr>
<tr class="separator:a98f5a5475025bc860510c29908fbe528"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad01febd59c4dfebc87b5d363955d65db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> Vector3R&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ad01febd59c4dfebc87b5d363955d65db">operator*</a> (<a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> c, const Vector3R &amp;v2)</td></tr>
<tr class="separator:ad01febd59c4dfebc87b5d363955d65db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab15a6bf3575e9fcd2bf0abdf1bdc36e1"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ab15a6bf3575e9fcd2bf0abdf1bdc36e1"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;(<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt; T &gt;::value||<a class="el" href="structhydra_1_1detail_1_1is__hydra__lambda.html">detail::is_hydra_lambda</a>&lt; T &gt;::value) &amp;&amp;(std::is_arithmetic&lt; U &gt;::value), <a class="el" href="classhydra_1_1Multiply.html">Multiply</a>&lt; <a class="el" href="structhydra_1_1Constant.html">Constant</a>&lt; U &gt;, T &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ab15a6bf3575e9fcd2bf0abdf1bdc36e1">operator*</a> (U const cte, T const &amp;F)</td></tr>
<tr class="separator:ab15a6bf3575e9fcd2bf0abdf1bdc36e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dce6130507b07eaac142c1815ade3f2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> Vector3R&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a0dce6130507b07eaac142c1815ade3f2">operator*</a> (const Vector3R &amp;v1, <a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> c)</td></tr>
<tr class="separator:a0dce6130507b07eaac142c1815ade3f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a958bc75ab95451e60e074488e75440ce"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a958bc75ab95451e60e074488e75440ce"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;(<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt; T &gt;::value||<a class="el" href="structhydra_1_1detail_1_1is__hydra__lambda.html">detail::is_hydra_lambda</a>&lt; T &gt;::value) &amp;&amp;(std::is_arithmetic&lt; U &gt;::value), <a class="el" href="classhydra_1_1Multiply.html">Multiply</a>&lt; <a class="el" href="structhydra_1_1Constant.html">Constant</a>&lt; U &gt;, T &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a958bc75ab95451e60e074488e75440ce">operator*</a> (T const &amp;F, U cte)</td></tr>
<tr class="separator:a958bc75ab95451e60e074488e75440ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd42c2a636a5bfb4e605ddd9f1ea069a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#afd42c2a636a5bfb4e605ddd9f1ea069a">operator*</a> (const Vector3R &amp;v1, const Vector3R &amp;v2)</td></tr>
<tr class="separator:afd42c2a636a5bfb4e605ddd9f1ea069a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70e470e57d62af68149525bd201989e5"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a70e470e57d62af68149525bd201989e5"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;(<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt; T &gt;::value||<a class="el" href="structhydra_1_1detail_1_1is__hydra__lambda.html">detail::is_hydra_lambda</a>&lt; T &gt;::value) &amp;&amp;(std::is_arithmetic&lt; U &gt;::value), <a class="el" href="classhydra_1_1Multiply.html">Multiply</a>&lt; <a class="el" href="structhydra_1_1Constant.html">Constant</a>&lt; <a class="el" href="namespacehydra.html#a9be56668c1da1edd25b29c366adf5df9">hydra::complex</a>&lt; U &gt; &gt;, T &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a70e470e57d62af68149525bd201989e5">operator*</a> (<a class="el" href="namespacehydra.html#a9be56668c1da1edd25b29c366adf5df9">hydra::complex</a>&lt; U &gt; const &amp;cte, T const &amp;F)</td></tr>
<tr class="separator:a70e470e57d62af68149525bd201989e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b4568e3cdf69d3cbec10c124850ee2c"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a1b4568e3cdf69d3cbec10c124850ee2c"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;(<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt; T &gt;::value||<a class="el" href="structhydra_1_1detail_1_1is__hydra__lambda.html">detail::is_hydra_lambda</a>&lt; T &gt;::value) &amp;&amp;(std::is_arithmetic&lt; U &gt;::value), <a class="el" href="classhydra_1_1Multiply.html">Multiply</a>&lt; <a class="el" href="structhydra_1_1Constant.html">Constant</a>&lt; U &gt;, T &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a1b4568e3cdf69d3cbec10c124850ee2c">operator*</a> (T const &amp;F, <a class="el" href="namespacehydra.html#a9be56668c1da1edd25b29c366adf5df9">hydra::complex</a>&lt; U &gt; const &amp;cte)</td></tr>
<tr class="separator:a1b4568e3cdf69d3cbec10c124850ee2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5bae5caa4d9b5c0190220e55f650859"><td class="memItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> Vector4R&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ae5bae5caa4d9b5c0190220e55f650859">operator*</a> (<a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> c, const Vector4R &amp;v2)</td></tr>
<tr class="separator:ae5bae5caa4d9b5c0190220e55f650859"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2b0be1f22ac4914bd6ce0bc97411bff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> Vector4R&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ae2b0be1f22ac4914bd6ce0bc97411bff">operator*</a> (const Vector4R &amp;v2, <a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> c)</td></tr>
<tr class="separator:ae2b0be1f22ac4914bd6ce0bc97411bff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb096b020e55914fe7a1e885dd66b17e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#adb096b020e55914fe7a1e885dd66b17e">operator*</a> (const Vector4R &amp;v1, const Vector4R &amp;v2)</td></tr>
<tr class="separator:adb096b020e55914fe7a1e885dd66b17e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89ff58cb476f9a4107bd46f1bc08ff86"><td class="memTemplParams" colspan="2">template&lt;typename ... T&gt; </td></tr>
<tr class="memitem:a89ff58cb476f9a4107bd46f1bc08ff86"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::tuple&lt; T... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a89ff58cb476f9a4107bd46f1bc08ff86">operator*</a> (const hydra_thrust::tuple&lt; T... &gt; &amp;a, const hydra_thrust::tuple&lt; T... &gt; &amp;b)</td></tr>
<tr class="separator:a89ff58cb476f9a4107bd46f1bc08ff86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b98f3604eca3a6023551cd4ce98020a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a0b98f3604eca3a6023551cd4ce98020a">operator*</a> (<a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a> par1, <a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a> const &amp;par2)</td></tr>
<tr class="separator:a0b98f3604eca3a6023551cd4ce98020a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac480ecaec81a0040f3b466ca5904ed5b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ac480ecaec81a0040f3b466ca5904ed5b">operator*</a> (<a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a> par1, <a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> par2)</td></tr>
<tr class="separator:ac480ecaec81a0040f3b466ca5904ed5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0bc15a0070c95cad2a9b6e300b430cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#aa0bc15a0070c95cad2a9b6e300b430cc">operator*</a> (<a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> par1, <a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a> const &amp;par2)</td></tr>
<tr class="separator:aa0bc15a0070c95cad2a9b6e300b430cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fafa9d71a3cc46ef785a70374501c78"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a7fafa9d71a3cc46ef785a70374501c78"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;(<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt; T1 &gt;::value||<a class="el" href="structhydra_1_1detail_1_1is__hydra__lambda.html">detail::is_hydra_lambda</a>&lt; T1 &gt;::value) &amp;&amp;(<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt; T2 &gt;::value||<a class="el" href="structhydra_1_1detail_1_1is__hydra__lambda.html">detail::is_hydra_lambda</a>&lt; T2 &gt;::value), <a class="el" href="classhydra_1_1Sum.html">Sum</a>&lt; T1, T2 &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a7fafa9d71a3cc46ef785a70374501c78">operator+</a> (T1 const &amp;F1, T2 const &amp;F2)</td></tr>
<tr class="separator:a7fafa9d71a3cc46ef785a70374501c78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4060305f83c9118349c59ab1b5331866"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a4060305f83c9118349c59ab1b5331866"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;(<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt; T &gt;::value||<a class="el" href="structhydra_1_1detail_1_1is__hydra__lambda.html">detail::is_hydra_lambda</a>&lt; T &gt;::value) &amp;&amp;(std::is_arithmetic&lt; U &gt;::value), <a class="el" href="classhydra_1_1Sum.html">Sum</a>&lt; <a class="el" href="structhydra_1_1Constant.html">Constant</a>&lt; U &gt;, T &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a4060305f83c9118349c59ab1b5331866">operator+</a> (U const cte, T const &amp;F)</td></tr>
<tr class="separator:a4060305f83c9118349c59ab1b5331866"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a2b546f3d37d1310cd805b5768be9cc"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a3a2b546f3d37d1310cd805b5768be9cc"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;(<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt; T &gt;::value||<a class="el" href="structhydra_1_1detail_1_1is__hydra__lambda.html">detail::is_hydra_lambda</a>&lt; T &gt;::value) &amp;&amp;(std::is_arithmetic&lt; U &gt;::value), <a class="el" href="classhydra_1_1Sum.html">Sum</a>&lt; <a class="el" href="structhydra_1_1Constant.html">Constant</a>&lt; U &gt;, T &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a3a2b546f3d37d1310cd805b5768be9cc">operator+</a> (T const &amp;F, U cte)</td></tr>
<tr class="separator:a3a2b546f3d37d1310cd805b5768be9cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5257853509f5e7d4ca8b4d68b96b2d6"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ab5257853509f5e7d4ca8b4d68b96b2d6"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;(<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt; T &gt;::value||<a class="el" href="structhydra_1_1detail_1_1is__hydra__lambda.html">detail::is_hydra_lambda</a>&lt; T &gt;::value) &amp;&amp;(std::is_arithmetic&lt; U &gt;::value), <a class="el" href="classhydra_1_1Sum.html">Sum</a>&lt; <a class="el" href="structhydra_1_1Constant.html">Constant</a>&lt; <a class="el" href="namespacehydra.html#a9be56668c1da1edd25b29c366adf5df9">hydra::complex</a>&lt; U &gt; &gt;, T &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ab5257853509f5e7d4ca8b4d68b96b2d6">operator+</a> (<a class="el" href="namespacehydra.html#a9be56668c1da1edd25b29c366adf5df9">hydra::complex</a>&lt; U &gt; const &amp;cte, T const &amp;F)</td></tr>
<tr class="separator:ab5257853509f5e7d4ca8b4d68b96b2d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c1fc13eb2a4a440f72991b4347a472c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> Vector3R&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a1c1fc13eb2a4a440f72991b4347a472c">operator+</a> (const Vector3R &amp;v1, const Vector3R &amp;v2)</td></tr>
<tr class="separator:a1c1fc13eb2a4a440f72991b4347a472c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07ce25e2c0bd0be95076f18159a925d2"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a07ce25e2c0bd0be95076f18159a925d2"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;(<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt; T &gt;::value||<a class="el" href="structhydra_1_1detail_1_1is__hydra__lambda.html">detail::is_hydra_lambda</a>&lt; T &gt;::value) &amp;&amp;(std::is_arithmetic&lt; U &gt;::value), <a class="el" href="classhydra_1_1Sum.html">Sum</a>&lt; <a class="el" href="structhydra_1_1Constant.html">Constant</a>&lt; U &gt;, T &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a07ce25e2c0bd0be95076f18159a925d2">operator+</a> (T const &amp;F, <a class="el" href="namespacehydra.html#a9be56668c1da1edd25b29c366adf5df9">hydra::complex</a>&lt; U &gt; const &amp;cte)</td></tr>
<tr class="separator:a07ce25e2c0bd0be95076f18159a925d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0bd5fcb530c7e864cfe16f05d4493a2"><td class="memTemplParams" colspan="2">template&lt;typename ... T&gt; </td></tr>
<tr class="memitem:ac0bd5fcb530c7e864cfe16f05d4493a2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::tuple&lt; T... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ac0bd5fcb530c7e864cfe16f05d4493a2">operator+</a> (const hydra_thrust::tuple&lt; T... &gt; a, const hydra_thrust::tuple&lt; T... &gt; &amp;b)</td></tr>
<tr class="separator:ac0bd5fcb530c7e864cfe16f05d4493a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af68a4c9bed0e1a2cf2ed9ba9ab057dd0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> Vector4R&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#af68a4c9bed0e1a2cf2ed9ba9ab057dd0">operator+</a> (const Vector4R &amp;v1, const Vector4R &amp;v2)</td></tr>
<tr class="separator:af68a4c9bed0e1a2cf2ed9ba9ab057dd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26e3492eb046c39e1b578738cd5ad7b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a26e3492eb046c39e1b578738cd5ad7b7">operator+</a> (<a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a> par1, <a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a> const &amp;par2)</td></tr>
<tr class="separator:a26e3492eb046c39e1b578738cd5ad7b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a357a28a5ec78cd838e8e90face792425"><td class="memItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a357a28a5ec78cd838e8e90face792425">operator+</a> (<a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a> par1, <a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> par2)</td></tr>
<tr class="separator:a357a28a5ec78cd838e8e90face792425"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84fc9a23e35641ee933be028786d852b"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a84fc9a23e35641ee933be028786d852b"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;(<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt; T1 &gt;::value||<a class="el" href="structhydra_1_1detail_1_1is__hydra__lambda.html">detail::is_hydra_lambda</a>&lt; T1 &gt;::value) &amp;&amp;(<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt; T2 &gt;::value||<a class="el" href="structhydra_1_1detail_1_1is__hydra__lambda.html">detail::is_hydra_lambda</a>&lt; T2 &gt;::value), <a class="el" href="classhydra_1_1Minus.html">Minus</a>&lt; T1, T2 &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a84fc9a23e35641ee933be028786d852b">operator-</a> (T1 const &amp;F1, T2 const &amp;F2)</td></tr>
<tr class="separator:a84fc9a23e35641ee933be028786d852b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18c2c67f2fe010ee6acf64c05ed2b94a"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a18c2c67f2fe010ee6acf64c05ed2b94a"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;(<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt; T &gt;::value||<a class="el" href="structhydra_1_1detail_1_1is__hydra__lambda.html">detail::is_hydra_lambda</a>&lt; T &gt;::value) &amp;&amp;(std::is_arithmetic&lt; U &gt;::value), <a class="el" href="classhydra_1_1Minus.html">Minus</a>&lt; <a class="el" href="structhydra_1_1Constant.html">Constant</a>&lt; U &gt;, T &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a18c2c67f2fe010ee6acf64c05ed2b94a">operator-</a> (U const cte, T const &amp;F)</td></tr>
<tr class="separator:a18c2c67f2fe010ee6acf64c05ed2b94a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a738a108d0225cb4655d273940b647d00"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a738a108d0225cb4655d273940b647d00"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;(<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt; T &gt;::value||<a class="el" href="structhydra_1_1detail_1_1is__hydra__lambda.html">detail::is_hydra_lambda</a>&lt; T &gt;::value) &amp;&amp;(std::is_arithmetic&lt; U &gt;::value), <a class="el" href="classhydra_1_1Minus.html">Minus</a>&lt; <a class="el" href="structhydra_1_1Constant.html">Constant</a>&lt; U &gt;, T &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a738a108d0225cb4655d273940b647d00">operator-</a> (T const &amp;F, U cte)</td></tr>
<tr class="separator:a738a108d0225cb4655d273940b647d00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe35592654935c44c6d5b47196bd054a"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:abe35592654935c44c6d5b47196bd054a"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;(<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt; T &gt;::value||<a class="el" href="structhydra_1_1detail_1_1is__hydra__lambda.html">detail::is_hydra_lambda</a>&lt; T &gt;::value) &amp;&amp;(std::is_arithmetic&lt; U &gt;::value), <a class="el" href="classhydra_1_1Minus.html">Minus</a>&lt; <a class="el" href="structhydra_1_1Constant.html">Constant</a>&lt; <a class="el" href="namespacehydra.html#a9be56668c1da1edd25b29c366adf5df9">hydra::complex</a>&lt; U &gt; &gt;, T &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#abe35592654935c44c6d5b47196bd054a">operator-</a> (<a class="el" href="namespacehydra.html#a9be56668c1da1edd25b29c366adf5df9">hydra::complex</a>&lt; U &gt; const &amp;cte, T const &amp;F)</td></tr>
<tr class="separator:abe35592654935c44c6d5b47196bd054a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f90d5023b833839c5f9c184ae7275dd"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a0f90d5023b833839c5f9c184ae7275dd"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;(<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt; T &gt;::value||<a class="el" href="structhydra_1_1detail_1_1is__hydra__lambda.html">detail::is_hydra_lambda</a>&lt; T &gt;::value) &amp;&amp;(std::is_arithmetic&lt; U &gt;::value), <a class="el" href="classhydra_1_1Minus.html">Minus</a>&lt; <a class="el" href="structhydra_1_1Constant.html">Constant</a>&lt; U &gt;, T &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a0f90d5023b833839c5f9c184ae7275dd">operator-</a> (T const &amp;F, <a class="el" href="namespacehydra.html#a9be56668c1da1edd25b29c366adf5df9">hydra::complex</a>&lt; U &gt; const &amp;cte)</td></tr>
<tr class="separator:a0f90d5023b833839c5f9c184ae7275dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1113b35a5588af8a55453fbd5e1b2651"><td class="memItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> Vector3R&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a1113b35a5588af8a55453fbd5e1b2651">operator-</a> (const Vector3R &amp;v1, const Vector3R &amp;v2)</td></tr>
<tr class="separator:a1113b35a5588af8a55453fbd5e1b2651"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a826a3a94946d3c2c5a3f34ca8a74999b"><td class="memTemplParams" colspan="2">template&lt;typename ... T&gt; </td></tr>
<tr class="memitem:a826a3a94946d3c2c5a3f34ca8a74999b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::tuple&lt; T... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a826a3a94946d3c2c5a3f34ca8a74999b">operator-</a> (const hydra_thrust::tuple&lt; T... &gt; &amp;a, const hydra_thrust::tuple&lt; T... &gt; &amp;b)</td></tr>
<tr class="separator:a826a3a94946d3c2c5a3f34ca8a74999b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a950f2d5dc4356f6c6c13b9fc3bc7c0ef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> Vector4R&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a950f2d5dc4356f6c6c13b9fc3bc7c0ef">operator-</a> (const Vector4R &amp;v1, const Vector4R &amp;v2)</td></tr>
<tr class="separator:a950f2d5dc4356f6c6c13b9fc3bc7c0ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68375d62444cb2341ade99f0ac15972f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a68375d62444cb2341ade99f0ac15972f">operator-</a> (<a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a> par1, <a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a> const &amp;par2)</td></tr>
<tr class="separator:a68375d62444cb2341ade99f0ac15972f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07c46e4c59a5208f5d495b4ddaf3af75"><td class="memItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a07c46e4c59a5208f5d495b4ddaf3af75">operator-</a> (<a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a> par1, <a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> par2)</td></tr>
<tr class="separator:a07c46e4c59a5208f5d495b4ddaf3af75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a247f457807559c67d34c5b9d15c0b4b4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a247f457807559c67d34c5b9d15c0b4b4">operator-</a> (<a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> par1, <a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a> par2)</td></tr>
<tr class="separator:a247f457807559c67d34c5b9d15c0b4b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3b16aaa8206238e19f573a8b0f07730"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:aa3b16aaa8206238e19f573a8b0f07730"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;(<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt; T1 &gt;::value||<a class="el" href="structhydra_1_1detail_1_1is__hydra__lambda.html">detail::is_hydra_lambda</a>&lt; T1 &gt;::value) &amp;&amp;(<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt; T2 &gt;::value||<a class="el" href="structhydra_1_1detail_1_1is__hydra__lambda.html">detail::is_hydra_lambda</a>&lt; T2 &gt;::value), <a class="el" href="classhydra_1_1Divide.html">Divide</a>&lt; T1, T2 &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#aa3b16aaa8206238e19f573a8b0f07730">operator/</a> (T1 const &amp;F1, T2 const &amp;F2)</td></tr>
<tr class="separator:aa3b16aaa8206238e19f573a8b0f07730"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab01044c5657e79152458266153d361e3"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ab01044c5657e79152458266153d361e3"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;(<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt; T &gt;::value||<a class="el" href="structhydra_1_1detail_1_1is__hydra__lambda.html">detail::is_hydra_lambda</a>&lt; T &gt;::value) &amp;&amp;(std::is_arithmetic&lt; U &gt;::value), <a class="el" href="classhydra_1_1Divide.html">Divide</a>&lt; <a class="el" href="structhydra_1_1Constant.html">Constant</a>&lt; U &gt;, T &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ab01044c5657e79152458266153d361e3">operator/</a> (U const cte, T const &amp;F)</td></tr>
<tr class="separator:ab01044c5657e79152458266153d361e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a975b2511acddbdf4f7c4442f266440c0"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a975b2511acddbdf4f7c4442f266440c0"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;(<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt; T &gt;::value||<a class="el" href="structhydra_1_1detail_1_1is__hydra__lambda.html">detail::is_hydra_lambda</a>&lt; T &gt;::value) &amp;&amp;(std::is_arithmetic&lt; U &gt;::value), <a class="el" href="classhydra_1_1Divide.html">Divide</a>&lt; <a class="el" href="structhydra_1_1Constant.html">Constant</a>&lt; U &gt;, T &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a975b2511acddbdf4f7c4442f266440c0">operator/</a> (T const &amp;F, U cte)</td></tr>
<tr class="separator:a975b2511acddbdf4f7c4442f266440c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae608d7550080817bb9932341d1c10b1f"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ae608d7550080817bb9932341d1c10b1f"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;(<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt; T &gt;::value||<a class="el" href="structhydra_1_1detail_1_1is__hydra__lambda.html">detail::is_hydra_lambda</a>&lt; T &gt;::value) &amp;&amp;(std::is_arithmetic&lt; U &gt;::value), <a class="el" href="classhydra_1_1Divide.html">Divide</a>&lt; <a class="el" href="structhydra_1_1Constant.html">Constant</a>&lt; <a class="el" href="namespacehydra.html#a9be56668c1da1edd25b29c366adf5df9">hydra::complex</a>&lt; U &gt; &gt;, T &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ae608d7550080817bb9932341d1c10b1f">operator/</a> (<a class="el" href="namespacehydra.html#a9be56668c1da1edd25b29c366adf5df9">hydra::complex</a>&lt; U &gt; const &amp;cte, T const &amp;F)</td></tr>
<tr class="separator:ae608d7550080817bb9932341d1c10b1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94cb4a79113148abd78aa8e4d6f7e41d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> Vector3R&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a94cb4a79113148abd78aa8e4d6f7e41d">operator/</a> (const Vector3R &amp;v1, <a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> c)</td></tr>
<tr class="separator:a94cb4a79113148abd78aa8e4d6f7e41d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f776567931eb9c539a7de28fe03a4c3"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a2f776567931eb9c539a7de28fe03a4c3"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;(<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt; T &gt;::value||<a class="el" href="structhydra_1_1detail_1_1is__hydra__lambda.html">detail::is_hydra_lambda</a>&lt; T &gt;::value) &amp;&amp;(std::is_arithmetic&lt; U &gt;::value), <a class="el" href="classhydra_1_1Divide.html">Divide</a>&lt; <a class="el" href="structhydra_1_1Constant.html">Constant</a>&lt; <a class="el" href="namespacehydra.html#a9be56668c1da1edd25b29c366adf5df9">hydra::complex</a>&lt; U &gt; &gt;, T &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a2f776567931eb9c539a7de28fe03a4c3">operator/</a> (T const &amp;F, <a class="el" href="namespacehydra.html#a9be56668c1da1edd25b29c366adf5df9">hydra::complex</a>&lt; U &gt; const &amp;cte)</td></tr>
<tr class="separator:a2f776567931eb9c539a7de28fe03a4c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4db4d6d0e3fe03dccf661b7ac0751fe7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> Vector4R&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a4db4d6d0e3fe03dccf661b7ac0751fe7">operator/</a> (const Vector4R &amp;v2, <a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> c)</td></tr>
<tr class="separator:a4db4d6d0e3fe03dccf661b7ac0751fe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9619c9f5a4ec3ce73574e1ce8f25708f"><td class="memTemplParams" colspan="2">template&lt;typename ... T&gt; </td></tr>
<tr class="memitem:a9619c9f5a4ec3ce73574e1ce8f25708f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::tuple&lt; T... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a9619c9f5a4ec3ce73574e1ce8f25708f">operator/</a> (const hydra_thrust::tuple&lt; T... &gt; &amp;a, const hydra_thrust::tuple&lt; T... &gt; &amp;b)</td></tr>
<tr class="separator:a9619c9f5a4ec3ce73574e1ce8f25708f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9b1664e58d41d5f8e7ec6d1c20bf9c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ac9b1664e58d41d5f8e7ec6d1c20bf9c0">operator/</a> (<a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a> par1, <a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a> const par2)</td></tr>
<tr class="separator:ac9b1664e58d41d5f8e7ec6d1c20bf9c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a4133d480d7e9f3f5e85286e47a3709"><td class="memItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a0a4133d480d7e9f3f5e85286e47a3709">operator/</a> (<a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a> par1, <a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> par2)</td></tr>
<tr class="separator:a0a4133d480d7e9f3f5e85286e47a3709"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af29cde1e70c62bec6f1fa1ee52940887"><td class="memItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#af29cde1e70c62bec6f1fa1ee52940887">operator/</a> (<a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> par1, <a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a> par2)</td></tr>
<tr class="separator:af29cde1e70c62bec6f1fa1ee52940887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15cdb083719133399edb77f5ef3eb547"><td class="memTemplParams" colspan="2">template&lt;size_t N, typename T &gt; </td></tr>
<tr class="memitem:a15cdb083719133399edb77f5ef3eb547"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a15cdb083719133399edb77f5ef3eb547">operator&lt;&lt;</a> (std::ostream &amp;os, std::array&lt; T, N &gt; const &amp;obj)</td></tr>
<tr class="separator:a15cdb083719133399edb77f5ef3eb547"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fab8d226ee701c0755c60202fc30f6c"><td class="memTemplParams" colspan="2">template&lt;typename ... T&gt; </td></tr>
<tr class="memitem:a6fab8d226ee701c0755c60202fc30f6c"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a6fab8d226ee701c0755c60202fc30f6c">operator&lt;&lt;</a> (std::ostream &amp;os, std::tuple&lt; T... &gt; const &amp;obj)</td></tr>
<tr class="separator:a6fab8d226ee701c0755c60202fc30f6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4d7f13d811f0d63d4ce49d31b6cfbe0"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ad4d7f13d811f0d63d4ce49d31b6cfbe0"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ad4d7f13d811f0d63d4ce49d31b6cfbe0">operator&lt;&lt;</a> (std::ostream &amp;os, std::pair&lt; T1, T2 &gt; const &amp;obj)</td></tr>
<tr class="separator:ad4d7f13d811f0d63d4ce49d31b6cfbe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fa8037907332bf633dfc1bc3b40865c"><td class="memItemLeft" align="right" valign="top">ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a3fa8037907332bf633dfc1bc3b40865c">operator&lt;&lt;</a> (ostream &amp;s, const Vector3R &amp;v)</td></tr>
<tr class="separator:a3fa8037907332bf633dfc1bc3b40865c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaacce78528c9499de97312cbe606ece4"><td class="memItemLeft" align="right" valign="top">ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#aaacce78528c9499de97312cbe606ece4">operator&lt;&lt;</a> (ostream &amp;s, const Vector4R &amp;v)</td></tr>
<tr class="separator:aaacce78528c9499de97312cbe606ece4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3be8e63c60c604b927f9638600a598b"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ad3be8e63c60c604b927f9638600a598b">operator&lt;&lt;</a> (std::ostream &amp;os, <a class="el" href="group__fit.html#classhydra_1_1UserParameters">UserParameters</a> const &amp;par)</td></tr>
<tr class="memdesc:ad3be8e63c60c604b927f9638600a598b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classhydra_1_1Print.html">Print</a> the ROOT::Minuit2 state to stream.  <a href="#ad3be8e63c60c604b927f9638600a598b">More...</a><br /></td></tr>
<tr class="separator:ad3be8e63c60c604b927f9638600a598b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21d7262b80d73f956ed1a477607b9053"><td class="memTemplParams" colspan="2">template&lt;typename ValueType , class charT , class traits &gt; </td></tr>
<tr class="memitem:a21d7262b80d73f956ed1a477607b9053"><td class="memTemplItemLeft" align="right" valign="top">std::basic_ostream&lt; charT, traits &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a21d7262b80d73f956ed1a477607b9053">operator&lt;&lt;</a> (std::basic_ostream&lt; charT, traits &gt; &amp;os, const <a class="el" href="namespacehydra.html#a9be56668c1da1edd25b29c366adf5df9">complex</a>&lt; ValueType &gt; &amp;z)</td></tr>
<tr class="separator:a21d7262b80d73f956ed1a477607b9053"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb57654e359a17e312e9aef986f956a8"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#adb57654e359a17e312e9aef986f956a8">operator&lt;&lt;</a> (std::ostream &amp;os, <a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a> const &amp;var)</td></tr>
<tr class="separator:adb57654e359a17e312e9aef986f956a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebc9da09d22eae43ed970a123baa27f1"><td class="memTemplParams" colspan="2">template&lt;size_t N1, hydra::detail::Backend BACKEND1, size_t N2, hydra::detail::Backend BACKEND2&gt; </td></tr>
<tr class="memitem:aebc9da09d22eae43ed970a123baa27f1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#aebc9da09d22eae43ed970a123baa27f1">operator==</a> (const <a class="el" href="group__phsp.html#classhydra_1_1Decays">Decays</a>&lt; <a class="el" href="particle__mass_8inl.html#a8106f09b6a7c8282d6f237364a30e5e4">N1</a>, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND1 &gt; &gt; &amp;lhs, const <a class="el" href="group__phsp.html#classhydra_1_1Decays">Decays</a>&lt; <a class="el" href="particle__mass_8inl.html#a5ec56f622b3760c006a55312a610fd3f">N2</a>, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND2 &gt; &gt; &amp;rhs)</td></tr>
<tr class="separator:aebc9da09d22eae43ed970a123baa27f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea70aec01321527f54717a004a3df99d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aea70aec01321527f54717a004a3df99d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#aea70aec01321527f54717a004a3df99d">operator==</a> (const <a class="el" href="namespacehydra.html#a9be56668c1da1edd25b29c366adf5df9">complex</a>&lt; T &gt; &amp;lhs, const <a class="el" href="namespacehydra.html#a9be56668c1da1edd25b29c366adf5df9">complex</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="separator:aea70aec01321527f54717a004a3df99d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a227370a3dddcea864f09490bc65b93ad"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a227370a3dddcea864f09490bc65b93ad"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a227370a3dddcea864f09490bc65b93ad">operator==</a> (const T &amp;lhs, const <a class="el" href="namespacehydra.html#a9be56668c1da1edd25b29c366adf5df9">complex</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="separator:a227370a3dddcea864f09490bc65b93ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99bf5390aa3ab39e8ac0cd109ef6b7c9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a99bf5390aa3ab39e8ac0cd109ef6b7c9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a99bf5390aa3ab39e8ac0cd109ef6b7c9">operator==</a> (const <a class="el" href="namespacehydra.html#a9be56668c1da1edd25b29c366adf5df9">complex</a>&lt; T &gt; &amp;lhs, const T &amp;rhs)</td></tr>
<tr class="separator:a99bf5390aa3ab39e8ac0cd109ef6b7c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3bafbf7fa6e97bc40b02d74d7d596ea"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N, hydra::detail::Backend BACKEND1, hydra::detail::Backend BACKEND2&gt; </td></tr>
<tr class="memitem:ab3bafbf7fa6e97bc40b02d74d7d596ea"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ab3bafbf7fa6e97bc40b02d74d7d596ea">operator==</a> (const <a class="el" href="namespacehydra.html#classhydra_1_1multiarray">multiarray</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND1 &gt;&gt; &amp;lhs, const <a class="el" href="namespacehydra.html#classhydra_1_1multiarray">multiarray</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND2 &gt;&gt; &amp;rhs)</td></tr>
<tr class="separator:ab3bafbf7fa6e97bc40b02d74d7d596ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bebd511416d4c9347e3b76fb8be4ee8"><td class="memTemplParams" colspan="2">template&lt;typename ... T, hydra::detail::Backend BACKEND1, hydra::detail::Backend BACKEND2&gt; </td></tr>
<tr class="memitem:a4bebd511416d4c9347e3b76fb8be4ee8"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a4bebd511416d4c9347e3b76fb8be4ee8">operator==</a> (const <a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; hydra_thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND1 &gt;&gt; &amp;lhs, const <a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; hydra_thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND2 &gt;&gt; &amp;rhs)</td></tr>
<tr class="separator:a4bebd511416d4c9347e3b76fb8be4ee8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63ad8f84031200c3161c889507d3a9c0"><td class="memTemplParams" colspan="2">template&lt;typename ValueType , typename charT , class traits &gt; </td></tr>
<tr class="memitem:a63ad8f84031200c3161c889507d3a9c0"><td class="memTemplItemLeft" align="right" valign="top">std::basic_istream&lt; charT, traits &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a63ad8f84031200c3161c889507d3a9c0">operator&gt;&gt;</a> (std::basic_istream&lt; charT, traits &gt; &amp;is, <a class="el" href="namespacehydra.html#a9be56668c1da1edd25b29c366adf5df9">complex</a>&lt; ValueType &gt; &amp;z)</td></tr>
<tr class="separator:a63ad8f84031200c3161c889507d3a9c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55811c5f0a84a83d2d43473fb464eb4b"><td class="memTemplParams" colspan="2">template&lt;typename Iterable , typename Functor &gt; </td></tr>
<tr class="memitem:a55811c5f0a84a83d2d43473fb464eb4b"><td class="memTemplItemLeft" align="right" valign="top">hydra_thrust::detail::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">detail::is_iterable</a>&lt; Iterable &gt;::value &amp;&amp;(<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt; Functor &gt;::value||<a class="el" href="structhydra_1_1detail_1_1is__hydra__lambda.html">detail::is_hydra_lambda</a>&lt; Functor &gt;::value), <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; decltype(std::declval&lt; const Iterable &gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()), Functor &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a55811c5f0a84a83d2d43473fb464eb4b">operator|</a> (Iterable const &amp;iterable, Functor const &amp;functor)</td></tr>
<tr class="separator:a55811c5f0a84a83d2d43473fb464eb4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c6bbe00afd80cfb16f208f98defdc1a"><td class="memTemplParams" colspan="2">template&lt;typename Iterable , typename Functor &gt; </td></tr>
<tr class="memitem:a6c6bbe00afd80cfb16f208f98defdc1a"><td class="memTemplItemLeft" align="right" valign="top">hydra_thrust::detail::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">detail::is_iterable</a>&lt; Iterable &gt;::value &amp;&amp;(<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt; Functor &gt;::value||<a class="el" href="structhydra_1_1detail_1_1is__hydra__lambda.html">detail::is_hydra_lambda</a>&lt; Functor &gt;::value), <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; decltype(std::declval&lt; Iterable &gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()), Functor &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a6c6bbe00afd80cfb16f208f98defdc1a">operator|</a> (Iterable &amp;&amp;iterable, Functor const &amp;functor)</td></tr>
<tr class="separator:a6c6bbe00afd80cfb16f208f98defdc1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48b523e6ba2de8e88d706f7bad439e00"><td class="memTemplParams" colspan="2">template&lt;size_t N&gt; </td></tr>
<tr class="memitem:a48b523e6ba2de8e88d706f7bad439e00"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; hydra_thrust::transform_iterator&lt; <a class="el" href="structhydra_1_1detail_1_1GenerateDecay.html">detail::GenerateDecay</a>&lt; N, hydra_thrust::random::default_random_engine &gt;, hydra_thrust::counting_iterator&lt; size_t &gt;, typename <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1tuple__cat__type">hydra::detail::tuple_cat_type</a>&lt; hydra_thrust::tuple&lt; <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt;, typename <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1tuple__type">hydra::detail::tuple_type</a>&lt; N, Vector4R &gt;::type &gt;::type &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a48b523e6ba2de8e88d706f7bad439e00">phase_space_range</a> (Vector4R const &amp;mother, std::array&lt; <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>, N &gt; <a class="el" href="phsp__unweighting_8inl.html#ad507bdbe1cd7219fead6e9dcd287d908">masses</a>, size_t seed, size_t length=0)</td></tr>
<tr class="separator:a48b523e6ba2de8e88d706f7bad439e00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae85d86e6980bcf24de91a003711b3224"><td class="memItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ae85d86e6980bcf24de91a003711b3224">pmf</a> (const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> mother_mass, const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> daughter1_mass, const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> daughter2_mass)</td></tr>
<tr class="memdesc:ae85d86e6980bcf24de91a003711b3224"><td class="mdescLeft">&#160;</td><td class="mdescRight">Momentum in mother frame of daughter particle in two-body-decay.  <a href="#ae85d86e6980bcf24de91a003711b3224">More...</a><br /></td></tr>
<tr class="separator:ae85d86e6980bcf24de91a003711b3224"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3cc52fabc8882be13d9a6ca92fc648e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae3cc52fabc8882be13d9a6ca92fc648e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespacehydra.html#a9be56668c1da1edd25b29c366adf5df9">complex</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ae3cc52fabc8882be13d9a6ca92fc648e">polar</a> (const T &amp;m, const T &amp;theta=0)</td></tr>
<tr class="separator:ae3cc52fabc8882be13d9a6ca92fc648e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95aad7e7e244a3cb3c71a4d57e695511"><td class="memTemplParams" colspan="2">template&lt;typename T , unsigned int N&gt; </td></tr>
<tr class="memitem:a95aad7e7e244a3cb3c71a4d57e695511"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a95aad7e7e244a3cb3c71a4d57e695511">pow</a> (T x)</td></tr>
<tr class="memdesc:a95aad7e7e244a3cb3c71a4d57e695511"><td class="mdescLeft">&#160;</td><td class="mdescRight">Power with integer exponent.  <a href="#a95aad7e7e244a3cb3c71a4d57e695511">More...</a><br /></td></tr>
<tr class="separator:a95aad7e7e244a3cb3c71a4d57e695511"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2256bff965f5a7359591579a97114ec"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac2256bff965f5a7359591579a97114ec"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespacehydra.html#a9be56668c1da1edd25b29c366adf5df9">complex</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ac2256bff965f5a7359591579a97114ec">pow</a> (const <a class="el" href="namespacehydra.html#a9be56668c1da1edd25b29c366adf5df9">complex</a>&lt; T &gt; &amp;x, const <a class="el" href="namespacehydra.html#a9be56668c1da1edd25b29c366adf5df9">complex</a>&lt; T &gt; &amp;y)</td></tr>
<tr class="separator:ac2256bff965f5a7359591579a97114ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cf806d100f53f6d281b8b826697e10f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4cf806d100f53f6d281b8b826697e10f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespacehydra.html#a9be56668c1da1edd25b29c366adf5df9">complex</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a4cf806d100f53f6d281b8b826697e10f">pow</a> (const <a class="el" href="namespacehydra.html#a9be56668c1da1edd25b29c366adf5df9">complex</a>&lt; T &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:a4cf806d100f53f6d281b8b826697e10f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e9146d77dfa5b6c0fcbcb31557f6854"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2e9146d77dfa5b6c0fcbcb31557f6854"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespacehydra.html#a9be56668c1da1edd25b29c366adf5df9">complex</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a2e9146d77dfa5b6c0fcbcb31557f6854">pow</a> (const T &amp;x, const <a class="el" href="namespacehydra.html#a9be56668c1da1edd25b29c366adf5df9">complex</a>&lt; T &gt; &amp;y)</td></tr>
<tr class="separator:a2e9146d77dfa5b6c0fcbcb31557f6854"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aece82a0891f743f40547b399caad49ec"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:aece82a0891f743f40547b399caad49ec"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespacehydra.html#a9be56668c1da1edd25b29c366adf5df9">complex</a>&lt; typename hydra_thrust::detail::promoted_numerical_type&lt; T, U &gt;::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#aece82a0891f743f40547b399caad49ec">pow</a> (const <a class="el" href="namespacehydra.html#a9be56668c1da1edd25b29c366adf5df9">complex</a>&lt; T &gt; &amp;x, const <a class="el" href="namespacehydra.html#a9be56668c1da1edd25b29c366adf5df9">complex</a>&lt; U &gt; &amp;y)</td></tr>
<tr class="separator:aece82a0891f743f40547b399caad49ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f50462bdedcc2c5965cbff78acb0bf3"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a6f50462bdedcc2c5965cbff78acb0bf3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespacehydra.html#a9be56668c1da1edd25b29c366adf5df9">complex</a>&lt; typename hydra_thrust::detail::promoted_numerical_type&lt; T, U &gt;::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a6f50462bdedcc2c5965cbff78acb0bf3">pow</a> (const <a class="el" href="namespacehydra.html#a9be56668c1da1edd25b29c366adf5df9">complex</a>&lt; T &gt; &amp;x, const U &amp;y)</td></tr>
<tr class="separator:a6f50462bdedcc2c5965cbff78acb0bf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeac8e091577c3ede26c1c26123c07621"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:aeac8e091577c3ede26c1c26123c07621"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespacehydra.html#a9be56668c1da1edd25b29c366adf5df9">complex</a>&lt; typename hydra_thrust::detail::promoted_numerical_type&lt; T, U &gt;::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#aeac8e091577c3ede26c1c26123c07621">pow</a> (const T &amp;x, const <a class="el" href="namespacehydra.html#a9be56668c1da1edd25b29c366adf5df9">complex</a>&lt; U &gt; &amp;y)</td></tr>
<tr class="separator:aeac8e091577c3ede26c1c26123c07621"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb0c9817024c69efe44c2d9653928519"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:acb0c9817024c69efe44c2d9653928519"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#acb0c9817024c69efe44c2d9653928519">PrintToStream</a> (std::ostream &amp;ostream, const char *format, Args... args)</td></tr>
<tr class="separator:acb0c9817024c69efe44c2d9653928519"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace0454750e3561d390ee18b96824227c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ace0454750e3561d390ee18b96824227c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespacehydra.html#a9be56668c1da1edd25b29c366adf5df9">complex</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ace0454750e3561d390ee18b96824227c">proj</a> (const T &amp;z)</td></tr>
<tr class="separator:ace0454750e3561d390ee18b96824227c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eaf1e3a145e0b3333e752ec877c4a96"><td class="memTemplParams" colspan="2">template&lt;typename Value_Type &gt; </td></tr>
<tr class="memitem:a5eaf1e3a145e0b3333e752ec877c4a96"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; hydra_thrust::transform_iterator&lt; <a class="el" href="structhydra_1_1detail_1_1RndExp.html">detail::RndExp</a>&lt; Value_Type, hydra_thrust::random::default_random_engine &gt;,hydra_thrust::counting_iterator&lt; size_t &gt;, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a5eaf1e3a145e0b3333e752ec877c4a96">random_exp_range</a> (const Value_Type &amp;<a class="el" href="basic__distributions_8inl.html#af09d0683face1f506ef2f42ab173b495">tau</a>, size_t seed, size_t length=0)</td></tr>
<tr class="separator:a5eaf1e3a145e0b3333e752ec877c4a96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20f37e84460e63d91583c2a08a6fe937"><td class="memTemplParams" colspan="2">template&lt;typename Value_Type &gt; </td></tr>
<tr class="memitem:a20f37e84460e63d91583c2a08a6fe937"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; hydra_thrust::transform_iterator&lt; <a class="el" href="structhydra_1_1detail_1_1RndGauss.html">detail::RndGauss</a>&lt; Value_Type, hydra_thrust::random::default_random_engine &gt;,hydra_thrust::counting_iterator&lt; size_t &gt;, Value_Type &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a20f37e84460e63d91583c2a08a6fe937">random_gauss_range</a> (Value_Type <a class="el" href="basic__distributions_8inl.html#af5f88b70b94c2ada29011f672e3e88a4">mean</a>, Value_Type <a class="el" href="basic__distributions_8inl.html#a3e2a4a021e927d770355f2971942d62a">width</a>, size_t seed, size_t length=0)</td></tr>
<tr class="separator:a20f37e84460e63d91583c2a08a6fe937"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17d0eafddb7421defa88d26db3605077"><td class="memTemplParams" colspan="2">template&lt;typename Value_Type &gt; </td></tr>
<tr class="memitem:a17d0eafddb7421defa88d26db3605077"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; hydra_thrust::transform_iterator&lt; <a class="el" href="structhydra_1_1detail_1_1RndUniform.html">detail::RndUniform</a>&lt; Value_Type, hydra_thrust::random::default_random_engine &gt;,hydra_thrust::counting_iterator&lt; size_t &gt;, Value_Type &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a17d0eafddb7421defa88d26db3605077">random_uniform_range</a> (const Value_Type &amp;<a class="el" href="particle__mass_8inl.html#aad36546e8175d2922bee165fe028fedc">min</a>, const Value_Type &amp;<a class="el" href="particle__mass_8inl.html#a0b0ede69e8156eb97acc579b88e883de">max</a>, size_t seed, size_t length=0)</td></tr>
<tr class="separator:a17d0eafddb7421defa88d26db3605077"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bcce8141d53ae8f8dafe05ff48eba90"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; hydra_thrust::counting_iterator&lt; long <a class="el" href="namespace_3globalScope_4.html#classint">int</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a5bcce8141d53ae8f8dafe05ff48eba90">range</a> (long <a class="el" href="namespace_3globalScope_4.html#classint">int</a> first, long <a class="el" href="namespace_3globalScope_4.html#classint">int</a> last)</td></tr>
<tr class="separator:a5bcce8141d53ae8f8dafe05ff48eba90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4aeda609504b066b04129ac175bc52f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae4aeda609504b066b04129ac175bc52f"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_floating_point&lt; T &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; hydra_thrust::counting_iterator&lt; <a class="el" href="namespace_3globalScope_4.html#classunsigned">unsigned</a> &gt;, <a class="el" href="structhydra_1_1detail_1_1range_1_1Shift.html">detail::range::Shift</a>&lt; T &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ae4aeda609504b066b04129ac175bc52f">range</a> (T <a class="el" href="particle__mass_8inl.html#aad36546e8175d2922bee165fe028fedc">min</a>, T <a class="el" href="particle__mass_8inl.html#a0b0ede69e8156eb97acc579b88e883de">max</a>, <a class="el" href="namespace_3globalScope_4.html#classunsigned">unsigned</a> nbins)</td></tr>
<tr class="separator:ae4aeda609504b066b04129ac175bc52f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a589e3fc7f3e94613126a8198bf90dd59"><td class="memItemLeft" align="right" valign="top"><a class="el" href="basic__distributions_8inl.html#a9717e7bbecb906637e86cef6da3d83c2">return</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a589e3fc7f3e94613126a8198bf90dd59">Range&lt; iterator_type &gt;</a> (other.begin(cls...), <a class="el" href="phsp__unweighting_8inl.html#a6be7d98960df33edf9f3998a9e8b2407">other.end</a>(cls...))</td></tr>
<tr class="separator:a589e3fc7f3e94613126a8198bf90dd59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf9723fecdbba95ef0e6ccfd8b30994a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="basic__distributions_8inl.html#a9717e7bbecb906637e86cef6da3d83c2">return</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#abf9723fecdbba95ef0e6ccfd8b30994a">Range&lt; iterator_type &gt;</a> (other.begin(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;{}), <a class="el" href="phsp__unweighting_8inl.html#a6be7d98960df33edf9f3998a9e8b2407">other.end</a>(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;{}))</td></tr>
<tr class="separator:abf9723fecdbba95ef0e6ccfd8b30994a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadcca49207bf7ab79088f28cddb8f21d"><td class="memTemplParams" colspan="2">template&lt;class C &gt; </td></tr>
<tr class="memitem:aadcca49207bf7ab79088f28cddb8f21d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#aadcca49207bf7ab79088f28cddb8f21d">rbegin</a> (<a class="el" href="basic__distributions_8inl.html#a4900ef306eb9271438791f1a98b8ccba">C</a> &amp;&amp;c) -&gt; decltype(std::forward&lt; <a class="el" href="basic__distributions_8inl.html#a4900ef306eb9271438791f1a98b8ccba">C</a> &gt;(c).rbegin())</td></tr>
<tr class="separator:aadcca49207bf7ab79088f28cddb8f21d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a434c6a6c1a24dbd8ca880af38694803d"><td class="memTemplParams" colspan="2">template&lt;class C &gt; </td></tr>
<tr class="memitem:a434c6a6c1a24dbd8ca880af38694803d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a434c6a6c1a24dbd8ca880af38694803d">rbegin</a> (const <a class="el" href="basic__distributions_8inl.html#a4900ef306eb9271438791f1a98b8ccba">C</a> &amp;c) -&gt; decltype(c.rbegin())</td></tr>
<tr class="separator:a434c6a6c1a24dbd8ca880af38694803d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d87c9638b5f275d1fbbef560a3c0197"><td class="memTemplParams" colspan="2">template&lt;class T , size_t N&gt; </td></tr>
<tr class="memitem:a0d87c9638b5f275d1fbbef560a3c0197"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a0d87c9638b5f275d1fbbef560a3c0197">rbegin</a> (T(&amp;array)[N])</td></tr>
<tr class="separator:a0d87c9638b5f275d1fbbef560a3c0197"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69daea4927958e8a666ee6ed3a795cbd"><td class="memTemplParams" colspan="2">template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename T , size_t N&gt; </td></tr>
<tr class="memitem:a69daea4927958e8a666ee6ed3a795cbd"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a69daea4927958e8a666ee6ed3a795cbd">rbegin</a> (<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;, <a class="el" href="namespacehydra.html#classhydra_1_1multiarray">multiarray</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; const &amp;other) -&gt; decltype(other.rbegin(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;</td></tr>
<tr class="separator:a69daea4927958e8a666ee6ed3a795cbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a932ef4185794129e04c9a4220db464eb"><td class="memTemplParams" colspan="2">template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename T , size_t N&gt; </td></tr>
<tr class="memitem:a932ef4185794129e04c9a4220db464eb"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a932ef4185794129e04c9a4220db464eb">rbegin</a> (<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;, <a class="el" href="namespacehydra.html#classhydra_1_1multiarray">multiarray</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; &amp;other) -&gt; decltype(other.rbegin(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;</td></tr>
<tr class="separator:a932ef4185794129e04c9a4220db464eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57219e4fdd099c8aa6146d96e25952a9"><td class="memTemplParams" colspan="2">template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename ... T&gt; </td></tr>
<tr class="memitem:a57219e4fdd099c8aa6146d96e25952a9"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a57219e4fdd099c8aa6146d96e25952a9">rbegin</a> (<a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; hydra_thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; const &amp;other) -&gt; decltype(other.rbegin(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;</td></tr>
<tr class="separator:a57219e4fdd099c8aa6146d96e25952a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a32676d58ec38a6d96188f2a4535ab5"><td class="memTemplParams" colspan="2">template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename ... T&gt; </td></tr>
<tr class="memitem:a8a32676d58ec38a6d96188f2a4535ab5"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a8a32676d58ec38a6d96188f2a4535ab5">rbegin</a> (<a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; hydra_thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; &amp;other) -&gt; decltype(other.rbegin(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;</td></tr>
<tr class="separator:a8a32676d58ec38a6d96188f2a4535ab5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6988f3f5580e46402b7162f9ceb43ee"><td class="memTemplParams" colspan="2">template&lt;typename Iterable &gt; </td></tr>
<tr class="memitem:aa6988f3f5580e46402b7162f9ceb43ee"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; Iterable &gt;::value, typename hydra_thrust::iterator_traits&lt; decltype(std::declval&lt; Iterable &gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>())&gt;::value_type &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#aa6988f3f5580e46402b7162f9ceb43ee">reduce</a> (Iterable &amp;&amp;iterable)</td></tr>
<tr class="separator:aa6988f3f5580e46402b7162f9ceb43ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63b9d5a2744d5acc0852b40f5262eb17"><td class="memTemplParams" colspan="2">template&lt;typename Iterable , typename Functor , typename T  = typename hydra_thrust::iterator_traits&lt;		     decltype(std::declval&lt;Iterable&gt;().begin())&gt;::value_type&gt; </td></tr>
<tr class="memitem:a63b9d5a2744d5acc0852b40f5262eb17"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; Iterable &gt;::value, T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a63b9d5a2744d5acc0852b40f5262eb17">reduce</a> (Iterable &amp;&amp;iterable, T const &amp;init, Functor const &amp;binary_functor)</td></tr>
<tr class="separator:a63b9d5a2744d5acc0852b40f5262eb17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58e00797465282d00eeaf0cd82d1c076"><td class="memTemplParams" colspan="2">template&lt;class C &gt; </td></tr>
<tr class="memitem:a58e00797465282d00eeaf0cd82d1c076"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a58e00797465282d00eeaf0cd82d1c076">rend</a> (<a class="el" href="basic__distributions_8inl.html#a4900ef306eb9271438791f1a98b8ccba">C</a> &amp;&amp;c) -&gt; decltype(std::forward&lt; <a class="el" href="basic__distributions_8inl.html#a4900ef306eb9271438791f1a98b8ccba">C</a> &gt;(c).rend())</td></tr>
<tr class="separator:a58e00797465282d00eeaf0cd82d1c076"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48be0e2a44047208c68e2c096683db35"><td class="memTemplParams" colspan="2">template&lt;class C &gt; </td></tr>
<tr class="memitem:a48be0e2a44047208c68e2c096683db35"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a48be0e2a44047208c68e2c096683db35">rend</a> (const <a class="el" href="basic__distributions_8inl.html#a4900ef306eb9271438791f1a98b8ccba">C</a> &amp;c) -&gt; decltype(c.rend())</td></tr>
<tr class="separator:a48be0e2a44047208c68e2c096683db35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f3625ffa0bf89a7d056a0d2b226e882"><td class="memTemplParams" colspan="2">template&lt;class T , size_t N&gt; </td></tr>
<tr class="memitem:a7f3625ffa0bf89a7d056a0d2b226e882"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a7f3625ffa0bf89a7d056a0d2b226e882">rend</a> (T(&amp;array)[N])</td></tr>
<tr class="separator:a7f3625ffa0bf89a7d056a0d2b226e882"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad79366fdc5ac96950ef240f03e0321b5"><td class="memTemplParams" colspan="2">template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename T , size_t N&gt; </td></tr>
<tr class="memitem:ad79366fdc5ac96950ef240f03e0321b5"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ad79366fdc5ac96950ef240f03e0321b5">rend</a> (<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;, <a class="el" href="namespacehydra.html#classhydra_1_1multiarray">multiarray</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; const &amp;other) -&gt; decltype(other.rend(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;</td></tr>
<tr class="separator:ad79366fdc5ac96950ef240f03e0321b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a175fc3749a8859251e455ea11b8739f8"><td class="memTemplParams" colspan="2">template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename T , size_t N&gt; </td></tr>
<tr class="memitem:a175fc3749a8859251e455ea11b8739f8"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a175fc3749a8859251e455ea11b8739f8">rend</a> (<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;, <a class="el" href="namespacehydra.html#classhydra_1_1multiarray">multiarray</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; &amp;other) -&gt; decltype(other.rend(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;</td></tr>
<tr class="separator:a175fc3749a8859251e455ea11b8739f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86b2c2246658f870623ef17332b1f3cd"><td class="memTemplParams" colspan="2">template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename ... T&gt; </td></tr>
<tr class="memitem:a86b2c2246658f870623ef17332b1f3cd"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a86b2c2246658f870623ef17332b1f3cd">rend</a> (<a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; hydra_thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; const &amp;other) -&gt; decltype(other.rend(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;</td></tr>
<tr class="separator:a86b2c2246658f870623ef17332b1f3cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a430457d59572ba165f2fcaf877e8975c"><td class="memTemplParams" colspan="2">template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename ... T&gt; </td></tr>
<tr class="memitem:a430457d59572ba165f2fcaf877e8975c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a430457d59572ba165f2fcaf877e8975c">rend</a> (<a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; hydra_thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; &amp;other) -&gt; decltype(other.rend(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;</td></tr>
<tr class="separator:a430457d59572ba165f2fcaf877e8975c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c4c8a32d3456681824f36d2058deb4b"><td class="memTemplParams" colspan="2">template&lt;typename Iterable &gt; </td></tr>
<tr class="memitem:a9c4c8a32d3456681824f36d2058deb4b"><td class="memTemplItemLeft" align="right" valign="top">hydra_thrust::detail::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">detail::is_iterable</a>&lt; Iterable &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; hydra_thrust::reverse_iterator&lt; decltype(std::declval&lt; Iterable &gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()) &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a9c4c8a32d3456681824f36d2058deb4b">reverse</a> (Iterable &amp;&amp;iterable)</td></tr>
<tr class="separator:a9c4c8a32d3456681824f36d2058deb4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad27ce158f82bfcf3ba0855a224a3f626"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad27ce158f82bfcf3ba0855a224a3f626"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ad27ce158f82bfcf3ba0855a224a3f626">rint</a> (T x)</td></tr>
<tr class="separator:ad27ce158f82bfcf3ba0855a224a3f626"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a9e21c7083ea65e58667297a801f0c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> Vector4R&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a4a9e21c7083ea65e58667297a801f0c0">rotateEuler</a> (const Vector4R &amp;rs, <a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> <a class="el" href="crystal__ball__plus__exponential_8inl.html#a143fa1ae6e83f554763008ef6fc4829b">alpha</a>, <a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> <a class="el" href="particle__mass_8inl.html#a7033d85826bd54896b58da524b818474">beta</a>, <a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> <a class="el" href="basic__distributions_8inl.html#acdd95f533acd83442ce3dec24fa4e49b">gamma</a>)</td></tr>
<tr class="separator:a4a9e21c7083ea65e58667297a801f0c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9637ed446b2f89c3514f57bac1fd1be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> Vector3R&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ab9637ed446b2f89c3514f57bac1fd1be">rotateEuler</a> (const Vector3R &amp;v, <a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> phi, <a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> theta, <a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> ksi)</td></tr>
<tr class="separator:ab9637ed446b2f89c3514f57bac1fd1be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed01ab7e551c3ca33d6b8df7b27c4a31"><td class="memTemplParams" colspan="2">template&lt;typename RNG , typename DerivedPolicy , typename Functor , typename Iterator &gt; </td></tr>
<tr class="memitem:aed01ab7e551c3ca33d6b8df7b27c4a31"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1random_1_1is__callable.html">detail::random::is_callable</a>&lt; Functor &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1random_1_1is__iterator.html">detail::random::is_iterator</a>&lt; Iterator &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; Iterator &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#aed01ab7e551c3ca33d6b8df7b27c4a31">sample</a> (hydra_thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; const  &amp;policy, Iterator <a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>, Iterator <a class="el" href="namespacehydra.html#a4274268d147e9a988f379326b73682b0">end</a>, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> <a class="el" href="particle__mass_8inl.html#aad36546e8175d2922bee165fe028fedc">min</a>, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> <a class="el" href="particle__mass_8inl.html#a0b0ede69e8156eb97acc579b88e883de">max</a>, Functor const  &amp;functor, size_t seed=0xb56c4feeef1b)</td></tr>
<tr class="memdesc:aed01ab7e551c3ca33d6b8df7b27c4a31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill a range with numbers distributed according a user defined distribution.  <a href="#aed01ab7e551c3ca33d6b8df7b27c4a31">More...</a><br /></td></tr>
<tr class="separator:aed01ab7e551c3ca33d6b8df7b27c4a31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ea037fa085eae26a9ff4b14d6473736"><td class="memTemplParams" colspan="2">template&lt;typename RNG , typename Functor , typename Iterator , hydra::detail::Backend BACKEND&gt; </td></tr>
<tr class="memitem:a9ea037fa085eae26a9ff4b14d6473736"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1random_1_1is__callable.html">detail::random::is_callable</a>&lt; Functor &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1random_1_1is__iterator.html">detail::random::is_iterator</a>&lt; Iterator &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; Iterator &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a9ea037fa085eae26a9ff4b14d6473736">sample</a> (<a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; const  &amp;policy, Iterator <a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>, Iterator <a class="el" href="namespacehydra.html#a4274268d147e9a988f379326b73682b0">end</a>, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> <a class="el" href="particle__mass_8inl.html#aad36546e8175d2922bee165fe028fedc">min</a>, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> <a class="el" href="particle__mass_8inl.html#a0b0ede69e8156eb97acc579b88e883de">max</a>, Functor const  &amp;functor, size_t seed=0xb56c4feeef1b)</td></tr>
<tr class="memdesc:a9ea037fa085eae26a9ff4b14d6473736"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill a range with numbers distributed according a user defined distribution.  <a href="#a9ea037fa085eae26a9ff4b14d6473736">More...</a><br /></td></tr>
<tr class="separator:a9ea037fa085eae26a9ff4b14d6473736"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e43c56c2acb0bc981adac7200f381d1"><td class="memTemplParams" colspan="2">template&lt;typename RNG , typename Functor , typename Iterator &gt; </td></tr>
<tr class="memitem:a5e43c56c2acb0bc981adac7200f381d1"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1random_1_1is__callable.html">detail::random::is_callable</a>&lt; Functor &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1random_1_1is__iterator.html">detail::random::is_iterator</a>&lt; Iterator &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; Iterator &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a5e43c56c2acb0bc981adac7200f381d1">sample</a> (Iterator <a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>, Iterator <a class="el" href="namespacehydra.html#a4274268d147e9a988f379326b73682b0">end</a>, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> <a class="el" href="particle__mass_8inl.html#aad36546e8175d2922bee165fe028fedc">min</a>, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> <a class="el" href="particle__mass_8inl.html#a0b0ede69e8156eb97acc579b88e883de">max</a>, Functor const  &amp;functor, size_t seed=0xb56c4feeef1b)</td></tr>
<tr class="memdesc:a5e43c56c2acb0bc981adac7200f381d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill a range with numbers distributed according a user defined distribution.  <a href="#a5e43c56c2acb0bc981adac7200f381d1">More...</a><br /></td></tr>
<tr class="separator:a5e43c56c2acb0bc981adac7200f381d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7a368f4ced51cbe178fe13bfc65b776"><td class="memTemplParams" colspan="2">template&lt;typename RNG , typename Functor , typename Iterable &gt; </td></tr>
<tr class="memitem:ac7a368f4ced51cbe178fe13bfc65b776"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1random_1_1is__callable.html">detail::random::is_callable</a>&lt; Functor &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1random_1_1is__iterable.html">detail::random::is_iterable</a>&lt; Iterable &gt;::value,<a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; decltype(std::declval&lt; Iterable &gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>())&gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ac7a368f4ced51cbe178fe13bfc65b776">sample</a> (Iterable &amp;&amp;output, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> <a class="el" href="particle__mass_8inl.html#aad36546e8175d2922bee165fe028fedc">min</a>, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> <a class="el" href="particle__mass_8inl.html#a0b0ede69e8156eb97acc579b88e883de">max</a>, Functor const  &amp;functor, size_t seed=0xb56c4feeef1b)</td></tr>
<tr class="memdesc:ac7a368f4ced51cbe178fe13bfc65b776"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill a range with numbers distributed according a user defined distribution.  <a href="#ac7a368f4ced51cbe178fe13bfc65b776">More...</a><br /></td></tr>
<tr class="separator:ac7a368f4ced51cbe178fe13bfc65b776"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28ab38a67a0c6da8c0b762e150d38363"><td class="memTemplParams" colspan="2">template&lt;typename RNG , typename DerivedPolicy , typename Functor , typename Iterator , size_t N&gt; </td></tr>
<tr class="memitem:a28ab38a67a0c6da8c0b762e150d38363"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1random_1_1is__callable.html">detail::random::is_callable</a>&lt; Functor &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1random_1_1is__iterator.html">detail::random::is_iterator</a>&lt; Iterator &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; Iterator &gt;&gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a28ab38a67a0c6da8c0b762e150d38363">sample</a> (hydra_thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; const &amp;policy, Iterator <a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>, Iterator <a class="el" href="namespacehydra.html#a4274268d147e9a988f379326b73682b0">end</a>, std::array&lt; <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>, N &gt; const &amp;<a class="el" href="particle__mass_8inl.html#aad36546e8175d2922bee165fe028fedc">min</a>, std::array&lt; <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>, N &gt; const &amp;<a class="el" href="particle__mass_8inl.html#a0b0ede69e8156eb97acc579b88e883de">max</a>, Functor const &amp;functor, size_t seed)</td></tr>
<tr class="memdesc:a28ab38a67a0c6da8c0b762e150d38363"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill a range with numbers distributed according a user defined distribution.  <a href="#a28ab38a67a0c6da8c0b762e150d38363">More...</a><br /></td></tr>
<tr class="separator:a28ab38a67a0c6da8c0b762e150d38363"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c226857e56377b95a3c80af185cd710"><td class="memTemplParams" colspan="2">template&lt;typename RNG , typename Functor , typename Iterator , hydra::detail::Backend BACKEND, size_t N&gt; </td></tr>
<tr class="memitem:a8c226857e56377b95a3c80af185cd710"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1random_1_1is__callable.html">detail::random::is_callable</a>&lt; Functor &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1random_1_1is__iterator.html">detail::random::is_iterator</a>&lt; Iterator &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; Iterator &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a8c226857e56377b95a3c80af185cd710">sample</a> (<a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; const  &amp;policy, Iterator <a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>, Iterator <a class="el" href="namespacehydra.html#a4274268d147e9a988f379326b73682b0">end</a>, std::array&lt; <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>, N &gt;const  &amp;<a class="el" href="particle__mass_8inl.html#aad36546e8175d2922bee165fe028fedc">min</a>, std::array&lt; <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>, N &gt;const  &amp;<a class="el" href="particle__mass_8inl.html#a0b0ede69e8156eb97acc579b88e883de">max</a>, Functor const  &amp;functor, size_t seed=0xb56c4feeef1b)</td></tr>
<tr class="memdesc:a8c226857e56377b95a3c80af185cd710"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill a range with numbers distributed according a user defined distribution.  <a href="#a8c226857e56377b95a3c80af185cd710">More...</a><br /></td></tr>
<tr class="separator:a8c226857e56377b95a3c80af185cd710"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8de60f2a597ac83cf3974b716a60f079"><td class="memTemplParams" colspan="2">template&lt;typename RNG , typename Functor , typename Iterator , size_t N&gt; </td></tr>
<tr class="memitem:a8de60f2a597ac83cf3974b716a60f079"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1random_1_1is__callable.html">detail::random::is_callable</a>&lt; Functor &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1random_1_1is__iterator.html">detail::random::is_iterator</a>&lt; Iterator &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; Iterator &gt;&gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a8de60f2a597ac83cf3974b716a60f079">sample</a> (Iterator <a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>, Iterator <a class="el" href="namespacehydra.html#a4274268d147e9a988f379326b73682b0">end</a>, std::array&lt; <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>, N &gt;const &amp;<a class="el" href="particle__mass_8inl.html#aad36546e8175d2922bee165fe028fedc">min</a>, std::array&lt; <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>, N &gt;const &amp;<a class="el" href="particle__mass_8inl.html#a0b0ede69e8156eb97acc579b88e883de">max</a>, Functor const &amp;functor, size_t seed)</td></tr>
<tr class="memdesc:a8de60f2a597ac83cf3974b716a60f079"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill a range with numbers distributed according a user defined distribution.  <a href="#a8de60f2a597ac83cf3974b716a60f079">More...</a><br /></td></tr>
<tr class="separator:a8de60f2a597ac83cf3974b716a60f079"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a580bac5409cfbad9ebcb47ed3f4d3842"><td class="memTemplParams" colspan="2">template&lt;typename RNG , typename Functor , typename Iterable , size_t N&gt; </td></tr>
<tr class="memitem:a580bac5409cfbad9ebcb47ed3f4d3842"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1random_1_1is__callable.html">detail::random::is_callable</a>&lt; Functor &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1random_1_1is__iterable.html">detail::random::is_iterable</a>&lt; Iterable &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; decltype(std::declval&lt; Iterable &gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>())&gt;&gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a580bac5409cfbad9ebcb47ed3f4d3842">sample</a> (Iterable &amp;&amp;output, std::array&lt; <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>, N &gt;const &amp;<a class="el" href="particle__mass_8inl.html#aad36546e8175d2922bee165fe028fedc">min</a>, std::array&lt; <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>, N &gt;const &amp;<a class="el" href="particle__mass_8inl.html#a0b0ede69e8156eb97acc579b88e883de">max</a>, Functor const &amp;functor, size_t seed)</td></tr>
<tr class="memdesc:a580bac5409cfbad9ebcb47ed3f4d3842"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill a range with numbers distributed according a user defined distribution.  <a href="#a580bac5409cfbad9ebcb47ed3f4d3842">More...</a><br /></td></tr>
<tr class="separator:a580bac5409cfbad9ebcb47ed3f4d3842"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a296616d9209f3b941819c71fd15fe490"><td class="memTemplParams" colspan="2">template&lt;typename RNG  = default_random_engine, typename Functor , typename Iterator , size_t N&gt; </td></tr>
<tr class="memitem:a296616d9209f3b941819c71fd15fe490"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1random_1_1is__callable.html">detail::random::is_callable</a>&lt; Functor &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1random_1_1is__iterator.html">detail::random::is_iterator</a>&lt; Iterator &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; Iterator &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a296616d9209f3b941819c71fd15fe490">sample</a> (Iterator <a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>, Iterator <a class="el" href="namespacehydra.html#a4274268d147e9a988f379326b73682b0">end</a>, std::array&lt; <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>, N &gt;const &amp;<a class="el" href="particle__mass_8inl.html#aad36546e8175d2922bee165fe028fedc">min</a>, std::array&lt; <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>, N &gt;const &amp;<a class="el" href="particle__mass_8inl.html#a0b0ede69e8156eb97acc579b88e883de">max</a>, Functor const &amp;functor, size_t seed=0xb56c4feeef1b)</td></tr>
<tr class="memdesc:a296616d9209f3b941819c71fd15fe490"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill a range with numbers distributed according a user defined distribution.  <a href="#a296616d9209f3b941819c71fd15fe490">More...</a><br /></td></tr>
<tr class="separator:a296616d9209f3b941819c71fd15fe490"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c55b6942a31d70e1a7a598ba29ad703"><td class="memTemplParams" colspan="2">template&lt;typename RNG  = default_random_engine, typename DerivedPolicy , typename Functor , typename Iterator , size_t N&gt; </td></tr>
<tr class="memitem:a5c55b6942a31d70e1a7a598ba29ad703"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1random_1_1is__callable.html">detail::random::is_callable</a>&lt; Functor &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1random_1_1is__iterator.html">detail::random::is_iterator</a>&lt; Iterator &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; Iterator &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a5c55b6942a31d70e1a7a598ba29ad703">sample</a> (hydra_thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; const &amp;policy, Iterator <a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>, Iterator <a class="el" href="namespacehydra.html#a4274268d147e9a988f379326b73682b0">end</a>, std::array&lt; <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>, N &gt;const &amp;<a class="el" href="particle__mass_8inl.html#aad36546e8175d2922bee165fe028fedc">min</a>, std::array&lt; <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>, N &gt;const &amp;<a class="el" href="particle__mass_8inl.html#a0b0ede69e8156eb97acc579b88e883de">max</a>, Functor const &amp;functor, size_t seed=0xb56c4feeef1b)</td></tr>
<tr class="memdesc:a5c55b6942a31d70e1a7a598ba29ad703"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill a range with numbers distributed according a user defined distribution.  <a href="#a5c55b6942a31d70e1a7a598ba29ad703">More...</a><br /></td></tr>
<tr class="separator:a5c55b6942a31d70e1a7a598ba29ad703"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13157ce8d4078e8b5bd17dbd9705a3ea"><td class="memTemplParams" colspan="2">template&lt;typename RNG  = default_random_engine, typename Functor , typename Iterable , size_t N&gt; </td></tr>
<tr class="memitem:a13157ce8d4078e8b5bd17dbd9705a3ea"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1random_1_1is__callable.html">detail::random::is_callable</a>&lt; Functor &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1random_1_1is__iterable.html">detail::random::is_iterable</a>&lt; Iterable &gt;::value,<a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; decltype(std::declval&lt; Iterable &gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>())&gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a13157ce8d4078e8b5bd17dbd9705a3ea">sample</a> (Iterable &amp;&amp;output, std::array&lt; <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>, N &gt;const &amp;<a class="el" href="particle__mass_8inl.html#aad36546e8175d2922bee165fe028fedc">min</a>, std::array&lt; <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>, N &gt;const &amp;<a class="el" href="particle__mass_8inl.html#a0b0ede69e8156eb97acc579b88e883de">max</a>, Functor const &amp;functor, size_t seed=0xb56c4feeef1b)</td></tr>
<tr class="memdesc:a13157ce8d4078e8b5bd17dbd9705a3ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill a range with numbers distributed according a user defined distribution.  <a href="#a13157ce8d4078e8b5bd17dbd9705a3ea">More...</a><br /></td></tr>
<tr class="separator:a13157ce8d4078e8b5bd17dbd9705a3ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b62f11052cf4a8e258b21b9f64f0c6d"><td class="memTemplParams" colspan="2">template&lt;typename Iterable_Source , typename Iterable_Target , typename Iterable_Map &gt; </td></tr>
<tr class="memitem:a7b62f11052cf4a8e258b21b9f64f0c6d"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; Iterable_Source &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; Iterable_Target &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; Iterable_Map &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; decltype(std::declval&lt; Iterable_Target &amp; &gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>())&gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a7b62f11052cf4a8e258b21b9f64f0c6d">scatter</a> (Iterable_Source &amp;&amp;source, Iterable_Map &amp;&amp;map, Iterable_Target &amp;&amp;target)</td></tr>
<tr class="separator:a7b62f11052cf4a8e258b21b9f64f0c6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8056e4374a5e077e4ecb940851166b51"><td class="memTemplParams" colspan="2">template&lt;typename Iterable , typename Functor &gt; </td></tr>
<tr class="memitem:a8056e4374a5e077e4ecb940851166b51"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; Iterable &gt;::value, std::pair&lt; <a class="el" href="namespacehydra.html#classhydra_1_1Range">hydra::Range</a>&lt; decltype(std::declval&lt; Iterable &gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>())&gt;, <a class="el" href="namespacehydra.html#classhydra_1_1Range">hydra::Range</a>&lt; decltype(std::declval&lt; Iterable &gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>())&gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a8056e4374a5e077e4ecb940851166b51">segregate</a> (Iterable &amp;&amp;container, Functor &amp;&amp;<a class="el" href="namespacehydra.html#aab0cc380e55d7f4d02106a74165f7162">filter</a>)</td></tr>
<tr class="separator:a8056e4374a5e077e4ecb940851166b51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5337fca35f17ea6b1001e76ce351f9e"><td class="memTemplParams" colspan="2">template&lt;typename Iterable , typename Functor &gt; </td></tr>
<tr class="memitem:ae5337fca35f17ea6b1001e76ce351f9e"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; Iterable &gt;::value, std::pair&lt; <a class="el" href="namespacehydra.html#classhydra_1_1Range">hydra::Range</a>&lt; decltype(std::declval&lt; Iterable &gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>())&gt;, <a class="el" href="namespacehydra.html#classhydra_1_1Range">hydra::Range</a>&lt; decltype(std::declval&lt; Iterable &gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>())&gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ae5337fca35f17ea6b1001e76ce351f9e">segregate</a> (Iterable &amp;&amp;container, Functor const &amp;<a class="el" href="namespacehydra.html#aab0cc380e55d7f4d02106a74165f7162">filter</a>)</td></tr>
<tr class="separator:ae5337fca35f17ea6b1001e76ce351f9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb7d0e5da38544692eb3545e81617e19"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:acb7d0e5da38544692eb3545e81617e19"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespacehydra.html#a9be56668c1da1edd25b29c366adf5df9">complex</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#acb7d0e5da38544692eb3545e81617e19">sin</a> (const <a class="el" href="namespacehydra.html#a9be56668c1da1edd25b29c366adf5df9">complex</a>&lt; T &gt; &amp;z)</td></tr>
<tr class="separator:acb7d0e5da38544692eb3545e81617e19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af59c474655ecd14c6748391d80e2e4c2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af59c474655ecd14c6748391d80e2e4c2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespacehydra.html#a9be56668c1da1edd25b29c366adf5df9">complex</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#af59c474655ecd14c6748391d80e2e4c2">sinh</a> (const <a class="el" href="namespacehydra.html#a9be56668c1da1edd25b29c366adf5df9">complex</a>&lt; T &gt; &amp;z)</td></tr>
<tr class="separator:af59c474655ecd14c6748391d80e2e4c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b6b3a330b6d16d3221bb7b994b9329b"><td class="memTemplParams" colspan="2">template&lt;typename Iterable , typename Iterator  = decltype(std::declval&lt;Iterable&gt;().begin())&gt; </td></tr>
<tr class="memitem:a5b6b3a330b6d16d3221bb7b994b9329b"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; Iterable &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; decltype(std::declval&lt; Iterable &amp; &gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>())&gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a5b6b3a330b6d16d3221bb7b994b9329b">sort</a> (Iterable &amp;iterable)</td></tr>
<tr class="separator:a5b6b3a330b6d16d3221bb7b994b9329b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac64c757c35da63a927af0ad5147ac7c5"><td class="memTemplParams" colspan="2">template&lt;typename Iterable , typename Functor , typename Iterator  = decltype(std::declval&lt;Iterable&gt;().begin())&gt; </td></tr>
<tr class="memitem:ac64c757c35da63a927af0ad5147ac7c5"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; Iterable &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; decltype(std::declval&lt; Iterable &amp; &gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>())&gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ac64c757c35da63a927af0ad5147ac7c5">sort</a> (Iterable &amp;iterable, Functor const &amp;comparator)</td></tr>
<tr class="separator:ac64c757c35da63a927af0ad5147ac7c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34662231e9292fda55e3a182ea5d342a"><td class="memTemplParams" colspan="2">template&lt;typename Iterable , typename Iterable_Key , typename Iterator  = decltype(std::declval&lt;Iterable&gt;().begin()), typename Iterator_Key  = decltype(std::declval&lt;Iterable_Key&gt;().begin()), typename Value_Key  = decltype(*std::declval&lt;Iterator_Key&gt;().begin())&gt; </td></tr>
<tr class="memitem:a34662231e9292fda55e3a182ea5d342a"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; Iterable &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; decltype(std::declval&lt; Iterable &amp; &gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>())&gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a34662231e9292fda55e3a182ea5d342a">sort_by_key</a> (Iterable &amp;iterable, Iterable_Key &amp;keys)</td></tr>
<tr class="separator:a34662231e9292fda55e3a182ea5d342a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5d13834b7141cdaba43ad83ca671e7a"><td class="memTemplParams" colspan="2">template&lt;typename Iterable , typename Iterator_Key , typename Functor , typename Iterator  = decltype(std::declval&lt;Iterable&gt;().begin()), typename Value_Key  = decltype(*std::declval&lt;Range&lt;Iterator_Key,Functor&gt;&gt;().begin())&gt; </td></tr>
<tr class="memitem:ae5d13834b7141cdaba43ad83ca671e7a"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; Iterable &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; decltype(std::declval&lt; Iterable &amp; &gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>())&gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ae5d13834b7141cdaba43ad83ca671e7a">sort_by_key</a> (Iterable &amp;iterable, <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; Iterator_Key, Functor &gt; keys)</td></tr>
<tr class="separator:ae5d13834b7141cdaba43ad83ca671e7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41f704c48c1d979a21484290bb17aaae"><td class="memTemplParams" colspan="2">template&lt;typename Iterator1 , typename Iterator2 , typename Type &gt; </td></tr>
<tr class="memitem:a41f704c48c1d979a21484290bb17aaae"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> std::enable_if&lt; std::is_floating_point&lt; typename hydra_thrust::iterator_traits&lt; Iterator1 &gt;::value_type &gt;::value &amp;&amp;std::is_floating_point&lt; typename hydra_thrust::iterator_traits&lt; Iterator2 &gt;::value_type &gt;::value, Type &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a41f704c48c1d979a21484290bb17aaae">spiline</a> (Iterator1 first, Iterator1 last, Iterator2 measurements, Type value)</td></tr>
<tr class="separator:a41f704c48c1d979a21484290bb17aaae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cfc5a85539744bfe13c531c9233b869"><td class="memTemplParams" colspan="2">template&lt;typename Iterable1 , typename Iterable2 , typename Type &gt; </td></tr>
<tr class="memitem:a9cfc5a85539744bfe13c531c9233b869"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; Iterable1 &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; Iterable2 &gt;::value &amp;&amp;std::is_floating_point&lt; typename Iterable1::value_type &gt;::value &amp;&amp;std::is_floating_point&lt; typename Iterable2::value_type &gt;::value, Type &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a9cfc5a85539744bfe13c531c9233b869">spiline</a> (Iterable1 &amp;&amp;abscissae, Iterable2 &amp;&amp;ordinate, Type value)</td></tr>
<tr class="separator:a9cfc5a85539744bfe13c531c9233b869"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74988a829019bf111e7f51d81b33eec7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a74988a829019bf111e7f51d81b33eec7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespacehydra.html#a9be56668c1da1edd25b29c366adf5df9">complex</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a74988a829019bf111e7f51d81b33eec7">sqrt</a> (const <a class="el" href="namespacehydra.html#a9be56668c1da1edd25b29c366adf5df9">complex</a>&lt; T &gt; &amp;z)</td></tr>
<tr class="separator:a74988a829019bf111e7f51d81b33eec7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa792627bbf68dd5d3c3d969c3462808f"><td class="memTemplParams" colspan="2">template&lt;size_t N, typename T , size_t I&gt; </td></tr>
<tr class="memitem:aa792627bbf68dd5d3c3d969c3462808f"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;(I==N), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#aa792627bbf68dd5d3c3d969c3462808f">stream_array_helper</a> (std::ostream &amp;, std::array&lt; T, N &gt; const &amp;)</td></tr>
<tr class="memdesc:aa792627bbf68dd5d3c3d969c3462808f"><td class="mdescLeft">&#160;</td><td class="mdescRight">array streamer helper  <a href="#aa792627bbf68dd5d3c3d969c3462808f">More...</a><br /></td></tr>
<tr class="separator:aa792627bbf68dd5d3c3d969c3462808f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b2446e6e58a2466b66c1277d67075ad"><td class="memTemplParams" colspan="2">template&lt;size_t N, typename T , size_t I = 0&gt; </td></tr>
<tr class="memitem:a6b2446e6e58a2466b66c1277d67075ad"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;(I&lt; N), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a6b2446e6e58a2466b66c1277d67075ad">stream_array_helper</a> (std::ostream &amp;os, std::array&lt; T, N &gt; const &amp;obj)</td></tr>
<tr class="separator:a6b2446e6e58a2466b66c1277d67075ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa8b42796ae70a6c34b6871a8755b382"><td class="memTemplParams" colspan="2">template&lt;size_t I, typename ... T&gt; </td></tr>
<tr class="memitem:afa8b42796ae70a6c34b6871a8755b382"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;(I==sizeof ...(T)), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#afa8b42796ae70a6c34b6871a8755b382">stream_tuple_helper</a> (std::ostream &amp;, std::tuple&lt; T... &gt; const &amp;)</td></tr>
<tr class="memdesc:afa8b42796ae70a6c34b6871a8755b382"><td class="mdescLeft">&#160;</td><td class="mdescRight">tuple streamer helper  <a href="#afa8b42796ae70a6c34b6871a8755b382">More...</a><br /></td></tr>
<tr class="separator:afa8b42796ae70a6c34b6871a8755b382"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0ba407638beac5920ac997d3021b413"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename ... T&gt; </td></tr>
<tr class="memitem:af0ba407638beac5920ac997d3021b413"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;(I&lt; sizeof ...(T)), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#af0ba407638beac5920ac997d3021b413">stream_tuple_helper</a> (std::ostream &amp;os, std::tuple&lt; T... &gt; const &amp;obj)</td></tr>
<tr class="separator:af0ba407638beac5920ac997d3021b413"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a939ad741ed8f9f39a61680c9f7f442ae"><td class="memTemplParams" colspan="2">template&lt;typename F1 , typename F2 , typename ... Fs&gt; </td></tr>
<tr class="memitem:a939ad741ed8f9f39a61680c9f7f442ae"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;(<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt; F1 &gt;::value||<a class="el" href="structhydra_1_1detail_1_1is__hydra__lambda.html">detail::is_hydra_lambda</a>&lt; F1 &gt;::value) &amp;&amp;(<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt; F2 &gt;::value||<a class="el" href="structhydra_1_1detail_1_1is__hydra__lambda.html">detail::is_hydra_lambda</a>&lt; F2 &gt;::value) &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1all__true.html">detail::all_true</a>&lt;(<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt; Fs &gt;::value||<a class="el" href="structhydra_1_1detail_1_1is__hydra__lambda.html">detail::is_hydra_lambda</a>&lt; Fs &gt;::value)... &gt;::value, <a class="el" href="classhydra_1_1Sum.html">Sum</a>&lt; F1, F2, Fs... &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a939ad741ed8f9f39a61680c9f7f442ae">sum</a> (F1 const &amp;f1, F2 const &amp;f2, Fs const &amp;... functors)</td></tr>
<tr class="separator:a939ad741ed8f9f39a61680c9f7f442ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7d619f99868f45f5e06b9040bcc68b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#aa7d619f99868f45f5e06b9040bcc68b7">swap</a> (Vector3R &amp;v1, Vector3R &amp;v2)</td></tr>
<tr class="separator:aa7d619f99868f45f5e06b9040bcc68b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67385a5afc562279b4419a11ab79e3d6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a67385a5afc562279b4419a11ab79e3d6">swap</a> (Vector4R &amp;v1, Vector4R &amp;v2)</td></tr>
<tr class="separator:a67385a5afc562279b4419a11ab79e3d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a110443bb149efe88b6713bc5aca89b7c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a110443bb149efe88b6713bc5aca89b7c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespacehydra.html#a9be56668c1da1edd25b29c366adf5df9">complex</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a110443bb149efe88b6713bc5aca89b7c">tan</a> (const <a class="el" href="namespacehydra.html#a9be56668c1da1edd25b29c366adf5df9">complex</a>&lt; T &gt; &amp;z)</td></tr>
<tr class="separator:a110443bb149efe88b6713bc5aca89b7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c39f4b7fa2b8b0c1e4066e9d059b435"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5c39f4b7fa2b8b0c1e4066e9d059b435"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespacehydra.html#a9be56668c1da1edd25b29c366adf5df9">complex</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a5c39f4b7fa2b8b0c1e4066e9d059b435">tanh</a> (const <a class="el" href="namespacehydra.html#a9be56668c1da1edd25b29c366adf5df9">complex</a>&lt; T &gt; &amp;z)</td></tr>
<tr class="separator:a5c39f4b7fa2b8b0c1e4066e9d059b435"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1dba4dcfb81c7ad5404533f6d3b4bd7"><td class="memTemplParams" colspan="2">template&lt;class ... T&gt; </td></tr>
<tr class="memitem:aa1dba4dcfb81c7ad5404533f6d3b4bd7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#aa1dba4dcfb81c7ad5404533f6d3b4bd7">tie</a> (T &amp;...t) -&gt; decltype(hydra_thrust::tie(t...))</td></tr>
<tr class="memdesc:aa1dba4dcfb81c7ad5404533f6d3b4bd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This version of <code>tie</code> creates a new <code>tuple</code> whose elements are references which refers to this function's arguments.  <a href="#aa1dba4dcfb81c7ad5404533f6d3b4bd7">More...</a><br /></td></tr>
<tr class="separator:aa1dba4dcfb81c7ad5404533f6d3b4bd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66e3f95285aed29c7f62df05eecf2f00"><td class="memTemplParams" colspan="2">template&lt;typename Iterable_Input , typename Iterable_Output , typename Functor , typename Iterator  = decltype(std::declval&lt;Iterable_Output&gt;().begin())&gt; </td></tr>
<tr class="memitem:a66e3f95285aed29c7f62df05eecf2f00"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; Iterable_Output &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; decltype(std::declval&lt; Iterable_Output &amp; &gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>())&gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a66e3f95285aed29c7f62df05eecf2f00">transform</a> (Iterable_Input &amp;&amp;iterable_input, Iterable_Output &amp;&amp;iterable_output, Functor const &amp;unary_functor)</td></tr>
<tr class="separator:a66e3f95285aed29c7f62df05eecf2f00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3cd03f6c91a7dea855ed430a12618f2"><td class="memTemplParams" colspan="2">template&lt;typename RNG , typename IteratorData , typename IteratorWeight , hydra::detail::Backend BACKEND&gt; </td></tr>
<tr class="memitem:gaf3cd03f6c91a7dea855ed430a12618f2"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1random_1_1is__iterator.html">detail::random::is_iterator</a>&lt; IteratorData &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1random_1_1is__iterator.html">detail::random::is_iterator</a>&lt; IteratorWeight &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; IteratorData &gt;&gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__random.html#gaf3cd03f6c91a7dea855ed430a12618f2">unweight</a> (<a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt; const &amp;policy, IteratorData data_begin, IteratorData data_end, IteratorWeight weights_begin)</td></tr>
<tr class="memdesc:gaf3cd03f6c91a7dea855ed430a12618f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This functions reorder a dataset to produce a unweighted sample according to the weights [wbegin, wend].  <a href="group__random.html#gaf3cd03f6c91a7dea855ed430a12618f2">More...</a><br /></td></tr>
<tr class="separator:gaf3cd03f6c91a7dea855ed430a12618f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae678e8eaa0ad279c9f5ce8f5714166a"><td class="memTemplParams" colspan="2">template&lt;typename RNG , typename IteratorData , typename IteratorWeight &gt; </td></tr>
<tr class="memitem:gaae678e8eaa0ad279c9f5ce8f5714166a"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1random_1_1is__iterator.html">detail::random::is_iterator</a>&lt; IteratorData &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1random_1_1is__iterator.html">detail::random::is_iterator</a>&lt; IteratorWeight &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; IteratorData &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__random.html#gaae678e8eaa0ad279c9f5ce8f5714166a">unweight</a> (IteratorData data_begin, IteratorData data_end, IteratorData weights_begin)</td></tr>
<tr class="memdesc:gaae678e8eaa0ad279c9f5ce8f5714166a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This functions reorder a dataset to produce a unweighted sample according to the weights [wbegin, wend].  <a href="group__random.html#gaae678e8eaa0ad279c9f5ce8f5714166a">More...</a><br /></td></tr>
<tr class="separator:gaae678e8eaa0ad279c9f5ce8f5714166a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga407c06a1f6a242e5f98150e95d733baf"><td class="memTemplParams" colspan="2">template&lt;typename RNG , typename IterableData , typename IterableWeight , hydra::detail::Backend BACKEND&gt; </td></tr>
<tr class="memitem:ga407c06a1f6a242e5f98150e95d733baf"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1random_1_1is__iterable.html">detail::random::is_iterable</a>&lt; IterableData &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1random_1_1is__iterable.html">detail::random::is_iterable</a>&lt; IterableWeight &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; decltype(std::declval&lt; IterableData &gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>())&gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__random.html#ga407c06a1f6a242e5f98150e95d733baf">unweight</a> (<a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; const  &amp;policy, IterableData &amp;&amp;<a class="el" href="basic__distributions_8inl.html#a248ea98483ce90baaf65a7682438d72d">data</a>, IterableWeight &amp;&amp;weights)</td></tr>
<tr class="memdesc:ga407c06a1f6a242e5f98150e95d733baf"><td class="mdescLeft">&#160;</td><td class="mdescRight">This functions reorder a dataset to produce a unweighted sample according to a weights.  <a href="group__random.html#ga407c06a1f6a242e5f98150e95d733baf">More...</a><br /></td></tr>
<tr class="separator:ga407c06a1f6a242e5f98150e95d733baf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9d0311b873d73e2980a800d69e9ff05"><td class="memTemplParams" colspan="2">template&lt;typename RNG , typename IterableData , typename IterableWeight &gt; </td></tr>
<tr class="memitem:af9d0311b873d73e2980a800d69e9ff05"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1random_1_1is__iterable.html">detail::random::is_iterable</a>&lt; IterableData &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1random_1_1is__iterable.html">detail::random::is_iterable</a>&lt; IterableWeight &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; decltype(std::declval&lt; IterableData &gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>())&gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#af9d0311b873d73e2980a800d69e9ff05">unweight</a> (IterableData &amp;&amp;<a class="el" href="basic__distributions_8inl.html#a248ea98483ce90baaf65a7682438d72d">data</a>, IterableWeight &amp;&amp;weights)</td></tr>
<tr class="separator:af9d0311b873d73e2980a800d69e9ff05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb651e93b792358b563e8ac20fddd028"><td class="memTemplParams" colspan="2">template&lt;typename RNG , typename Functor , typename Iterator , hydra::detail::Backend BACKEND&gt; </td></tr>
<tr class="memitem:gadb651e93b792358b563e8ac20fddd028"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1random_1_1is__callable.html">detail::random::is_callable</a>&lt; Functor &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1random_1_1is__iterator.html">detail::random::is_iterator</a>&lt; Iterator &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; Iterator &gt;&gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__random.html#gadb651e93b792358b563e8ac20fddd028">unweight</a> (<a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; const  &amp;policy, Iterator <a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>, Iterator <a class="el" href="namespacehydra.html#a4274268d147e9a988f379326b73682b0">end</a>, Functor const  &amp;functor)</td></tr>
<tr class="memdesc:gadb651e93b792358b563e8ac20fddd028"><td class="mdescLeft">&#160;</td><td class="mdescRight">This functions reorder a dataset to produce an unweighted sample according to.  <a href="group__random.html#gadb651e93b792358b563e8ac20fddd028">More...</a><br /></td></tr>
<tr class="separator:gadb651e93b792358b563e8ac20fddd028"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a7d4b333528d673d75fe20cfb86f03e"><td class="memTemplParams" colspan="2">template&lt;typename RNG , typename Functor , typename Iterator &gt; </td></tr>
<tr class="memitem:ga9a7d4b333528d673d75fe20cfb86f03e"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1random_1_1is__callable.html">detail::random::is_callable</a>&lt; Functor &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1random_1_1is__iterator.html">detail::random::is_iterator</a>&lt; Iterator &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; Iterator &gt;&gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__random.html#ga9a7d4b333528d673d75fe20cfb86f03e">unweight</a> (Iterator <a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>, Iterator <a class="el" href="namespacehydra.html#a4274268d147e9a988f379326b73682b0">end</a>, Functor const  &amp;functor)</td></tr>
<tr class="memdesc:ga9a7d4b333528d673d75fe20cfb86f03e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This functions reorder a dataset to produce an unweighted sample according to.  <a href="group__random.html#ga9a7d4b333528d673d75fe20cfb86f03e">More...</a><br /></td></tr>
<tr class="separator:ga9a7d4b333528d673d75fe20cfb86f03e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3cd03f6c91a7dea855ed430a12618f2"><td class="memTemplParams" colspan="2">template&lt;typename RNG  = default_random_engine, typename IteratorData , typename IteratorWeight , hydra::detail::Backend BACKEND&gt; </td></tr>
<tr class="memitem:gaf3cd03f6c91a7dea855ed430a12618f2"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1random_1_1is__iterator.html">detail::random::is_iterator</a>&lt; IteratorData &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1random_1_1is__iterator.html">detail::random::is_iterator</a>&lt; IteratorWeight &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; IteratorData &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__random.html#gaf3cd03f6c91a7dea855ed430a12618f2">unweight</a> (<a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt; const &amp;policy, IteratorData data_begin, IteratorData data_end, IteratorWeight weights_begin)</td></tr>
<tr class="memdesc:gaf3cd03f6c91a7dea855ed430a12618f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This functions reorder a dataset to produce a unweighted sample according to the weights [wbegin, wend].  <a href="group__random.html#gaf3cd03f6c91a7dea855ed430a12618f2">More...</a><br /></td></tr>
<tr class="separator:gaf3cd03f6c91a7dea855ed430a12618f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b91ce799b5efa01c16593d023b9b355"><td class="memTemplParams" colspan="2">template&lt;typename RNG , typename Functor , typename Iterable , hydra::detail::Backend BACKEND&gt; </td></tr>
<tr class="memitem:ga3b91ce799b5efa01c16593d023b9b355"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1random_1_1is__callable.html">detail::random::is_callable</a>&lt; Functor &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1random_1_1is__iterable.html">detail::random::is_iterable</a>&lt; Iterable &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; decltype(std::declval&lt; Iterable &gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>())&gt;&gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__random.html#ga3b91ce799b5efa01c16593d023b9b355">unweight</a> (<a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; const  &amp;policy, Iterable &amp;&amp;iterable, Functor const  &amp;functor)</td></tr>
<tr class="memdesc:ga3b91ce799b5efa01c16593d023b9b355"><td class="mdescLeft">&#160;</td><td class="mdescRight">This functions reorder a dataset to produce an unweighted sample according to.  <a href="group__random.html#ga3b91ce799b5efa01c16593d023b9b355">More...</a><br /></td></tr>
<tr class="separator:ga3b91ce799b5efa01c16593d023b9b355"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef41f0eac7bce40769634467f2ae3347"><td class="memTemplParams" colspan="2">template&lt;typename RNG , typename Functor , typename Iterable &gt; </td></tr>
<tr class="memitem:gaef41f0eac7bce40769634467f2ae3347"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1random_1_1is__callable.html">detail::random::is_callable</a>&lt; Functor &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1random_1_1is__iterable.html">detail::random::is_iterable</a>&lt; Iterable &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; decltype(std::declval&lt; Iterable &gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>())&gt;&gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__random.html#gaef41f0eac7bce40769634467f2ae3347">unweight</a> (Iterable &amp;&amp;iterable, Functor const &amp;functor)</td></tr>
<tr class="memdesc:gaef41f0eac7bce40769634467f2ae3347"><td class="mdescLeft">&#160;</td><td class="mdescRight">This functions reorder a dataset to produce an unweighted sample according to.  <a href="group__random.html#gaef41f0eac7bce40769634467f2ae3347">More...</a><br /></td></tr>
<tr class="separator:gaef41f0eac7bce40769634467f2ae3347"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae678e8eaa0ad279c9f5ce8f5714166a"><td class="memTemplParams" colspan="2">template&lt;typename RNG  = default_random_engine, typename IteratorData , typename IteratorWeight &gt; </td></tr>
<tr class="memitem:gaae678e8eaa0ad279c9f5ce8f5714166a"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1random_1_1is__iterator.html">detail::random::is_iterator</a>&lt; IteratorData &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1random_1_1is__iterator.html">detail::random::is_iterator</a>&lt; IteratorWeight &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; IteratorData &gt;&gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__random.html#gaae678e8eaa0ad279c9f5ce8f5714166a">unweight</a> (IteratorData data_begin, IteratorData data_end, IteratorData weights_begin)</td></tr>
<tr class="memdesc:gaae678e8eaa0ad279c9f5ce8f5714166a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This functions reorder a dataset to produce a unweighted sample according to the weights [wbegin, wend].  <a href="group__random.html#gaae678e8eaa0ad279c9f5ce8f5714166a">More...</a><br /></td></tr>
<tr class="separator:gaae678e8eaa0ad279c9f5ce8f5714166a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad7a85d3fb6639d4e9414d2fbd65c76e9"><td class="memTemplParams" colspan="2">template&lt;typename RNG  = default_random_engine, typename IterableData , typename IterableWeight &gt; </td></tr>
<tr class="memitem:gad7a85d3fb6639d4e9414d2fbd65c76e9"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1random_1_1is__iterable.html">detail::random::is_iterable</a>&lt; IterableData &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1random_1_1is__iterable.html">detail::random::is_iterable</a>&lt; IterableWeight &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; decltype(std::declval&lt; IterableData &gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>())&gt;&gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__random.html#gad7a85d3fb6639d4e9414d2fbd65c76e9">unweight</a> (IterableData <a class="el" href="basic__distributions_8inl.html#a248ea98483ce90baaf65a7682438d72d">data</a>, IterableWeight weights)</td></tr>
<tr class="memdesc:gad7a85d3fb6639d4e9414d2fbd65c76e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This functions reorder a dataset to produce an unweighted sample according to a weights.  <a href="group__random.html#gad7a85d3fb6639d4e9414d2fbd65c76e9">More...</a><br /></td></tr>
<tr class="separator:gad7a85d3fb6639d4e9414d2fbd65c76e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef41f0eac7bce40769634467f2ae3347"><td class="memTemplParams" colspan="2">template&lt;typename RNG  = default_random_engine, typename Functor , typename Iterable &gt; </td></tr>
<tr class="memitem:gaef41f0eac7bce40769634467f2ae3347"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1random_1_1is__callable.html">detail::random::is_callable</a>&lt; Functor &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1random_1_1is__iterable.html">detail::random::is_iterable</a>&lt; Iterable &gt;::value,<a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; decltype(std::declval&lt; Iterable &gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>())&gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__random.html#gaef41f0eac7bce40769634467f2ae3347">unweight</a> (Iterable &amp;&amp;iterable, Functor const &amp;functor)</td></tr>
<tr class="memdesc:gaef41f0eac7bce40769634467f2ae3347"><td class="mdescLeft">&#160;</td><td class="mdescRight">This functions reorder a dataset to produce an unweighted sample according to.  <a href="group__random.html#gaef41f0eac7bce40769634467f2ae3347">More...</a><br /></td></tr>
<tr class="separator:gaef41f0eac7bce40769634467f2ae3347"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16cc58cf433d121a37c54f965023d49a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a16cc58cf433d121a37c54f965023d49a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a16cc58cf433d121a37c54f965023d49a">wigner_d_matrix</a> (<a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> j, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> m, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> <a class="el" href="crystal__ball__plus__exponential_8inl.html#a21f77208d6bc667560ff8aaf8f943b6a">n</a>, const T theta)</td></tr>
<tr class="separator:a16cc58cf433d121a37c54f965023d49a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaec6f8e5354bb7e586f34b1d4659ca8c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aaec6f8e5354bb7e586f34b1d4659ca8c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#aaec6f8e5354bb7e586f34b1d4659ca8c">wigner_d_matrix</a> (<a class="el" href="namespace_3globalScope_4.html#classunsigned">unsigned</a> j, <a class="el" href="namespace_3globalScope_4.html#classunsigned">unsigned</a> m, <a class="el" href="namespace_3globalScope_4.html#classunsigned">unsigned</a> <a class="el" href="crystal__ball__plus__exponential_8inl.html#a21f77208d6bc667560ff8aaf8f943b6a">n</a>, const T theta)</td></tr>
<tr class="separator:aaec6f8e5354bb7e586f34b1d4659ca8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a094f4a025290ae35ad9eb8c553c7fc61"><td class="memTemplParams" colspan="2">template&lt;typename LambdaType &gt; </td></tr>
<tr class="memitem:a094f4a025290ae35ad9eb8c553c7fc61"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classhydra_1_1Lambda.html">hydra::Lambda</a>&lt; LambdaType, 0 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a094f4a025290ae35ad9eb8c553c7fc61">wrap_lambda</a> (LambdaType const &amp;<a class="el" href="basic__distributions_8inl.html#a226b5ae55983130a9a1e82e0ecdd8c1b">lambda</a>)</td></tr>
<tr class="separator:a094f4a025290ae35ad9eb8c553c7fc61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d026eb3807e3f2358feb9a7890b4598"><td class="memTemplParams" colspan="2">template&lt;typename LambdaType , typename ... T&gt; </td></tr>
<tr class="memitem:a5d026eb3807e3f2358feb9a7890b4598"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1all__true.html">detail::all_true</a>&lt; std::is_same&lt; T, <a class="el" href="group__fit.html#structhydra_1_1Parameter">hydra::Parameter</a> &gt;::value... &gt;::value, <a class="el" href="classhydra_1_1Lambda.html">hydra::Lambda</a>&lt; LambdaType, sizeof...(T)&gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a5d026eb3807e3f2358feb9a7890b4598">wrap_lambda</a> (LambdaType const &amp;<a class="el" href="basic__distributions_8inl.html#a226b5ae55983130a9a1e82e0ecdd8c1b">lambda</a>, T const &amp;...parameters)</td></tr>
<tr class="separator:a5d026eb3807e3f2358feb9a7890b4598"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1c8be57a887f2bb9d01ba075a5de0f2"><td class="memTemplParams" colspan="2">template&lt;typename ... Iterables&gt; </td></tr>
<tr class="memitem:ae1c8be57a887f2bb9d01ba075a5de0f2"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1all__true.html">detail::all_true</a>&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">detail::is_iterable</a>&lt; Iterables &gt;::value... &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; hydra_thrust::zip_iterator&lt; decltype(hydra_thrust::make_tuple(std::declval&lt; Iterables &amp; &gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()...))&gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ae1c8be57a887f2bb9d01ba075a5de0f2">zip</a> (Iterables &amp;&amp;... iterables)</td></tr>
<tr class="separator:ae1c8be57a887f2bb9d01ba075a5de0f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:gab8c80dcd76b312f12b98bc04918e4b20"><td class="memTemplParams" colspan="2">template&lt;typename Engine  = hydra_thrust::default_random_engine, hydra::detail::Backend BACKEND, typename Iterator , typename FUNCTOR &gt; </td></tr>
<tr class="memitem:gab8c80dcd76b312f12b98bc04918e4b20"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1has__rng__formula.html">hydra::detail::has_rng_formula</a>&lt; FUNCTOR &gt;::value &amp;&amp;std::is_convertible&lt; decltype(std::declval&lt; <a class="el" href="classhydra_1_1RngFormula.html">RngFormula</a>&lt; FUNCTOR &gt; &gt;).<a class="el" href="phsp__unweighting_8inl.html#aae0754269ece74173f4afd72643b7e3e">Generate</a>(std::declval&lt; Engine &amp; &gt;), std::declval&lt; FUNCTOR const  &amp; &gt;))), typename hydra_thrust::iterator_traits&lt; Iterator &gt;::value_type &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__random.html#gab8c80dcd76b312f12b98bc04918e4b20">fill_random</a> (<a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; const &amp;policy, Iterator <a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>, Iterator <a class="el" href="namespacehydra.html#a4274268d147e9a988f379326b73682b0">end</a>, FUNCTOR const &amp;functor, size_t seed=0x254a0afcf7da74a2)</td></tr>
<tr class="memdesc:gab8c80dcd76b312f12b98bc04918e4b20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill a range with numbers distributed according a user defined distribution using a RNG analytical formula.  <a href="group__random.html#gab8c80dcd76b312f12b98bc04918e4b20">More...</a><br /></td></tr>
<tr class="separator:gab8c80dcd76b312f12b98bc04918e4b20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89686ff2116120de2d9e2ad6889a47de"><td class="memItemLeft" align="right" valign="top">decltype(other.begin(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;{})) typedef&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a89686ff2116120de2d9e2ad6889a47de">iterator_type</a></td></tr>
<tr class="separator:a89686ff2116120de2d9e2ad6889a47de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab14adaa26f703b8c130df530167ebd23"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacehydra.html#aa8c251ed5017d0638da929130062bcad">GBool_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#ab14adaa26f703b8c130df530167ebd23">kFalse</a> = false</td></tr>
<tr class="separator:ab14adaa26f703b8c130df530167ebd23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1556536d7a73fa95e5a9c9610f76a3c1"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacehydra.html#aa8c251ed5017d0638da929130062bcad">GBool_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a1556536d7a73fa95e5a9c9610f76a3c1">kTrue</a> = true</td></tr>
<tr class="separator:a1556536d7a73fa95e5a9c9610f76a3c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7cb37dfdb2198202b4cb3f0b79f94080"><td class="memTemplParams" colspan="2">template&lt;typename ... Pdfs, typename Histogram &gt; </td></tr>
<tr class="memitem:ga7cb37dfdb2198202b4cb3f0b79f94080"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__hydra__dense__histogram.html">detail::is_hydra_dense_histogram</a>&lt; Histogram &gt;::value||<a class="el" href="structhydra_1_1detail_1_1is__hydra__sparse__histogram.html">detail::is_hydra_sparse_histogram</a>&lt; Histogram &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1LogLikelihoodFCN">LogLikelihoodFCN</a>&lt; <a class="el" href="group__fit.html#classhydra_1_1PDFSumExtendable">PDFSumExtendable</a>&lt; Pdfs... &gt;, decltype(std::declval&lt; const Histogram &amp; &gt;).GetBinsCenters().<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()), decltype(std::declval&lt; const Histogram &amp; &gt;).GetBinsContents().<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()) &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__fit.html#ga7cb37dfdb2198202b4cb3f0b79f94080">make_loglikehood_fcn</a> (<a class="el" href="group__fit.html#classhydra_1_1PDFSumExtendable">PDFSumExtendable</a>&lt; Pdfs... &gt; const &amp;pdf, Histogram const &amp;<a class="el" href="basic__distributions_8inl.html#a248ea98483ce90baaf65a7682438d72d">data</a>)</td></tr>
<tr class="memdesc:ga7cb37dfdb2198202b4cb3f0b79f94080"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function to build up loglikehood fcns for densely and sparsely binned datasets.  <a href="group__fit.html#ga7cb37dfdb2198202b4cb3f0b79f94080">More...</a><br /></td></tr>
<tr class="separator:ga7cb37dfdb2198202b4cb3f0b79f94080"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5afb8f1b6ea1ba2b8fc79444e5d20f20"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_3globalScope_4.html#classint">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html#a5afb8f1b6ea1ba2b8fc79444e5d20f20">PrintLevel</a> = <a class="el" href="namespacehydra.html#ad87c68ca6adb981f4c31ae73ef97de3ba1bf857a06d5b8463494a6fcac6f4ea26">WARNING</a></td></tr>
<tr class="separator:a5afb8f1b6ea1ba2b8fc79444e5d20f20"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Generic policies definition. </p>
<p>namespace thrust</p>
<p><code>thrust</code> is the top-level namespace which contains all Hydra functions and types.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000002">Todo:</a></b></dt><dd>: fix compile error in nvcc adding variants to vectors</dd></dl>
</div><hr/><h2 class="groupheader">Data Structure Documentation</h2>
<a name="classhydra_1_1BaseCompositeFunctor" id="classhydra_1_1BaseCompositeFunctor"></a>
<h2 class="memtitle"><span class="permalink"><a href="#classhydra_1_1BaseCompositeFunctor">&#9670;&nbsp;</a></span>hydra::BaseCompositeFunctor</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class hydra::BaseCompositeFunctor</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename Composite, typename FunctorList, typename Signature&gt;<br />
class hydra::BaseCompositeFunctor&lt; Composite, FunctorList, Signature &gt;</h3>

</div><div class="dynheader">
Inheritance diagram for hydra::BaseCompositeFunctor&lt; Composite, FunctorList, Signature &gt;:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="classhydra_1_1BaseCompositeFunctor__inherit__graph.svg" width="100%" height="600"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</div>
<div class="dynheader">
Collaboration diagram for hydra::BaseCompositeFunctor&lt; Composite, FunctorList, Signature &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classhydra_1_1BaseCompositeFunctor__coll__graph.svg" width="210" height="118"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a name="classhydra_1_1ConvolutionFunctor" id="classhydra_1_1ConvolutionFunctor"></a>
<h2 class="memtitle"><span class="permalink"><a href="#classhydra_1_1ConvolutionFunctor">&#9670;&nbsp;</a></span>hydra::ConvolutionFunctor</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class hydra::ConvolutionFunctor</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename Functor, typename Kernel, typename Backend, typename FFT, typename ArgType&gt;<br />
class hydra::ConvolutionFunctor&lt; Functor, Kernel, Backend, FFT, ArgType &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::ConvolutionFunctor&lt; Functor, Kernel, Backend, FFT, ArgType &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classhydra_1_1ConvolutionFunctor__coll__graph.svg" width="196" height="118"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a name="classhydra_1_1Distribution" id="classhydra_1_1Distribution"></a>
<h2 class="memtitle"><span class="permalink"><a href="#classhydra_1_1Distribution">&#9670;&nbsp;</a></span>hydra::Distribution</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class hydra::Distribution</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename Functor, bool Implemented = detail::has_rng_formula&lt;Functor&gt;::value&gt;<br />
class hydra::Distribution&lt; Functor, Implemented &gt;</h3>

<dl><dt><b>Examples: </b></dt><dd><a class="el" href="basic_distributions_8inl-example.html#_a47">basic_distributions.inl</a>.</dd>
</dl></div><div class="dynheader">
Collaboration diagram for hydra::Distribution&lt; Functor, Implemented &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classhydra_1_1Distribution__coll__graph.svg" width="183" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a name="structhydra_1_1Distribution_3_01Class_00_01false_01_4" id="structhydra_1_1Distribution_3_01Class_00_01false_01_4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1Distribution_3_01Class_00_01false_01_4">&#9670;&nbsp;</a></span>hydra::Distribution&lt; Class, false &gt;</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::Distribution&lt; Class, false &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename Class&gt;<br />
struct hydra::Distribution&lt; Class, false &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::Distribution&lt; Class, false &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1Distribution_3_01Class_00_01false_01_4__coll__graph.svg" width="139" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a name="classhydra_1_1GaussKronrodAdaptiveQuadrature" id="classhydra_1_1GaussKronrodAdaptiveQuadrature"></a>
<h2 class="memtitle"><span class="permalink"><a href="#classhydra_1_1GaussKronrodAdaptiveQuadrature">&#9670;&nbsp;</a></span>hydra::GaussKronrodAdaptiveQuadrature</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class hydra::GaussKronrodAdaptiveQuadrature</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;size_t NRULE, size_t NBIN, typename BACKEND&gt;<br />
class hydra::GaussKronrodAdaptiveQuadrature&lt; NRULE, NBIN, BACKEND &gt;</h3>

<dl><dt><b>Examples: </b></dt><dd><a class="el" href="adaptive_gauss_kronrod_8inl-example.html#_a12">adaptive_gauss_kronrod.inl</a>.</dd>
</dl></div><div class="dynheader">
Collaboration diagram for hydra::GaussKronrodAdaptiveQuadrature&lt; NRULE, NBIN, BACKEND &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classhydra_1_1GaussKronrodAdaptiveQuadrature__coll__graph.svg" width="207" height="118"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a name="classhydra_1_1GaussKronrodQuadrature" id="classhydra_1_1GaussKronrodQuadrature"></a>
<h2 class="memtitle"><span class="permalink"><a href="#classhydra_1_1GaussKronrodQuadrature">&#9670;&nbsp;</a></span>hydra::GaussKronrodQuadrature</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class hydra::GaussKronrodQuadrature</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;size_t NRULE, size_t NBIN, typename BACKEND&gt;<br />
class hydra::GaussKronrodQuadrature&lt; NRULE, NBIN, BACKEND &gt;</h3>

<dl><dt><b>Examples: </b></dt><dd><a class="el" href="fit_convoluted_pdfs_8inl-example.html#_a25">fit_convoluted_pdfs.inl</a>, and <a class="el" href="gauss_kronrod_8inl-example.html#_a13">gauss_kronrod.inl</a>.</dd>
</dl></div><div class="dynheader">
Collaboration diagram for hydra::GaussKronrodQuadrature&lt; NRULE, NBIN, BACKEND &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classhydra_1_1GaussKronrodQuadrature__coll__graph.svg" width="220" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a name="structhydra_1_1GaussKronrodRuleSelector" id="structhydra_1_1GaussKronrodRuleSelector"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1GaussKronrodRuleSelector">&#9670;&nbsp;</a></span>hydra::GaussKronrodRuleSelector</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::GaussKronrodRuleSelector</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;size_t N&gt;<br />
struct hydra::GaussKronrodRuleSelector&lt; N &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::GaussKronrodRuleSelector&lt; N &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1GaussKronrodRuleSelector__coll__graph.svg" width="266" height="88"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a name="classhydra_1_1GenzMalikQuadrature" id="classhydra_1_1GenzMalikQuadrature"></a>
<h2 class="memtitle"><span class="permalink"><a href="#classhydra_1_1GenzMalikQuadrature">&#9670;&nbsp;</a></span>hydra::GenzMalikQuadrature</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class hydra::GenzMalikQuadrature</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;size_t N, typename BACKEND&gt;<br />
class hydra::GenzMalikQuadrature&lt; N, BACKEND &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::GenzMalikQuadrature&lt; N, BACKEND &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classhydra_1_1GenzMalikQuadrature__coll__graph.svg" width="199" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a name="classhydra_1_1GenzMalikRule" id="classhydra_1_1GenzMalikRule"></a>
<h2 class="memtitle"><span class="permalink"><a href="#classhydra_1_1GenzMalikRule">&#9670;&nbsp;</a></span>hydra::GenzMalikRule</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class hydra::GenzMalikRule</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;size_t DIM, typename BACKEND&gt;<br />
class hydra::GenzMalikRule&lt; DIM, BACKEND &gt;</h3>

</div><div class="dynheader">
Inheritance diagram for hydra::GenzMalikRule&lt; DIM, BACKEND &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classhydra_1_1GenzMalikRule__inherit__graph.svg" width="300" height="287"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Collaboration diagram for hydra::GenzMalikRule&lt; DIM, BACKEND &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classhydra_1_1GenzMalikRule__coll__graph.svg" width="162" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a name="classhydra_1_1LogLikelihoodFCN" id="classhydra_1_1LogLikelihoodFCN"></a>
<h2 class="memtitle"><span class="permalink"><a href="#classhydra_1_1LogLikelihoodFCN">&#9670;&nbsp;</a></span>hydra::LogLikelihoodFCN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class hydra::LogLikelihoodFCN</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename PDF, typename Iterator, typename... Extensions&gt;<br />
class hydra::LogLikelihoodFCN&lt; PDF, Iterator, Extensions &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::LogLikelihoodFCN&lt; PDF, Iterator, Extensions &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classhydra_1_1LogLikelihoodFCN__coll__graph.svg" width="203" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a name="classhydra_1_1multiarray" id="classhydra_1_1multiarray"></a>
<h2 class="memtitle"><span class="permalink"><a href="#classhydra_1_1multiarray">&#9670;&nbsp;</a></span>hydra::multiarray</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class hydra::multiarray</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename T, size_t N, typename BACKEND&gt;<br />
class hydra::multiarray&lt; T, N, BACKEND &gt;</h3>

<dl><dt><b>Examples: </b></dt><dd><a class="el" href="multiarray_container_8inl-example.html#_a6">multiarray_container.inl</a>, <a class="el" href="pseudo_experiment_8inl-example.html#_a31">pseudo_experiment.inl</a>, <a class="el" href="sample_distribution_8inl-example.html#_a13">sample_distribution.inl</a>, and <a class="el" href="splot_8inl-example.html#_a42">splot.inl</a>.</dd>
</dl></div><div class="dynheader">
Inheritance diagram for hydra::multiarray&lt; T, N, BACKEND &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classhydra_1_1multiarray__inherit__graph.svg" width="246" height="287"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Collaboration diagram for hydra::multiarray&lt; T, N, BACKEND &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classhydra_1_1multiarray__coll__graph.svg" width="147" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a name="classhydra_1_1multivector" id="classhydra_1_1multivector"></a>
<h2 class="memtitle"><span class="permalink"><a href="#classhydra_1_1multivector">&#9670;&nbsp;</a></span>hydra::multivector</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class hydra::multivector</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename T, typename BACKEND&gt;<br />
class hydra::multivector&lt; T, BACKEND &gt;</h3>

<dl><dt><b>Examples: </b></dt><dd><a class="el" href="dense_histogram_8inl-example.html#_a12">dense_histogram.inl</a>, <a class="el" href="multidimensional_fit_8inl-example.html#_a38">multidimensional_fit.inl</a>, <a class="el" href="multivector_container_8inl-example.html#_a6">multivector_container.inl</a>, <a class="el" href="phsp_chain_8inl-example.html#_a24">phsp_chain.inl</a>, <a class="el" href="pseudo_experiment_8inl-example.html#_a24">pseudo_experiment.inl</a>, <a class="el" href="range_semantics_8inl-example.html#_a8">range_semantics.inl</a>, and <a class="el" href="splot_8inl-example.html#_a26">splot.inl</a>.</dd>
</dl></div><div class="dynheader">
Inheritance diagram for hydra::multivector&lt; T, BACKEND &gt;:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="classhydra_1_1multivector__inherit__graph.svg" width="100%" height="537"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</div>
<div class="dynheader">
Collaboration diagram for hydra::multivector&lt; T, BACKEND &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classhydra_1_1multivector__coll__graph.svg" width="138" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a name="structhydra_1_1null__type" id="structhydra_1_1null__type"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1null__type">&#9670;&nbsp;</a></span>hydra::null_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::null_type</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"></div><div class="dynheader">
Collaboration diagram for hydra::null_type:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1null__type__coll__graph.svg" width="126" height="88"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a name="structhydra_1_1Plain" id="structhydra_1_1Plain"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1Plain">&#9670;&nbsp;</a></span>hydra::Plain</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::Plain</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;size_t N, typename BACKEND, typename GRND = hydra_thrust::random::default_random_engine&gt;<br />
struct hydra::Plain&lt; N, BACKEND, GRND &gt;</h3>

<dl><dt><b>Examples: </b></dt><dd><a class="el" href="multidimensional_fit_8inl-example.html#_a34">multidimensional_fit.inl</a>, and <a class="el" href="plain_mc_8inl-example.html#_a12">plain_mc.inl</a>.</dd>
</dl></div><div class="dynheader">
Collaboration diagram for hydra::Plain&lt; N, BACKEND, GRND &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1Plain__coll__graph.svg" width="202" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a name="classhydra_1_1Range" id="classhydra_1_1Range"></a>
<h2 class="memtitle"><span class="permalink"><a href="#classhydra_1_1Range">&#9670;&nbsp;</a></span>hydra::Range</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class hydra::Range</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename ... T&gt;<br />
class hydra::Range&lt; T &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::Range&lt; T &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classhydra_1_1Range__coll__graph.svg" width="143" height="88"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a name="classhydra_1_1ScopedBuffer" id="classhydra_1_1ScopedBuffer"></a>
<h2 class="memtitle"><span class="permalink"><a href="#classhydra_1_1ScopedBuffer">&#9670;&nbsp;</a></span>hydra::ScopedBuffer</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class hydra::ScopedBuffer</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename T, typename BACKEND&gt;<br />
class hydra::ScopedBuffer&lt; T, BACKEND &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::ScopedBuffer&lt; T, BACKEND &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classhydra_1_1ScopedBuffer__coll__graph.svg" width="152" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a name="classhydra_1_1Vegas" id="classhydra_1_1Vegas"></a>
<h2 class="memtitle"><span class="permalink"><a href="#classhydra_1_1Vegas">&#9670;&nbsp;</a></span>hydra::Vegas</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class hydra::Vegas</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;size_t N, typename BACKEND, typename GRND = hydra_thrust::random::default_random_engine&gt;<br />
class hydra::Vegas&lt; N, BACKEND, GRND &gt;</h3>

<dl><dt><b>Examples: </b></dt><dd><a class="el" href="vegas_8inl-example.html#_a13">vegas.inl</a>.</dd>
</dl></div><div class="dynheader">
Collaboration diagram for hydra::Vegas&lt; N, BACKEND, GRND &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classhydra_1_1Vegas__coll__graph.svg" width="210" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a9be56668c1da1edd25b29c366adf5df9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9be56668c1da1edd25b29c366adf5df9">&#9670;&nbsp;</a></span>complex</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacehydra.html#a9be56668c1da1edd25b29c366adf5df9">hydra::complex</a> = typedef hydra_thrust::complex&lt;T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="dalitz_plot_8C-example.html#a13">dalitz_plot.C</a>.</dd>
</dl>
</div>
</div>
<a id="a1e747e9ec41024e3efe0349f8ac10062"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e747e9ec41024e3efe0349f8ac10062">&#9670;&nbsp;</a></span>default_random_engine</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacehydra.html#a1e747e9ec41024e3efe0349f8ac10062">hydra::default_random_engine</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An implementation-defined "default" random number engine. </p>
<dl class="section note"><dt>Note</dt><dd><code>default_random_engine</code> is currently an alias for <code>minstd_rand</code>, and may change in a future version. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="basic_distributions_8inl-example.html#a45">basic_distributions.inl</a>, and <a class="el" href="fill_basic_distributions_8inl-example.html#a44">fill_basic_distributions.inl</a>.</dd>
</dl>
</div>
</div>
<a id="ad614c0d4d1799d691f39110ece55090c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad614c0d4d1799d691f39110ece55090c">&#9670;&nbsp;</a></span>default_sobol_table</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structhydra_1_1detail_1_1SobolTable.html">detail::SobolTable</a> <a class="el" href="namespacehydra.html#ad614c0d4d1799d691f39110ece55090c">hydra::default_sobol_table</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa8c251ed5017d0638da929130062bcad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8c251ed5017d0638da929130062bcad">&#9670;&nbsp;</a></span>GBool_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef bool <a class="el" href="namespacehydra.html#aa8c251ed5017d0638da929130062bcad">hydra::GBool_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Boolean (0=false, 1=true) (bool) </p>

</div>
</div>
<a id="ae2da2ab0037e6bca3cb7c15adc5c4125"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2da2ab0037e6bca3cb7c15adc5c4125">&#9670;&nbsp;</a></span>GByte_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="namespace_3globalScope_4.html#classunsigned">unsigned</a> char <a class="el" href="namespacehydra.html#ae2da2ab0037e6bca3cb7c15adc5c4125">hydra::GByte_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Byte (8 bits) (unsigned char) </p>

</div>
</div>
<a id="a7ab04a199389c4989174dc115507fa89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ab04a199389c4989174dc115507fa89">&#9670;&nbsp;</a></span>GChar_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef char <a class="el" href="namespacehydra.html#a7ab04a199389c4989174dc115507fa89">hydra::GChar_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signed Character 1 byte (char) </p>

</div>
</div>
<a id="af986267d40d932c5cbf0ae874a506f83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af986267d40d932c5cbf0ae874a506f83">&#9670;&nbsp;</a></span>GDouble_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> <a class="el" href="namespacehydra.html#af986267d40d932c5cbf0ae874a506f83">hydra::GDouble_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Double 8 bytes. </p>

</div>
</div>
<a id="a71bab7b854d7b3c3042fe47201b765eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71bab7b854d7b3c3042fe47201b765eb">&#9670;&nbsp;</a></span>GFloat_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef float <a class="el" href="namespacehydra.html#a71bab7b854d7b3c3042fe47201b765eb">hydra::GFloat_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Float 4 bytes (float) </p>

</div>
</div>
<a id="a0c9fb4d7195ab952da10a82d5c4ad30e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c9fb4d7195ab952da10a82d5c4ad30e">&#9670;&nbsp;</a></span>GInt_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="namespace_3globalScope_4.html#classint">int</a> <a class="el" href="namespacehydra.html#a0c9fb4d7195ab952da10a82d5c4ad30e">hydra::GInt_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signed integer 4 bytes (int) </p>

</div>
</div>
<a id="a9d68c21fb715bbfb1edc5b1933b173e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d68c21fb715bbfb1edc5b1933b173e9">&#9670;&nbsp;</a></span>GLong64_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef long long <a class="el" href="namespacehydra.html#a9d68c21fb715bbfb1edc5b1933b173e9">hydra::GLong64_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Portable signed long integer 8 bytes. </p>

</div>
</div>
<a id="a5f57a4025b40929c2708cd544c3a1ccd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f57a4025b40929c2708cd544c3a1ccd">&#9670;&nbsp;</a></span>GLong_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef long <a class="el" href="namespacehydra.html#a5f57a4025b40929c2708cd544c3a1ccd">hydra::GLong_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signed long integer 4 bytes (long) </p>

</div>
</div>
<a id="a751abe69b482cde879c718fd4775733f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a751abe69b482cde879c718fd4775733f">&#9670;&nbsp;</a></span>GLongDouble_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef long <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> <a class="el" href="namespacehydra.html#a751abe69b482cde879c718fd4775733f">hydra::GLongDouble_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Long Double. </p>

</div>
</div>
<a id="a971e94bcb8c43741d11f9d8eb98f5fab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a971e94bcb8c43741d11f9d8eb98f5fab">&#9670;&nbsp;</a></span>GReal_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> <a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">hydra::GReal_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Double 16 bytes or float 4 bytes. </p>

</div>
</div>
<a id="a589c60d92ba893c28d814edd6e149a9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a589c60d92ba893c28d814edd6e149a9c">&#9670;&nbsp;</a></span>GShort_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef short <a class="el" href="namespacehydra.html#a589c60d92ba893c28d814edd6e149a9c">hydra::GShort_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signed Short integer 2 bytes (short) </p>

</div>
</div>
<a id="abc842c1ec8321e9637dee714dcdaebff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc842c1ec8321e9637dee714dcdaebff">&#9670;&nbsp;</a></span>GText_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef char <a class="el" href="namespacehydra.html#abc842c1ec8321e9637dee714dcdaebff">hydra::GText_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>General string (char) </p>

</div>
</div>
<a id="a51ef97faee95aa79f3839eb7abdf5238"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51ef97faee95aa79f3839eb7abdf5238">&#9670;&nbsp;</a></span>GUChar_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="namespace_3globalScope_4.html#classunsigned">unsigned</a> char <a class="el" href="namespacehydra.html#a51ef97faee95aa79f3839eb7abdf5238">hydra::GUChar_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unsigned Character 1 byte (unsigned char) </p>

</div>
</div>
<a id="a251a7b1f515ac1ed9409afd67252a32b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a251a7b1f515ac1ed9409afd67252a32b">&#9670;&nbsp;</a></span>GUInt_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="namespace_3globalScope_4.html#classunsigned">unsigned</a> <a class="el" href="namespace_3globalScope_4.html#classint">int</a> <a class="el" href="namespacehydra.html#a251a7b1f515ac1ed9409afd67252a32b">hydra::GUInt_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unsigned integer 4 bytes (unsigned int) </p>

</div>
</div>
<a id="a55e8443cd746900da90cb1f77807e7c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55e8443cd746900da90cb1f77807e7c0">&#9670;&nbsp;</a></span>GULong64_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="namespace_3globalScope_4.html#classunsigned">unsigned</a> long long <a class="el" href="namespacehydra.html#a55e8443cd746900da90cb1f77807e7c0">hydra::GULong64_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Portable unsigned long integer 8 bytes. </p>

</div>
</div>
<a id="abf9a0d54fd4ed46052939549edd086c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf9a0d54fd4ed46052939549edd086c5">&#9670;&nbsp;</a></span>GULong_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="namespace_3globalScope_4.html#classunsigned">unsigned</a> long <a class="el" href="namespacehydra.html#abf9a0d54fd4ed46052939549edd086c5">hydra::GULong_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a911a3042526fac189d0c87a089f52955"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a911a3042526fac189d0c87a089f52955">&#9670;&nbsp;</a></span>GUShort_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="namespace_3globalScope_4.html#classunsigned">unsigned</a> short <a class="el" href="namespacehydra.html#a911a3042526fac189d0c87a089f52955">hydra::GUShort_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unsigned Short integer 2 bytes (unsigned short) </p>

</div>
</div>
<a id="a764c9ef4c89f8ff3f6ae5c8c636b5642"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a764c9ef4c89f8ff3f6ae5c8c636b5642">&#9670;&nbsp;</a></span>mc_device_vector</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacehydra.html#a764c9ef4c89f8ff3f6ae5c8c636b5642">hydra::mc_device_vector</a> = typedef hydra_thrust::device_vector&lt;T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generic template typedef for hydra_thrust::host_vector. </p>
<p>Use it instead of Thrust implementation in order to avoid problems to compile OpenMP based applications using gcc and without a cuda runtime installation. </p>

</div>
</div>
<a id="aaf5afa07506de0eb902a93ff656e8e25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf5afa07506de0eb902a93ff656e8e25">&#9670;&nbsp;</a></span>mc_host_vector</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacehydra.html#aaf5afa07506de0eb902a93ff656e8e25">hydra::mc_host_vector</a> = typedef hydra_thrust::host_vector&lt;T, hydra_thrust::system::cuda::experimental::pinned_allocator&lt;T&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generic template typedef for hydra_thrust::host_vector. </p>
<p>Use it instead of Thrust implementation in order to avoid problems to compile OpenMP based applications using gcc and without a cuda runtime installation. mc_host_vectot will always allocate page locked memory on CUDA backends in order to maximize speed in memory transfers to the device. </p>

</div>
</div>
<a id="aeccdd58e3a4c27246dadd0930e3fb569"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeccdd58e3a4c27246dadd0930e3fb569">&#9670;&nbsp;</a></span>minstd_rand</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacehydra.html#aeccdd58e3a4c27246dadd0930e3fb569">hydra::minstd_rand</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A random number engine with predefined parameters which implements a version of the Minimal Standard random number generation algorithm. </p>
<dl class="section note"><dt>Note</dt><dd>The 10000th consecutive invocation of a default-constructed object of type <code>minstd_rand</code> shall produce the value <code>399268537</code> . </dd></dl>

</div>
</div>
<a id="ab7c3603cf7a6c467176d8be9dd2c82fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7c3603cf7a6c467176d8be9dd2c82fd">&#9670;&nbsp;</a></span>minstd_rand0</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacehydra.html#ab7c3603cf7a6c467176d8be9dd2c82fd">hydra::minstd_rand0</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A random number engine with predefined parameters which implements a version of the Minimal Standard random number generation algorithm. </p>
<dl class="section note"><dt>Note</dt><dd>The 10000th consecutive invocation of a default-constructed object of type <code>minstd_rand0</code> shall produce the value <code>1043618065</code> . </dd></dl>

</div>
</div>
<a id="a412c01a2247e7a463fc693a43310d00e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a412c01a2247e7a463fc693a43310d00e">&#9670;&nbsp;</a></span>pair</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacehydra.html#a412c01a2247e7a463fc693a43310d00e">hydra::pair</a> = typedef hydra_thrust::pair&lt;T1,T2&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>pair</code> template is an alias to the hydra_thrust::pair structure. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>The type of <code>pair's</code> first object type. There are no requirements on the type of <code>T1</code>. <code>T1</code>'s type is provided by <code>pair::first_type</code>.</td></tr>
    <tr><td class="paramname">T2</td><td>The type of <code>pair's</code> second object type. There are no requirements on the type of <code>T2</code>. <code>T2</code>'s type is provided by <code>pair::second_type</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a943a0571fdadbbb4bc9b17ba7ae4b59b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a943a0571fdadbbb4bc9b17ba7ae4b59b">&#9670;&nbsp;</a></span>ranlux24</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacehydra.html#a943a0571fdadbbb4bc9b17ba7ae4b59b">hydra::ranlux24</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A random number engine with predefined parameters which implements the RANLUX level-3 random number generation algorithm. </p>
<dl class="section note"><dt>Note</dt><dd>The 10000th consecutive invocation of a default-constructed object of type <code>ranlux24</code> shall produce the value <code>9901578</code> . </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="pseudo_experiment_8inl-example.html#a27">pseudo_experiment.inl</a>.</dd>
</dl>
</div>
</div>
<a id="a6950c5abef4e2015f833501684940b5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6950c5abef4e2015f833501684940b5d">&#9670;&nbsp;</a></span>ranlux48</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacehydra.html#a6950c5abef4e2015f833501684940b5d">hydra::ranlux48</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A random number engine with predefined parameters which implements the RANLUX level-4 random number generation algorithm. </p>
<dl class="section note"><dt>Note</dt><dd>The 10000th consecutive invocation of a default-constructed object of type <code>ranlux48</code> shall produce the value <code>88229545517833</code> . </dd></dl>

</div>
</div>
<a id="a27378ecbb012326012d334cf11431549"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27378ecbb012326012d334cf11431549">&#9670;&nbsp;</a></span>sobol</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned D&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacehydra.html#a27378ecbb012326012d334cf11431549">hydra::sobol</a> = typedef <a class="el" href="classhydra_1_1sobol__engine.html">sobol_engine</a>&lt;uint_least64_t, <a class="el" href="basic__distributions_8inl.html#a6f9cfa21f3993da1ed1a77acbc9bd9be">D</a>, 64u, default_sobol_table&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section attention"><dt>Attention</dt><dd>This specialization of  supports up to 3667 dimensions.</dd></dl>
<p>Data on the primitive binary polynomials <code>a</code> and the corresponding starting values <code>m</code> for Sobol sequences in up to 21201 dimensions was taken from</p>
<p>S. Joe and F. Y. Kuo, Constructing Sobol sequences with better two-dimensional projections, SIAM J. Sci. Comput. 30, 2635-2654 (2008). </p>
<p>See the original tables up to dimension 21201: <a href="https://web.archive.org/web/20170802022909/http://web.maths.unsw.edu.au/~fkuo/sobol/new-joe-kuo-6.21201">https://web.archive.org/web/20170802022909/http://web.maths.unsw.edu.au/~fkuo/sobol/new-joe-kuo-6.21201</a></p>
<p>For practical reasons the default table uses only the subset of binary polynomials <code>a</code> &lt; 2<sup>16</sup>.</p>
<p>However, it is possible to provide your own table to  should the default one be insufficient. </p>

</div>
</div>
<a id="a2633cfe1492c02cfb2aef6a79804f191"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2633cfe1492c02cfb2aef6a79804f191">&#9670;&nbsp;</a></span>taus88</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacehydra.html#a2633cfe1492c02cfb2aef6a79804f191">hydra::taus88</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A random number engine with predefined parameters which implements L'Ecuyer's 1996 three-component Tausworthe random number generator. </p>
<dl class="section note"><dt>Note</dt><dd>The 10000th consecutive invocation of a default-constructed object of type <code>taus88</code> shall produce the value <code>3535848941</code> . </dd></dl>

</div>
</div>
<a id="a717fc4e6b10453164099beade13d0226"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a717fc4e6b10453164099beade13d0226">&#9670;&nbsp;</a></span>tuple</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacehydra.html#a717fc4e6b10453164099beade13d0226">hydra::tuple</a> = typedef hydra_thrust::tuple&lt;T...&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>tuple</code> template is an alias to the variadic version of hydra_thrust::tuple and that can be instantiated with a indefinite number of arguments. </p>
<p>Each template argument specifies the type of element in the <code>tuple</code>. Consequently, tuples are heterogeneous, fixed-size collections of values. An instantiation of <code>tuple</code> with two arguments is similar to an instantiation of <code>pair</code> with the same two arguments. Individual elements of a <code>tuple</code> may be accessed with the <code>get</code> function.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TN</td><td>The type of the <code>N</code> <code>tuple</code> element.</td></tr>
  </table>
  </dd>
</dl>
<p>The following code snippet demonstrates how to create a new <code>tuple</code> object and inspect and modify the value of its elements.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;hydra/tuple.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line">...</div><div class="line"><span class="comment">// create a tuple containing an int, a float, and a string</span></div><div class="line">hydra::tuple&lt;<a class="code" href="namespace_3globalScope_4.html#classint">int</a>, float, <span class="keyword">const</span> <span class="keywordtype">char</span>*&gt; t(13, 0.1f, <span class="stringliteral">&quot;hydra&quot;</span>);</div><div class="line"></div><div class="line"><span class="comment">// individual members are accessed with the free function get</span></div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;The first element&#39;s value is &quot;</span> &lt;&lt; hydra::get&lt;0&gt;(t) &lt;&lt; std::endl;</div><div class="line"></div><div class="line"><span class="comment">// or the member function get</span></div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;The second element&#39;s value is &quot;</span> &lt;&lt; t.get&lt;1&gt;() &lt;&lt; std::endl;</div><div class="line"></div><div class="line"><span class="comment">// we can also modify elements with the same function</span></div><div class="line">hydra::get&lt;0&gt;(t) += 10;</div></div><!-- fragment --> 
</div>
</div>
<a id="a2fb67e052a2a37c16a026792014cc585"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fb67e052a2a37c16a026792014cc585">&#9670;&nbsp;</a></span>tuple_element</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N, class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacehydra.html#a2fb67e052a2a37c16a026792014cc585">hydra::tuple_element</a> = typedef hydra_thrust::tuple_element&lt;N,T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The <code>get</code> function returns a <code>const</code> reference to a <code>tuple</code> element of interest. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>A reference to a <code>tuple</code> of interest. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>const</code> reference to <code>t's</code> <code>N</code>th element.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">N</td><td>The index of the element of interest.</td></tr>
  </table>
  </dd>
</dl>
<p>The following code snippet demonstrates how to use <code>get</code> to print the value of a <code>tuple</code> element.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="Tuple_8h.html">hydra/Tuple.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line">...</div><div class="line">hydra::tuple&lt;<a class="code" href="namespace_3globalScope_4.html#classint">int</a>, <span class="keyword">const</span> <span class="keywordtype">char</span> *&gt; t(13, <span class="stringliteral">&quot;hydra&quot;</span>);</div><div class="line"></div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;The 1st value of t is &quot;</span> &lt;&lt; hydra::get&lt;0&gt;(t) &lt;&lt; std::endl;</div></div><!-- fragment --><p>This metafunction returns the type of a <code>tuple's</code> <code>N</code>th element.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">N</td><td>This parameter selects the element of interest. </td></tr>
    <tr><td class="paramname">T</td><td>A <code>tuple</code> type of interest. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aea1e8b0aafd04f1005a05ae93a72bf9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea1e8b0aafd04f1005a05ae93a72bf9b">&#9670;&nbsp;</a></span>tuple_size</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacehydra.html#aea1e8b0aafd04f1005a05ae93a72bf9b">hydra::tuple_size</a> = typedef hydra_thrust::tuple_size&lt;T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This metafunction returns the number of elements of a <code>tuple</code> type of interest. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>A <code>tuple</code> type of interest. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ad59ea019090ed4c8a3aa6d8cab9ea696"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad59ea019090ed4c8a3aa6d8cab9ea696">&#9670;&nbsp;</a></span>anonymous enum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ad59ea019090ed4c8a3aa6d8cab9ea696aae772e8b4c5ada0e1e4c65495702176a"></a>MODE_IMPORTANCE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ad59ea019090ed4c8a3aa6d8cab9ea696a28550661921a3af1306fa74a26b8569c"></a>MODE_IMPORTANCE_ONLY&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ad59ea019090ed4c8a3aa6d8cab9ea696acb2c0124fecbf6c1182f1cf7cd9bc37a"></a>MODE_STRATIFIED&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ad59ea019090ed4c8a3aa6d8cab9ea696aba2629d0445cc7ef401fd6793f047da0"></a>BINS_MAX&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="ad87c68ca6adb981f4c31ae73ef97de3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad87c68ca6adb981f4c31ae73ef97de3b">&#9670;&nbsp;</a></span>anonymous enum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ad87c68ca6adb981f4c31ae73ef97de3ba4517ec382985cb7a39393c0da09e58d5"></a>INFO&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ad87c68ca6adb981f4c31ae73ef97de3ba1bf857a06d5b8463494a6fcac6f4ea26"></a>WARNING&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ad87c68ca6adb981f4c31ae73ef97de3badbc96f88184ea3a51f68df95e2b44851"></a>ERROR&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a5e095cca28f6bec603156fd48914aefe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e095cca28f6bec603156fd48914aefe">&#9670;&nbsp;</a></span>abs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> T hydra::abs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#a9be56668c1da1edd25b29c366adf5df9">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a256097a85b1ce0eafa6e497f46d87383"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a256097a85b1ce0eafa6e497f46d87383">&#9670;&nbsp;</a></span>acos()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespacehydra.html#a9be56668c1da1edd25b29c366adf5df9">complex</a>&lt;T&gt; hydra::acos </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#a9be56668c1da1edd25b29c366adf5df9">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aec91f5ec5ff214023b38f72ec4ac1e76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec91f5ec5ff214023b38f72ec4ac1e76">&#9670;&nbsp;</a></span>acosh()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespacehydra.html#a9be56668c1da1edd25b29c366adf5df9">complex</a>&lt;T&gt; hydra::acosh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#a9be56668c1da1edd25b29c366adf5df9">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae96191cbaa62c58f63b7e58924362c24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae96191cbaa62c58f63b7e58924362c24">&#9670;&nbsp;</a></span>arg()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> T hydra::arg </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#a9be56668c1da1edd25b29c366adf5df9">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9a7e65b9bb4aca1f24356f2d43f91bda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a7e65b9bb4aca1f24356f2d43f91bda">&#9670;&nbsp;</a></span>asin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespacehydra.html#a9be56668c1da1edd25b29c366adf5df9">complex</a>&lt;T&gt; hydra::asin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#a9be56668c1da1edd25b29c366adf5df9">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abd779382ac3242158686664a9a3ca3a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd779382ac3242158686664a9a3ca3a0">&#9670;&nbsp;</a></span>asinh()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespacehydra.html#a9be56668c1da1edd25b29c366adf5df9">complex</a>&lt;T&gt; hydra::asinh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#a9be56668c1da1edd25b29c366adf5df9">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9772b7e92ecdf60524cde428c1670bd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9772b7e92ecdf60524cde428c1670bd4">&#9670;&nbsp;</a></span>atan()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespacehydra.html#a9be56668c1da1edd25b29c366adf5df9">complex</a>&lt;T&gt; hydra::atan </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#a9be56668c1da1edd25b29c366adf5df9">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a24b7bc13880335fdf6964df5034ade29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24b7bc13880335fdf6964df5034ade29">&#9670;&nbsp;</a></span>atanh()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespacehydra.html#a9be56668c1da1edd25b29c366adf5df9">complex</a>&lt;T&gt; hydra::atanh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#a9be56668c1da1edd25b29c366adf5df9">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a03f4e98f986e55037e1a01fe4d9b8fc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03f4e98f986e55037e1a01fe4d9b8fc8">&#9670;&nbsp;</a></span>BarrierFactor&lt; hydra::DWave &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> <a class="el" href="group__common__functions.html#gacd995d684b15024c891571fe47518404">hydra::BarrierFactor</a>&lt; <a class="el" href="group__common__functions.html#gga0dc858c0fb14ade1e8abc19cdd0959e2a74097dfe50b93307e587c23f9180b6b3">hydra::DWave</a> &gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td>
          <td class="paramname"><em>radi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td>
          <td class="paramname"><em>p0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac5a1e302e48427c947ab2084811df1df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5a1e302e48427c947ab2084811df1df">&#9670;&nbsp;</a></span>BarrierFactor&lt; hydra::FWave &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> <a class="el" href="group__common__functions.html#gacd995d684b15024c891571fe47518404">hydra::BarrierFactor</a>&lt; <a class="el" href="group__common__functions.html#gga0dc858c0fb14ade1e8abc19cdd0959e2a82415de987820fb86ab995f1dee87db1">hydra::FWave</a> &gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td>
          <td class="paramname"><em>radi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td>
          <td class="paramname"><em>p0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac0e0a9c294368d8d5b74fb919e261bef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0e0a9c294368d8d5b74fb919e261bef">&#9670;&nbsp;</a></span>BarrierFactor&lt; hydra::GWave &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> <a class="el" href="group__common__functions.html#gacd995d684b15024c891571fe47518404">hydra::BarrierFactor</a>&lt; <a class="el" href="group__common__functions.html#gga0dc858c0fb14ade1e8abc19cdd0959e2a113622b6b528bfd4a76d68e9a99ac032">hydra::GWave</a> &gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td>
          <td class="paramname"><em>radi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td>
          <td class="paramname"><em>p0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae223d417259cf7e660fd89a54438d45b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae223d417259cf7e660fd89a54438d45b">&#9670;&nbsp;</a></span>BarrierFactor&lt; hydra::HWave &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> <a class="el" href="group__common__functions.html#gacd995d684b15024c891571fe47518404">hydra::BarrierFactor</a>&lt; <a class="el" href="group__common__functions.html#gga0dc858c0fb14ade1e8abc19cdd0959e2af168d5a7a174aa70e881f13fdeaf4426">hydra::HWave</a> &gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td>
          <td class="paramname"><em>radi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td>
          <td class="paramname"><em>p0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa78649879f76b3b52249830df2482980"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa78649879f76b3b52249830df2482980">&#9670;&nbsp;</a></span>BarrierFactor&lt; hydra::PWave &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> <a class="el" href="group__common__functions.html#gacd995d684b15024c891571fe47518404">hydra::BarrierFactor</a>&lt; <a class="el" href="group__common__functions.html#gga0dc858c0fb14ade1e8abc19cdd0959e2ae382eaafad7afe6dee68693249ff8a45">hydra::PWave</a> &gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td>
          <td class="paramname"><em>radi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td>
          <td class="paramname"><em>p0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aab59597f876fc220d388f5911bb9822c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab59597f876fc220d388f5911bb9822c">&#9670;&nbsp;</a></span>BarrierFactor&lt; hydra::SWave &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> <a class="el" href="group__common__functions.html#gacd995d684b15024c891571fe47518404">hydra::BarrierFactor</a>&lt; <a class="el" href="group__common__functions.html#gga0dc858c0fb14ade1e8abc19cdd0959e2a4f4fc5545002d4eada7e2a14c27c5dfd">hydra::SWave</a> &gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab9d562f964ef193664077363da8859e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9d562f964ef193664077363da8859e2">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::begin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="basic__distributions_8inl.html#a4900ef306eb9271438791f1a98b8ccba">C</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td> -&gt;  decltype(c.begin())</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="multiarray_container_8inl-example.html#a7">multiarray_container.inl</a>.</dd>
</dl>
</div>
</div>
<a id="a7e149bee61e4ddabca7fa0aafa121fe1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e149bee61e4ddabca7fa0aafa121fe1">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::begin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="basic__distributions_8inl.html#a4900ef306eb9271438791f1a98b8ccba">C</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td> -&gt;  decltype(std::forward&lt; <a class="el" href="basic__distributions_8inl.html#a4900ef306eb9271438791f1a98b8ccba">C</a> &gt;(c).begin())</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6c64031cbdf1765fdf74577297ddb758"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c64031cbdf1765fdf74577297ddb758">&#9670;&nbsp;</a></span>begin() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T * hydra::begin </td>
          <td>(</td>
          <td class="paramtype">T(&amp;)&#160;</td>
          <td class="paramname"><em>array</em>[N]</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afd4f46840c85ee014f1d237601913ae1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd4f46840c85ee014f1d237601913ae1">&#9670;&nbsp;</a></span>begin() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename T , size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::begin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#classhydra_1_1multiarray">multiarray</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(other.begin(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt;I&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6483cec578e17112f07ba012a4dc50ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6483cec578e17112f07ba012a4dc50ed">&#9670;&nbsp;</a></span>begin() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename T , size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::begin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#classhydra_1_1multiarray">multiarray</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(other.begin(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt;I&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a20ab2350fcc599675e32aa7226258b22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20ab2350fcc599675e32aa7226258b22">&#9670;&nbsp;</a></span>begin() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::begin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; hydra_thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> -&gt; decltype(other.begin(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt;I&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="adf567807d28a79686b53c5380afcbbdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf567807d28a79686b53c5380afcbbdc">&#9670;&nbsp;</a></span>begin() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::begin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; hydra_thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> -&gt; decltype(other.begin(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt;I&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a608214dc8fa90b976dc3eb5e7a98327e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a608214dc8fa90b976dc3eb5e7a98327e">&#9670;&nbsp;</a></span>boost_strapped_range()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterable &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;<a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt;Iterable&gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; hydra_thrust::permutation_iterator&lt;decltype(std::declval&lt;Iterable&amp;&gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()), hydra_thrust::transform_iterator&lt; <a class="el" href="structhydra_1_1detail_1_1RndUniform.html">detail::RndUniform</a>&lt;size_t, hydra_thrust::random::default_random_engine&gt; ,hydra_thrust::counting_iterator&lt;size_t&gt;,size_t &gt; &gt; &gt; &gt;::type hydra::boost_strapped_range </td>
          <td>(</td>
          <td class="paramtype">Iterable &amp;&amp;&#160;</td>
          <td class="paramname"><em>iterable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>seed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="booststrapping_8inl-example.html#a5">booststrapping.inl</a>, and <a class="el" href="pseudo_experiment_8inl-example.html#a32">pseudo_experiment.inl</a>.</dd>
</dl>
</div>
</div>
<a id="a39ca77c714b3e8b913c37d323cfd5640"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39ca77c714b3e8b913c37d323cfd5640">&#9670;&nbsp;</a></span>boostTo() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> Vector4R hydra::boostTo </td>
          <td>(</td>
          <td class="paramtype">const Vector4R &amp;&#160;</td>
          <td class="paramname"><em>rs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector4R &amp;&#160;</td>
          <td class="paramname"><em>p4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>inverse</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1c1de9e4fabdb747b9e3352ef6298476"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c1de9e4fabdb747b9e3352ef6298476">&#9670;&nbsp;</a></span>boostTo() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> Vector4R hydra::boostTo </td>
          <td>(</td>
          <td class="paramtype">const Vector4R &amp;&#160;</td>
          <td class="paramname"><em>rs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector3R &amp;&#160;</td>
          <td class="paramname"><em>boost</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>inverse</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae19bb84d35c2b4edaea63abe6c1298ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae19bb84d35c2b4edaea63abe6c1298ef">&#9670;&nbsp;</a></span>chebychev_1st_kind()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> T hydra::chebychev_1st_kind </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_3globalScope_4.html#classunsigned">unsigned</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implementation of <a class="el" href="group__common__functions.html#classhydra_1_1Chebychev" title="The Chebyshev polynomials  (first kind) are polynomials with the largest possible leading coefficient...">Chebychev</a> polynomials of first kind \( P_n(n) \) using the recursive relation. </p>
<p class="formulaDsp">
\[P_{n+1}(x) = 2xP_n(x)-P_{n-1}(x) \]
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>order of the polynomial </td></tr>
    <tr><td class="paramname">x</td><td>argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a610d6c3636b0ee33dcebe0f10bb9d7d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a610d6c3636b0ee33dcebe0f10bb9d7d1">&#9670;&nbsp;</a></span>chebychev_2nd_kind()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> T hydra::chebychev_2nd_kind </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_3globalScope_4.html#classunsigned">unsigned</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implementation of <a class="el" href="group__common__functions.html#classhydra_1_1Chebychev" title="The Chebyshev polynomials  (first kind) are polynomials with the largest possible leading coefficient...">Chebychev</a> polynomials of second kind \( P_n(n) \) using the recursive relation. </p>
<p class="formulaDsp">
\[ P_{n+1}(x) = 2xP_n(x) - P_{n-1}(x) \]
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>order of the polynomial </td></tr>
    <tr><td class="paramname">x</td><td>argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="ac35031f37b7ebb095def140f0a7b9aef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac35031f37b7ebb095def140f0a7b9aef">&#9670;&nbsp;</a></span>collect()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterable_Index , typename Iterable_Values &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::collect </td>
          <td>(</td>
          <td class="paramtype">Iterable_Index &amp;&#160;</td>
          <td class="paramname"><em>indexing_scheme</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterable_Values &amp;&#160;</td>
          <td class="paramname"><em>collected_values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; typename std::enable_if&lt;<a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt;Iterable_Index&gt;::value
					    &amp;&amp; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt;Iterable_Values&gt;::value,
<a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt;hydra_thrust::permutation_iterator&lt;
		decltype(std::declval&lt;Iterable_Values&amp;&gt;().<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()),
		decltype(std::declval&lt;Iterable_Index&amp;&gt;().<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>())&gt;
&gt;::type
</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aec19ef09aa95bbdb2230bd31d879b94d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec19ef09aa95bbdb2230bd31d879b94d">&#9670;&nbsp;</a></span>columns() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;hydra::detail::Backend BACKEND, typename T , size_t N, unsigned int... I&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::columns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#classhydra_1_1multiarray">multiarray</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt;const &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;...&#160;</td>
          <td class="paramname"><em>cls</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt;decltype(std::declval&lt;	<a class="el" href="namespacehydra.html#classhydra_1_1multiarray">multiarray</a>&lt;T,N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt;BACKEND&gt;&gt;const&amp;&gt;().<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt;I&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="pseudo_experiment_8inl-example.html#a34">pseudo_experiment.inl</a>, and <a class="el" href="range_semantics_8inl-example.html#a13">range_semantics.inl</a>.</dd>
</dl>
</div>
</div>
<a id="ac897e7fcbfbb068d5d29122253491201"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac897e7fcbfbb068d5d29122253491201">&#9670;&nbsp;</a></span>columns() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;hydra::detail::Backend BACKEND, typename T , size_t N, unsigned int... I&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::columns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#classhydra_1_1multiarray">multiarray</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;...&#160;</td>
          <td class="paramname"><em>cls</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt;decltype(std::declval&lt;<a class="el" href="namespacehydra.html#classhydra_1_1multiarray">multiarray</a>&lt;T,N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt;BACKEND&gt;&gt;&amp;&amp;&gt;().<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt;I&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adcaf864dba8ea6caf619dfa3887a275c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcaf864dba8ea6caf619dfa3887a275c">&#9670;&nbsp;</a></span>columns() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;hydra::detail::Backend BACKEND, typename ... T, unsigned int... I&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::columns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; hydra_thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt;&gt;const &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;...&#160;</td>
          <td class="paramname"><em>cls</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt;decltype(std::declval&lt;<a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt;hydra_thrust::tuple&lt;T...&gt;,
		<a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt;BACKEND&gt;&gt; const&amp;&gt;().<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt;I&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1944b47c3207786971f8931d6b18c6be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1944b47c3207786971f8931d6b18c6be">&#9670;&nbsp;</a></span>columns() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;hydra::detail::Backend BACKEND, typename ... T, unsigned int... I&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::columns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; hydra_thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;...&#160;</td>
          <td class="paramname"><em>cls</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt;decltype(std::declval&lt;<a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt;hydra_thrust::tuple&lt;T...&gt;,
		<a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt;BACKEND&gt;&gt;&amp;&gt;().<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt;I&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a085cd308929f36e2ea3b0c1975ac989f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a085cd308929f36e2ea3b0c1975ac989f">&#9670;&nbsp;</a></span>columns() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , hydra::detail::Backend BACKEND, typename ... T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::columns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; hydra_thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> -&gt; <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt;decltype(
std::declval&lt;<a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt;hydra_thrust::tuple&lt;T...&gt;,
<a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt;BACKEND&gt;&gt;&amp;&gt;().<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>(
		<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt;<a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1index__in__tuple">detail::index_in_tuple</a>&lt;Type, hydra_thrust::tuple&lt;T...&gt; &gt;::value&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae10c8ab337cbc0b309aa95eb345ddc5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae10c8ab337cbc0b309aa95eb345ddc5d">&#9670;&nbsp;</a></span>compose()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T0 , typename T1 , typename ... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;(<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt;T0&gt;::value || <a class="el" href="structhydra_1_1detail_1_1is__hydra__lambda.html">detail::is_hydra_lambda</a>&lt;T0&gt;::value) &amp;&amp;(<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt;T1&gt;::value || <a class="el" href="structhydra_1_1detail_1_1is__hydra__lambda.html">detail::is_hydra_lambda</a>&lt;T1&gt;::value) &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1all__true.html">detail::all_true</a>&lt;(<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt;Ts&gt;::value || <a class="el" href="structhydra_1_1detail_1_1is__hydra__lambda.html">detail::is_hydra_lambda</a>&lt;Ts&gt;::value)...&gt;::value,<a class="el" href="classhydra_1_1Compose.html">Compose</a>&lt;T0,T1,Ts...&gt; &gt;::type hydra::compose </td>
          <td>(</td>
          <td class="paramtype">T0 const &amp;&#160;</td>
          <td class="paramname"><em>F0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T1 const &amp;&#160;</td>
          <td class="paramname"><em>F1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ts const &amp;...&#160;</td>
          <td class="paramname"><em>Fs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="dalitz_plot_8C-example.html#a34">dalitz_plot.C</a>, and <a class="el" href="dalitz_plot_8inl-example.html#a20">dalitz_plot.inl</a>.</dd>
</dl>
</div>
</div>
<a id="ad2ffe3ace108474a31b8cb84ceae7f14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2ffe3ace108474a31b8cb84ceae7f14">&#9670;&nbsp;</a></span>conj()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespacehydra.html#a9be56668c1da1edd25b29c366adf5df9">complex</a>&lt;T&gt; hydra::conj </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#a9be56668c1da1edd25b29c366adf5df9">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0f6311fb715b4a280af3c04790c7b122"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f6311fb715b4a280af3c04790c7b122">&#9670;&nbsp;</a></span>constant_range()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt;hydra_thrust::constant_iterator&lt;Value_Type&gt; &gt; hydra::constant_range </td>
          <td>(</td>
          <td class="paramtype">const Value_Type &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ade5b435c4a37bbda1d67cd8fe18b526f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade5b435c4a37bbda1d67cd8fe18b526f">&#9670;&nbsp;</a></span>convolute()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;detail::Backend BACKEND, detail::FFTCalculator FFTBackend, typename Functor , typename Kernel , typename Iterable , typename T  = typename detail::stripped_type&lt;typename hydra_thrust::iterator_traits&lt;decltype(std::declval&lt;Iterable&gt;().begin())&gt;::value_type&gt;::type, typename USING_CUDA_BACKEND  = typename std::conditional&lt; std::is_convertible&lt;detail::BackendPolicy&lt;BACKEND&gt;,hydra_thrust::system::cuda::tag &gt;::value, std::integral_constant&lt;int, 1&gt;,std::integral_constant&lt;int, 0&gt;&gt;::type, typename USING_CUFFT  = typename std::conditional&lt; FFTBackend==detail::CuFFT, std::integral_constant&lt;int, 1&gt;,std::integral_constant&lt;int, 0&gt;&gt;::type, typename GPU_DATA  = typename std::conditional&lt; std::is_convertible&lt;typename hydra_thrust::iterator_system&lt; decltype(std::declval&lt;Iterable&gt;().begin())&gt;::type,                        hydra_thrust::system::cuda::tag&gt;::value         , std::integral_constant&lt;int, 1&gt;, std::integral_constant&lt;int, 0&gt; &gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;std::is_floating_point&lt;T&gt;::value &amp;&amp; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt;Iterable&gt;::value ,void&gt;::type hydra::convolute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&#160;</td>
          <td class="paramname"><em>policy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1FFTPolicy">detail::FFTPolicy</a>&lt; T, FFTBackend &gt;&#160;</td>
          <td class="paramname"><em>fft_policy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Functor const &amp;&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Kernel const &amp;&#160;</td>
          <td class="paramname"><em>kernel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterable &amp;&amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>power_up</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="convolute_functions_8inl-example.html#a23">convolute_functions.inl</a>.</dd>
</dl>
</div>
</div>
<a id="a0b928198a46f83eb9d2793e8e079ba5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b928198a46f83eb9d2793e8e079ba5a">&#9670;&nbsp;</a></span>copy() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterable_Source , typename Iterable_Target &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;<a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt;Iterable_Source&gt;::value&amp;&amp; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt;Iterable_Target&gt;::value,<a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt;decltype(std::declval&lt;Iterable_Target&amp;&gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>())&gt; &gt;::type hydra::copy </td>
          <td>(</td>
          <td class="paramtype">Iterable_Source &amp;&amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterable_Target &amp;&amp;&#160;</td>
          <td class="paramname"><em>destination</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="basic_fit_8inl-example.html#a18">basic_fit.inl</a>, <a class="el" href="fill_basic_distributions_8inl-example.html#a47">fill_basic_distributions.inl</a>, <a class="el" href="phsp_chain_8inl-example.html#a25">phsp_chain.inl</a>, <a class="el" href="simultaneous_fit_8inl-example.html#a20">simultaneous_fit.inl</a>, and <a class="el" href="splot_8inl-example.html#a29">splot.inl</a>.</dd>
</dl>
</div>
</div>
<a id="a28aa8ffeea73bf98ccab0fb7cd1c8116"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28aa8ffeea73bf98ccab0fb7cd1c8116">&#9670;&nbsp;</a></span>copy() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator , typename OutputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator hydra::copy </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a98b97d9c4a1b0350ef7c2d646c8c504a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98b97d9c4a1b0350ef7c2d646c8c504a">&#9670;&nbsp;</a></span>copy() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;detail::Backend Backend, typename InputIterator , typename OutputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator hydra::copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; Backend &gt; const &amp;&#160;</td>
          <td class="paramname"><em>policy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a82497912f037617b630d048bfcc515c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82497912f037617b630d048bfcc515c0">&#9670;&nbsp;</a></span>cos()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespacehydra.html#a9be56668c1da1edd25b29c366adf5df9">complex</a>&lt;T&gt; hydra::cos </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#a9be56668c1da1edd25b29c366adf5df9">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="dalitz_plot_8C-example.html#a23">dalitz_plot.C</a>, and <a class="el" href="dalitz_plot_8inl-example.html#a31">dalitz_plot.inl</a>.</dd>
</dl>
</div>
</div>
<a id="ac9aa7456a15f61cd1ed2b5ef7227409e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9aa7456a15f61cd1ed2b5ef7227409e">&#9670;&nbsp;</a></span>cosh()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespacehydra.html#a9be56668c1da1edd25b29c366adf5df9">complex</a>&lt;T&gt; hydra::cosh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#a9be56668c1da1edd25b29c366adf5df9">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6d55d71b4eca1da2fac83a615ea4b990"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d55d71b4eca1da2fac83a615ea4b990">&#9670;&nbsp;</a></span>cross()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> Vector3R hydra::cross </td>
          <td>(</td>
          <td class="paramtype">const Vector3R &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector3R &amp;&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7c937d0257bdadba3cfa1983d357f06b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c937d0257bdadba3cfa1983d357f06b">&#9670;&nbsp;</a></span>distance()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> auto hydra::distance </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype( hydra_thrust::distance&lt;Iterator&gt;(first,last))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4fec57c554e6c86f34145e7aa8845506"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fec57c554e6c86f34145e7aa8845506">&#9670;&nbsp;</a></span>divide()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F1 , typename F2 , typename ... Fs&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;(<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt;F1&gt;::value || <a class="el" href="structhydra_1_1detail_1_1is__hydra__lambda.html">detail::is_hydra_lambda</a>&lt;F1&gt;::value) &amp;&amp;(<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt;F2&gt;::value || <a class="el" href="structhydra_1_1detail_1_1is__hydra__lambda.html">detail::is_hydra_lambda</a>&lt;F2&gt;::value),<a class="el" href="classhydra_1_1Divide.html">Divide</a>&lt;F1, F2&gt; &gt;::type hydra::divide </td>
          <td>(</td>
          <td class="paramtype">F1 const &amp;&#160;</td>
          <td class="paramname"><em>f1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F2 const &amp;&#160;</td>
          <td class="paramname"><em>f2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4274268d147e9a988f379326b73682b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4274268d147e9a988f379326b73682b0">&#9670;&nbsp;</a></span>end() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::end </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="basic__distributions_8inl.html#a4900ef306eb9271438791f1a98b8ccba">C</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td> -&gt;  decltype(c.end())</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="multiarray_container_8inl-example.html#a9">multiarray_container.inl</a>, <a class="el" href="phsp_averaging_functor_8inl-example.html#a21">phsp_averaging_functor.inl</a>, <a class="el" href="phsp_basic_8inl-example.html#a24">phsp_basic.inl</a>, <a class="el" href="phsp_chain_8inl-example.html#a22">phsp_chain.inl</a>, <a class="el" href="phsp_reweighting_8inl-example.html#a29">phsp_reweighting.inl</a>, <a class="el" href="phsp_unweighting_8inl-example.html#a24">phsp_unweighting.inl</a>, <a class="el" href="phsp_unweighting_functor_8inl-example.html#a29">phsp_unweighting_functor.inl</a>, and <a class="el" href="pseudo_experiment_8inl-example.html#a41">pseudo_experiment.inl</a>.</dd>
</dl>
</div>
</div>
<a id="a1d1cd86c2f2c422730b87a5890dbaee3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d1cd86c2f2c422730b87a5890dbaee3">&#9670;&nbsp;</a></span>end() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="basic__distributions_8inl.html#a4900ef306eb9271438791f1a98b8ccba">C</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td> -&gt;  decltype(std::forward&lt; <a class="el" href="basic__distributions_8inl.html#a4900ef306eb9271438791f1a98b8ccba">C</a> &gt;(c).end())</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3e7ed93e81eae920f0c85fea012dc23c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e7ed93e81eae920f0c85fea012dc23c">&#9670;&nbsp;</a></span>end() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T * hydra::end </td>
          <td>(</td>
          <td class="paramtype">T(&amp;)&#160;</td>
          <td class="paramname"><em>array</em>[N]</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a03f64a7db637f2f1865093311d69f0bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03f64a7db637f2f1865093311d69f0bc">&#9670;&nbsp;</a></span>end() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename T , size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#classhydra_1_1multiarray">multiarray</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(other.end(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt;I&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab07ef1a981144fec2ec0227a346bedf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab07ef1a981144fec2ec0227a346bedf8">&#9670;&nbsp;</a></span>end() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename T , size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#classhydra_1_1multiarray">multiarray</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(other.end(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt;I&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2c79b2fbe8baa0770d528d6847ad63fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c79b2fbe8baa0770d528d6847ad63fd">&#9670;&nbsp;</a></span>end() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; hydra_thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> -&gt; decltype(other.end(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt;I&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae4175978e51ef65de39c073ca98ff48a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4175978e51ef65de39c073ca98ff48a">&#9670;&nbsp;</a></span>end() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; hydra_thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> -&gt; decltype(other.end(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt;I&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5a9d4c5b0ed8b81a1ddc80ac67189b6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a9d4c5b0ed8b81a1ddc80ac67189b6f">&#9670;&nbsp;</a></span>erfinv()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> long <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> hydra::erfinv </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5acb87c4eb594ddbf0c4322a11cf4d8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5acb87c4eb594ddbf0c4322a11cf4d8a">&#9670;&nbsp;</a></span>exp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespacehydra.html#a9be56668c1da1edd25b29c366adf5df9">complex</a>&lt;T&gt; hydra::exp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#a9be56668c1da1edd25b29c366adf5df9">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="basic_distributions_8inl-example.html#a19">basic_distributions.inl</a>, <a class="el" href="dense_histogram_8inl-example.html#a7">dense_histogram.inl</a>, and <a class="el" href="fill_basic_distributions_8inl-example.html#a18">fill_basic_distributions.inl</a>.</dd>
</dl>
</div>
</div>
<a id="a512babb40a76dd738ca038f5fa7b1d51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a512babb40a76dd738ca038f5fa7b1d51">&#9670;&nbsp;</a></span>fill_random() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Engine , hydra::detail::Backend BACKEND, typename Iterator , typename FUNCTOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1has__rng__formula.html">hydra::detail::has_rng_formula</a>&lt;FUNCTOR&gt;::value &amp;&amp; std::is_convertible&lt; decltype(std::declval&lt;<a class="el" href="classhydra_1_1RngFormula.html">RngFormula</a>&lt;FUNCTOR&gt; &gt;).<a class="el" href="phsp__unweighting_8inl.html#aae0754269ece74173f4afd72643b7e3e">Generate</a>( std::declval&lt;Engine&amp;&gt;), std::declval&lt;FUNCTOR const&amp;&gt;))), typename hydra_thrust::iterator_traits&lt;Iterator&gt;::value_type &gt;::value, void&gt;::type hydra::fill_random </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; const &amp;&#160;</td>
          <td class="paramname"><em>policy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FUNCTOR const &amp;&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>seed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fill a range with numbers distributed according a user defined distribution using a RNG analytical formula. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">policy</td><td>backend to perform the calculation. </td></tr>
    <tr><td class="paramname">begin</td><td>beginning of the range storing the generated values </td></tr>
    <tr><td class="paramname">end</td><td>ending of the range storing the generated values </td></tr>
    <tr><td class="paramname">functor</td><td>distribution to be sampled </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6c8bad583601746518bdf2e8cd07394d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6c8bad583601746518bdf2e8cd07394d">&#9670;&nbsp;</a></span>fill_random() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Engine , typename Iterator , typename FUNCTOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1has__rng__formula.html">hydra::detail::has_rng_formula</a>&lt; FUNCTOR &gt;::value &amp;&amp;std::is_convertible&lt; decltype(std::declval&lt; <a class="el" href="classhydra_1_1RngFormula.html">RngFormula</a>&lt; FUNCTOR &gt; &gt;).<a class="el" href="phsp__unweighting_8inl.html#aae0754269ece74173f4afd72643b7e3e">Generate</a>(std::declval&lt; Engine &amp; &gt;), std::declval&lt; FUNCTOR const  &amp; &gt;))), typename hydra_thrust::iterator_traits&lt; Iterator &gt;::value_type &gt;::value, void &gt;::type hydra::fill_random </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FUNCTOR const &amp;&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>seed</em> = <code>0x254a0afcf7da74a2</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fill a range with numbers distributed according a user defined distribution using a RNG analytical formula. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>beginning of the range storing the generated values </td></tr>
    <tr><td class="paramname">end</td><td>ending of the range storing the generated values </td></tr>
    <tr><td class="paramname">functor</td><td>distribution to be sampled </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab04906caf93945fb2c86780c1cea2286"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab04906caf93945fb2c86780c1cea2286">&#9670;&nbsp;</a></span>fill_random() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Engine , hydra::detail::Backend BACKEND, typename Iterator , typename FUNCTOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; !std::is_convertible&lt; decltype(std::declval&lt; <a class="el" href="classhydra_1_1RngFormula.html">RngFormula</a>&lt; FUNCTOR &gt; &gt;).<a class="el" href="phsp__unweighting_8inl.html#aae0754269ece74173f4afd72643b7e3e">Generate</a>(std::declval&lt; Engine &amp; &gt;), std::declval&lt; FUNCTOR const  &amp; &gt;))), typename std::iterator_traits&lt; Iterator &gt;::value_type &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1has__rng__formula.html">hydra::detail::has_rng_formula</a>&lt; FUNCTOR &gt;::value, void &gt;::type hydra::fill_random </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; const &amp;&#160;</td>
          <td class="paramname"><em>policy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FUNCTOR const &amp;&#160;</td>
          <td class="paramname"><em>funct</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>seed</em> = <code>0x254a0afcf7da74a2</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fall back function if RngFormula::Generate() return value is not convertible to functor return value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">policy</td><td>backend to perform the calculation. </td></tr>
    <tr><td class="paramname">begin</td><td>beginning of the range storing the generated values </td></tr>
    <tr><td class="paramname">end</td><td>ending of the range storing the generated values </td></tr>
    <tr><td class="paramname">functor</td><td>distribution to be sampled </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6c8bad583601746518bdf2e8cd07394d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6c8bad583601746518bdf2e8cd07394d">&#9670;&nbsp;</a></span>fill_random() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Engine , typename Iterator , typename FUNCTOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; !std::is_convertible&lt; decltype(std::declval&lt; <a class="el" href="classhydra_1_1RngFormula.html">RngFormula</a>&lt; FUNCTOR &gt; &gt;).<a class="el" href="phsp__unweighting_8inl.html#aae0754269ece74173f4afd72643b7e3e">Generate</a>(std::declval&lt; Engine &amp; &gt;), std::declval&lt; FUNCTOR const  &amp; &gt;))), typename std::iterator_traits&lt; Iterator &gt;::value_type &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1has__rng__formula.html">hydra::detail::has_rng_formula</a>&lt; FUNCTOR &gt;::value, void &gt;::type hydra::fill_random </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FUNCTOR const &amp;&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>seed</em> = <code>0x254a0afcf7da74a2</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fall back function if RngFormula::Generate() return value is not convertible to functor return value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>beginning of the range storing the generated values </td></tr>
    <tr><td class="paramname">end</td><td>ending of the range storing the generated values </td></tr>
    <tr><td class="paramname">functor</td><td>distribution to be sampled </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1cc4cdb2d1cef66ec9cd64977d917725"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1cc4cdb2d1cef66ec9cd64977d917725">&#9670;&nbsp;</a></span>fill_random() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Engine , hydra::detail::Backend BACKEND, typename Iterable , typename FUNCTOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; !<a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; Iterable &gt;::value||!std::is_convertible&lt; decltype(*std::declval&lt; Iterable &gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()), typename FUNCTOR::return_type &gt;::value, void &gt;::type hydra::fill_random </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; const &amp;&#160;</td>
          <td class="paramname"><em>policy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterable &amp;&amp;&#160;</td>
          <td class="paramname"><em>iterable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FUNCTOR const &amp;&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>seed</em> = <code>0x254a0afcf7da74a2</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fall back function if the argument is not an Iterable or if it is not convertible to the Functor return value. </p>
<p>Fall back function if the argument is not an Iterable or if itis not convertible to the Functor return value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">policy</td><td>backend to perform the calculation. </td></tr>
    <tr><td class="paramname">iterable</td><td>range storing the generated values </td></tr>
    <tr><td class="paramname">functor</td><td>distribution to be sampled </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaeece1c5ccb29403fd0a8322a37e851d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeece1c5ccb29403fd0a8322a37e851d7">&#9670;&nbsp;</a></span>fill_random() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Engine , typename Iterable , typename FUNCTOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; !<a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; Iterable &gt;::value||!std::is_convertible&lt; decltype(*std::declval&lt; Iterable &gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()), typename FUNCTOR::return_type &gt;::value, void &gt;::type hydra::fill_random </td>
          <td>(</td>
          <td class="paramtype">Iterable &amp;&amp;&#160;</td>
          <td class="paramname"><em>iterable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FUNCTOR const &amp;&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>seed</em> = <code>0x254a0afcf7da74a2</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fall back function if the argument is not an Iterable or if it is not convertible to the Functor return value. </p>
<p>Fall back function if the argument is not an Iterable or if itis not convertible to the Functor return value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iterable</td><td>range storing the generated values </td></tr>
    <tr><td class="paramname">functor</td><td>distribution to be sampled </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aab0cc380e55d7f4d02106a74165f7162"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab0cc380e55d7f4d02106a74165f7162">&#9670;&nbsp;</a></span>filter() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterable , typename Functor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt;Iterable&gt;::value,<a class="el" href="namespacehydra.html#classhydra_1_1Range">hydra::Range</a>&lt;decltype(std::declval&lt;Iterable&gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>())&gt; &gt;::type hydra::filter </td>
          <td>(</td>
          <td class="paramtype">Iterable &amp;&amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Functor &amp;&amp;&#160;</td>
          <td class="paramname"><em>filter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="basic_fit_range_semantics_8inl-example.html#a24">basic_fit_range_semantics.inl</a>, <a class="el" href="extended_logLL_fit_8inl-example.html#a32">extended_logLL_fit.inl</a>, <a class="el" href="fit_gaussian_8C-example.html#a18">fit_gaussian.C</a>, <a class="el" href="fit_johnson_8C-example.html#a19">fit_johnson.C</a>, <a class="el" href="fractional_logLL_fit_8inl-example.html#a30">fractional_logLL_fit.inl</a>, <a class="el" href="multidimensional_fit_8inl-example.html#a45">multidimensional_fit.inl</a>, <a class="el" href="simultaneous_fit_8inl-example.html#a21">simultaneous_fit.inl</a>, and <a class="el" href="splot_8inl-example.html#a31">splot.inl</a>.</dd>
</dl>
</div>
</div>
<a id="a10d99a671eb993b054706c645b533533"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10d99a671eb993b054706c645b533533">&#9670;&nbsp;</a></span>filter() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterable , typename Functor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt;Iterable&gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1Range">hydra::Range</a>&lt;decltype(std::declval&lt;Iterable&gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>())&gt; &gt;::type hydra::filter </td>
          <td>(</td>
          <td class="paramtype">Iterable &amp;&amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Functor const &amp;&#160;</td>
          <td class="paramname"><em>filter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply a filter to the range [first, last] and return a pair of iterators for the filtered events. </p>
<p>This function will not change the size of the original range, [first, last], but will reorder the entries to put together the accepted entries. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>Iterator pointing to the begin of the range to filter. </td></tr>
    <tr><td class="paramname">last</td><td>Iterator pointing to the end of the range to filter. </td></tr>
    <tr><td class="paramname">filter</td><td>Functor returning bool. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="ab056ed3df61b0755f67d96f8537c657f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab056ed3df61b0755f67d96f8537c657f">&#9670;&nbsp;</a></span>for_each()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterable , typename Functor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;<a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt;Iterable&gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt;decltype(std::declval&lt;Iterable&amp;&gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>())&gt; &gt;::type hydra::for_each </td>
          <td>(</td>
          <td class="paramtype">Iterable &amp;&amp;&#160;</td>
          <td class="paramname"><em>iterable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Functor const &amp;&#160;</td>
          <td class="paramname"><em>functor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="booststrapping_8inl-example.html#a7">booststrapping.inl</a>, <a class="el" href="cufft_8inl-example.html#a20">cufft.inl</a>, <a class="el" href="fft_8inl-example.html#a20">fft.inl</a>, and <a class="el" href="range_semantics_8inl-example.html#a16">range_semantics.inl</a>.</dd>
</dl>
</div>
</div>
<a id="a6f07a165f21dcc1cbbe1b48fdb609398"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f07a165f21dcc1cbbe1b48fdb609398">&#9670;&nbsp;</a></span>forward_as_tuple()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> auto hydra::forward_as_tuple </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;...&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td> -&gt; decltype(hydra_thrust::forward_as_tuple(std::forward&lt;T&gt;(t)...))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a tuple of references to the arguments in args suitable for forwarding as an argument to a function. </p>
<p>The tuple has rvalue reference data members when rvalues are used as arguments, and otherwise has lvalue reference data members. </p>

</div>
</div>
<a id="a75feeef216747fa3b7c90b590f2761e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75feeef216747fa3b7c90b590f2761e8">&#9670;&nbsp;</a></span>gather()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterable_Source , typename Iterable_Target , typename Iterable_Map &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;<a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt;Iterable_Source&gt;::value &amp;&amp; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt;Iterable_Target&gt;::value &amp;&amp; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt;Iterable_Map&gt;::value,<a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt;decltype(std::declval&lt;Iterable_Target&amp;&gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>())&gt; &gt;::type hydra::gather </td>
          <td>(</td>
          <td class="paramtype">Iterable_Source &amp;&amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterable_Map &amp;&amp;&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterable_Target &amp;&amp;&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac71b87e64d6dbb15c41c8f77e95a8072"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac71b87e64d6dbb15c41c8f77e95a8072">&#9670;&nbsp;</a></span>get() <span class="overload">[1/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int I, int N, typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> T hydra::get </td>
          <td>(</td>
          <td class="paramtype">T(&amp;)&#160;</td>
          <td class="paramname"><em>array</em>[N]</td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a048ae1166f9c2988a3d1933b0a3843d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a048ae1166f9c2988a3d1933b0a3843d7">&#9670;&nbsp;</a></span>get() <span class="overload">[2/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int I, typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> T hydra::get </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a60f5ccfd225166dc9b3d89c0eff5a413"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60f5ccfd225166dc9b3d89c0eff5a413">&#9670;&nbsp;</a></span>get() <span class="overload">[3/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , typename ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> Type&amp; hydra::get </td>
          <td>(</td>
          <td class="paramtype">hydra_thrust::tuple&lt; T... &gt; const &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The <code>get</code> function returns a reference to a <code>tuple</code> element of interest. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>A reference to a <code>tuple</code> of interest. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to <code>t's</code> <code>N</code>th element.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">N</td><td>The index of the element of interest.</td></tr>
  </table>
  </dd>
</dl>
<p>The following code snippet demonstrates how to use <code>get</code> to print the value of a <code>tuple</code> element.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="Tuple_8h.html">hydra/Tuple.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line">...</div><div class="line">hydra::tuple&lt;<a class="code" href="namespace_3globalScope_4.html#classint">int</a>, <span class="keyword">const</span> <span class="keywordtype">char</span> *&gt; t(13, <span class="stringliteral">&quot;hydra&quot;</span>);</div><div class="line"></div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;The 1st value of t is &quot;</span> &lt;&lt; hydra::get&lt;0&gt;(t) &lt;&lt; std::endl;</div></div><!-- fragment --> 
</div>
</div>
<a id="a32d44a759daba901b4cd71a76ca9d86b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32d44a759daba901b4cd71a76ca9d86b">&#9670;&nbsp;</a></span>get() <span class="overload">[4/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N, typename ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> const hydra_thrust::tuple_element&lt;N,hydra_thrust::tuple&lt;T...&gt; &gt;::type&amp; hydra::get </td>
          <td>(</td>
          <td class="paramtype">hydra_thrust::tuple&lt; T... &gt; const &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0ab8f1851e2270ea973292200068d80c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ab8f1851e2270ea973292200068d80c">&#9670;&nbsp;</a></span>get() <span class="overload">[5/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , typename ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> Type&amp; hydra::get </td>
          <td>(</td>
          <td class="paramtype">hydra_thrust::tuple&lt; T... &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aba82a044ff758f7eefe8627efc3a10a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba82a044ff758f7eefe8627efc3a10a2">&#9670;&nbsp;</a></span>get() <span class="overload">[6/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N, typename ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::tuple_element&lt;N,hydra_thrust::tuple&lt;T...&gt; &gt;::type&amp; hydra::get </td>
          <td>(</td>
          <td class="paramtype">hydra_thrust::tuple&lt; T... &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4a267c8e70bcec4d44eb523c0dac39ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a267c8e70bcec4d44eb523c0dac39ad">&#9670;&nbsp;</a></span>get() <span class="overload">[7/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , typename ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> Type&amp;&amp; hydra::get </td>
          <td>(</td>
          <td class="paramtype">hydra_thrust::tuple&lt; T... &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a247c447c60ebd2007261398741a274ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a247c447c60ebd2007261398741a274ba">&#9670;&nbsp;</a></span>get() <span class="overload">[8/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N, typename ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::tuple_element&lt;N,hydra_thrust::tuple&lt;T...&gt; &gt;::type&amp;&amp; hydra::get </td>
          <td>(</td>
          <td class="paramtype">hydra_thrust::tuple&lt; T... &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a49b811128ade29a492e778eb1a829ba3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49b811128ade29a492e778eb1a829ba3">&#9670;&nbsp;</a></span>get() <span class="overload">[9/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N, typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::tuple_element&lt;N,hydra_thrust::pair&lt;T1,T2&gt; &gt;::type&amp; hydra::get </td>
          <td>(</td>
          <td class="paramtype">hydra_thrust::pair&lt; T1, T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad8aefcb814b129eee45f1ec95fdf907a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8aefcb814b129eee45f1ec95fdf907a">&#9670;&nbsp;</a></span>get() <span class="overload">[10/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N, typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> const hydra_thrust::tuple_element&lt;N,hydra_thrust::pair&lt;T1,T2&gt; &gt;::type&amp; hydra::get </td>
          <td>(</td>
          <td class="paramtype">hydra_thrust::pair&lt; T1, T2 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5b0f0cce7a103359def82b175c766f9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b0f0cce7a103359def82b175c766f9d">&#9670;&nbsp;</a></span>get() <span class="overload">[11/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N, typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::tuple_element&lt;N,hydra_thrust::pair&lt;T1,T2&gt; &gt;::type&amp;&amp; hydra::get </td>
          <td>(</td>
          <td class="paramtype">hydra_thrust::pair&lt; T1, T2 &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2658beb74af1f617373f6f640e2949e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2658beb74af1f617373f6f640e2949e4">&#9670;&nbsp;</a></span>get() <span class="overload">[12/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename T , size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#classhydra_1_1multiarray">multiarray</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(other.column(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt;I&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the column <code>_I</code> of the <a class="el" href="namespacehydra.html#classhydra_1_1multiarray">hydra::multiarray</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="af63079c411073c082f1099994bd539af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af63079c411073c082f1099994bd539af">&#9670;&nbsp;</a></span>get() <span class="overload">[13/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename T , size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#classhydra_1_1multiarray">multiarray</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(other.column(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt;I&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the column <code>_I</code> of the <a class="el" href="namespacehydra.html#classhydra_1_1multiarray">hydra::multiarray</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="ae440b48ee87508e2b2dadabfc85a9bcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae440b48ee87508e2b2dadabfc85a9bcc">&#9670;&nbsp;</a></span>get() <span class="overload">[14/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; hydra_thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> -&gt; decltype(other.column(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt;I&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7db056c1c062f48448f0bfaa0cd1eb32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7db056c1c062f48448f0bfaa0cd1eb32">&#9670;&nbsp;</a></span>get_flat_tuple()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhydra_1_1detail_1_1tuple__utility_1_1flat__tuple.html">detail::tuple_utility::flat_tuple</a>&lt;T...&gt;::type hydra::get_flat_tuple </td>
          <td>(</td>
          <td class="paramtype">T const &amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7582acf570b53c033d52c6ff0fecb43e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7582acf570b53c033d52c6ff0fecb43e">&#9670;&nbsp;</a></span>GetFormatedString()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string hydra::GetFormatedString </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7640497da0f9e58a93fbb73a130008af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7640497da0f9e58a93fbb73a130008af">&#9670;&nbsp;</a></span>hermite()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> T hydra::hermite </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_3globalScope_4.html#classunsigned">unsigned</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implementation of Hermite polynomials \( P_n(n) \) using the recursive relation. </p>
<p class="formulaDsp">
\[ P_{n + 1}(x) = 2xP_n(x) - 2nP_{n - 1}(x) \]
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>order of the polynomial </td></tr>
    <tr><td class="paramname">x</td><td>argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="ae56f5771a38cd48141f2e02712ac025f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae56f5771a38cd48141f2e02712ac025f">&#9670;&nbsp;</a></span>jacobi()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> T hydra::jacobi </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_3globalScope_4.html#classunsigned">unsigned</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>P_{n-1}^{(,)}(z) - 2 (n+ - 1) (n + -1) (2n+ + ) P_{n-2}^{(, )}(z), {align}&lt;/math&gt; </p>
<p>for ''n'' = 2, 3, .... </p>

</div>
</div>
<a id="a9fcbd1b972dcec1554ce96916da38a6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fcbd1b972dcec1554ce96916da38a6f">&#9670;&nbsp;</a></span>laguerre()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> T hydra::laguerre </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_3globalScope_4.html#classunsigned">unsigned</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implementation of Laguerre polynomials \( P_n(n) \) using the recursive relation. </p>
<p class="formulaDsp">
\[ P_{n + 1}(x) = \frac{(2n + 1 - x)P_n(x) - n P_{n - 1}(x)}{n + 1} \]
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>order of the polynomial </td></tr>
    <tr><td class="paramname">x</td><td>argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a17470c2d2376f96c63d7c89ed6b6cd5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17470c2d2376f96c63d7c89ed6b6cd5c">&#9670;&nbsp;</a></span>legendre()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> T hydra::legendre </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_3globalScope_4.html#classunsigned">unsigned</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implementation of Legendre polynomials \( P_n(n) \) using the recursive relation. </p>
<p class="formulaDsp">
\[ (n+1)P_{n+1}(x) = (2n+1)xP_{n}(x) - nP_{n-1}(x) \]
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>order of the polynomial </td></tr>
    <tr><td class="paramname">x</td><td>argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a2725e178af11595cbeba053c1f84dfa8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2725e178af11595cbeba053c1f84dfa8">&#9670;&nbsp;</a></span>log()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespacehydra.html#a9be56668c1da1edd25b29c366adf5df9">complex</a>&lt;T&gt; hydra::log </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#a9be56668c1da1edd25b29c366adf5df9">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a64d53a33e43032b9e482284fd1a38b08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64d53a33e43032b9e482284fd1a38b08">&#9670;&nbsp;</a></span>log10()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespacehydra.html#a9be56668c1da1edd25b29c366adf5df9">complex</a>&lt;T&gt; hydra::log10 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#a9be56668c1da1edd25b29c366adf5df9">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a18b264f6b9b7f5c64e717b6fdff18a53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18b264f6b9b7f5c64e717b6fdff18a53">&#9670;&nbsp;</a></span>make_convolution() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int ArgIndex, typename Functor , typename Kernel , detail::FFTCalculator FFTBackend, typename T  = typename std::common_type&lt;typename Functor::return_type, typename Kernel::return_type&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_floating_point&lt;T&gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1ConvolutionFunctor">ConvolutionFunctor</a>&lt;Functor, Kernel, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1FFTPolicy">detail::FFTPolicy</a>&lt;T, FFTBackend&gt;, ArgIndex&gt; &gt;::type hydra::make_convolution </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1FFTPolicy">detail::FFTPolicy</a>&lt; T, FFTBackend &gt;&#160;</td>
          <td class="paramname"><em>policy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Functor const &amp;&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Kernel const &amp;&#160;</td>
          <td class="paramname"><em>kernel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>kmin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>kmax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_3globalScope_4.html#classunsigned">unsigned</a>&#160;</td>
          <td class="paramname"><em>nsamples</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aec6434cd5d4090bff5bbac363febb2df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec6434cd5d4090bff5bbac363febb2df">&#9670;&nbsp;</a></span>make_convolution() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ArgType , typename Functor , typename Kernel , detail::Backend BACKEND, detail::FFTCalculator FFT, typename T  = typename detail::stripped_type&lt;typename std::common_type&lt;typename Functor::return_type, typename Kernel::return_type&gt;::type&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_floating_point&lt;T&gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1ConvolutionFunctor">ConvolutionFunctor</a>&lt;Functor, Kernel, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt;BACKEND&gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1FFTPolicy">detail::FFTPolicy</a>&lt;T, FFT&gt;, ArgType&gt; &gt;::type hydra::make_convolution </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt; const &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1FFTPolicy">detail::FFTPolicy</a>&lt; T, FFT &gt; const &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Functor const &amp;&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Kernel const &amp;&#160;</td>
          <td class="paramname"><em>kernel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>kmin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>kmax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_3globalScope_4.html#classunsigned">unsigned</a>&#160;</td>
          <td class="paramname"><em>nsamples</em> = <code>1024</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>interpolate</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>power_up</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae0a25f4f1f126bf7058fb3db42ff0396"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0a25f4f1f126bf7058fb3db42ff0396">&#9670;&nbsp;</a></span>make_dense_histogram()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator1 , typename Iterator2 , typename T , size_t N, hydra::detail::Backend BACKEND&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__histogram.html#classhydra_1_1DenseHistogram">DenseHistogram</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt;BACKEND&gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1multidimensional">detail::multidimensional</a>&gt; hydra::make_dense_histogram </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; size_t, N &gt; const &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; T, N &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lowerlimits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; T, N &gt; const &amp;&#160;</td>
          <td class="paramname"><em>upperlimits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator1&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator1&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator2&#160;</td>
          <td class="paramname"><em>wfirst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a820a933e48fa338a812a9f88bfb18e56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a820a933e48fa338a812a9f88bfb18e56">&#9670;&nbsp;</a></span>make_loglikehood_fcn()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... Pdfs, typename Histogram &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;<a class="el" href="structhydra_1_1detail_1_1is__hydra__dense__histogram.html">detail::is_hydra_dense_histogram</a>&lt;Histogram&gt;::value || <a class="el" href="structhydra_1_1detail_1_1is__hydra__sparse__histogram.html">detail::is_hydra_sparse_histogram</a>&lt;Histogram&gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1LogLikelihoodFCN">LogLikelihoodFCN</a>&lt; <a class="el" href="group__fit.html#classhydra_1_1PDFSumExtendable">PDFSumExtendable</a>&lt;Pdfs...&gt;, decltype(std::declval&lt;const Histogram&amp;&gt;).GetBinsCenters().<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()), decltype(std::declval&lt;const Histogram&amp;&gt;).GetBinsContents().<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()) &gt; &gt;::type hydra::make_loglikehood_fcn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__fit.html#classhydra_1_1PDFSumExtendable">PDFSumExtendable</a>&lt; Pdfs... &gt; const &amp;&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Histogram const &amp;&#160;</td>
          <td class="paramname"><em>points</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="acc64c5495b930568c11a5c29bd553e4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc64c5495b930568c11a5c29bd553e4d">&#9670;&nbsp;</a></span>make_pair()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> auto hydra::make_pair </td>
          <td>(</td>
          <td class="paramtype">T1 &amp;&amp;&#160;</td>
          <td class="paramname"><em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2 &amp;&amp;&#160;</td>
          <td class="paramname"><em>t2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(hydra_thrust::make_pair( std::forward&lt;T1&gt;(t1), std::forward&lt;T2&gt;(t2) ))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This version of <code>make_pair</code> creates a new <code>pair</code> object from a list of objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">T1</td><td>The first object to copy from. </td></tr>
    <tr><td class="paramname">T2</td><td>The second object to copy from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>pair</code> object with members which are copies of <code>t</code>. </dd></dl>

</div>
</div>
<a id="a77c630f8a750d37a4644fc0be2f98c8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77c630f8a750d37a4644fc0be2f98c8c">&#9670;&nbsp;</a></span>make_range() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator , typename Functor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">hydra_thrust::detail::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt;Functor&gt;::value , <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt;Iterator, Functor&gt; &gt;::type hydra::make_range </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Functor const &amp;&#160;</td>
          <td class="paramname"><em>functor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aed731c061feb7b22667628e351da610b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed731c061feb7b22667628e351da610b">&#9670;&nbsp;</a></span>make_range() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt;Iterator&gt; hydra::make_range </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="cufft_8inl-example.html#a16">cufft.inl</a>, <a class="el" href="dalitz_plot_8C-example.html#a46">dalitz_plot.C</a>, <a class="el" href="fft_8inl-example.html#a16">fft.inl</a>, and <a class="el" href="pseudo_experiment_8inl-example.html#a28">pseudo_experiment.inl</a>.</dd>
</dl>
</div>
</div>
<a id="aeb94a482290a0c2c1764865e7d16dcf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb94a482290a0c2c1764865e7d16dcf8">&#9670;&nbsp;</a></span>make_range() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterable &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;<a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt;Iterable&gt;::value,<a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt;decltype(std::declval&lt;Iterable&gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>())&gt; &gt;::type hydra::make_range </td>
          <td>(</td>
          <td class="paramtype">Iterable const &amp;&#160;</td>
          <td class="paramname"><em>container</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a21c52c12d57be6225d5a286890b7def5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21c52c12d57be6225d5a286890b7def5">&#9670;&nbsp;</a></span>make_range() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterable , typename Functor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">hydra_thrust::detail::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">detail::is_iterable</a>&lt;Iterable&gt;::value &amp;&amp; <a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt;Functor&gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt;decltype(std::declval&lt;Iterable&gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()), Functor&gt; &gt;::type hydra::make_range </td>
          <td>(</td>
          <td class="paramtype">Iterable const &amp;&#160;</td>
          <td class="paramname"><em>iterable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Functor const &amp;&#160;</td>
          <td class="paramname"><em>functor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a997423cc7da26ee78b795e07a6910c29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a997423cc7da26ee78b795e07a6910c29">&#9670;&nbsp;</a></span>make_range() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterable &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;<a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt;Iterable&gt;::value,<a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt;decltype(std::declval&lt;Iterable&gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>())&gt; &gt;::type hydra::make_range </td>
          <td>(</td>
          <td class="paramtype">Iterable &amp;&amp;&#160;</td>
          <td class="paramname"><em>container</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac03229293f965b9aeb8704c32b0fa8bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac03229293f965b9aeb8704c32b0fa8bb">&#9670;&nbsp;</a></span>make_range() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterable , typename Functor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">hydra_thrust::detail::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">detail::is_iterable</a>&lt;Iterable&gt;::value &amp;&amp; <a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt;Functor&gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt;decltype(std::declval&lt;Iterable&gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()), Functor&gt; &gt;::type hydra::make_range </td>
          <td>(</td>
          <td class="paramtype">Iterable &amp;&amp;&#160;</td>
          <td class="paramname"><em>iterable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Functor const &amp;&#160;</td>
          <td class="paramname"><em>functor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4e767e7adf0e19fd813cba22bf470f27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e767e7adf0e19fd813cba22bf470f27">&#9670;&nbsp;</a></span>make_reverse_range() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator , typename Functor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">hydra_thrust::detail::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt;Functor&gt;::value , <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt;hydra_thrust::reverse_iterator&lt;Iterator&gt;, Functor&gt; &gt;::type hydra::make_reverse_range </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Functor const &amp;&#160;</td>
          <td class="paramname"><em>functor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8ba38bc66af36e3e6f949fcb49ac78d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ba38bc66af36e3e6f949fcb49ac78d4">&#9670;&nbsp;</a></span>make_reverse_range() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt;hydra_thrust::reverse_iterator&lt;Iterator&gt; &gt; hydra::make_reverse_range </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8be66889f53db6bbae8365d509c13cd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8be66889f53db6bbae8365d509c13cd1">&#9670;&nbsp;</a></span>make_reverse_range() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterable &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;<a class="el" href="structhydra_1_1detail_1_1is__reverse__iterable.html">hydra::detail::is_reverse_iterable</a>&lt;Iterable&gt;::value,<a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt;decltype(std::declval&lt;Iterable&gt;).<a class="el" href="namespacehydra.html#aadcca49207bf7ab79088f28cddb8f21d">rbegin</a>())&gt; &gt;::type hydra::make_reverse_range </td>
          <td>(</td>
          <td class="paramtype">Iterable const &amp;&#160;</td>
          <td class="paramname"><em>container</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae2416806c69de19541c8156b9e060dda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2416806c69de19541c8156b9e060dda">&#9670;&nbsp;</a></span>make_reverse_range() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterable , typename Functor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">hydra_thrust::detail::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__reverse__iterable.html">detail::is_reverse_iterable</a>&lt;Iterable&gt;::value &amp;&amp; <a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt;Functor&gt;::value , <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt;decltype(std::declval&lt;Iterable&gt;).<a class="el" href="namespacehydra.html#aadcca49207bf7ab79088f28cddb8f21d">rbegin</a>()), Functor&gt; &gt;::type hydra::make_reverse_range </td>
          <td>(</td>
          <td class="paramtype">Iterable const &amp;&#160;</td>
          <td class="paramname"><em>iterable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Functor const &amp;&#160;</td>
          <td class="paramname"><em>functor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abdb731a7ec634ab03b448a6cc6230d68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdb731a7ec634ab03b448a6cc6230d68">&#9670;&nbsp;</a></span>make_reverse_range() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterable &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;<a class="el" href="structhydra_1_1detail_1_1is__reverse__iterable.html">hydra::detail::is_reverse_iterable</a>&lt;Iterable&gt;::value,<a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt;decltype(std::declval&lt;Iterable&gt;).<a class="el" href="namespacehydra.html#aadcca49207bf7ab79088f28cddb8f21d">rbegin</a>())&gt; &gt;::type hydra::make_reverse_range </td>
          <td>(</td>
          <td class="paramtype">Iterable &amp;&amp;&#160;</td>
          <td class="paramname"><em>container</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8c9ee9245860252a898f227d242011f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c9ee9245860252a898f227d242011f2">&#9670;&nbsp;</a></span>make_reverse_range() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterable , typename Functor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">hydra_thrust::detail::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__reverse__iterable.html">detail::is_reverse_iterable</a>&lt;Iterable&gt;::value &amp;&amp; <a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt;Functor&gt;::value , <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt;decltype(std::declval&lt;Iterable&gt;).<a class="el" href="namespacehydra.html#aadcca49207bf7ab79088f28cddb8f21d">rbegin</a>()), Functor&gt; &gt;::type hydra::make_reverse_range </td>
          <td>(</td>
          <td class="paramtype">Iterable &amp;&amp;&#160;</td>
          <td class="paramname"><em>iterable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Functor const &amp;&#160;</td>
          <td class="paramname"><em>functor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adaa5d26dd9be08404491e90f3848fc7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adaa5d26dd9be08404491e90f3848fc7d">&#9670;&nbsp;</a></span>make_sparse_histogram() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t N, hydra::detail::Backend BACKEND, typename Iterable &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt;Iterable&gt;::value,<a class="el" href="group__histogram.html#classhydra_1_1SparseHistogram">SparseHistogram</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt;BACKEND&gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1multidimensional">detail::multidimensional</a>&gt; &gt;::type hydra::make_sparse_histogram </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&#160;</td>
          <td class="paramname"><em>backend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; size_t, N &gt;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>lowerlimits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>upperlimits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterable &amp;&amp;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae548b2f803d456afc6b24b44dd78ef4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae548b2f803d456afc6b24b44dd78ef4f">&#9670;&nbsp;</a></span>make_sparse_histogram() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t N, hydra::detail::Backend BACKEND, typename Iterable1 , typename Iterable2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt;Iterable1&gt;::value&amp;&amp;<a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt;Iterable2&gt;::value,<a class="el" href="group__histogram.html#classhydra_1_1SparseHistogram">SparseHistogram</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt;BACKEND&gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1multidimensional">detail::multidimensional</a>&gt; &gt;::type hydra::make_sparse_histogram </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&#160;</td>
          <td class="paramname"><em>backend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; size_t, N &gt;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>lowerlimits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>upperlimits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterable1 &amp;&amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterable2 &amp;&amp;&#160;</td>
          <td class="paramname"><em>weights</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a195ab6db84a5d1df9b9df6a21cce73e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a195ab6db84a5d1df9b9df6a21cce73e5">&#9670;&nbsp;</a></span>make_spiline() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ArgType , typename Iterator1 , typename Iterator2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhydra_1_1SpilineFunctor.html">SpilineFunctor</a>&lt;Iterator1, Iterator2, ArgType&gt; hydra::make_spiline </td>
          <td>(</td>
          <td class="paramtype">Iterator1&#160;</td>
          <td class="paramname"><em>firstX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator1&#160;</td>
          <td class="paramname"><em>lastX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator2&#160;</td>
          <td class="paramname"><em>firstY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae425b2f411e337b0606f465e115aec69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae425b2f411e337b0606f465e115aec69">&#9670;&nbsp;</a></span>make_spiline() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ArgType , typename Iterable1 , typename Iterable2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt;Iterable1&gt;::value &amp;&amp; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt;Iterable2&gt;::value, <a class="el" href="classhydra_1_1SpilineFunctor.html">SpilineFunctor</a>&lt; decltype(std::declval&lt;Iterable1&gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()), decltype(std::declval&lt;Iterable2&gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()), ArgType&gt; &gt;::type hydra::make_spiline </td>
          <td>(</td>
          <td class="paramtype">Iterable1 &amp;&amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterable2 &amp;&amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7f74fb09a286265393fbce752c0c32cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f74fb09a286265393fbce752c0c32cb">&#9670;&nbsp;</a></span>make_splot() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator , typename PDF1 , typename PDF2 , typename ... PDFs&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterator.html">detail::is_iterator</a>&lt;Iterator&gt;::value, <a class="el" href="group__fit.html#classhydra_1_1SPlot">SPlot</a>&lt;Iterator, PDF1, PDF2, PDFs...&gt; &gt;::type hydra::make_splot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__fit.html#classhydra_1_1PDFSumExtendable">PDFSumExtendable</a>&lt; PDF1, PDF2, PDFs... &gt; const &amp;&#160;</td>
          <td class="paramname"><em>pdf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience function for instantiating <a class="el" href="group__fit.html#classhydra_1_1SPlot" title="Implementation of {s}_{Plot} technique for statistical unfolding of sample containing events from dif...">SPlot</a> objects using type deduction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pdf</td><td>PDFSumExtendable&lt;PDF1, PDF2, PDFs...&gt; optimized object </td></tr>
    <tr><td class="paramname">first</td><td>iterator pointing to beginning of the data range. </td></tr>
    <tr><td class="paramname">last</td><td>iterator pointing to end of the data range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="pseudo_experiment_8inl-example.html#a43">pseudo_experiment.inl</a>, and <a class="el" href="splot_8inl-example.html#a41">splot.inl</a>.</dd>
</dl>
</div>
</div>
<a id="ac5ead3609a0334574dba725caebf656b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5ead3609a0334574dba725caebf656b">&#9670;&nbsp;</a></span>make_splot() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterable , typename PDF1 , typename PDF2 , typename ... PDFs&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">detail::is_iterable</a>&lt;Iterable&gt;::value, <a class="el" href="group__fit.html#classhydra_1_1SPlot">SPlot</a>&lt; decltype(std::declval&lt;Iterable&gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()), PDF1, PDF2, PDFs...&gt; &gt;::type hydra::make_splot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__fit.html#classhydra_1_1PDFSumExtendable">PDFSumExtendable</a>&lt; PDF1, PDF2, PDFs... &gt; const &amp;&#160;</td>
          <td class="paramname"><em>pdf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterable &amp;&amp;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience function for instantiating <a class="el" href="group__fit.html#classhydra_1_1SPlot" title="Implementation of {s}_{Plot} technique for statistical unfolding of sample containing events from dif...">SPlot</a> objects using type deduction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pdf</td><td>PDFSumExtendable&lt;PDF1, PDF2, PDFs...&gt; optimized object </td></tr>
    <tr><td class="paramname">data</td><td>iterable representing the data-range </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a1db1d8c170d119e8a99389cf5eb0b5d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1db1d8c170d119e8a99389cf5eb0b5d5">&#9670;&nbsp;</a></span>make_tuple()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> auto hydra::make_tuple </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;...&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td> -&gt; decltype(hydra_thrust::make_tuple( std::forward&lt;T&gt;(t)...))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This version of <code>make_tuple</code> creates a new <code>tuple</code> object from a list of objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">T</td><td>The first object to copy from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>tuple</code> object with members which are copies of <code>t</code>. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="dalitz_plot_8C-example.html#a39">dalitz_plot.C</a>, <a class="el" href="dalitz_plot_8inl-example.html#a44">dalitz_plot.inl</a>, <a class="el" href="multiarray_container_8inl-example.html#a5">multiarray_container.inl</a>, <a class="el" href="multidimensional_fit_8inl-example.html#a56">multidimensional_fit.inl</a>, <a class="el" href="multivector_container_8inl-example.html#a5">multivector_container.inl</a>, <a class="el" href="phsp_basic_8inl-example.html#a20">phsp_basic.inl</a>, <a class="el" href="phsp_chain_8inl-example.html#a16">phsp_chain.inl</a>, <a class="el" href="phsp_reweighting_8inl-example.html#a20">phsp_reweighting.inl</a>, <a class="el" href="phsp_unweighting_8inl-example.html#a20">phsp_unweighting.inl</a>, <a class="el" href="phsp_unweighting_functor_8inl-example.html#a20">phsp_unweighting_functor.inl</a>, and <a class="el" href="pseudo_experiment_8inl-example.html#a46">pseudo_experiment.inl</a>.</dd>
</dl>
</div>
</div>
<a id="a4c4bda231cb9e6f06a12f2740f976009"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c4bda231cb9e6f06a12f2740f976009">&#9670;&nbsp;</a></span>meld()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;hydra::detail::Backend BACKEND, typename ... T, typename ... U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacehydra.html#classhydra_1_1Range">hydra::Range</a>&lt; hydra_thrust::zip_iterator&lt; typename <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1tuple__cat__type">detail::tuple_cat_type</a>&lt;typename <a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt;hydra_thrust::tuple&lt;T...&gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt;BACKEND&gt; &gt;::iterator_tuple,typename <a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt;hydra_thrust::tuple&lt;U...&gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt;BACKEND&gt; &gt;::iterator_tuple&gt;::type&gt; &gt; hydra::meld </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; hydra_thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; hydra_thrust::tuple&lt; U... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2a141f2382a6bd83a2c71c886c5b687d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a141f2382a6bd83a2c71c886c5b687d">&#9670;&nbsp;</a></span>minus()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F1 , typename F2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;(<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt;F1&gt;::value || <a class="el" href="structhydra_1_1detail_1_1is__hydra__lambda.html">detail::is_hydra_lambda</a>&lt;F1&gt;::value) &amp;&amp;(<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt;F2&gt;::value || <a class="el" href="structhydra_1_1detail_1_1is__hydra__lambda.html">detail::is_hydra_lambda</a>&lt;F2&gt;::value),<a class="el" href="classhydra_1_1Minus.html">Minus</a>&lt;F1, F2&gt; &gt;::type hydra::minus </td>
          <td>(</td>
          <td class="paramtype">F1 const &amp;&#160;</td>
          <td class="paramname"><em>f1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F2 const &amp;&#160;</td>
          <td class="paramname"><em>f2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7ecc65021a3e485b3ae047da8bcd1025"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ecc65021a3e485b3ae047da8bcd1025">&#9670;&nbsp;</a></span>multiply()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F1 , typename F2 , typename ... Fs&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;(<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt;F1&gt;::value || <a class="el" href="structhydra_1_1detail_1_1is__hydra__lambda.html">detail::is_hydra_lambda</a>&lt;F1&gt;::value) &amp;&amp;(<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt;F2&gt;::value || <a class="el" href="structhydra_1_1detail_1_1is__hydra__lambda.html">detail::is_hydra_lambda</a>&lt;F2&gt;::value) &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1all__true.html">detail::all_true</a>&lt;(<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt;Fs&gt;::value || <a class="el" href="structhydra_1_1detail_1_1is__hydra__lambda.html">detail::is_hydra_lambda</a>&lt;Fs&gt;::value)...&gt;::value,<a class="el" href="classhydra_1_1Multiply.html">Multiply</a>&lt;F1, F2,Fs...&gt; &gt;::type hydra::multiply </td>
          <td>(</td>
          <td class="paramtype">F1 const &amp;&#160;</td>
          <td class="paramname"><em>f1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F2 const &amp;&#160;</td>
          <td class="paramname"><em>f2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Fs const &amp;...&#160;</td>
          <td class="paramname"><em>functors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2f06ee4cd16c4cd697a380053748bf67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f06ee4cd16c4cd697a380053748bf67">&#9670;&nbsp;</a></span>nint()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespace_3globalScope_4.html#classint">int</a> hydra::nint </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Round to nearest integer. </p>
<p>Rounds half integers to the nearest even integer. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="ab5fd2d8f62c3075ccdd36241e8dc6881"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5fd2d8f62c3075ccdd36241e8dc6881">&#9670;&nbsp;</a></span>norm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> T hydra::norm </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#a9be56668c1da1edd25b29c366adf5df9">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="dalitz_plot_8C-example.html#a33">dalitz_plot.C</a>, and <a class="el" href="dalitz_plot_8inl-example.html#a17">dalitz_plot.inl</a>.</dd>
</dl>
</div>
</div>
<a id="a74f09f60eaa232f756f2e5ee0ccb5326"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74f09f60eaa232f756f2e5ee0ccb5326">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t N1, hydra::detail::Backend BACKEND1, size_t N2, hydra::detail::Backend BACKEND2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool hydra::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__phsp.html#classhydra_1_1Decays">Decays</a>&lt; <a class="el" href="particle__mass_8inl.html#a8106f09b6a7c8282d6f237364a30e5e4">N1</a>, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND1 &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__phsp.html#classhydra_1_1Decays">Decays</a>&lt; <a class="el" href="particle__mass_8inl.html#a5ec56f622b3760c006a55312a610fd3f">N2</a>, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND2 &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a24943c0d2419a40a68f0fb61e0a1b05f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24943c0d2419a40a68f0fb61e0a1b05f">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> bool hydra::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#a9be56668c1da1edd25b29c366adf5df9">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#a9be56668c1da1edd25b29c366adf5df9">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a716c80436ab96c757325cae3cd517960"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a716c80436ab96c757325cae3cd517960">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> bool hydra::operator!= </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#a9be56668c1da1edd25b29c366adf5df9">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a91d952f42e31697e4b457b1a58424cb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91d952f42e31697e4b457b1a58424cb5">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> bool hydra::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#a9be56668c1da1edd25b29c366adf5df9">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa51499fa04d39681eb6244313d32a16c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa51499fa04d39681eb6244313d32a16c">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t N, hydra::detail::Backend BACKEND1, hydra::detail::Backend BACKEND2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool hydra::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#classhydra_1_1multiarray">multiarray</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND1 &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#classhydra_1_1multiarray">multiarray</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND2 &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a66b6224a152f0204d791b66b17502084"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66b6224a152f0204d791b66b17502084">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND1, hydra::detail::Backend BACKEND2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool hydra::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; hydra_thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND1 &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; hydra_thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND2 &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a98f5a5475025bc860510c29908fbe528"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98f5a5475025bc860510c29908fbe528">&#9670;&nbsp;</a></span>operator*() <span class="overload">[1/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;(<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt;T1&gt;::value || <a class="el" href="structhydra_1_1detail_1_1is__hydra__lambda.html">detail::is_hydra_lambda</a>&lt;T1&gt;::value) &amp;&amp;(<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt;T2&gt;::value || <a class="el" href="structhydra_1_1detail_1_1is__hydra__lambda.html">detail::is_hydra_lambda</a>&lt;T2&gt;::value),<a class="el" href="classhydra_1_1Multiply.html">Multiply</a>&lt;T1, T2&gt; &gt;::type hydra::operator* </td>
          <td>(</td>
          <td class="paramtype">T1 const &amp;&#160;</td>
          <td class="paramname"><em>F1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2 const &amp;&#160;</td>
          <td class="paramname"><em>F2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad01febd59c4dfebc87b5d363955d65db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad01febd59c4dfebc87b5d363955d65db">&#9670;&nbsp;</a></span>operator*() <span class="overload">[2/15]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> Vector3R hydra::operator* </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector3R &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab15a6bf3575e9fcd2bf0abdf1bdc36e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab15a6bf3575e9fcd2bf0abdf1bdc36e1">&#9670;&nbsp;</a></span>operator*() <span class="overload">[3/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;(<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt;T&gt;::value || <a class="el" href="structhydra_1_1detail_1_1is__hydra__lambda.html">detail::is_hydra_lambda</a>&lt;T&gt;::value) &amp;&amp;(std::is_arithmetic&lt;U&gt;::value),<a class="el" href="classhydra_1_1Multiply.html">Multiply</a>&lt; <a class="el" href="structhydra_1_1Constant.html">Constant</a>&lt;U&gt;, T&gt; &gt;::type hydra::operator* </td>
          <td>(</td>
          <td class="paramtype">U const&#160;</td>
          <td class="paramname"><em>cte</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>F</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0dce6130507b07eaac142c1815ade3f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dce6130507b07eaac142c1815ade3f2">&#9670;&nbsp;</a></span>operator*() <span class="overload">[4/15]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> Vector3R hydra::operator* </td>
          <td>(</td>
          <td class="paramtype">const Vector3R &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a958bc75ab95451e60e074488e75440ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a958bc75ab95451e60e074488e75440ce">&#9670;&nbsp;</a></span>operator*() <span class="overload">[5/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;(<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt;T&gt;::value || <a class="el" href="structhydra_1_1detail_1_1is__hydra__lambda.html">detail::is_hydra_lambda</a>&lt;T&gt;::value) &amp;&amp;(std::is_arithmetic&lt;U&gt;::value),<a class="el" href="classhydra_1_1Multiply.html">Multiply</a>&lt; <a class="el" href="structhydra_1_1Constant.html">Constant</a>&lt;U&gt;, T&gt; &gt;::type hydra::operator* </td>
          <td>(</td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U&#160;</td>
          <td class="paramname"><em>cte</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afd42c2a636a5bfb4e605ddd9f1ea069a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd42c2a636a5bfb4e605ddd9f1ea069a">&#9670;&nbsp;</a></span>operator*() <span class="overload">[6/15]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> hydra::operator* </td>
          <td>(</td>
          <td class="paramtype">const Vector3R &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector3R &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a70e470e57d62af68149525bd201989e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70e470e57d62af68149525bd201989e5">&#9670;&nbsp;</a></span>operator*() <span class="overload">[7/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;(<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt;T&gt;::value || <a class="el" href="structhydra_1_1detail_1_1is__hydra__lambda.html">detail::is_hydra_lambda</a>&lt;T&gt;::value) &amp;&amp;(std::is_arithmetic&lt;U&gt;::value),<a class="el" href="classhydra_1_1Multiply.html">Multiply</a>&lt; <a class="el" href="structhydra_1_1Constant.html">Constant</a>&lt;<a class="el" href="namespacehydra.html#a9be56668c1da1edd25b29c366adf5df9">hydra::complex</a>&lt;U&gt; &gt;, T&gt; &gt;::type hydra::operator* </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#a9be56668c1da1edd25b29c366adf5df9">hydra::complex</a>&lt; U &gt; const &amp;&#160;</td>
          <td class="paramname"><em>cte</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>F</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1b4568e3cdf69d3cbec10c124850ee2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b4568e3cdf69d3cbec10c124850ee2c">&#9670;&nbsp;</a></span>operator*() <span class="overload">[8/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;(<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt;T&gt;::value || <a class="el" href="structhydra_1_1detail_1_1is__hydra__lambda.html">detail::is_hydra_lambda</a>&lt;T&gt;::value) &amp;&amp;(std::is_arithmetic&lt;U&gt;::value),<a class="el" href="classhydra_1_1Multiply.html">Multiply</a>&lt; <a class="el" href="structhydra_1_1Constant.html">Constant</a>&lt;U&gt;, T&gt; &gt;::type hydra::operator* </td>
          <td>(</td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#a9be56668c1da1edd25b29c366adf5df9">hydra::complex</a>&lt; U &gt; const &amp;&#160;</td>
          <td class="paramname"><em>cte</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae5bae5caa4d9b5c0190220e55f650859"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5bae5caa4d9b5c0190220e55f650859">&#9670;&nbsp;</a></span>operator*() <span class="overload">[9/15]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> Vector4R hydra::operator* </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector4R &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae2b0be1f22ac4914bd6ce0bc97411bff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2b0be1f22ac4914bd6ce0bc97411bff">&#9670;&nbsp;</a></span>operator*() <span class="overload">[10/15]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> Vector4R hydra::operator* </td>
          <td>(</td>
          <td class="paramtype">const Vector4R &amp;&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="adb096b020e55914fe7a1e885dd66b17e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb096b020e55914fe7a1e885dd66b17e">&#9670;&nbsp;</a></span>operator*() <span class="overload">[11/15]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> hydra::operator* </td>
          <td>(</td>
          <td class="paramtype">const Vector4R &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector4R &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a89ff58cb476f9a4107bd46f1bc08ff86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89ff58cb476f9a4107bd46f1bc08ff86">&#9670;&nbsp;</a></span>operator*() <span class="overload">[12/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::tuple&lt;T...&gt; hydra::operator* </td>
          <td>(</td>
          <td class="paramtype">const hydra_thrust::tuple&lt; T... &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const hydra_thrust::tuple&lt; T... &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0b98f3604eca3a6023551cd4ce98020a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b98f3604eca3a6023551cd4ce98020a">&#9670;&nbsp;</a></span>operator*() <span class="overload">[13/15]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a> hydra::operator* </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a>&#160;</td>
          <td class="paramname"><em>par1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a> const &amp;&#160;</td>
          <td class="paramname"><em>par2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac480ecaec81a0040f3b466ca5904ed5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac480ecaec81a0040f3b466ca5904ed5b">&#9670;&nbsp;</a></span>operator*() <span class="overload">[14/15]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> hydra::operator* </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a>&#160;</td>
          <td class="paramname"><em>par1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>&#160;</td>
          <td class="paramname"><em>par2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa0bc15a0070c95cad2a9b6e300b430cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0bc15a0070c95cad2a9b6e300b430cc">&#9670;&nbsp;</a></span>operator*() <span class="overload">[15/15]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> hydra::operator* </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>&#160;</td>
          <td class="paramname"><em>par1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a> const &amp;&#160;</td>
          <td class="paramname"><em>par2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7fafa9d71a3cc46ef785a70374501c78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fafa9d71a3cc46ef785a70374501c78">&#9670;&nbsp;</a></span>operator+() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;(<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt;T1&gt;::value || <a class="el" href="structhydra_1_1detail_1_1is__hydra__lambda.html">detail::is_hydra_lambda</a>&lt;T1&gt;::value) &amp;&amp;(<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt;T2&gt;::value || <a class="el" href="structhydra_1_1detail_1_1is__hydra__lambda.html">detail::is_hydra_lambda</a>&lt;T2&gt;::value),<a class="el" href="classhydra_1_1Sum.html">Sum</a>&lt;T1, T2&gt; &gt;::type hydra::operator+ </td>
          <td>(</td>
          <td class="paramtype">T1 const &amp;&#160;</td>
          <td class="paramname"><em>F1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2 const &amp;&#160;</td>
          <td class="paramname"><em>F2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4060305f83c9118349c59ab1b5331866"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4060305f83c9118349c59ab1b5331866">&#9670;&nbsp;</a></span>operator+() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;(<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt;T&gt;::value || <a class="el" href="structhydra_1_1detail_1_1is__hydra__lambda.html">detail::is_hydra_lambda</a>&lt;T&gt;::value) &amp;&amp;(std::is_arithmetic&lt;U&gt;::value),<a class="el" href="classhydra_1_1Sum.html">Sum</a>&lt; <a class="el" href="structhydra_1_1Constant.html">Constant</a>&lt;U&gt;, T&gt; &gt;::type hydra::operator+ </td>
          <td>(</td>
          <td class="paramtype">U const&#160;</td>
          <td class="paramname"><em>cte</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>F</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3a2b546f3d37d1310cd805b5768be9cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a2b546f3d37d1310cd805b5768be9cc">&#9670;&nbsp;</a></span>operator+() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;(<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt;T&gt;::value || <a class="el" href="structhydra_1_1detail_1_1is__hydra__lambda.html">detail::is_hydra_lambda</a>&lt;T&gt;::value) &amp;&amp;(std::is_arithmetic&lt;U&gt;::value),<a class="el" href="classhydra_1_1Sum.html">Sum</a>&lt; <a class="el" href="structhydra_1_1Constant.html">Constant</a>&lt;U&gt;, T&gt; &gt;::type hydra::operator+ </td>
          <td>(</td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U&#160;</td>
          <td class="paramname"><em>cte</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab5257853509f5e7d4ca8b4d68b96b2d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5257853509f5e7d4ca8b4d68b96b2d6">&#9670;&nbsp;</a></span>operator+() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;(<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt;T&gt;::value || <a class="el" href="structhydra_1_1detail_1_1is__hydra__lambda.html">detail::is_hydra_lambda</a>&lt;T&gt;::value) &amp;&amp;(std::is_arithmetic&lt;U&gt;::value),<a class="el" href="classhydra_1_1Sum.html">Sum</a>&lt; <a class="el" href="structhydra_1_1Constant.html">Constant</a>&lt;<a class="el" href="namespacehydra.html#a9be56668c1da1edd25b29c366adf5df9">hydra::complex</a>&lt;U&gt; &gt;, T&gt; &gt;::type hydra::operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#a9be56668c1da1edd25b29c366adf5df9">hydra::complex</a>&lt; U &gt; const &amp;&#160;</td>
          <td class="paramname"><em>cte</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>F</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1c1fc13eb2a4a440f72991b4347a472c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c1fc13eb2a4a440f72991b4347a472c">&#9670;&nbsp;</a></span>operator+() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> Vector3R hydra::operator+ </td>
          <td>(</td>
          <td class="paramtype">const Vector3R &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector3R &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a07ce25e2c0bd0be95076f18159a925d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07ce25e2c0bd0be95076f18159a925d2">&#9670;&nbsp;</a></span>operator+() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;(<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt;T&gt;::value || <a class="el" href="structhydra_1_1detail_1_1is__hydra__lambda.html">detail::is_hydra_lambda</a>&lt;T&gt;::value) &amp;&amp;(std::is_arithmetic&lt;U&gt;::value),<a class="el" href="classhydra_1_1Sum.html">Sum</a>&lt; <a class="el" href="structhydra_1_1Constant.html">Constant</a>&lt;U&gt;, T&gt; &gt;::type hydra::operator+ </td>
          <td>(</td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#a9be56668c1da1edd25b29c366adf5df9">hydra::complex</a>&lt; U &gt; const &amp;&#160;</td>
          <td class="paramname"><em>cte</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac0bd5fcb530c7e864cfe16f05d4493a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0bd5fcb530c7e864cfe16f05d4493a2">&#9670;&nbsp;</a></span>operator+() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::tuple&lt;T...&gt; hydra::operator+ </td>
          <td>(</td>
          <td class="paramtype">const hydra_thrust::tuple&lt; T... &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const hydra_thrust::tuple&lt; T... &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af68a4c9bed0e1a2cf2ed9ba9ab057dd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af68a4c9bed0e1a2cf2ed9ba9ab057dd0">&#9670;&nbsp;</a></span>operator+() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> Vector4R hydra::operator+ </td>
          <td>(</td>
          <td class="paramtype">const Vector4R &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector4R &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a26e3492eb046c39e1b578738cd5ad7b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26e3492eb046c39e1b578738cd5ad7b7">&#9670;&nbsp;</a></span>operator+() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a> hydra::operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a>&#160;</td>
          <td class="paramname"><em>par1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a> const &amp;&#160;</td>
          <td class="paramname"><em>par2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a357a28a5ec78cd838e8e90face792425"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a357a28a5ec78cd838e8e90face792425">&#9670;&nbsp;</a></span>operator+() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> hydra::operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a>&#160;</td>
          <td class="paramname"><em>par1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>&#160;</td>
          <td class="paramname"><em>par2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a84fc9a23e35641ee933be028786d852b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84fc9a23e35641ee933be028786d852b">&#9670;&nbsp;</a></span>operator-() <span class="overload">[1/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;(<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt;T1&gt;::value || <a class="el" href="structhydra_1_1detail_1_1is__hydra__lambda.html">detail::is_hydra_lambda</a>&lt;T1&gt;::value) &amp;&amp;(<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt;T2&gt;::value || <a class="el" href="structhydra_1_1detail_1_1is__hydra__lambda.html">detail::is_hydra_lambda</a>&lt;T2&gt;::value),<a class="el" href="classhydra_1_1Minus.html">Minus</a>&lt;T1, T2&gt; &gt;::type hydra::operator- </td>
          <td>(</td>
          <td class="paramtype">T1 const &amp;&#160;</td>
          <td class="paramname"><em>F1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2 const &amp;&#160;</td>
          <td class="paramname"><em>F2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a18c2c67f2fe010ee6acf64c05ed2b94a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18c2c67f2fe010ee6acf64c05ed2b94a">&#9670;&nbsp;</a></span>operator-() <span class="overload">[2/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;(<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt;T&gt;::value || <a class="el" href="structhydra_1_1detail_1_1is__hydra__lambda.html">detail::is_hydra_lambda</a>&lt;T&gt;::value) &amp;&amp;(std::is_arithmetic&lt;U&gt;::value),<a class="el" href="classhydra_1_1Minus.html">Minus</a>&lt; <a class="el" href="structhydra_1_1Constant.html">Constant</a>&lt;U&gt;, T&gt; &gt;::type hydra::operator- </td>
          <td>(</td>
          <td class="paramtype">U const&#160;</td>
          <td class="paramname"><em>cte</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>F</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a738a108d0225cb4655d273940b647d00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a738a108d0225cb4655d273940b647d00">&#9670;&nbsp;</a></span>operator-() <span class="overload">[3/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;(<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt;T&gt;::value || <a class="el" href="structhydra_1_1detail_1_1is__hydra__lambda.html">detail::is_hydra_lambda</a>&lt;T&gt;::value) &amp;&amp;(std::is_arithmetic&lt;U&gt;::value),<a class="el" href="classhydra_1_1Minus.html">Minus</a>&lt; <a class="el" href="structhydra_1_1Constant.html">Constant</a>&lt;U&gt;, T&gt; &gt;::type hydra::operator- </td>
          <td>(</td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U&#160;</td>
          <td class="paramname"><em>cte</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abe35592654935c44c6d5b47196bd054a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe35592654935c44c6d5b47196bd054a">&#9670;&nbsp;</a></span>operator-() <span class="overload">[4/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;(<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt;T&gt;::value || <a class="el" href="structhydra_1_1detail_1_1is__hydra__lambda.html">detail::is_hydra_lambda</a>&lt;T&gt;::value) &amp;&amp;(std::is_arithmetic&lt;U&gt;::value),<a class="el" href="classhydra_1_1Minus.html">Minus</a>&lt; <a class="el" href="structhydra_1_1Constant.html">Constant</a>&lt;<a class="el" href="namespacehydra.html#a9be56668c1da1edd25b29c366adf5df9">hydra::complex</a>&lt;U&gt; &gt;, T&gt; &gt;::type hydra::operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#a9be56668c1da1edd25b29c366adf5df9">hydra::complex</a>&lt; U &gt; const &amp;&#160;</td>
          <td class="paramname"><em>cte</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>F</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0f90d5023b833839c5f9c184ae7275dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f90d5023b833839c5f9c184ae7275dd">&#9670;&nbsp;</a></span>operator-() <span class="overload">[5/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;(<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt;T&gt;::value || <a class="el" href="structhydra_1_1detail_1_1is__hydra__lambda.html">detail::is_hydra_lambda</a>&lt;T&gt;::value) &amp;&amp;(std::is_arithmetic&lt;U&gt;::value),<a class="el" href="classhydra_1_1Minus.html">Minus</a>&lt; <a class="el" href="structhydra_1_1Constant.html">Constant</a>&lt;U&gt;, T&gt; &gt;::type hydra::operator- </td>
          <td>(</td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#a9be56668c1da1edd25b29c366adf5df9">hydra::complex</a>&lt; U &gt; const &amp;&#160;</td>
          <td class="paramname"><em>cte</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1113b35a5588af8a55453fbd5e1b2651"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1113b35a5588af8a55453fbd5e1b2651">&#9670;&nbsp;</a></span>operator-() <span class="overload">[6/11]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> Vector3R hydra::operator- </td>
          <td>(</td>
          <td class="paramtype">const Vector3R &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector3R &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a826a3a94946d3c2c5a3f34ca8a74999b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a826a3a94946d3c2c5a3f34ca8a74999b">&#9670;&nbsp;</a></span>operator-() <span class="overload">[7/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::tuple&lt;T...&gt; hydra::operator- </td>
          <td>(</td>
          <td class="paramtype">const hydra_thrust::tuple&lt; T... &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const hydra_thrust::tuple&lt; T... &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a950f2d5dc4356f6c6c13b9fc3bc7c0ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a950f2d5dc4356f6c6c13b9fc3bc7c0ef">&#9670;&nbsp;</a></span>operator-() <span class="overload">[8/11]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> Vector4R hydra::operator- </td>
          <td>(</td>
          <td class="paramtype">const Vector4R &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector4R &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a68375d62444cb2341ade99f0ac15972f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68375d62444cb2341ade99f0ac15972f">&#9670;&nbsp;</a></span>operator-() <span class="overload">[9/11]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a> hydra::operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a>&#160;</td>
          <td class="paramname"><em>par1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a> const &amp;&#160;</td>
          <td class="paramname"><em>par2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a07c46e4c59a5208f5d495b4ddaf3af75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07c46e4c59a5208f5d495b4ddaf3af75">&#9670;&nbsp;</a></span>operator-() <span class="overload">[10/11]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> hydra::operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a>&#160;</td>
          <td class="paramname"><em>par1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>&#160;</td>
          <td class="paramname"><em>par2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a247f457807559c67d34c5b9d15c0b4b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a247f457807559c67d34c5b9d15c0b4b4">&#9670;&nbsp;</a></span>operator-() <span class="overload">[11/11]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> hydra::operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>&#160;</td>
          <td class="paramname"><em>par1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a>&#160;</td>
          <td class="paramname"><em>par2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa3b16aaa8206238e19f573a8b0f07730"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3b16aaa8206238e19f573a8b0f07730">&#9670;&nbsp;</a></span>operator/() <span class="overload">[1/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;(<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt;T1&gt;::value || <a class="el" href="structhydra_1_1detail_1_1is__hydra__lambda.html">detail::is_hydra_lambda</a>&lt;T1&gt;::value) &amp;&amp;(<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt;T2&gt;::value || <a class="el" href="structhydra_1_1detail_1_1is__hydra__lambda.html">detail::is_hydra_lambda</a>&lt;T2&gt;::value),<a class="el" href="classhydra_1_1Divide.html">Divide</a>&lt;T1, T2&gt; &gt;::type hydra::operator/ </td>
          <td>(</td>
          <td class="paramtype">T1 const &amp;&#160;</td>
          <td class="paramname"><em>F1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2 const &amp;&#160;</td>
          <td class="paramname"><em>F2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab01044c5657e79152458266153d361e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab01044c5657e79152458266153d361e3">&#9670;&nbsp;</a></span>operator/() <span class="overload">[2/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;(<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt;T&gt;::value || <a class="el" href="structhydra_1_1detail_1_1is__hydra__lambda.html">detail::is_hydra_lambda</a>&lt;T&gt;::value) &amp;&amp;(std::is_arithmetic&lt;U&gt;::value),<a class="el" href="classhydra_1_1Divide.html">Divide</a>&lt; <a class="el" href="structhydra_1_1Constant.html">Constant</a>&lt;U&gt;, T&gt; &gt;::type hydra::operator/ </td>
          <td>(</td>
          <td class="paramtype">U const&#160;</td>
          <td class="paramname"><em>cte</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>F</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a975b2511acddbdf4f7c4442f266440c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a975b2511acddbdf4f7c4442f266440c0">&#9670;&nbsp;</a></span>operator/() <span class="overload">[3/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;(<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt;T&gt;::value || <a class="el" href="structhydra_1_1detail_1_1is__hydra__lambda.html">detail::is_hydra_lambda</a>&lt;T&gt;::value) &amp;&amp;(std::is_arithmetic&lt;U&gt;::value),<a class="el" href="classhydra_1_1Divide.html">Divide</a>&lt; <a class="el" href="structhydra_1_1Constant.html">Constant</a>&lt;U&gt;, T&gt; &gt;::type hydra::operator/ </td>
          <td>(</td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U&#160;</td>
          <td class="paramname"><em>cte</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae608d7550080817bb9932341d1c10b1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae608d7550080817bb9932341d1c10b1f">&#9670;&nbsp;</a></span>operator/() <span class="overload">[4/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;(<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt;T&gt;::value || <a class="el" href="structhydra_1_1detail_1_1is__hydra__lambda.html">detail::is_hydra_lambda</a>&lt;T&gt;::value) &amp;&amp;(std::is_arithmetic&lt;U&gt;::value),<a class="el" href="classhydra_1_1Divide.html">Divide</a>&lt; <a class="el" href="structhydra_1_1Constant.html">Constant</a>&lt;<a class="el" href="namespacehydra.html#a9be56668c1da1edd25b29c366adf5df9">hydra::complex</a>&lt;U&gt; &gt;, T&gt; &gt;::type hydra::operator/ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#a9be56668c1da1edd25b29c366adf5df9">hydra::complex</a>&lt; U &gt; const &amp;&#160;</td>
          <td class="paramname"><em>cte</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>F</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a94cb4a79113148abd78aa8e4d6f7e41d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94cb4a79113148abd78aa8e4d6f7e41d">&#9670;&nbsp;</a></span>operator/() <span class="overload">[5/11]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> Vector3R hydra::operator/ </td>
          <td>(</td>
          <td class="paramtype">const Vector3R &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2f776567931eb9c539a7de28fe03a4c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f776567931eb9c539a7de28fe03a4c3">&#9670;&nbsp;</a></span>operator/() <span class="overload">[6/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;(<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt;T&gt;::value || <a class="el" href="structhydra_1_1detail_1_1is__hydra__lambda.html">detail::is_hydra_lambda</a>&lt;T&gt;::value) &amp;&amp;(std::is_arithmetic&lt;U&gt;::value),<a class="el" href="classhydra_1_1Divide.html">Divide</a>&lt; <a class="el" href="structhydra_1_1Constant.html">Constant</a>&lt;<a class="el" href="namespacehydra.html#a9be56668c1da1edd25b29c366adf5df9">hydra::complex</a>&lt;U&gt; &gt;, T&gt; &gt;::type hydra::operator/ </td>
          <td>(</td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#a9be56668c1da1edd25b29c366adf5df9">hydra::complex</a>&lt; U &gt; const &amp;&#160;</td>
          <td class="paramname"><em>cte</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4db4d6d0e3fe03dccf661b7ac0751fe7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4db4d6d0e3fe03dccf661b7ac0751fe7">&#9670;&nbsp;</a></span>operator/() <span class="overload">[7/11]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> Vector4R hydra::operator/ </td>
          <td>(</td>
          <td class="paramtype">const Vector4R &amp;&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9619c9f5a4ec3ce73574e1ce8f25708f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9619c9f5a4ec3ce73574e1ce8f25708f">&#9670;&nbsp;</a></span>operator/() <span class="overload">[8/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra_thrust::tuple&lt;T...&gt; hydra::operator/ </td>
          <td>(</td>
          <td class="paramtype">const hydra_thrust::tuple&lt; T... &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const hydra_thrust::tuple&lt; T... &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac9b1664e58d41d5f8e7ec6d1c20bf9c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9b1664e58d41d5f8e7ec6d1c20bf9c0">&#9670;&nbsp;</a></span>operator/() <span class="overload">[9/11]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a> hydra::operator/ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a>&#160;</td>
          <td class="paramname"><em>par1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a> const&#160;</td>
          <td class="paramname"><em>par2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0a4133d480d7e9f3f5e85286e47a3709"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a4133d480d7e9f3f5e85286e47a3709">&#9670;&nbsp;</a></span>operator/() <span class="overload">[10/11]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> hydra::operator/ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a>&#160;</td>
          <td class="paramname"><em>par1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>&#160;</td>
          <td class="paramname"><em>par2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af29cde1e70c62bec6f1fa1ee52940887"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af29cde1e70c62bec6f1fa1ee52940887">&#9670;&nbsp;</a></span>operator/() <span class="overload">[11/11]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a> hydra::operator/ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>&#160;</td>
          <td class="paramname"><em>par1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a>&#160;</td>
          <td class="paramname"><em>par2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a15cdb083719133399edb77f5ef3eb547"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15cdb083719133399edb77f5ef3eb547">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t N, typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; hydra::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; T, N &gt; const &amp;&#160;</td>
          <td class="paramname"><em>obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6fab8d226ee701c0755c60202fc30f6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fab8d226ee701c0755c60202fc30f6c">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; hydra::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::tuple&lt; T... &gt; const &amp;&#160;</td>
          <td class="paramname"><em>obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad4d7f13d811f0d63d4ce49d31b6cfbe0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4d7f13d811f0d63d4ce49d31b6cfbe0">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; hydra::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::pair&lt; T1, T2 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3fa8037907332bf633dfc1bc3b40865c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fa8037907332bf633dfc1bc3b40865c">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ostream&amp; hydra::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector3R &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aaacce78528c9499de97312cbe606ece4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaacce78528c9499de97312cbe606ece4">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ostream&amp; hydra::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector4R &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad3be8e63c60c604b927f9638600a598b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3be8e63c60c604b927f9638600a598b">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; hydra::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__fit.html#classhydra_1_1UserParameters">UserParameters</a> const &amp;&#160;</td>
          <td class="paramname"><em>par</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classhydra_1_1Print.html">Print</a> the ROOT::Minuit2 state to stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>std::ostream </td></tr>
    <tr><td class="paramname">par</td><td><a class="el" href="group__fit.html#classhydra_1_1UserParameters" title="Class implementing a interface to ROOT::Minuit2::MnUserParameters. ">hydra::UserParameters</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a21d7262b80d73f956ed1a477607b9053"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21d7262b80d73f956ed1a477607b9053">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , class charT , class traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::basic_ostream&lt; charT,traits &gt;&amp; hydra::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::basic_ostream&lt; charT, traits &gt; &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#a9be56668c1da1edd25b29c366adf5df9">complex</a>&lt; ValueType &gt; &amp;&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adb57654e359a17e312e9aef986f956a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb57654e359a17e312e9aef986f956a8">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; hydra::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__fit.html#structhydra_1_1Parameter">Parameter</a> const &amp;&#160;</td>
          <td class="paramname"><em>var</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aebc9da09d22eae43ed970a123baa27f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebc9da09d22eae43ed970a123baa27f1">&#9670;&nbsp;</a></span>operator==() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t N1, hydra::detail::Backend BACKEND1, size_t N2, hydra::detail::Backend BACKEND2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool hydra::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__phsp.html#classhydra_1_1Decays">Decays</a>&lt; <a class="el" href="particle__mass_8inl.html#a8106f09b6a7c8282d6f237364a30e5e4">N1</a>, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND1 &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__phsp.html#classhydra_1_1Decays">Decays</a>&lt; <a class="el" href="particle__mass_8inl.html#a5ec56f622b3760c006a55312a610fd3f">N2</a>, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND2 &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aea70aec01321527f54717a004a3df99d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea70aec01321527f54717a004a3df99d">&#9670;&nbsp;</a></span>operator==() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> bool hydra::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#a9be56668c1da1edd25b29c366adf5df9">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#a9be56668c1da1edd25b29c366adf5df9">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a227370a3dddcea864f09490bc65b93ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a227370a3dddcea864f09490bc65b93ad">&#9670;&nbsp;</a></span>operator==() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> bool hydra::operator== </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#a9be56668c1da1edd25b29c366adf5df9">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a99bf5390aa3ab39e8ac0cd109ef6b7c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99bf5390aa3ab39e8ac0cd109ef6b7c9">&#9670;&nbsp;</a></span>operator==() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> bool hydra::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#a9be56668c1da1edd25b29c366adf5df9">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab3bafbf7fa6e97bc40b02d74d7d596ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3bafbf7fa6e97bc40b02d74d7d596ea">&#9670;&nbsp;</a></span>operator==() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t N, hydra::detail::Backend BACKEND1, hydra::detail::Backend BACKEND2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool hydra::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#classhydra_1_1multiarray">multiarray</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND1 &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#classhydra_1_1multiarray">multiarray</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND2 &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4bebd511416d4c9347e3b76fb8be4ee8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bebd511416d4c9347e3b76fb8be4ee8">&#9670;&nbsp;</a></span>operator==() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T, hydra::detail::Backend BACKEND1, hydra::detail::Backend BACKEND2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool hydra::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; hydra_thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND1 &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; hydra_thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND2 &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a63ad8f84031200c3161c889507d3a9c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63ad8f84031200c3161c889507d3a9c0">&#9670;&nbsp;</a></span>operator&gt;&gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename charT , class traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::basic_istream&lt; charT,traits &gt;&amp; hydra::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::basic_istream&lt; charT, traits &gt; &amp;&#160;</td>
          <td class="paramname"><em>is</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#a9be56668c1da1edd25b29c366adf5df9">complex</a>&lt; ValueType &gt; &amp;&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a55811c5f0a84a83d2d43473fb464eb4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55811c5f0a84a83d2d43473fb464eb4b">&#9670;&nbsp;</a></span>operator|() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterable , typename Functor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">hydra_thrust::detail::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">detail::is_iterable</a>&lt;Iterable&gt;::value &amp;&amp; ( <a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt;Functor&gt;::value || <a class="el" href="structhydra_1_1detail_1_1is__hydra__lambda.html">detail::is_hydra_lambda</a>&lt;Functor&gt;::value ) , <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt;decltype(std::declval&lt; const Iterable&gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()), Functor&gt; &gt;::type hydra::operator| </td>
          <td>(</td>
          <td class="paramtype">Iterable const &amp;&#160;</td>
          <td class="paramname"><em>iterable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Functor const &amp;&#160;</td>
          <td class="paramname"><em>functor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6c6bbe00afd80cfb16f208f98defdc1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c6bbe00afd80cfb16f208f98defdc1a">&#9670;&nbsp;</a></span>operator|() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterable , typename Functor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">hydra_thrust::detail::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">detail::is_iterable</a>&lt;Iterable&gt;::value &amp;&amp; (<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt;Functor&gt;::value || <a class="el" href="structhydra_1_1detail_1_1is__hydra__lambda.html">detail::is_hydra_lambda</a>&lt;Functor&gt;::value ), <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt;decltype(std::declval&lt;Iterable&gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()), Functor&gt; &gt;::type hydra::operator| </td>
          <td>(</td>
          <td class="paramtype">Iterable &amp;&amp;&#160;</td>
          <td class="paramname"><em>iterable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Functor const &amp;&#160;</td>
          <td class="paramname"><em>functor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a48b523e6ba2de8e88d706f7bad439e00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48b523e6ba2de8e88d706f7bad439e00">&#9670;&nbsp;</a></span>phase_space_range()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt;hydra_thrust::transform_iterator&lt; <a class="el" href="structhydra_1_1detail_1_1GenerateDecay.html">detail::GenerateDecay</a>&lt;N,hydra_thrust::random::default_random_engine&gt;, hydra_thrust::counting_iterator&lt;size_t&gt;, typename <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1tuple__cat__type">hydra::detail::tuple_cat_type</a>&lt; hydra_thrust::tuple&lt;<a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&gt;, typename <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1tuple__type">hydra::detail::tuple_type</a>&lt;N,Vector4R&gt;::type&gt;::type&gt; &gt; hydra::phase_space_range </td>
          <td>(</td>
          <td class="paramtype">Vector4R const &amp;&#160;</td>
          <td class="paramname"><em>mother</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>, N &gt;&#160;</td>
          <td class="paramname"><em>masses</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="range_semantics_8inl-example.html#a21">range_semantics.inl</a>.</dd>
</dl>
</div>
</div>
<a id="ae85d86e6980bcf24de91a003711b3224"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae85d86e6980bcf24de91a003711b3224">&#9670;&nbsp;</a></span>pmf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> hydra::pmf </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td>
          <td class="paramname"><em>mother_mass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td>
          <td class="paramname"><em>daughter1_mass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td>
          <td class="paramname"><em>daughter2_mass</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Momentum in mother frame of daughter particle in two-body-decay. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mother_mass</td><td></td></tr>
    <tr><td class="paramname">daughter1_mass</td><td></td></tr>
    <tr><td class="paramname">daughter2_mass</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="ae3cc52fabc8882be13d9a6ca92fc648e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3cc52fabc8882be13d9a6ca92fc648e">&#9670;&nbsp;</a></span>polar()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespacehydra.html#a9be56668c1da1edd25b29c366adf5df9">complex</a>&lt;T&gt; hydra::polar </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>theta</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a95aad7e7e244a3cb3c71a4d57e695511"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95aad7e7e244a3cb3c71a4d57e695511">&#9670;&nbsp;</a></span>pow() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , unsigned int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> T hydra::pow </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Power with integer exponent. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="ac2256bff965f5a7359591579a97114ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2256bff965f5a7359591579a97114ec">&#9670;&nbsp;</a></span>pow() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespacehydra.html#a9be56668c1da1edd25b29c366adf5df9">complex</a>&lt;T&gt; hydra::pow </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#a9be56668c1da1edd25b29c366adf5df9">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#a9be56668c1da1edd25b29c366adf5df9">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="dalitz_plot_8C-example.html#a40">dalitz_plot.C</a>, <a class="el" href="dalitz_plot_8inl-example.html#a45">dalitz_plot.inl</a>, <a class="el" href="gaussian_plus_argus_8inl-example.html#a33">gaussian_plus_argus.inl</a>, <a class="el" href="phsp_basic_8inl-example.html#a12">phsp_basic.inl</a>, <a class="el" href="phsp_chain_8inl-example.html#a10">phsp_chain.inl</a>, <a class="el" href="phsp_reweighting_8inl-example.html#a12">phsp_reweighting.inl</a>, <a class="el" href="phsp_unweighting_8inl-example.html#a12">phsp_unweighting.inl</a>, and <a class="el" href="phsp_unweighting_functor_8inl-example.html#a12">phsp_unweighting_functor.inl</a>.</dd>
</dl>
</div>
</div>
<a id="a4cf806d100f53f6d281b8b826697e10f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cf806d100f53f6d281b8b826697e10f">&#9670;&nbsp;</a></span>pow() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespacehydra.html#a9be56668c1da1edd25b29c366adf5df9">complex</a>&lt;T&gt; hydra::pow </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#a9be56668c1da1edd25b29c366adf5df9">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2e9146d77dfa5b6c0fcbcb31557f6854"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e9146d77dfa5b6c0fcbcb31557f6854">&#9670;&nbsp;</a></span>pow() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespacehydra.html#a9be56668c1da1edd25b29c366adf5df9">complex</a>&lt;T&gt; hydra::pow </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#a9be56668c1da1edd25b29c366adf5df9">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aece82a0891f743f40547b399caad49ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aece82a0891f743f40547b399caad49ec">&#9670;&nbsp;</a></span>pow() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespacehydra.html#a9be56668c1da1edd25b29c366adf5df9">complex</a>&lt; typename hydra_thrust::detail::promoted_numerical_type&lt; T, U &gt;::type &gt; hydra::pow </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#a9be56668c1da1edd25b29c366adf5df9">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#a9be56668c1da1edd25b29c366adf5df9">complex</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6f50462bdedcc2c5965cbff78acb0bf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f50462bdedcc2c5965cbff78acb0bf3">&#9670;&nbsp;</a></span>pow() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespacehydra.html#a9be56668c1da1edd25b29c366adf5df9">complex</a>&lt; typename hydra_thrust::detail::promoted_numerical_type&lt; T, U &gt;::type &gt; hydra::pow </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#a9be56668c1da1edd25b29c366adf5df9">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aeac8e091577c3ede26c1c26123c07621"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeac8e091577c3ede26c1c26123c07621">&#9670;&nbsp;</a></span>pow() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespacehydra.html#a9be56668c1da1edd25b29c366adf5df9">complex</a>&lt; typename hydra_thrust::detail::promoted_numerical_type&lt; T, U &gt;::type &gt; hydra::pow </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#a9be56668c1da1edd25b29c366adf5df9">complex</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acb0c9817024c69efe44c2d9653928519"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb0c9817024c69efe44c2d9653928519">&#9670;&nbsp;</a></span>PrintToStream()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void hydra::PrintToStream </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>ostream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ace0454750e3561d390ee18b96824227c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace0454750e3561d390ee18b96824227c">&#9670;&nbsp;</a></span>proj()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespacehydra.html#a9be56668c1da1edd25b29c366adf5df9">complex</a>&lt;T&gt; hydra::proj </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5eaf1e3a145e0b3333e752ec877c4a96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5eaf1e3a145e0b3333e752ec877c4a96">&#9670;&nbsp;</a></span>random_exp_range()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt;hydra_thrust::transform_iterator&lt;<a class="el" href="structhydra_1_1detail_1_1RndExp.html">detail::RndExp</a>&lt;Value_Type, hydra_thrust::random::default_random_engine&gt; ,hydra_thrust::counting_iterator&lt;size_t&gt;, <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&gt; &gt; hydra::random_exp_range </td>
          <td>(</td>
          <td class="paramtype">const Value_Type &amp;&#160;</td>
          <td class="paramname"><em>tau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a20f37e84460e63d91583c2a08a6fe937"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20f37e84460e63d91583c2a08a6fe937">&#9670;&nbsp;</a></span>random_gauss_range()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt;hydra_thrust::transform_iterator&lt;<a class="el" href="structhydra_1_1detail_1_1RndGauss.html">detail::RndGauss</a>&lt;Value_Type, hydra_thrust::random::default_random_engine&gt; ,hydra_thrust::counting_iterator&lt;size_t&gt;, Value_Type&gt; &gt; hydra::random_gauss_range </td>
          <td>(</td>
          <td class="paramtype">Value_Type&#160;</td>
          <td class="paramname"><em>mean</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Value_Type&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="basic_fit_8inl-example.html#a19">basic_fit.inl</a>, and <a class="el" href="simultaneous_fit_8inl-example.html#a19">simultaneous_fit.inl</a>.</dd>
</dl>
</div>
</div>
<a id="a17d0eafddb7421defa88d26db3605077"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17d0eafddb7421defa88d26db3605077">&#9670;&nbsp;</a></span>random_uniform_range()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt;hydra_thrust::transform_iterator&lt;<a class="el" href="structhydra_1_1detail_1_1RndUniform.html">detail::RndUniform</a>&lt;Value_Type, hydra_thrust::random::default_random_engine&gt; ,hydra_thrust::counting_iterator&lt;size_t&gt;, Value_Type&gt; &gt; hydra::random_uniform_range </td>
          <td>(</td>
          <td class="paramtype">const Value_Type &amp;&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Value_Type &amp;&#160;</td>
          <td class="paramname"><em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="range_semantics_8inl-example.html#a11">range_semantics.inl</a>.</dd>
</dl>
</div>
</div>
<a id="a5bcce8141d53ae8f8dafe05ff48eba90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bcce8141d53ae8f8dafe05ff48eba90">&#9670;&nbsp;</a></span>range() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt;hydra_thrust::counting_iterator&lt;long <a class="el" href="namespace_3globalScope_4.html#classint">int</a>&gt; &gt; hydra::range </td>
          <td>(</td>
          <td class="paramtype">long <a class="el" href="namespace_3globalScope_4.html#classint">int</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long <a class="el" href="namespace_3globalScope_4.html#classint">int</a>&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="booststrapping_8inl-example.html#a4">booststrapping.inl</a>, <a class="el" href="dense_histogram_8inl-example.html#a14">dense_histogram.inl</a>, and <a class="el" href="fit_convoluted_pdfs_8inl-example.html#a38">fit_convoluted_pdfs.inl</a>.</dd>
</dl>
</div>
</div>
<a id="ae4aeda609504b066b04129ac175bc52f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4aeda609504b066b04129ac175bc52f">&#9670;&nbsp;</a></span>range() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_floating_point&lt;T&gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt;hydra_thrust::counting_iterator&lt;<a class="el" href="namespace_3globalScope_4.html#classunsigned">unsigned</a>&gt;, <a class="el" href="structhydra_1_1detail_1_1range_1_1Shift.html">detail::range::Shift</a>&lt;T&gt; &gt; &gt;::type hydra::range </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_3globalScope_4.html#classunsigned">unsigned</a>&#160;</td>
          <td class="paramname"><em>nbins</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a589e3fc7f3e94613126a8198bf90dd59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a589e3fc7f3e94613126a8198bf90dd59">&#9670;&nbsp;</a></span>Range&lt; iterator_type &gt;() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="basic__distributions_8inl.html#a9717e7bbecb906637e86cef6da3d83c2">return</a> <a class="el" href="namespacehydra.html#classhydra_1_1Range">hydra::Range</a>&lt; <a class="el" href="namespacehydra.html#a89686ff2116120de2d9e2ad6889a47de">iterator_type</a> &gt; </td>
          <td>(</td>
          <td class="paramtype">other.&#160;</td>
          <td class="paramname"><em>begin</em>cls..., </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">other.&#160;</td>
          <td class="paramname"><em>end</em>cls...&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{</div><div class="line"></div><div class="line">    <span class="keyword">typedef</span> decltype( other.begin(cls...)) <a class="code" href="namespacehydra.html#a89686ff2116120de2d9e2ad6889a47de">iterator_type</a></div><div class="ttc" id="namespacehydra_html_a89686ff2116120de2d9e2ad6889a47de"><div class="ttname"><a href="namespacehydra.html#a89686ff2116120de2d9e2ad6889a47de">hydra::iterator_type</a></div><div class="ttdeci">decltype(other.begin(placeholders::placeholder&lt; I &gt;{})) typedef iterator_type</div><div class="ttdef"><b>Definition:</b> multivector.h:1594</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="abf9723fecdbba95ef0e6ccfd8b30994a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf9723fecdbba95ef0e6ccfd8b30994a">&#9670;&nbsp;</a></span>Range&lt; iterator_type &gt;() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="basic__distributions_8inl.html#a9717e7bbecb906637e86cef6da3d83c2">return</a> <a class="el" href="namespacehydra.html#classhydra_1_1Range">hydra::Range</a>&lt; <a class="el" href="namespacehydra.html#a89686ff2116120de2d9e2ad6889a47de">iterator_type</a> &gt; </td>
          <td>(</td>
          <td class="paramtype">other.&#160;</td>
          <td class="paramname"><em>begin</em>placeholders::placeholder&lt; I &gt;{}, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">other.&#160;</td>
          <td class="paramname"><em>end</em>placeholders::placeholder&lt; I &gt;{}&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aadcca49207bf7ab79088f28cddb8f21d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadcca49207bf7ab79088f28cddb8f21d">&#9670;&nbsp;</a></span>rbegin() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::rbegin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="basic__distributions_8inl.html#a4900ef306eb9271438791f1a98b8ccba">C</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td> -&gt;  decltype(std::forward&lt; <a class="el" href="basic__distributions_8inl.html#a4900ef306eb9271438791f1a98b8ccba">C</a> &gt;(c).rbegin())</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a434c6a6c1a24dbd8ca880af38694803d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a434c6a6c1a24dbd8ca880af38694803d">&#9670;&nbsp;</a></span>rbegin() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::rbegin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="basic__distributions_8inl.html#a4900ef306eb9271438791f1a98b8ccba">C</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td> -&gt;  decltype(c.rbegin())</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0d87c9638b5f275d1fbbef560a3c0197"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d87c9638b5f275d1fbbef560a3c0197">&#9670;&nbsp;</a></span>rbegin() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T * hydra::rbegin </td>
          <td>(</td>
          <td class="paramtype">T(&amp;)&#160;</td>
          <td class="paramname"><em>array</em>[N]</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a69daea4927958e8a666ee6ed3a795cbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69daea4927958e8a666ee6ed3a795cbd">&#9670;&nbsp;</a></span>rbegin() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename T , size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::rbegin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#classhydra_1_1multiarray">multiarray</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(other.rbegin(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt;I&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a932ef4185794129e04c9a4220db464eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a932ef4185794129e04c9a4220db464eb">&#9670;&nbsp;</a></span>rbegin() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename T , size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::rbegin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#classhydra_1_1multiarray">multiarray</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(other.rbegin(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt;I&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a57219e4fdd099c8aa6146d96e25952a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57219e4fdd099c8aa6146d96e25952a9">&#9670;&nbsp;</a></span>rbegin() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::rbegin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; hydra_thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> -&gt; decltype(other.rbegin(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt;I&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8a32676d58ec38a6d96188f2a4535ab5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a32676d58ec38a6d96188f2a4535ab5">&#9670;&nbsp;</a></span>rbegin() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::rbegin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; hydra_thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> -&gt; decltype(other.rbegin(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt;I&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa6988f3f5580e46402b7162f9ceb43ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6988f3f5580e46402b7162f9ceb43ee">&#9670;&nbsp;</a></span>reduce() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterable &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;<a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt;Iterable&gt;::value,typename hydra_thrust::iterator_traits&lt;decltype(std::declval&lt;Iterable&gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>())&gt;::value_type &gt;::type hydra::reduce </td>
          <td>(</td>
          <td class="paramtype">Iterable &amp;&amp;&#160;</td>
          <td class="paramname"><em>iterable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a63b9d5a2744d5acc0852b40f5262eb17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63b9d5a2744d5acc0852b40f5262eb17">&#9670;&nbsp;</a></span>reduce() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterable , typename Functor , typename T  = typename hydra_thrust::iterator_traits&lt;		     decltype(std::declval&lt;Iterable&gt;().begin())&gt;::value_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;<a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt;Iterable&gt;::value, T &gt;::type hydra::reduce </td>
          <td>(</td>
          <td class="paramtype">Iterable &amp;&amp;&#160;</td>
          <td class="paramname"><em>iterable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Functor const &amp;&#160;</td>
          <td class="paramname"><em>binary_functor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a58e00797465282d00eeaf0cd82d1c076"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58e00797465282d00eeaf0cd82d1c076">&#9670;&nbsp;</a></span>rend() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::rend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="basic__distributions_8inl.html#a4900ef306eb9271438791f1a98b8ccba">C</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td> -&gt;  decltype(std::forward&lt; <a class="el" href="basic__distributions_8inl.html#a4900ef306eb9271438791f1a98b8ccba">C</a> &gt;(c).rend())</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a48be0e2a44047208c68e2c096683db35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48be0e2a44047208c68e2c096683db35">&#9670;&nbsp;</a></span>rend() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::rend </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="basic__distributions_8inl.html#a4900ef306eb9271438791f1a98b8ccba">C</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td> -&gt;  decltype(c.rend())</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7f3625ffa0bf89a7d056a0d2b226e882"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f3625ffa0bf89a7d056a0d2b226e882">&#9670;&nbsp;</a></span>rend() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T * hydra::rend </td>
          <td>(</td>
          <td class="paramtype">T(&amp;)&#160;</td>
          <td class="paramname"><em>array</em>[N]</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad79366fdc5ac96950ef240f03e0321b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad79366fdc5ac96950ef240f03e0321b5">&#9670;&nbsp;</a></span>rend() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename T , size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::rend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#classhydra_1_1multiarray">multiarray</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(other.rend(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt;I&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a175fc3749a8859251e455ea11b8739f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a175fc3749a8859251e455ea11b8739f8">&#9670;&nbsp;</a></span>rend() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename T , size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::rend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt; I &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#classhydra_1_1multiarray">multiarray</a>&lt; T, N, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(other.rend(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt;I&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a86b2c2246658f870623ef17332b1f3cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86b2c2246658f870623ef17332b1f3cd">&#9670;&nbsp;</a></span>rend() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::rend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; hydra_thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> -&gt; decltype(other.rend(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt;I&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a430457d59572ba165f2fcaf877e8975c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a430457d59572ba165f2fcaf877e8975c">&#9670;&nbsp;</a></span>rend() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int I, hydra::detail::Backend BACKEND, typename ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto hydra::rend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#classhydra_1_1multivector">multivector</a>&lt; hydra_thrust::tuple&lt; T... &gt;, <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">detail::BackendPolicy</a>&lt; BACKEND &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> -&gt; decltype(other.rend(<a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt;I&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9c4c8a32d3456681824f36d2058deb4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c4c8a32d3456681824f36d2058deb4b">&#9670;&nbsp;</a></span>reverse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterable &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">hydra_thrust::detail::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">detail::is_iterable</a>&lt;Iterable&gt;::value , <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; hydra_thrust::reverse_iterator&lt; decltype(std::declval&lt;Iterable&gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()) &gt; &gt; &gt;::type hydra::reverse </td>
          <td>(</td>
          <td class="paramtype">Iterable &amp;&amp;&#160;</td>
          <td class="paramname"><em>iterable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad27ce158f82bfcf3ba0855a224a3f626"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad27ce158f82bfcf3ba0855a224a3f626">&#9670;&nbsp;</a></span>rint()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> hydra::rint </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4a9e21c7083ea65e58667297a801f0c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a9e21c7083ea65e58667297a801f0c0">&#9670;&nbsp;</a></span>rotateEuler() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> Vector4R hydra::rotateEuler </td>
          <td>(</td>
          <td class="paramtype">const Vector4R &amp;&#160;</td>
          <td class="paramname"><em>rs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>&#160;</td>
          <td class="paramname"><em>gamma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab9637ed446b2f89c3514f57bac1fd1be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9637ed446b2f89c3514f57bac1fd1be">&#9670;&nbsp;</a></span>rotateEuler() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> Vector3R hydra::rotateEuler </td>
          <td>(</td>
          <td class="paramtype">const Vector3R &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>&#160;</td>
          <td class="paramname"><em>phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#a971e94bcb8c43741d11f9d8eb98f5fab">GReal_t</a>&#160;</td>
          <td class="paramname"><em>ksi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aed01ab7e551c3ca33d6b8df7b27c4a31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed01ab7e551c3ca33d6b8df7b27c4a31">&#9670;&nbsp;</a></span>sample() <span class="overload">[1/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RNG , typename DerivedPolicy , typename Functor , typename Iterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1random_1_1is__callable.html">detail::random::is_callable</a>&lt; Functor &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1random_1_1is__iterator.html">detail::random::is_iterator</a>&lt; Iterator &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; Iterator &gt; &gt;::type hydra::sample </td>
          <td>(</td>
          <td class="paramtype">hydra_thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; const &amp;&#160;</td>
          <td class="paramname"><em>policy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td>
          <td class="paramname"><em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Functor const &amp;&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>seed</em> = <code>0xb56c4feeef1b</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fill a range with numbers distributed according a user defined distribution. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">policy</td><td>backend to perform the calculation. </td></tr>
    <tr><td class="paramname">begin</td><td>beginning of the range storing the generated values </td></tr>
    <tr><td class="paramname">end</td><td>ending of the range storing the generated values </td></tr>
    <tr><td class="paramname">min</td><td>lower limit of sampling region </td></tr>
    <tr><td class="paramname">max</td><td>upper limit of sampling region. </td></tr>
    <tr><td class="paramname">functor</td><td>distribution to be sampled </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>range with the generated values </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="breit_wigner_plus_polynomial_8inl-example.html#a31">breit_wigner_plus_polynomial.inl</a>, <a class="el" href="crystal_ball_plus_exponential_8inl-example.html#a32">crystal_ball_plus_exponential.inl</a>, <a class="el" href="dalitz_plot_8inl-example.html#a70">dalitz_plot.inl</a>, <a class="el" href="dense_histogram_8inl-example.html#a15">dense_histogram.inl</a>, <a class="el" href="double_gaussian_plus_exponential_8inl-example.html#a33">double_gaussian_plus_exponential.inl</a>, <a class="el" href="fit_convoluted_pdfs_8inl-example.html#a39">fit_convoluted_pdfs.inl</a>, <a class="el" href="gaussian_plus_argus_8inl-example.html#a36">gaussian_plus_argus.inl</a>, and <a class="el" href="sample_distribution_8inl-example.html#a16">sample_distribution.inl</a>.</dd>
</dl>
</div>
</div>
<a id="a9ea037fa085eae26a9ff4b14d6473736"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ea037fa085eae26a9ff4b14d6473736">&#9670;&nbsp;</a></span>sample() <span class="overload">[2/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RNG , typename Functor , typename Iterator , hydra::detail::Backend BACKEND&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1random_1_1is__callable.html">detail::random::is_callable</a>&lt; Functor &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1random_1_1is__iterator.html">detail::random::is_iterator</a>&lt; Iterator &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; Iterator &gt; &gt;::type hydra::sample </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; const &amp;&#160;</td>
          <td class="paramname"><em>policy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td>
          <td class="paramname"><em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Functor const &amp;&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>seed</em> = <code>0xb56c4feeef1b</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fill a range with numbers distributed according a user defined distribution. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">policy</td><td>backend to perform the calculation. </td></tr>
    <tr><td class="paramname">begin</td><td>beginning of the range storing the generated values </td></tr>
    <tr><td class="paramname">end</td><td>ending of the range storing the generated values </td></tr>
    <tr><td class="paramname">min</td><td>lower limit of sampling region </td></tr>
    <tr><td class="paramname">max</td><td>upper limit of sampling region. </td></tr>
    <tr><td class="paramname">functor</td><td>distribution to be sampled </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>range with the generated values </dd></dl>

</div>
</div>
<a id="a5e43c56c2acb0bc981adac7200f381d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e43c56c2acb0bc981adac7200f381d1">&#9670;&nbsp;</a></span>sample() <span class="overload">[3/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RNG , typename Functor , typename Iterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1random_1_1is__callable.html">detail::random::is_callable</a>&lt; Functor &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1random_1_1is__iterator.html">detail::random::is_iterator</a>&lt; Iterator &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; Iterator &gt; &gt;::type hydra::sample </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td>
          <td class="paramname"><em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Functor const &amp;&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>seed</em> = <code>0xb56c4feeef1b</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fill a range with numbers distributed according a user defined distribution. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>beginning of the range storing the generated values </td></tr>
    <tr><td class="paramname">end</td><td>ending of the range storing the generated values </td></tr>
    <tr><td class="paramname">min</td><td>lower limit of sampling region </td></tr>
    <tr><td class="paramname">max</td><td>upper limit of sampling region. </td></tr>
    <tr><td class="paramname">functor</td><td>distribution to be sampled </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>range with the generated values </dd></dl>

</div>
</div>
<a id="ac7a368f4ced51cbe178fe13bfc65b776"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7a368f4ced51cbe178fe13bfc65b776">&#9670;&nbsp;</a></span>sample() <span class="overload">[4/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RNG , typename Functor , typename Iterable &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1random_1_1is__callable.html">detail::random::is_callable</a>&lt; Functor &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1random_1_1is__iterable.html">detail::random::is_iterable</a>&lt; Iterable &gt;::value,<a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; decltype(std::declval&lt; Iterable &gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>())&gt; &gt;::type hydra::sample </td>
          <td>(</td>
          <td class="paramtype">Iterable &amp;&amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td>
          <td class="paramname"><em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Functor const &amp;&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>seed</em> = <code>0xb56c4feeef1b</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fill a range with numbers distributed according a user defined distribution. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">output</td><td>range storing the generated values </td></tr>
    <tr><td class="paramname">min</td><td>lower limit of sampling region </td></tr>
    <tr><td class="paramname">max</td><td>upper limit of sampling region. </td></tr>
    <tr><td class="paramname">functor</td><td>distribution to be sampled </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>range with the generated values </dd></dl>

</div>
</div>
<a id="a28ab38a67a0c6da8c0b762e150d38363"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28ab38a67a0c6da8c0b762e150d38363">&#9670;&nbsp;</a></span>sample() <span class="overload">[5/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RNG , typename DerivedPolicy , typename Functor , typename Iterator , size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1random_1_1is__callable.html">detail::random::is_callable</a>&lt;Functor&gt;::value &amp;&amp; <a class="el" href="structhydra_1_1detail_1_1random_1_1is__iterator.html">detail::random::is_iterator</a>&lt;Iterator&gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt;Iterator&gt;&gt;::type hydra::sample </td>
          <td>(</td>
          <td class="paramtype">hydra_thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; const &amp;&#160;</td>
          <td class="paramname"><em>policy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>, N &gt;const &amp;&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>, N &gt;const &amp;&#160;</td>
          <td class="paramname"><em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Functor const &amp;&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>seed</em> = <code>0xb56c4feeef1b</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fill a range with numbers distributed according a user defined distribution. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">policy</td><td>backend to perform the calculation. </td></tr>
    <tr><td class="paramname">begin</td><td>beginning of the range storing the generated values </td></tr>
    <tr><td class="paramname">end</td><td>ending of the range storing the generated values </td></tr>
    <tr><td class="paramname">min</td><td>array of lower limits of sampling region </td></tr>
    <tr><td class="paramname">max</td><td>array of upper limits of sampling region. </td></tr>
    <tr><td class="paramname">functor</td><td>distribution to be sampled </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8c226857e56377b95a3c80af185cd710"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c226857e56377b95a3c80af185cd710">&#9670;&nbsp;</a></span>sample() <span class="overload">[6/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RNG , typename Functor , typename Iterator , hydra::detail::Backend BACKEND, size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1random_1_1is__callable.html">detail::random::is_callable</a>&lt; Functor &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1random_1_1is__iterator.html">detail::random::is_iterator</a>&lt; Iterator &gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; Iterator &gt; &gt;::type hydra::sample </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1BackendPolicy">hydra::detail::BackendPolicy</a>&lt; BACKEND &gt; const &amp;&#160;</td>
          <td class="paramname"><em>policy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>, N &gt;const &amp;&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>, N &gt;const &amp;&#160;</td>
          <td class="paramname"><em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Functor const &amp;&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>seed</em> = <code>0xb56c4feeef1b</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fill a range with numbers distributed according a user defined distribution. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">policy</td><td>backend to perform the calculation. </td></tr>
    <tr><td class="paramname">begin</td><td>beginning of the range storing the generated values </td></tr>
    <tr><td class="paramname">end</td><td>ending of the range storing the generated values </td></tr>
    <tr><td class="paramname">min</td><td>array of lower limits of sampling region </td></tr>
    <tr><td class="paramname">max</td><td>array of upper limits of sampling region. </td></tr>
    <tr><td class="paramname">functor</td><td>distribution to be sampled </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8de60f2a597ac83cf3974b716a60f079"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8de60f2a597ac83cf3974b716a60f079">&#9670;&nbsp;</a></span>sample() <span class="overload">[7/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RNG , typename Functor , typename Iterator , size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1random_1_1is__callable.html">detail::random::is_callable</a>&lt;Functor&gt;::value &amp;&amp; <a class="el" href="structhydra_1_1detail_1_1random_1_1is__iterator.html">detail::random::is_iterator</a>&lt;Iterator&gt;::value, <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt;Iterator&gt;&gt;::type hydra::sample </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>, N &gt;const &amp;&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>, N &gt;const &amp;&#160;</td>
          <td class="paramname"><em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Functor const &amp;&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>seed</em> = <code>0xb56c4feeef1b</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fill a range with numbers distributed according a user defined distribution. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>beginning of the range storing the generated values </td></tr>
    <tr><td class="paramname">end</td><td>ending of the range storing the generated values </td></tr>
    <tr><td class="paramname">min</td><td>array of lower limits of sampling region </td></tr>
    <tr><td class="paramname">max</td><td>array of upper limits of sampling region. </td></tr>
    <tr><td class="paramname">functor</td><td>distribution to be sampled </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>range with the generated values </dd></dl>

</div>
</div>
<a id="a580bac5409cfbad9ebcb47ed3f4d3842"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a580bac5409cfbad9ebcb47ed3f4d3842">&#9670;&nbsp;</a></span>sample() <span class="overload">[8/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RNG , typename Functor , typename Iterable , size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1random_1_1is__callable.html">detail::random::is_callable</a>&lt;Functor&gt;::value &amp;&amp; <a class="el" href="structhydra_1_1detail_1_1random_1_1is__iterable.html">detail::random::is_iterable</a>&lt;Iterable&gt;::value , <a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; decltype(std::declval&lt;Iterable&gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>())&gt;&gt;::type hydra::sample </td>
          <td>(</td>
          <td class="paramtype">Iterable &amp;&amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>, N &gt;const &amp;&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>, N &gt;const &amp;&#160;</td>
          <td class="paramname"><em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Functor const &amp;&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>seed</em> = <code>0xb56c4feeef1b</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fill a range with numbers distributed according a user defined distribution. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">output</td><td>range storing the generated values </td></tr>
    <tr><td class="paramname">min</td><td>array of lower limits of sampling region </td></tr>
    <tr><td class="paramname">max</td><td>array of upper limits of sampling region. </td></tr>
    <tr><td class="paramname">functor</td><td>distribution to be sampled </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>output range with the generated values </dd></dl>

</div>
</div>
<a id="a296616d9209f3b941819c71fd15fe490"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a296616d9209f3b941819c71fd15fe490">&#9670;&nbsp;</a></span>sample() <span class="overload">[9/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RNG  = default_random_engine, typename Functor , typename Iterator , size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;<a class="el" href="structhydra_1_1detail_1_1random_1_1is__callable.html">detail::random::is_callable</a>&lt;Functor&gt;::value &amp;&amp; <a class="el" href="structhydra_1_1detail_1_1random_1_1is__iterator.html">detail::random::is_iterator</a>&lt;Iterator&gt;::value,<a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt;Iterator&gt; &gt;::type hydra::sample </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>, N &gt;const &amp;&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>, N &gt;const &amp;&#160;</td>
          <td class="paramname"><em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Functor const &amp;&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>seed</em> = <code>0xb56c4feeef1b</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fill a range with numbers distributed according a user defined distribution. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>beginning of the range storing the generated values </td></tr>
    <tr><td class="paramname">end</td><td>ending of the range storing the generated values </td></tr>
    <tr><td class="paramname">min</td><td>array of lower limits of sampling region </td></tr>
    <tr><td class="paramname">max</td><td>array of upper limits of sampling region. </td></tr>
    <tr><td class="paramname">functor</td><td>distribution to be sampled </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>range with the generated values </dd></dl>

</div>
</div>
<a id="a5c55b6942a31d70e1a7a598ba29ad703"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c55b6942a31d70e1a7a598ba29ad703">&#9670;&nbsp;</a></span>sample() <span class="overload">[10/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RNG  = default_random_engine, typename DerivedPolicy , typename Functor , typename Iterator , size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;<a class="el" href="structhydra_1_1detail_1_1random_1_1is__callable.html">detail::random::is_callable</a>&lt;Functor&gt;::value &amp;&amp; <a class="el" href="structhydra_1_1detail_1_1random_1_1is__iterator.html">detail::random::is_iterator</a>&lt;Iterator&gt;::value,<a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt;Iterator&gt; &gt;::type hydra::sample </td>
          <td>(</td>
          <td class="paramtype">hydra_thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; const &amp;&#160;</td>
          <td class="paramname"><em>policy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>, N &gt;const &amp;&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>, N &gt;const &amp;&#160;</td>
          <td class="paramname"><em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Functor const &amp;&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>seed</em> = <code>0xb56c4feeef1b</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fill a range with numbers distributed according a user defined distribution. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">policy</td><td>backend to perform the calculation. </td></tr>
    <tr><td class="paramname">begin</td><td>beginning of the range storing the generated values </td></tr>
    <tr><td class="paramname">end</td><td>ending of the range storing the generated values </td></tr>
    <tr><td class="paramname">min</td><td>array of lower limits of sampling region </td></tr>
    <tr><td class="paramname">max</td><td>array of upper limits of sampling region. </td></tr>
    <tr><td class="paramname">functor</td><td>distribution to be sampled </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a13157ce8d4078e8b5bd17dbd9705a3ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13157ce8d4078e8b5bd17dbd9705a3ea">&#9670;&nbsp;</a></span>sample() <span class="overload">[11/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RNG  = default_random_engine, typename Functor , typename Iterable , size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;<a class="el" href="structhydra_1_1detail_1_1random_1_1is__callable.html">detail::random::is_callable</a>&lt;Functor&gt;::value &amp;&amp; <a class="el" href="structhydra_1_1detail_1_1random_1_1is__iterable.html">detail::random::is_iterable</a>&lt;Iterable&gt;::value ,<a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; decltype(std::declval&lt;Iterable&gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>())&gt; &gt;::type hydra::sample </td>
          <td>(</td>
          <td class="paramtype">Iterable &amp;&amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>, N &gt;const &amp;&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>, N &gt;const &amp;&#160;</td>
          <td class="paramname"><em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Functor const &amp;&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>seed</em> = <code>0xb56c4feeef1b</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fill a range with numbers distributed according a user defined distribution. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">output</td><td>range storing the generated values </td></tr>
    <tr><td class="paramname">min</td><td>array of lower limits of sampling region </td></tr>
    <tr><td class="paramname">max</td><td>array of upper limits of sampling region. </td></tr>
    <tr><td class="paramname">functor</td><td>distribution to be sampled </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>output range with the generated values </dd></dl>

</div>
</div>
<a id="a7b62f11052cf4a8e258b21b9f64f0c6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b62f11052cf4a8e258b21b9f64f0c6d">&#9670;&nbsp;</a></span>scatter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterable_Source , typename Iterable_Target , typename Iterable_Map &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;<a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt;Iterable_Source&gt;::value &amp;&amp; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt;Iterable_Target&gt;::value &amp;&amp; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt;Iterable_Map&gt;::value,<a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt;decltype(std::declval&lt;Iterable_Target&amp;&gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>())&gt; &gt;::type hydra::scatter </td>
          <td>(</td>
          <td class="paramtype">Iterable_Source &amp;&amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterable_Map &amp;&amp;&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterable_Target &amp;&amp;&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8056e4374a5e077e4ecb940851166b51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8056e4374a5e077e4ecb940851166b51">&#9670;&nbsp;</a></span>segregate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterable , typename Functor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt;Iterable&gt;::value,std::pair&lt;<a class="el" href="namespacehydra.html#classhydra_1_1Range">hydra::Range</a>&lt;decltype(std::declval&lt;Iterable&gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>())&gt;, <a class="el" href="namespacehydra.html#classhydra_1_1Range">hydra::Range</a>&lt;decltype(std::declval&lt;Iterable&gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>())&gt; &gt; &gt;::type hydra::segregate </td>
          <td>(</td>
          <td class="paramtype">Iterable &amp;&amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Functor &amp;&amp;&#160;</td>
          <td class="paramname"><em>filter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae5337fca35f17ea6b1001e76ce351f9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5337fca35f17ea6b1001e76ce351f9e">&#9670;&nbsp;</a></span>segregate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterable , typename Functor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt;Iterable&gt;::value, std::pair&lt;<a class="el" href="namespacehydra.html#classhydra_1_1Range">hydra::Range</a>&lt;decltype(std::declval&lt;Iterable&gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>())&gt;, <a class="el" href="namespacehydra.html#classhydra_1_1Range">hydra::Range</a>&lt;decltype(std::declval&lt;Iterable&gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>())&gt; &gt; &gt;::type hydra::segregate </td>
          <td>(</td>
          <td class="paramtype">Iterable &amp;&amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Functor const &amp;&#160;</td>
          <td class="paramname"><em>filter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="acb7d0e5da38544692eb3545e81617e19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb7d0e5da38544692eb3545e81617e19">&#9670;&nbsp;</a></span>sin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespacehydra.html#a9be56668c1da1edd25b29c366adf5df9">complex</a>&lt;T&gt; hydra::sin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#a9be56668c1da1edd25b29c366adf5df9">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="dalitz_plot_8C-example.html#a24">dalitz_plot.C</a>, and <a class="el" href="dalitz_plot_8inl-example.html#a32">dalitz_plot.inl</a>.</dd>
</dl>
</div>
</div>
<a id="af59c474655ecd14c6748391d80e2e4c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af59c474655ecd14c6748391d80e2e4c2">&#9670;&nbsp;</a></span>sinh()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespacehydra.html#a9be56668c1da1edd25b29c366adf5df9">complex</a>&lt;T&gt; hydra::sinh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#a9be56668c1da1edd25b29c366adf5df9">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5b6b3a330b6d16d3221bb7b994b9329b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b6b3a330b6d16d3221bb7b994b9329b">&#9670;&nbsp;</a></span>sort() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterable , typename Iterator  = decltype(std::declval&lt;Iterable&gt;().begin())&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;<a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt;Iterable&gt;::value,<a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt;decltype(std::declval&lt;Iterable&amp;&gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>())&gt; &gt;::type hydra::sort </td>
          <td>(</td>
          <td class="paramtype">Iterable &amp;&#160;</td>
          <td class="paramname"><em>iterable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac64c757c35da63a927af0ad5147ac7c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac64c757c35da63a927af0ad5147ac7c5">&#9670;&nbsp;</a></span>sort() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterable , typename Functor , typename Iterator  = decltype(std::declval&lt;Iterable&gt;().begin())&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;<a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt;Iterable&gt;::value,<a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt;decltype(std::declval&lt;Iterable&amp;&gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>())&gt; &gt;::type hydra::sort </td>
          <td>(</td>
          <td class="paramtype">Iterable &amp;&#160;</td>
          <td class="paramname"><em>iterable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Functor const &amp;&#160;</td>
          <td class="paramname"><em>comparator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a34662231e9292fda55e3a182ea5d342a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34662231e9292fda55e3a182ea5d342a">&#9670;&nbsp;</a></span>sort_by_key() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterable , typename Iterable_Key , typename Iterator  = decltype(std::declval&lt;Iterable&gt;().begin()), typename Iterator_Key  = decltype(std::declval&lt;Iterable_Key&gt;().begin()), typename Value_Key  = decltype(*std::declval&lt;Iterator_Key&gt;().begin())&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;<a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt;Iterable&gt;::value,<a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt;decltype(std::declval&lt;Iterable&amp;&gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>())&gt; &gt;::type hydra::sort_by_key </td>
          <td>(</td>
          <td class="paramtype">Iterable &amp;&#160;</td>
          <td class="paramname"><em>iterable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterable_Key &amp;&#160;</td>
          <td class="paramname"><em>keys</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="range_semantics_8inl-example.html#a12">range_semantics.inl</a>.</dd>
</dl>
</div>
</div>
<a id="ae5d13834b7141cdaba43ad83ca671e7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5d13834b7141cdaba43ad83ca671e7a">&#9670;&nbsp;</a></span>sort_by_key() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterable , typename Iterator_Key , typename Functor , typename Iterator  = decltype(std::declval&lt;Iterable&gt;().begin()), typename Value_Key  = decltype(*std::declval&lt;Range&lt;Iterator_Key,Functor&gt;&gt;().begin())&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;<a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt;Iterable&gt;::value,<a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt;decltype(std::declval&lt;Iterable&amp;&gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>())&gt; &gt;::type hydra::sort_by_key </td>
          <td>(</td>
          <td class="paramtype">Iterable &amp;&#160;</td>
          <td class="paramname"><em>iterable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; Iterator_Key, Functor &gt;&#160;</td>
          <td class="paramname"><em>keys</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a41f704c48c1d979a21484290bb17aaae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41f704c48c1d979a21484290bb17aaae">&#9670;&nbsp;</a></span>spiline() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator1 , typename Iterator2 , typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> std::enable_if&lt; std::is_floating_point&lt; typename hydra_thrust::iterator_traits&lt; Iterator1 &gt;::value_type &gt;::value &amp;&amp;std::is_floating_point&lt; typename hydra_thrust::iterator_traits&lt; Iterator2 &gt;::value_type &gt;::value, Type &gt;::type hydra::spiline </td>
          <td>(</td>
          <td class="paramtype">Iterator1&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator1&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator2&#160;</td>
          <td class="paramname"><em>measurements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9cfc5a85539744bfe13c531c9233b869"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cfc5a85539744bfe13c531c9233b869">&#9670;&nbsp;</a></span>spiline() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterable1 , typename Iterable2 , typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; Iterable1 &gt;::value &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt; Iterable2 &gt;::value &amp;&amp;std::is_floating_point&lt; typename Iterable1::value_type &gt;::value &amp;&amp;std::is_floating_point&lt; typename Iterable2::value_type &gt;::value, Type &gt;::type hydra::spiline </td>
          <td>(</td>
          <td class="paramtype">Iterable1 &amp;&amp;&#160;</td>
          <td class="paramname"><em>abscissae</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterable2 &amp;&amp;&#160;</td>
          <td class="paramname"><em>ordinate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a74988a829019bf111e7f51d81b33eec7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74988a829019bf111e7f51d81b33eec7">&#9670;&nbsp;</a></span>sqrt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespacehydra.html#a9be56668c1da1edd25b29c366adf5df9">complex</a>&lt;T&gt; hydra::sqrt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#a9be56668c1da1edd25b29c366adf5df9">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="adaptive_gauss_kronrod_8inl-example.html#a8">adaptive_gauss_kronrod.inl</a>, <a class="el" href="binned_extended_logLL_fit_8inl-example.html#a26">binned_extended_logLL_fit.inl</a>, <a class="el" href="dense_histogram_8inl-example.html#a8">dense_histogram.inl</a>, <a class="el" href="extended_logLL_fit_8inl-example.html#a26">extended_logLL_fit.inl</a>, <a class="el" href="fit_convoluted_pdfs_8inl-example.html#a31">fit_convoluted_pdfs.inl</a>, <a class="el" href="gauss_kronrod_8inl-example.html#a8">gauss_kronrod.inl</a>, <a class="el" href="multidimensional_fit_8inl-example.html#a32">multidimensional_fit.inl</a>, <a class="el" href="phsp_chain_8inl-example.html#a14">phsp_chain.inl</a>, <a class="el" href="plain_mc_8inl-example.html#a8">plain_mc.inl</a>, <a class="el" href="range_semantics_8inl-example.html#a7">range_semantics.inl</a>, <a class="el" href="splot_8inl-example.html#a19">splot.inl</a>, and <a class="el" href="vegas_8inl-example.html#a8">vegas.inl</a>.</dd>
</dl>
</div>
</div>
<a id="aa792627bbf68dd5d3c3d969c3462808f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa792627bbf68dd5d3c3d969c3462808f">&#9670;&nbsp;</a></span>stream_array_helper() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t N, typename T , size_t I&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;(I==N), void&gt;::type hydra::stream_array_helper </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; T, N &gt; const &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>array streamer helper </p>

</div>
</div>
<a id="a6b2446e6e58a2466b66c1277d67075ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b2446e6e58a2466b66c1277d67075ad">&#9670;&nbsp;</a></span>stream_array_helper() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t N, typename T , size_t I = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; (I &lt; N), void&gt;::type hydra::stream_array_helper </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; T, N &gt; const &amp;&#160;</td>
          <td class="paramname"><em>obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afa8b42796ae70a6c34b6871a8755b382"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa8b42796ae70a6c34b6871a8755b382">&#9670;&nbsp;</a></span>stream_tuple_helper() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I, typename ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;(I==sizeof ...(T)), void&gt;::type hydra::stream_tuple_helper </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::tuple&lt; T... &gt; const &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>tuple streamer helper </p>

</div>
</div>
<a id="af0ba407638beac5920ac997d3021b413"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0ba407638beac5920ac997d3021b413">&#9670;&nbsp;</a></span>stream_tuple_helper() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I = 0, typename ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; (I &lt; sizeof ...(T)), void&gt;::type hydra::stream_tuple_helper </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::tuple&lt; T... &gt; const &amp;&#160;</td>
          <td class="paramname"><em>obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a939ad741ed8f9f39a61680c9f7f442ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a939ad741ed8f9f39a61680c9f7f442ae">&#9670;&nbsp;</a></span>sum()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F1 , typename F2 , typename ... Fs&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;(<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt;F1&gt;::value || <a class="el" href="structhydra_1_1detail_1_1is__hydra__lambda.html">detail::is_hydra_lambda</a>&lt;F1&gt;::value) &amp;&amp;(<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt;F2&gt;::value || <a class="el" href="structhydra_1_1detail_1_1is__hydra__lambda.html">detail::is_hydra_lambda</a>&lt;F2&gt;::value) &amp;&amp;<a class="el" href="structhydra_1_1detail_1_1all__true.html">detail::all_true</a>&lt;(<a class="el" href="structhydra_1_1detail_1_1is__hydra__functor.html">detail::is_hydra_functor</a>&lt;Fs&gt;::value || <a class="el" href="structhydra_1_1detail_1_1is__hydra__lambda.html">detail::is_hydra_lambda</a>&lt;Fs&gt;::value)...&gt;::value,<a class="el" href="classhydra_1_1Sum.html">Sum</a>&lt;F1, F2,Fs...&gt; &gt;::type hydra::sum </td>
          <td>(</td>
          <td class="paramtype">F1 const &amp;&#160;</td>
          <td class="paramname"><em>f1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F2 const &amp;&#160;</td>
          <td class="paramname"><em>f2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Fs const &amp;...&#160;</td>
          <td class="paramname"><em>functors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa7d619f99868f45f5e06b9040bcc68b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7d619f99868f45f5e06b9040bcc68b7">&#9670;&nbsp;</a></span>swap() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> void hydra::swap </td>
          <td>(</td>
          <td class="paramtype">Vector3R &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector3R &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a67385a5afc562279b4419a11ab79e3d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67385a5afc562279b4419a11ab79e3d6">&#9670;&nbsp;</a></span>swap() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> void hydra::swap </td>
          <td>(</td>
          <td class="paramtype">Vector4R &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector4R &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a110443bb149efe88b6713bc5aca89b7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a110443bb149efe88b6713bc5aca89b7c">&#9670;&nbsp;</a></span>tan()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespacehydra.html#a9be56668c1da1edd25b29c366adf5df9">complex</a>&lt;T&gt; hydra::tan </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#a9be56668c1da1edd25b29c366adf5df9">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="pseudo_experiment_8inl-example.html#a29">pseudo_experiment.inl</a>.</dd>
</dl>
</div>
</div>
<a id="a5c39f4b7fa2b8b0c1e4066e9d059b435"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c39f4b7fa2b8b0c1e4066e9d059b435">&#9670;&nbsp;</a></span>tanh()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> <a class="el" href="namespacehydra.html#a9be56668c1da1edd25b29c366adf5df9">complex</a>&lt;T&gt; hydra::tanh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehydra.html#a9be56668c1da1edd25b29c366adf5df9">complex</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa1dba4dcfb81c7ad5404533f6d3b4bd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1dba4dcfb81c7ad5404533f6d3b4bd7">&#9670;&nbsp;</a></span>tie()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> auto hydra::tie </td>
          <td>(</td>
          <td class="paramtype">T &amp;...&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td> -&gt; decltype(hydra_thrust::tie(t...))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This version of <code>tie</code> creates a new <code>tuple</code> whose elements are references which refers to this function's arguments. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>The objects to reference. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>tuple</code> object with members which are references to <code>t</code>. </dd></dl>

</div>
</div>
<a id="a66e3f95285aed29c7f62df05eecf2f00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66e3f95285aed29c7f62df05eecf2f00">&#9670;&nbsp;</a></span>transform()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterable_Input , typename Iterable_Output , typename Functor , typename Iterator  = decltype(std::declval&lt;Iterable_Output&gt;().begin())&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;<a class="el" href="structhydra_1_1detail_1_1is__iterable.html">hydra::detail::is_iterable</a>&lt;Iterable_Output&gt;::value,<a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt;decltype(std::declval&lt;Iterable_Output&amp;&gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>())&gt; &gt;::type hydra::transform </td>
          <td>(</td>
          <td class="paramtype">Iterable_Input &amp;&amp;&#160;</td>
          <td class="paramname"><em>iterable_input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterable_Output &amp;&amp;&#160;</td>
          <td class="paramname"><em>iterable_output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Functor const &amp;&#160;</td>
          <td class="paramname"><em>unary_functor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af9d0311b873d73e2980a800d69e9ff05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9d0311b873d73e2980a800d69e9ff05">&#9670;&nbsp;</a></span>unweight()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RNG , typename IterableData , typename IterableWeight &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;<a class="el" href="structhydra_1_1detail_1_1random_1_1is__iterable.html">detail::random::is_iterable</a>&lt;IterableData&gt;::value &amp;&amp; <a class="el" href="structhydra_1_1detail_1_1random_1_1is__iterable.html">detail::random::is_iterable</a>&lt;IterableWeight&gt;::value,<a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; decltype(std::declval&lt;IterableData&gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>())&gt; &gt;::type hydra::unweight </td>
          <td>(</td>
          <td class="paramtype">IterableData &amp;&amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IterableWeight &amp;&amp;&#160;</td>
          <td class="paramname"><em>weights</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a16cc58cf433d121a37c54f965023d49a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16cc58cf433d121a37c54f965023d49a">&#9670;&nbsp;</a></span>wigner_d_matrix() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> T hydra::wigner_d_matrix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_3globalScope_4.html#classdouble">double</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>theta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aaec6f8e5354bb7e586f34b1d4659ca8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaec6f8e5354bb7e586f34b1d4659ca8c">&#9670;&nbsp;</a></span>wigner_d_matrix() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> T hydra::wigner_d_matrix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_3globalScope_4.html#classunsigned">unsigned</a>&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_3globalScope_4.html#classunsigned">unsigned</a>&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_3globalScope_4.html#classunsigned">unsigned</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>theta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a094f4a025290ae35ad9eb8c553c7fc61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a094f4a025290ae35ad9eb8c553c7fc61">&#9670;&nbsp;</a></span>wrap_lambda() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LambdaType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhydra_1_1Lambda.html">hydra::Lambda</a>&lt;LambdaType, 0&gt; hydra::wrap_lambda </td>
          <td>(</td>
          <td class="paramtype">LambdaType const &amp;&#160;</td>
          <td class="paramname"><em>lambda</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="adaptive_gauss_kronrod_8inl-example.html#a11">adaptive_gauss_kronrod.inl</a>, <a class="el" href="basic_fit_range_semantics_8inl-example.html#a25">basic_fit_range_semantics.inl</a>, <a class="el" href="dalitz_plot_8C-example.html#a32">dalitz_plot.C</a>, <a class="el" href="dalitz_plot_8inl-example.html#a43">dalitz_plot.inl</a>, <a class="el" href="dense_histogram_8inl-example.html#a5">dense_histogram.inl</a>, <a class="el" href="extended_logLL_fit_8inl-example.html#a33">extended_logLL_fit.inl</a>, <a class="el" href="fit_gaussian_8C-example.html#a19">fit_gaussian.C</a>, <a class="el" href="fit_johnson_8C-example.html#a20">fit_johnson.C</a>, <a class="el" href="fractional_logLL_fit_8inl-example.html#a31">fractional_logLL_fit.inl</a>, <a class="el" href="gauss_kronrod_8inl-example.html#a11">gauss_kronrod.inl</a>, <a class="el" href="multidimensional_fit_8inl-example.html#a26">multidimensional_fit.inl</a>, <a class="el" href="phsp_averaging_functor_8inl-example.html#a12">phsp_averaging_functor.inl</a>, <a class="el" href="phsp_basic_8inl-example.html#a18">phsp_basic.inl</a>, <a class="el" href="phsp_chain_8inl-example.html#a11">phsp_chain.inl</a>, <a class="el" href="phsp_reweighting_8inl-example.html#a18">phsp_reweighting.inl</a>, <a class="el" href="phsp_unweighting_8inl-example.html#a18">phsp_unweighting.inl</a>, <a class="el" href="phsp_unweighting_functor_8inl-example.html#a18">phsp_unweighting_functor.inl</a>, <a class="el" href="plain_mc_8inl-example.html#a11">plain_mc.inl</a>, <a class="el" href="range_semantics_8inl-example.html#a5">range_semantics.inl</a>, <a class="el" href="sample_distribution_8inl-example.html#a8">sample_distribution.inl</a>, <a class="el" href="splot_8inl-example.html#a32">splot.inl</a>, and <a class="el" href="vegas_8inl-example.html#a11">vegas.inl</a>.</dd>
</dl>
</div>
</div>
<a id="a5d026eb3807e3f2358feb9a7890b4598"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d026eb3807e3f2358feb9a7890b4598">&#9670;&nbsp;</a></span>wrap_lambda() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LambdaType , typename ... T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;<a class="el" href="structhydra_1_1detail_1_1all__true.html">detail::all_true</a>&lt;std::is_same&lt;T, <a class="el" href="group__fit.html#structhydra_1_1Parameter">hydra::Parameter</a>&gt;::value...&gt;::value,<a class="el" href="classhydra_1_1Lambda.html">hydra::Lambda</a>&lt;LambdaType, sizeof...(T)&gt; &gt;::type hydra::wrap_lambda </td>
          <td>(</td>
          <td class="paramtype">LambdaType const &amp;&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;...&#160;</td>
          <td class="paramname"><em>parameters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae1c8be57a887f2bb9d01ba075a5de0f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1c8be57a887f2bb9d01ba075a5de0f2">&#9670;&nbsp;</a></span>zip()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... Iterables&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structhydra_1_1detail_1_1all__true.html">detail::all_true</a>&lt; <a class="el" href="structhydra_1_1detail_1_1is__iterable.html">detail::is_iterable</a>&lt;Iterables&gt;::value...&gt;::value,<a class="el" href="namespacehydra.html#classhydra_1_1Range">Range</a>&lt; hydra_thrust::zip_iterator&lt; decltype(hydra_thrust::make_tuple(std::declval&lt;Iterables&amp;&gt;).<a class="el" href="namespacehydra.html#ab9d562f964ef193664077363da8859e2">begin</a>()...))&gt; &gt; &gt;::type hydra::zip </td>
          <td>(</td>
          <td class="paramtype">Iterables &amp;&amp;...&#160;</td>
          <td class="paramname"><em>iterables</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="booststrapping_8inl-example.html#a6">booststrapping.inl</a>, <a class="el" href="cufft_8inl-example.html#a19">cufft.inl</a>, <a class="el" href="fft_8inl-example.html#a19">fft.inl</a>, and <a class="el" href="range_semantics_8inl-example.html#a10">range_semantics.inl</a>.</dd>
</dl>
</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a89686ff2116120de2d9e2ad6889a47de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89686ff2116120de2d9e2ad6889a47de">&#9670;&nbsp;</a></span>iterator_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">decltype( other.begin( <a class="el" href="structhydra_1_1placeholders_1_1placeholder.html">placeholders::placeholder</a>&lt;I&gt;{} )) typedef hydra::iterator_type</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{</div><div class="line"></div><div class="line">    constexpr <span class="keywordtype">size_t</span> I = detail::index_in_tuple&lt;Type, <a class="code" href="namespacehydra.html#a717fc4e6b10453164099beade13d0226">hydra_thrust::tuple</a>&lt;T...&gt; &gt;::value</div><div class="ttc" id="namespacehydra_html_a717fc4e6b10453164099beade13d0226"><div class="ttname"><a href="namespacehydra.html#a717fc4e6b10453164099beade13d0226">hydra::tuple</a></div><div class="ttdeci">hydra_thrust::tuple&lt; T... &gt; tuple</div><div class="ttdoc">tuple template is an alias to the variadic version of hydra_thrust::tuple and that can be instantiate...</div><div class="ttdef"><b>Definition:</b> Tuple.h:71</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ab14adaa26f703b8c130df530167ebd23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab14adaa26f703b8c130df530167ebd23">&#9670;&nbsp;</a></span>kFalse</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespacehydra.html#aa8c251ed5017d0638da929130062bcad">GBool_t</a> hydra::kFalse = false</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1556536d7a73fa95e5a9c9610f76a3c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1556536d7a73fa95e5a9c9610f76a3c1">&#9670;&nbsp;</a></span>kTrue</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespacehydra.html#aa8c251ed5017d0638da929130062bcad">GBool_t</a> hydra::kTrue = true</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5afb8f1b6ea1ba2b8fc79444e5d20f20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5afb8f1b6ea1ba2b8fc79444e5d20f20">&#9670;&nbsp;</a></span>PrintLevel</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_3globalScope_4.html#classint">int</a> hydra::PrintLevel = <a class="el" href="namespacehydra.html#ad87c68ca6adb981f4c31ae73ef97de3ba1bf857a06d5b8463494a6fcac6f4ea26">WARNING</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacehydra.html">hydra</a></li>
    <li class="footer">Generated on Sun Jun 28 2020 00:00:02 for Hydra by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.14 </li>
  </ul>
</div>
</body>
</html>
