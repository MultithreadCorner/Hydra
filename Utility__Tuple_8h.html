<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Hydra: Utility_Tuple.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo_Hydra2.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Hydra
   &#160;<span id="projectnumber">4.0.1</span>
   </div>
   <div id="projectbrief">A header-only templated C++ framework to perform data analysis on massively parallel platforms.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('Utility__Tuple_8h.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#namespaces">Namespaces</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Utility_Tuple.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;<a class="el" href="">hydra/detail/Config.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="">hydra/Types.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="">hydra/detail/utility/Generic.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="">hydra/detail/TagTraits.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="">hydra/detail/FunctorTraits.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="">hydra/Parameter.h</a>&gt;</code><br />
<code>#include &lt;hydra/detail/external/hydra_thrust/tuple.h&gt;</code><br />
<code>#include &lt;hydra/detail/external/hydra_thrust/detail/type_traits.h&gt;</code><br />
<code>#include &lt;hydra/detail/external/hydra_thrust/iterator/detail/tuple_of_iterator_references.h&gt;</code><br />
<code>#include &lt;type_traits&gt;</code><br />
<code>#include &lt;array&gt;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for Utility_Tuple.h:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="Utility__Tuple_8h__incl.svg" width="100%" height="600"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</div>
</div><div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="Utility__Tuple_8h__dep__incl.svg" width="100%" height="600"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</div>
</div>
<p><a href="">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1CompareTuples.html">hydra::detail::CompareTuples&lt; N, COM &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1is__homogeneous.html">hydra::detail::is_homogeneous&lt; A, Tuple &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1is__homogeneous__base.html">hydra::detail::is_homogeneous_base&lt; A, Tp, I &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhydra_1_1detail_1_1is__homogeneous__base_3_01A_00_01Tp_00_010_01_4.html">hydra::detail::is_homogeneous_base&lt; A, Tp, 0 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1detail_1_1references__tuple__type"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1references__tuple__type">hydra::detail::references_tuple_type&lt; N, T &gt;</a></td></tr>
<tr class="separator:structhydra_1_1detail_1_1references__tuple__type"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1detail_1_1tuple__cat__type"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1tuple__cat__type">hydra::detail::tuple_cat_type&lt; Tuple1, Tuple2 &gt;</a></td></tr>
<tr class="separator:structhydra_1_1detail_1_1tuple__cat__type"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1detail_1_1tuple__cat__type_3_01hydra_1_1thrust_1_1detail_1_1tuple__of__iterator__e875b1e0f0d98602461f9d0c3462aad3"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1tuple__cat__type_3_01hydra_1_1thrust_1_1detail_1_1tuple__of__iterator__e875b1e0f0d98602461f9d0c3462aad3">hydra::detail::tuple_cat_type&lt; hydra::thrust::detail::tuple_of_iterator_references&lt; T1... &gt;, hydra::thrust::detail::tuple_of_iterator_references&lt; T2... &gt; &gt;</a></td></tr>
<tr class="separator:structhydra_1_1detail_1_1tuple__cat__type_3_01hydra_1_1thrust_1_1detail_1_1tuple__of__iterator__e875b1e0f0d98602461f9d0c3462aad3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1detail_1_1tuple__cat__type_3_01hydra_1_1thrust_1_1tuple_3_01T1_8_8_8_01_4_00_01hy02a3f5f695c9d282a0a9beeb429a18a4"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1tuple__cat__type_3_01hydra_1_1thrust_1_1tuple_3_01T1_8_8_8_01_4_00_01hy02a3f5f695c9d282a0a9beeb429a18a4">hydra::detail::tuple_cat_type&lt; hydra::thrust::tuple&lt; T1... &gt;, hydra::thrust::tuple&lt; T2... &gt; &gt;</a></td></tr>
<tr class="separator:structhydra_1_1detail_1_1tuple__cat__type_3_01hydra_1_1thrust_1_1tuple_3_01T1_8_8_8_01_4_00_01hy02a3f5f695c9d282a0a9beeb429a18a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhydra_1_1detail_1_1tuple__type"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1tuple__type">hydra::detail::tuple_type&lt; N, T &gt;</a></td></tr>
<tr class="separator:structhydra_1_1detail_1_1tuple__type"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacehydra"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra.html">hydra</a></td></tr>
<tr class="memdesc:namespacehydra"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic policies definition. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacehydra_1_1detail"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html">hydra::detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacehydra_1_1detail_1_1utils"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail_1_1utils.html">hydra::detail::utils</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a52a71a770e750c0031cdad447a7d31fd"><td class="memTemplParams" colspan="2">template&lt;typename R , typename T , size_t I&gt; </td></tr>
<tr class="memitem:a52a71a770e750c0031cdad447a7d31fd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::detail::enable_if&lt;(I==<a class="el" href="namespacehydra.html#a58298133d4826dc6f35253762a7d6788">hydra::thrust::tuple_size</a>&lt; T &gt;::value), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a52a71a770e750c0031cdad447a7d31fd">hydra::detail::_get_element</a> (const size_t, T &amp;, R *&amp;)</td></tr>
<tr class="separator:a52a71a770e750c0031cdad447a7d31fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a515bd52a87e3b90c746742adae859ab7"><td class="memTemplParams" colspan="2">template&lt;typename R , typename T , size_t I = 0&gt; </td></tr>
<tr class="memitem:a515bd52a87e3b90c746742adae859ab7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::detail::enable_if&lt;(I&lt; <a class="el" href="namespacehydra.html#a58298133d4826dc6f35253762a7d6788">hydra::thrust::tuple_size</a>&lt; T &gt;::value), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a515bd52a87e3b90c746742adae859ab7">hydra::detail::_get_element</a> (const size_t index, T &amp;t, R *&amp;ptr)</td></tr>
<tr class="separator:a515bd52a87e3b90c746742adae859ab7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c75fa87187777181601014b9e4a1f62"><td class="memTemplParams" colspan="2">template&lt;typename TupleType , typename ArrayType , size_t I&gt; </td></tr>
<tr class="memitem:a6c75fa87187777181601014b9e4a1f62"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::detail::enable_if&lt; I==<a class="el" href="namespacehydra.html#a58298133d4826dc6f35253762a7d6788">hydra::thrust::tuple_size</a>&lt; TupleType &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail_1_1utils.html#a6c75fa87187777181601014b9e4a1f62">hydra::detail::utils::_tuple_to_array</a> (TupleType const &amp;, ArrayType *)</td></tr>
<tr class="separator:a6c75fa87187777181601014b9e4a1f62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31bfd6894ad39b66da15df4dc436d35e"><td class="memTemplParams" colspan="2">template&lt;typename Return_Type , typename ArgType , typename ... Tp, typename  = typename hydra::thrust::detail::enable_if&lt;std::is_convertible&lt;Return_Type, double&gt;::value || std::is_constructible&lt;hydra::thrust::complex&lt;double&gt;,Return_Type&gt;::value &gt;::type&gt; </td></tr>
<tr class="memitem:a31bfd6894ad39b66da15df4dc436d35e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> Return_Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a31bfd6894ad39b66da15df4dc436d35e">hydra::detail::accumulate</a> (ArgType &amp;x, <a class="el" href="namespacehydra.html#ac3486502b2db72187626125cea971683">hydra::thrust::tuple</a>&lt; Tp... &gt; &amp;t)</td></tr>
<tr class="separator:a31bfd6894ad39b66da15df4dc436d35e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06d87d0383479101350ee8934d7fcdf2"><td class="memTemplParams" colspan="2">template&lt;typename Return_Type , typename ArgType , typename ... Tp, typename  = typename hydra::thrust::detail::enable_if&lt;std::is_convertible&lt;Return_Type, double&gt;::value || std::is_constructible&lt;hydra::thrust::complex&lt;double&gt;,Return_Type&gt;::value &gt;::type&gt; </td></tr>
<tr class="memitem:a06d87d0383479101350ee8934d7fcdf2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> Return_Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a06d87d0383479101350ee8934d7fcdf2">hydra::detail::accumulate</a> (ArgType const &amp;x, <a class="el" href="namespacehydra.html#ac3486502b2db72187626125cea971683">hydra::thrust::tuple</a>&lt; Tp... &gt; const &amp;t)</td></tr>
<tr class="separator:a06d87d0383479101350ee8934d7fcdf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b42783cc9a200f4083295d1e2cfd374"><td class="memTemplParams" colspan="2">template&lt;typename Return_Type , typename ArgType1 , typename ArgType2 , typename ... Tp, typename  = typename hydra::thrust::detail::enable_if&lt;std::is_convertible&lt;Return_Type, double&gt;::value || std::is_constructible&lt;hydra::thrust::complex&lt;double&gt;,Return_Type&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a9b42783cc9a200f4083295d1e2cfd374"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> Return_Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a9b42783cc9a200f4083295d1e2cfd374">hydra::detail::accumulate2</a> (ArgType1 &amp;x, ArgType2 &amp;y, <a class="el" href="namespacehydra.html#ac3486502b2db72187626125cea971683">hydra::thrust::tuple</a>&lt; Tp... &gt; &amp;t)</td></tr>
<tr class="separator:a9b42783cc9a200f4083295d1e2cfd374"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a966cab74d28014bd9c6c90524a933f53"><td class="memTemplParams" colspan="2">template&lt;typename Return_Type , typename ArgType1 , typename ArgType2 , typename ... Tp, typename  = typename hydra::thrust::detail::enable_if&lt;std::is_convertible&lt;Return_Type, double&gt;::value || std::is_constructible&lt;hydra::thrust::complex&lt;double&gt;,Return_Type&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a966cab74d28014bd9c6c90524a933f53"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> Return_Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a966cab74d28014bd9c6c90524a933f53">hydra::detail::accumulate2</a> (ArgType1 const &amp;x, ArgType2 const &amp;y, <a class="el" href="namespacehydra.html#ac3486502b2db72187626125cea971683">hydra::thrust::tuple</a>&lt; Tp... &gt; const &amp;t)</td></tr>
<tr class="separator:a966cab74d28014bd9c6c90524a933f53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5e05e95babbc9b3610158ca245e9ea9"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename ... Tp&gt; </td></tr>
<tr class="memitem:ad5e05e95babbc9b3610158ca245e9ea9"><td class="memTemplItemLeft" align="right" valign="top">hydra::thrust::detail::enable_if&lt; I==sizeof...(Tp), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#ad5e05e95babbc9b3610158ca245e9ea9">hydra::detail::add_parameters_in_tuple</a> (std::vector&lt; <a class="el" href="group__fit.html#structhydra_1_1Parameter">hydra::Parameter</a> *&gt; &amp;, <a class="el" href="namespacehydra.html#ac3486502b2db72187626125cea971683">hydra::thrust::tuple</a>&lt; Tp... &gt; &amp;)</td></tr>
<tr class="separator:ad5e05e95babbc9b3610158ca245e9ea9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ec0b20f1c76a09e6f8c20bff1b1606f"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename ... Tp&gt; </td></tr>
<tr class="memitem:a7ec0b20f1c76a09e6f8c20bff1b1606f"><td class="memTemplItemLeft" align="right" valign="top">hydra::thrust::detail::enable_if&lt;(I&lt; sizeof...(Tp)), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a7ec0b20f1c76a09e6f8c20bff1b1606f">hydra::detail::add_parameters_in_tuple</a> (std::vector&lt; <a class="el" href="group__fit.html#structhydra_1_1Parameter">hydra::Parameter</a> *&gt; &amp;user_parameters, <a class="el" href="namespacehydra.html#ac3486502b2db72187626125cea971683">hydra::thrust::tuple</a>&lt; Tp... &gt; &amp;t)</td></tr>
<tr class="separator:a7ec0b20f1c76a09e6f8c20bff1b1606f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47ca3e1e60cf87925082ffecc2ffc189"><td class="memTemplParams" colspan="2">template&lt;size_t I, typename ... T&gt; </td></tr>
<tr class="memitem:a47ca3e1e60cf87925082ffecc2ffc189"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::detail::enable_if&lt;(I==sizeof...(T)), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a47ca3e1e60cf87925082ffecc2ffc189">hydra::detail::add_tuple_values</a> (GReal_t &amp;, <a class="el" href="namespacehydra.html#ac3486502b2db72187626125cea971683">hydra::thrust::tuple</a>&lt; T... &gt; const &amp;)</td></tr>
<tr class="separator:a47ca3e1e60cf87925082ffecc2ffc189"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af386c271b963d41d9cfc54fe76a0d581"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename ... T&gt; </td></tr>
<tr class="memitem:af386c271b963d41d9cfc54fe76a0d581"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::detail::enable_if&lt;(I&lt; sizeof...(T)), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#af386c271b963d41d9cfc54fe76a0d581">hydra::detail::add_tuple_values</a> (GReal_t &amp;result, <a class="el" href="namespacehydra.html#ac3486502b2db72187626125cea971683">hydra::thrust::tuple</a>&lt; T... &gt; const &amp;tpl)</td></tr>
<tr class="separator:af386c271b963d41d9cfc54fe76a0d581"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fb09f08e05c59f9cb8f7810677b0a35"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N&gt; </td></tr>
<tr class="memitem:a2fb09f08e05c59f9cb8f7810677b0a35"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a2fb09f08e05c59f9cb8f7810677b0a35">hydra::detail::arrayToTuple</a> (std::array&lt; T, N &gt;const &amp;Array) -&gt; decltype(arrayToTupleHelper(Array, make_index_sequence&lt; N &gt;</td></tr>
<tr class="separator:a2fb09f08e05c59f9cb8f7810677b0a35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d0da29f0be34c5fe0f79e47b6963340"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N&gt; </td></tr>
<tr class="memitem:a9d0da29f0be34c5fe0f79e47b6963340"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a9d0da29f0be34c5fe0f79e47b6963340">hydra::detail::arrayToTuple</a> (T *Array) -&gt; decltype(arrayToTupleHelper(Array, make_index_sequence&lt; N &gt;</td></tr>
<tr class="separator:a9d0da29f0be34c5fe0f79e47b6963340"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad94bd46c688eb458dde424609df5dae"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t... Is&gt; </td></tr>
<tr class="memitem:aad94bd46c688eb458dde424609df5dae"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#aad94bd46c688eb458dde424609df5dae">hydra::detail::arrayToTupleHelper</a> (std::array&lt; T, sizeof...(Is)&gt;const &amp;Array, index_sequence&lt; Is... &gt;) -&gt; decltype(<a class="el" href="namespacehydra.html#ae9e1c8df3eaea2b9e4646c5dcdeaf322">hydra::thrust::make_tuple</a>(Array[Is]...))</td></tr>
<tr class="separator:aad94bd46c688eb458dde424609df5dae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6551302bfdad575a3f6a01b57d14f0d"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t... Indices&gt; </td></tr>
<tr class="memitem:ab6551302bfdad575a3f6a01b57d14f0d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#ab6551302bfdad575a3f6a01b57d14f0d">hydra::detail::arrayToTupleHelper</a> (T *Array, index_sequence&lt; Indices... &gt;) -&gt; decltype(<a class="el" href="namespacehydra.html#ae9e1c8df3eaea2b9e4646c5dcdeaf322">hydra::thrust::make_tuple</a>(Array[Indices]...))</td></tr>
<tr class="separator:ab6551302bfdad575a3f6a01b57d14f0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81d062e40531f7b09a8926d642ba2032"><td class="memTemplParams" colspan="2">template&lt;size_t I, typename ArrayType , typename FistType , typename ... OtherTypes&gt; </td></tr>
<tr class="memitem:a81d062e40531f7b09a8926d642ba2032"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::detail::enable_if&lt; I==(sizeof...(OtherTypes)+1) &amp;&amp;std::is_convertible&lt; FistType, ArrayType &gt;::value &amp;&amp;all_true&lt; std::is_convertible&lt; OtherTypes, ArrayType &gt;::value... &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a81d062e40531f7b09a8926d642ba2032">hydra::detail::assignArrayToTuple</a> (<a class="el" href="namespacehydra.html#ac3486502b2db72187626125cea971683">hydra::thrust::tuple</a>&lt; FistType, OtherTypes... &gt; &amp;, ArrayType const *)</td></tr>
<tr class="separator:a81d062e40531f7b09a8926d642ba2032"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a688c325b220c8fa30f5790d636183eca"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename ArrayType , typename FistType , typename ... OtherTypes&gt; </td></tr>
<tr class="memitem:a688c325b220c8fa30f5790d636183eca"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::detail::enable_if&lt;(I&lt; sizeof...(OtherTypes)+1) &amp;&amp;std::is_convertible&lt; FistType, ArrayType &gt;::value &amp;&amp;all_true&lt; std::is_convertible&lt; OtherTypes, ArrayType &gt;::value... &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a688c325b220c8fa30f5790d636183eca">hydra::detail::assignArrayToTuple</a> (<a class="el" href="namespacehydra.html#ac3486502b2db72187626125cea971683">hydra::thrust::tuple</a>&lt; FistType, OtherTypes... &gt; &amp;t, ArrayType const *Array)</td></tr>
<tr class="separator:a688c325b220c8fa30f5790d636183eca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a240c9e228115543008d63b6e21f300ea"><td class="memTemplParams" colspan="2">template&lt;size_t I, typename ArrayType , typename FistType , typename ... OtherTypes&gt; </td></tr>
<tr class="memitem:a240c9e228115543008d63b6e21f300ea"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::detail::enable_if&lt; I==(sizeof...(OtherTypes)+1) &amp;&amp;std::is_convertible&lt; FistType, ArrayType &gt;::value &amp;&amp;all_true&lt; std::is_convertible&lt; OtherTypes, ArrayType &gt;::value... &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a240c9e228115543008d63b6e21f300ea">hydra::detail::assignArrayToTuple</a> (hydra::thrust::detail::tuple_of_iterator_references&lt; FistType, OtherTypes... &gt; &amp;, ArrayType const *)</td></tr>
<tr class="separator:a240c9e228115543008d63b6e21f300ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed9ce2a67e87b89e2bacaeac434fc5a8"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename ArrayType , typename FistType , typename ... OtherTypes&gt; </td></tr>
<tr class="memitem:aed9ce2a67e87b89e2bacaeac434fc5a8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::detail::enable_if&lt;(I&lt; sizeof...(OtherTypes)+1) &amp;&amp;std::is_convertible&lt; FistType, ArrayType &gt;::value &amp;&amp;all_true&lt; std::is_convertible&lt; OtherTypes, ArrayType &gt;::value... &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#aed9ce2a67e87b89e2bacaeac434fc5a8">hydra::detail::assignArrayToTuple</a> (hydra::thrust::detail::tuple_of_iterator_references&lt; FistType, OtherTypes... &gt; &amp;t, ArrayType const *Array)</td></tr>
<tr class="separator:aed9ce2a67e87b89e2bacaeac434fc5a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d6f9257e6380f1890e0b7adc0190747"><td class="memTemplParams" colspan="2">template&lt;size_t I, typename Type , typename Head , typename ... Tail&gt; </td></tr>
<tr class="memitem:a3d6f9257e6380f1890e0b7adc0190747"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> std::enable_if&lt;(I==sizeof...(Tail)+1) &amp;&amp;std::is_convertible&lt; Head, Type &gt;::value &amp;&amp;all_true&lt; std::is_convertible&lt; Tail, Type &gt;::value ... &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a3d6f9257e6380f1890e0b7adc0190747">hydra::detail::assignTupleToArray</a> (<a class="el" href="namespacehydra.html#ac3486502b2db72187626125cea971683">hydra::thrust::tuple</a>&lt; Head, Tail... &gt; const &amp;, Type(&amp;)[sizeof...(Tail)+1])</td></tr>
<tr class="separator:a3d6f9257e6380f1890e0b7adc0190747"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3b86512e9cd5ea9ed988e099f5c54b4"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename Type , typename Head , typename ... Tail&gt; </td></tr>
<tr class="memitem:ac3b86512e9cd5ea9ed988e099f5c54b4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> std::enable_if&lt;(I&lt; sizeof...(Tail)+1) &amp;&amp;std::is_convertible&lt; Head, Type &gt;::value &amp;&amp;all_true&lt; std::is_convertible&lt; Tail, Type &gt;::value ... &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#ac3b86512e9cd5ea9ed988e099f5c54b4">hydra::detail::assignTupleToArray</a> (<a class="el" href="namespacehydra.html#ac3486502b2db72187626125cea971683">hydra::thrust::tuple</a>&lt; Head, Tail... &gt; const &amp;Tuple, Type(&amp;Array)[sizeof...(Tail)+1])</td></tr>
<tr class="separator:ac3b86512e9cd5ea9ed988e099f5c54b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a713732dd6592045a450b169e34ef956c"><td class="memTemplParams" colspan="2">template&lt;size_t I, typename Type , typename Head , typename ... Tail&gt; </td></tr>
<tr class="memitem:a713732dd6592045a450b169e34ef956c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> std::enable_if&lt;(I==sizeof...(Tail)+1) &amp;&amp;std::is_convertible&lt; Head, Type &gt;::value &amp;&amp;all_true&lt; std::is_convertible&lt; Tail, Type &gt;::value ... &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a713732dd6592045a450b169e34ef956c">hydra::detail::assignTupleToArray</a> (<a class="el" href="namespacehydra.html#ac3486502b2db72187626125cea971683">hydra::thrust::tuple</a>&lt; Head, Tail... &gt; const &amp;, std::array&lt; Type, sizeof...(Tail)+1 &gt; &amp;)</td></tr>
<tr class="separator:a713732dd6592045a450b169e34ef956c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31af39400225fa9e9ff79a3b802e73d0"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename Type , typename Head , typename ... Tail&gt; </td></tr>
<tr class="memitem:a31af39400225fa9e9ff79a3b802e73d0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> std::enable_if&lt;(I&lt; sizeof...(Tail)+1) &amp;&amp;std::is_convertible&lt; Head, Type &gt;::value &amp;&amp;all_true&lt; std::is_convertible&lt; Tail, Type &gt;::value ... &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a31af39400225fa9e9ff79a3b802e73d0">hydra::detail::assignTupleToArray</a> (<a class="el" href="namespacehydra.html#ac3486502b2db72187626125cea971683">hydra::thrust::tuple</a>&lt; Head, Tail... &gt; const &amp;Tuple, std::array&lt; Type, sizeof...(Tail)+1 &gt; &amp;Array)</td></tr>
<tr class="separator:a31af39400225fa9e9ff79a3b802e73d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a857673d7a6d3e5e5da3891670a276c6e"><td class="memTemplParams" colspan="2">template&lt;size_t I, typename Type , typename Head , typename ... Tail&gt; </td></tr>
<tr class="memitem:a857673d7a6d3e5e5da3891670a276c6e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> std::enable_if&lt;(I==sizeof...(Tail)+1) &amp;&amp;std::is_convertible&lt; typename remove_device_reference&lt; Head &gt;::type, Type &gt;::value &amp;&amp;all_true&lt; std::is_convertible&lt; typename remove_device_reference&lt; Tail &gt;::type, Type &gt;::value ... &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a857673d7a6d3e5e5da3891670a276c6e">hydra::detail::assignTupleToArray</a> (hydra::thrust::detail::tuple_of_iterator_references&lt; Head, Tail... &gt; const &amp;, Type(&amp;)[sizeof...(Tail)+1])</td></tr>
<tr class="separator:a857673d7a6d3e5e5da3891670a276c6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23efaec2eb9afcba167ec112900bd809"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename Type , typename Head , typename ... Tail&gt; </td></tr>
<tr class="memitem:a23efaec2eb9afcba167ec112900bd809"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> std::enable_if&lt;(I&lt; sizeof...(Tail)+1) &amp;&amp;std::is_convertible&lt; typename remove_device_reference&lt; Head &gt;::type, Type &gt;::value &amp;&amp;all_true&lt; std::is_convertible&lt; typename remove_device_reference&lt; Tail &gt;::type, Type &gt;::value ... &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a23efaec2eb9afcba167ec112900bd809">hydra::detail::assignTupleToArray</a> (hydra::thrust::detail::tuple_of_iterator_references&lt; Head, Tail... &gt; const &amp;Tuple, Type(&amp;Array)[sizeof...(Tail)+1])</td></tr>
<tr class="separator:a23efaec2eb9afcba167ec112900bd809"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9eba02ade1dc8fad3c8a812861d1f51"><td class="memTemplParams" colspan="2">template&lt;size_t I, typename Type , typename Head , typename ... Tail&gt; </td></tr>
<tr class="memitem:ab9eba02ade1dc8fad3c8a812861d1f51"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> std::enable_if&lt;(I==sizeof...(Tail)+1) &amp;&amp;std::is_convertible&lt; typename remove_device_reference&lt; Head &gt;::type, Type &gt;::value &amp;&amp;all_true&lt; std::is_convertible&lt; typename remove_device_reference&lt; Tail &gt;::type, Type &gt;::value ... &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#ab9eba02ade1dc8fad3c8a812861d1f51">hydra::detail::assignTupleToArray</a> (hydra::thrust::detail::tuple_of_iterator_references&lt; Head, Tail... &gt; const &amp;, std::array&lt; Type, sizeof...(Tail)+1 &gt; &amp;)</td></tr>
<tr class="separator:ab9eba02ade1dc8fad3c8a812861d1f51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b8e2c32f19fd47e9ca64e2cc2352c55"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename Type , typename Head , typename ... Tail&gt; </td></tr>
<tr class="memitem:a9b8e2c32f19fd47e9ca64e2cc2352c55"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> std::enable_if&lt;(I&lt; sizeof...(Tail)+1) &amp;&amp;std::is_convertible&lt; typename remove_device_reference&lt; Head &gt;::type, Type &gt;::value &amp;&amp;all_true&lt; std::is_convertible&lt; typename remove_device_reference&lt; Tail &gt;::type, Type &gt;::value ... &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a9b8e2c32f19fd47e9ca64e2cc2352c55">hydra::detail::assignTupleToArray</a> (hydra::thrust::detail::tuple_of_iterator_references&lt; Head, Tail... &gt; const &amp;Tuple, std::array&lt; Type, sizeof...(Tail)+1 &gt; &amp;Array)</td></tr>
<tr class="separator:a9b8e2c32f19fd47e9ca64e2cc2352c55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa48b8114dfe40b2ad9f15962fca73873"><td class="memTemplParams" colspan="2">template&lt;unsigned int I = 0, typename FuncT , typename ... Tp&gt; </td></tr>
<tr class="memitem:aa48b8114dfe40b2ad9f15962fca73873"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::detail::enable_if&lt; I==sizeof...(Tp), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#aa48b8114dfe40b2ad9f15962fca73873">hydra::detail::eval_on_tuple_element</a> (<a class="el" href="namespace_3globalScope_4.html#classint">int</a>, <a class="el" href="namespacehydra.html#ac3486502b2db72187626125cea971683">hydra::thrust::tuple</a>&lt; Tp... &gt; const &amp;, FuncT const &amp;)</td></tr>
<tr class="separator:aa48b8114dfe40b2ad9f15962fca73873"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa22e275cf1dc4aa0553815e5a403afe9"><td class="memTemplParams" colspan="2">template&lt;unsigned int I = 0, typename FuncT , typename ... Tp&gt; </td></tr>
<tr class="memitem:aa22e275cf1dc4aa0553815e5a403afe9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::detail::enable_if&lt;(I&lt; sizeof...(Tp)), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#aa22e275cf1dc4aa0553815e5a403afe9">hydra::detail::eval_on_tuple_element</a> (<a class="el" href="namespace_3globalScope_4.html#classint">int</a> index, <a class="el" href="namespacehydra.html#ac3486502b2db72187626125cea971683">hydra::thrust::tuple</a>&lt; Tp... &gt; const &amp;t, FuncT const &amp;f)</td></tr>
<tr class="separator:aa22e275cf1dc4aa0553815e5a403afe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c36121fc4ff640d4bb5e46df8fab18a"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename Return_Type , typename ArgType , typename ... Tp&gt; </td></tr>
<tr class="memitem:a5c36121fc4ff640d4bb5e46df8fab18a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::detail::enable_if&lt; I==sizeof...(Tp), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a5c36121fc4ff640d4bb5e46df8fab18a">hydra::detail::eval_tuple_element</a> (Return_Type &amp;, <a class="el" href="namespace_3globalScope_4.html#classint">int</a>, <a class="el" href="namespacehydra.html#ac3486502b2db72187626125cea971683">hydra::thrust::tuple</a>&lt; Tp... &gt; const &amp;, ArgType const &amp;)</td></tr>
<tr class="separator:a5c36121fc4ff640d4bb5e46df8fab18a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a822da880b13448285790c6d029454a4f"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename Return_Type , typename ArgType , typename ... Tp&gt; </td></tr>
<tr class="memitem:a822da880b13448285790c6d029454a4f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::detail::enable_if&lt;(I&lt; sizeof...(Tp)), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a822da880b13448285790c6d029454a4f">hydra::detail::eval_tuple_element</a> (Return_Type &amp;r, <a class="el" href="namespace_3globalScope_4.html#classint">int</a> index, <a class="el" href="namespacehydra.html#ac3486502b2db72187626125cea971683">hydra::thrust::tuple</a>&lt; Tp... &gt; const &amp;t, ArgType const &amp;arg)</td></tr>
<tr class="separator:a822da880b13448285790c6d029454a4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96a946dad2a4b9f834836d9b954ad8b6"><td class="memTemplParams" colspan="2">template&lt;typename Type , typename Tuple &gt; </td></tr>
<tr class="memitem:a96a946dad2a4b9f834836d9b954ad8b6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a96a946dad2a4b9f834836d9b954ad8b6">hydra::detail::extract</a> (const <a class="el" href="namespace_3globalScope_4.html#classint">int</a> idx, const Tuple &amp;t)</td></tr>
<tr class="separator:a96a946dad2a4b9f834836d9b954ad8b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3128d1411d3b961132470fbad5761721"><td class="memTemplParams" colspan="2">template&lt;typename R , typename ... T&gt; </td></tr>
<tr class="memitem:a3128d1411d3b961132470fbad5761721"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> R &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a3128d1411d3b961132470fbad5761721">hydra::detail::get_element</a> (const size_t index, <a class="el" href="namespacehydra.html#ac3486502b2db72187626125cea971683">hydra::thrust::tuple</a>&lt; T... &gt; &amp;t)</td></tr>
<tr class="separator:a3128d1411d3b961132470fbad5761721"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a602cafd73a2e5770fad6ee90d555e0e0"><td class="memTemplParams" colspan="2">template&lt;unsigned int I = 0, typename T , typename ... Tp&gt; </td></tr>
<tr class="memitem:a602cafd73a2e5770fad6ee90d555e0e0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::detail::enable_if&lt; I==sizeof...(Tp), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a602cafd73a2e5770fad6ee90d555e0e0">hydra::detail::get_tuple_element</a> (const <a class="el" href="namespace_3globalScope_4.html#classint">int</a>, <a class="el" href="namespacehydra.html#ac3486502b2db72187626125cea971683">hydra::thrust::tuple</a>&lt; Tp... &gt; const &amp;, T &amp;)</td></tr>
<tr class="separator:a602cafd73a2e5770fad6ee90d555e0e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18ad8af35017817d42f421ba36a832b9"><td class="memTemplParams" colspan="2">template&lt;unsigned int I = 0, typename T , typename ... Tp&gt; </td></tr>
<tr class="memitem:a18ad8af35017817d42f421ba36a832b9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::detail::enable_if&lt;(I&lt; sizeof...(Tp)), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a18ad8af35017817d42f421ba36a832b9">hydra::detail::get_tuple_element</a> (const <a class="el" href="namespace_3globalScope_4.html#classint">int</a> index, <a class="el" href="namespacehydra.html#ac3486502b2db72187626125cea971683">hydra::thrust::tuple</a>&lt; Tp... &gt; const &amp;t, T &amp;x)</td></tr>
<tr class="separator:a18ad8af35017817d42f421ba36a832b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a227e0b524804a0ceef56b4a1da1953d4"><td class="memTemplParams" colspan="2">template&lt;typename Iterator , size_t N&gt; </td></tr>
<tr class="memitem:a227e0b524804a0ceef56b4a1da1953d4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a227e0b524804a0ceef56b4a1da1953d4">hydra::detail::get_zip_iterator</a> (std::array&lt; Iterator, N &gt;const &amp;array_of_iterators) -&gt; decltype(get_zip_iterator_helper(array_of_iterators, make_index_sequence&lt; N &gt;</td></tr>
<tr class="separator:a227e0b524804a0ceef56b4a1da1953d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9da0535b5305aaf5cfe698c42ebc8d6"><td class="memTemplParams" colspan="2">template&lt;typename IteratorHead , typename IteratorTail , size_t N&gt; </td></tr>
<tr class="memitem:ae9da0535b5305aaf5cfe698c42ebc8d6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#ae9da0535b5305aaf5cfe698c42ebc8d6">hydra::detail::get_zip_iterator</a> (IteratorHead head, std::array&lt; IteratorTail, N &gt;const &amp;array_of_iterators) -&gt; decltype(get_zip_iterator_helper(head, array_of_iterators, make_index_sequence&lt; N &gt;</td></tr>
<tr class="separator:ae9da0535b5305aaf5cfe698c42ebc8d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70f2fe29b87457d99a58eb0025bf88dd"><td class="memTemplParams" colspan="2">template&lt;typename Iterator , size_t ... Index&gt; </td></tr>
<tr class="memitem:a70f2fe29b87457d99a58eb0025bf88dd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a70f2fe29b87457d99a58eb0025bf88dd">hydra::detail::get_zip_iterator_helper</a> (std::array&lt; Iterator, sizeof ...(Index)&gt;const &amp;array_of_iterators, index_sequence&lt; Index... &gt;) -&gt; decltype(hydra::thrust::make_zip_iterator(<a class="el" href="namespacehydra.html#ae9e1c8df3eaea2b9e4646c5dcdeaf322">hydra::thrust::make_tuple</a>(array_of_iterators[Index]...)))</td></tr>
<tr class="separator:a70f2fe29b87457d99a58eb0025bf88dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a935492c6993543ddd346a1ce0bb1e2"><td class="memTemplParams" colspan="2">template&lt;typename IteratorHead , typename IteratorTail , size_t ... Index&gt; </td></tr>
<tr class="memitem:a8a935492c6993543ddd346a1ce0bb1e2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a8a935492c6993543ddd346a1ce0bb1e2">hydra::detail::get_zip_iterator_helper</a> (IteratorHead head, std::array&lt; IteratorTail, sizeof ...(Index)&gt;const &amp;array_of_iterators, index_sequence&lt; Index... &gt;) -&gt; decltype(hydra::thrust::make_zip_iterator(<a class="el" href="namespacehydra.html#ae9e1c8df3eaea2b9e4646c5dcdeaf322">hydra::thrust::make_tuple</a>(head, array_of_iterators[Index]...)))</td></tr>
<tr class="separator:a8a935492c6993543ddd346a1ce0bb1e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b30f3961b7f4ed7c28a4e1373281c1c"><td class="memTemplParams" colspan="2">template&lt;typename Tup , typename ArgType , size_t N = hydra::thrust::tuple_size&lt;typename hydra::thrust::detail::remove_reference&lt;Tup&gt;::type&gt;::value&gt; </td></tr>
<tr class="memitem:a0b30f3961b7f4ed7c28a4e1373281c1c"><td class="memTemplItemLeft" align="right" valign="top">__hydra_thrust_exec_check_disable__ <a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a0b30f3961b7f4ed7c28a4e1373281c1c">hydra::detail::invoke</a> (ArgType &amp;&amp;x, Tup &amp;&amp;tup) -&gt; decltype(invoke_helper(std::forward&lt; ArgType &gt;(x), std::forward&lt; Tup &gt;(tup), make_index_sequence&lt; N &gt;</td></tr>
<tr class="separator:a0b30f3961b7f4ed7c28a4e1373281c1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad31b6d1499b5a6b2d77c015a71385a6e"><td class="memTemplParams" colspan="2">template&lt;typename Tup , typename ArgType , size_t N = hydra::thrust::tuple_size&lt;typename hydra::thrust::detail::remove_reference&lt;Tup&gt;::type&gt;::value&gt; </td></tr>
<tr class="memitem:ad31b6d1499b5a6b2d77c015a71385a6e"><td class="memTemplItemLeft" align="right" valign="top">__hydra_thrust_exec_check_disable__ <a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#ad31b6d1499b5a6b2d77c015a71385a6e">hydra::detail::invoke</a> (ArgType const &amp;x, Tup const &amp;tup) -&gt; decltype(invoke_helper(x, tup, make_index_sequence&lt; N &gt;</td></tr>
<tr class="separator:ad31b6d1499b5a6b2d77c015a71385a6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7367f21b0df25c033551a4f2a88b9f7"><td class="memTemplParams" colspan="2">template&lt;typename Tup , typename ArgType1 , typename ArgType2 , size_t N = hydra::thrust::tuple_size&lt;typename hydra::thrust::detail::remove_reference&lt;Tup&gt;::type&gt;::value&gt; </td></tr>
<tr class="memitem:ab7367f21b0df25c033551a4f2a88b9f7"><td class="memTemplItemLeft" align="right" valign="top">__hydra_thrust_exec_check_disable__ <a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#ab7367f21b0df25c033551a4f2a88b9f7">hydra::detail::invoke</a> (ArgType1 &amp;&amp;x, ArgType2 &amp;&amp;y, Tup &amp;&amp;tup) -&gt; decltype(invoke_helper(std::forward&lt; ArgType1 &gt;(x), std::forward&lt; ArgType2 &gt;(y), std::forward&lt; Tup &gt;(tup), make_index_sequence&lt; <a class="el" href="namespacehydra.html#a58298133d4826dc6f35253762a7d6788">hydra::thrust::tuple_size</a>&lt; Tup &gt;::value &gt;</td></tr>
<tr class="separator:ab7367f21b0df25c033551a4f2a88b9f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12930cc3363cf266694e4e13077758de"><td class="memTemplParams" colspan="2">template&lt;typename Tup , typename ArgType1 , typename ArgType2 &gt; </td></tr>
<tr class="memitem:a12930cc3363cf266694e4e13077758de"><td class="memTemplItemLeft" align="right" valign="top">__hydra_thrust_exec_check_disable__ <a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a12930cc3363cf266694e4e13077758de">hydra::detail::invoke</a> (ArgType1 const &amp;x, ArgType2 const &amp;y, Tup const &amp;tup) -&gt; decltype(invoke_helper(x, y, tup, make_index_sequence&lt; <a class="el" href="namespacehydra.html#a58298133d4826dc6f35253762a7d6788">hydra::thrust::tuple_size</a>&lt; Tup &gt;::value &gt;</td></tr>
<tr class="separator:a12930cc3363cf266694e4e13077758de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15800958694e9465ff44c60dae36d25b"><td class="memTemplParams" colspan="2">template&lt;typename Tup , typename ArgType , size_t ... index&gt; </td></tr>
<tr class="memitem:a15800958694e9465ff44c60dae36d25b"><td class="memTemplItemLeft" align="right" valign="top">__hydra_thrust_exec_check_disable__ <a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a15800958694e9465ff44c60dae36d25b">hydra::detail::invoke_helper</a> (ArgType &amp;&amp;x, Tup &amp;&amp;tup, index_sequence&lt; index... &gt;) -&gt; decltype(<a class="el" href="namespacehydra.html#ae9e1c8df3eaea2b9e4646c5dcdeaf322">hydra::thrust::make_tuple</a>(<a class="el" href="namespacehydra.html#a2658beb74af1f617373f6f640e2949e4">hydra::thrust::get</a>&lt; index &gt;(std::forward&lt; Tup &gt;(tup))(std::forward&lt; ArgType &gt;(x))...))</td></tr>
<tr class="separator:a15800958694e9465ff44c60dae36d25b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78cc12c7ba49afe6f1ad39c31d705758"><td class="memTemplParams" colspan="2">template&lt;typename Tup , typename ArgType , size_t ... index&gt; </td></tr>
<tr class="memitem:a78cc12c7ba49afe6f1ad39c31d705758"><td class="memTemplItemLeft" align="right" valign="top">__hydra_thrust_exec_check_disable__ <a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a78cc12c7ba49afe6f1ad39c31d705758">hydra::detail::invoke_helper</a> (ArgType const &amp;x, Tup const &amp;tup, index_sequence&lt; index... &gt;) -&gt; decltype(<a class="el" href="namespacehydra.html#ae9e1c8df3eaea2b9e4646c5dcdeaf322">hydra::thrust::make_tuple</a>(<a class="el" href="namespacehydra.html#a2658beb74af1f617373f6f640e2949e4">hydra::thrust::get</a>&lt; index &gt;(tup)(x)...))</td></tr>
<tr class="separator:a78cc12c7ba49afe6f1ad39c31d705758"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38971d6835214e8b68e4d05ec01a8360"><td class="memTemplParams" colspan="2">template&lt;typename Tup , typename ArgType1 , typename ArgType2 , size_t ... index&gt; </td></tr>
<tr class="memitem:a38971d6835214e8b68e4d05ec01a8360"><td class="memTemplItemLeft" align="right" valign="top">__hydra_thrust_exec_check_disable__ <a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a38971d6835214e8b68e4d05ec01a8360">hydra::detail::invoke_helper</a> (ArgType1 &amp;&amp;x, ArgType2 &amp;&amp;y, Tup &amp;&amp;tup, index_sequence&lt; index... &gt;) -&gt; decltype(<a class="el" href="namespacehydra.html#ae9e1c8df3eaea2b9e4646c5dcdeaf322">hydra::thrust::make_tuple</a>(<a class="el" href="namespacehydra.html#a2658beb74af1f617373f6f640e2949e4">hydra::thrust::get</a>&lt; index &gt;(std::forward&lt; Tup &gt;(tup))(std::forward&lt; ArgType1 &gt;(x), std::forward&lt; ArgType2 &gt;(y))...))</td></tr>
<tr class="separator:a38971d6835214e8b68e4d05ec01a8360"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12be32d2ba8df4c278c368d8df150084"><td class="memTemplParams" colspan="2">template&lt;typename Tup , typename ArgType1 , typename ArgType2 , size_t ... index&gt; </td></tr>
<tr class="memitem:a12be32d2ba8df4c278c368d8df150084"><td class="memTemplItemLeft" align="right" valign="top">__hydra_thrust_exec_check_disable__ <a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a12be32d2ba8df4c278c368d8df150084">hydra::detail::invoke_helper</a> (ArgType1 const &amp;x, ArgType2 const &amp;y, Tup const &amp;tup, index_sequence&lt; index... &gt;) -&gt; decltype(<a class="el" href="namespacehydra.html#ae9e1c8df3eaea2b9e4646c5dcdeaf322">hydra::thrust::make_tuple</a>(<a class="el" href="namespacehydra.html#a2658beb74af1f617373f6f640e2949e4">hydra::thrust::get</a>&lt; index &gt;(tup)(x, y)...))</td></tr>
<tr class="separator:a12be32d2ba8df4c278c368d8df150084"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9360a30d9cffc4d39b34187a56f0bb92"><td class="memItemLeft" align="right" valign="top"><a class="el" href="basic__distributions_8inl.html#a9717e7bbecb906637e86cef6da3d83c2">return</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a9360a30d9cffc4d39b34187a56f0bb92">hydra::detail::invoke_helper</a> (x, y, tup, make_index_sequence&lt; Size &gt; { })</td></tr>
<tr class="separator:a9360a30d9cffc4d39b34187a56f0bb92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cf84b4edaeb303174a32a9d9ee44e39"><td class="memTemplParams" colspan="2">template&lt;typename Tup , typename ArgType &gt; </td></tr>
<tr class="memitem:a9cf84b4edaeb303174a32a9d9ee44e39"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a9cf84b4edaeb303174a32a9d9ee44e39">hydra::detail::invoke_normalized</a> (ArgType const &amp;x, Tup const &amp;tup) -&gt; decltype(invoke_helper(x, tup, make_index_sequence&lt; <a class="el" href="namespacehydra.html#a58298133d4826dc6f35253762a7d6788">hydra::thrust::tuple_size</a>&lt; Tup &gt;::value &gt;</td></tr>
<tr class="separator:a9cf84b4edaeb303174a32a9d9ee44e39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4c0051b20d34181994aa5560387054e"><td class="memTemplParams" colspan="2">template&lt;typename Tup , typename ArgType , size_t N = hydra::thrust::tuple_size&lt;typename hydra::thrust::detail::remove_reference&lt;Tup&gt;::type&gt;::value&gt; </td></tr>
<tr class="memitem:af4c0051b20d34181994aa5560387054e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#af4c0051b20d34181994aa5560387054e">hydra::detail::invoke_normalized</a> (ArgType &amp;&amp;x, Tup &amp;&amp;tup) -&gt; decltype(invoke_helper(std::forward&lt; ArgType &gt;(x), std::forward&lt; Tup &gt;(tup), make_index_sequence&lt; N &gt;</td></tr>
<tr class="separator:af4c0051b20d34181994aa5560387054e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00f219e8545b9dcff63940bf1bc4d63e"><td class="memTemplParams" colspan="2">template&lt;typename Tup , typename ArgType , size_t ... index&gt; </td></tr>
<tr class="memitem:a00f219e8545b9dcff63940bf1bc4d63e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a00f219e8545b9dcff63940bf1bc4d63e">hydra::detail::invoke_normalized_helper</a> (ArgType const &amp;x, Tup const &amp;tup, index_sequence&lt; index... &gt;) -&gt; decltype(<a class="el" href="namespacehydra.html#ae9e1c8df3eaea2b9e4646c5dcdeaf322">hydra::thrust::make_tuple</a>(<a class="el" href="namespacehydra.html#a2658beb74af1f617373f6f640e2949e4">hydra::thrust::get</a>&lt; index &gt;(tup)(x)...))</td></tr>
<tr class="separator:a00f219e8545b9dcff63940bf1bc4d63e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a173eb394103a0e94fbf9abbc1918a894"><td class="memItemLeft" align="right" valign="top"><a class="el" href="basic__distributions_8inl.html#a9717e7bbecb906637e86cef6da3d83c2">return</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a173eb394103a0e94fbf9abbc1918a894">hydra::detail::invoke_normalized_helper</a> (x, tup, make_index_sequence&lt; Size &gt; { })</td></tr>
<tr class="separator:a173eb394103a0e94fbf9abbc1918a894"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3253bf4c374c43071735c8ca91a1598"><td class="memTemplParams" colspan="2">template&lt;typename Tup , typename ArgType , size_t ... index&gt; </td></tr>
<tr class="memitem:af3253bf4c374c43071735c8ca91a1598"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#af3253bf4c374c43071735c8ca91a1598">hydra::detail::invoke_normalized_helper</a> (ArgType &amp;&amp;x, Tup &amp;&amp;tup, index_sequence&lt; index... &gt;) -&gt; decltype(<a class="el" href="namespacehydra.html#ae9e1c8df3eaea2b9e4646c5dcdeaf322">hydra::thrust::make_tuple</a>(<a class="el" href="namespacehydra.html#a2658beb74af1f617373f6f640e2949e4">hydra::thrust::get</a>&lt; index &gt;(std::forward&lt; Tup &gt;(tup))(std::forward&lt; ArgType &gt;(x))...))</td></tr>
<tr class="separator:af3253bf4c374c43071735c8ca91a1598"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecd9fdc1ef691978c73582a7f81ca59b"><td class="memTemplParams" colspan="2">template&lt;typename ... T&gt; </td></tr>
<tr class="memitem:aecd9fdc1ef691978c73582a7f81ca59b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#aecd9fdc1ef691978c73582a7f81ca59b">hydra::detail::make_rtuple</a> (<a class="el" href="namespacehydra.html#ac3486502b2db72187626125cea971683">hydra::thrust::tuple</a>&lt; T... &gt; &amp;t) -&gt; <a class="el" href="namespacehydra.html#ac3486502b2db72187626125cea971683">hydra::thrust::tuple</a>&lt; T &amp;... &gt;</td></tr>
<tr class="separator:aecd9fdc1ef691978c73582a7f81ca59b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dbc5fcecd172e18c2ecb75b89560ac2"><td class="memTemplParams" colspan="2">template&lt;typename ... T, size_t... I&gt; </td></tr>
<tr class="memitem:a6dbc5fcecd172e18c2ecb75b89560ac2"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a6dbc5fcecd172e18c2ecb75b89560ac2">hydra::detail::make_rtuple_helper</a> (<a class="el" href="namespacehydra.html#ac3486502b2db72187626125cea971683">hydra::thrust::tuple</a>&lt; T... &gt; &amp;t, index_sequence&lt; I... &gt;) -&gt; <a class="el" href="namespacehydra.html#ac3486502b2db72187626125cea971683">hydra::thrust::tuple</a>&lt; T &amp;... &gt;</td></tr>
<tr class="separator:a6dbc5fcecd172e18c2ecb75b89560ac2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac16e513053ac8d97923ac166db8e6a98"><td class="memItemLeft" align="right" valign="top">T ::type TupleType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#ac16e513053ac8d97923ac166db8e6a98">hydra::detail::make_tuple</a> (T &amp;&amp;value)</td></tr>
<tr class="separator:ac16e513053ac8d97923ac166db8e6a98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad720a19d349e53d36757cfe71338ca64"><td class="memTemplParams" colspan="2">template&lt;typename ... T&gt; </td></tr>
<tr class="memitem:ad720a19d349e53d36757cfe71338ca64"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#ad720a19d349e53d36757cfe71338ca64">hydra::detail::max</a> (<a class="el" href="namespacehydra.html#ac3486502b2db72187626125cea971683">hydra::thrust::tuple</a>&lt; T... &gt; const &amp;tuple)</td></tr>
<tr class="separator:ad720a19d349e53d36757cfe71338ca64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4140580867ee73e401e1bb1e213548c"><td class="memTemplParams" colspan="2">template&lt;typename T , typename C , size_t N, size_t I&gt; </td></tr>
<tr class="memitem:aa4140580867ee73e401e1bb1e213548c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> std::enable_if&lt; I==N, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#aa4140580867ee73e401e1bb1e213548c">hydra::detail::max_helper</a> (T const &amp;, <a class="el" href="basic__distributions_8inl.html#a4900ef306eb9271438791f1a98b8ccba">C</a> &amp;, size_t &amp;)</td></tr>
<tr class="separator:aa4140580867ee73e401e1bb1e213548c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad23b453b58064598dbd7596ffca55422"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#ad23b453b58064598dbd7596ffca55422">hydra::detail::max_helper&lt; T, C, N, I+1 &gt;</a> (tuple, max_value, max_index)</td></tr>
<tr class="separator:ad23b453b58064598dbd7596ffca55422"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b1dbe6a0f5f757d371526da98ae8402"><td class="memTemplParams" colspan="2">template&lt;typename ... T&gt; </td></tr>
<tr class="memitem:a2b1dbe6a0f5f757d371526da98ae8402"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a2b1dbe6a0f5f757d371526da98ae8402">hydra::detail::multiply_array_tuple</a> (GReal_t(&amp;fCoefficients)[sizeof...(T)], <a class="el" href="namespacehydra.html#ac3486502b2db72187626125cea971683">hydra::thrust::tuple</a>&lt; T... &gt; const &amp;tpl) -&gt; decltype(multiply_array_tuple_helper(fCoefficients, tpl, make_index_sequence&lt; sizeof...(T)&gt;</td></tr>
<tr class="separator:a2b1dbe6a0f5f757d371526da98ae8402"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dedb058563f9d7f616d862fd25b9e3b"><td class="memTemplParams" colspan="2">template&lt;typename Tuple , size_t ... I&gt; </td></tr>
<tr class="memitem:a9dedb058563f9d7f616d862fd25b9e3b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> tuple_type&lt; sizeof...(I), GReal_t &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a9dedb058563f9d7f616d862fd25b9e3b">hydra::detail::multiply_array_tuple_helper</a> (GReal_t(&amp;fCoefficients)[sizeof...(I)], Tuple const &amp;tpl, index_sequence&lt; I... &gt;)</td></tr>
<tr class="separator:a9dedb058563f9d7f616d862fd25b9e3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a983d20b80673f7930cb06751ddfe2685"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename Return_Type , typename ... Tp&gt; </td></tr>
<tr class="memitem:a983d20b80673f7930cb06751ddfe2685"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::detail::enable_if&lt; I==sizeof...(Tp), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a983d20b80673f7930cb06751ddfe2685">hydra::detail::multiply_tuple</a> (Return_Type &amp;, <a class="el" href="namespacehydra.html#ac3486502b2db72187626125cea971683">hydra::thrust::tuple</a>&lt; Tp... &gt; const &amp;)</td></tr>
<tr class="separator:a983d20b80673f7930cb06751ddfe2685"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac68db34ed817ab2a9dd8dca991576c4f"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename Return_Type , typename ... Tp&gt; </td></tr>
<tr class="memitem:ac68db34ed817ab2a9dd8dca991576c4f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::detail::enable_if&lt;(I&lt; sizeof...(Tp)), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#ac68db34ed817ab2a9dd8dca991576c4f">hydra::detail::multiply_tuple</a> (Return_Type &amp;r, <a class="el" href="namespacehydra.html#ac3486502b2db72187626125cea971683">hydra::thrust::tuple</a>&lt; Tp... &gt;const &amp;t)</td></tr>
<tr class="separator:ac68db34ed817ab2a9dd8dca991576c4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5306b782f3856dcd6fe0deb087d3d547"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename Return_Type , typename ... Tp&gt; </td></tr>
<tr class="memitem:a5306b782f3856dcd6fe0deb087d3d547"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::detail::enable_if&lt; I==sizeof...(Tp), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a5306b782f3856dcd6fe0deb087d3d547">hydra::detail::multiply_tuple</a> (Return_Type &amp;, <a class="el" href="namespacehydra.html#ac3486502b2db72187626125cea971683">hydra::thrust::tuple</a>&lt; Tp... &gt; &amp;&amp;)</td></tr>
<tr class="separator:a5306b782f3856dcd6fe0deb087d3d547"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d606d63c86ccd96e65d66a120fa9738"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename Return_Type , typename ... Tp&gt; </td></tr>
<tr class="memitem:a9d606d63c86ccd96e65d66a120fa9738"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::detail::enable_if&lt;(I&lt; sizeof...(Tp)), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a9d606d63c86ccd96e65d66a120fa9738">hydra::detail::multiply_tuple</a> (Return_Type &amp;r, <a class="el" href="namespacehydra.html#ac3486502b2db72187626125cea971683">hydra::thrust::tuple</a>&lt; Tp... &gt; &amp;&amp;t)</td></tr>
<tr class="separator:a9d606d63c86ccd96e65d66a120fa9738"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3571c0ce97f1472331216a675bb7857"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename ... Tp&gt; </td></tr>
<tr class="memitem:ae3571c0ce97f1472331216a675bb7857"><td class="memTemplItemLeft" align="right" valign="top">hydra::thrust::detail::enable_if&lt; I==sizeof...(Tp), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#ae3571c0ce97f1472331216a675bb7857">hydra::detail::print_parameters_in_tuple</a> (<a class="el" href="namespacehydra.html#ac3486502b2db72187626125cea971683">hydra::thrust::tuple</a>&lt; Tp... &gt; &amp;)</td></tr>
<tr class="separator:ae3571c0ce97f1472331216a675bb7857"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1df72ec6bac610a8f6d2be642ca1d3a"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename ... Tp&gt; </td></tr>
<tr class="memitem:ae1df72ec6bac610a8f6d2be642ca1d3a"><td class="memTemplItemLeft" align="right" valign="top">hydra::thrust::detail::enable_if&lt;(I&lt; sizeof...(Tp)), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#ae1df72ec6bac610a8f6d2be642ca1d3a">hydra::detail::print_parameters_in_tuple</a> (<a class="el" href="namespacehydra.html#ac3486502b2db72187626125cea971683">hydra::thrust::tuple</a>&lt; Tp... &gt; &amp;t)</td></tr>
<tr class="separator:ae1df72ec6bac610a8f6d2be642ca1d3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9df96670ef4114c14fa30390b3dca5e"><td class="memTemplParams" colspan="2">template&lt;typename Return_Type , typename ArgType , typename ... Tp, typename  = typename hydra::thrust::detail::enable_if&lt;std::is_convertible&lt;Return_Type, double&gt;::value || std::is_constructible&lt;hydra::thrust::complex&lt;double&gt;,Return_Type&gt;::value &gt;::type&gt; </td></tr>
<tr class="memitem:aa9df96670ef4114c14fa30390b3dca5e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> Return_Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#aa9df96670ef4114c14fa30390b3dca5e">hydra::detail::product</a> (ArgType const &amp;x, <a class="el" href="namespacehydra.html#ac3486502b2db72187626125cea971683">hydra::thrust::tuple</a>&lt; Tp... &gt; const &amp;t)</td></tr>
<tr class="separator:aa9df96670ef4114c14fa30390b3dca5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad71212520aeba6bfdd5f2f08b1e57949"><td class="memTemplParams" colspan="2">template&lt;typename Return_Type , typename ArgType , typename ... Tp, typename  = typename hydra::thrust::detail::enable_if&lt;std::is_convertible&lt;Return_Type, double&gt;::value || std::is_constructible&lt;hydra::thrust::complex&lt;double&gt;,Return_Type&gt;::value &gt;::type&gt; </td></tr>
<tr class="memitem:ad71212520aeba6bfdd5f2f08b1e57949"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> Return_Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#ad71212520aeba6bfdd5f2f08b1e57949">hydra::detail::product</a> (ArgType &amp;x, <a class="el" href="namespacehydra.html#ac3486502b2db72187626125cea971683">hydra::thrust::tuple</a>&lt; Tp... &gt; &amp;t)</td></tr>
<tr class="separator:ad71212520aeba6bfdd5f2f08b1e57949"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06f0f7278adec0e18aa797ff500aeec5"><td class="memTemplParams" colspan="2">template&lt;typename Return_Type , typename ArgType1 , typename ArgType2 , typename ... Tp, typename  = typename hydra::thrust::detail::enable_if&lt;std::is_convertible&lt;Return_Type, double&gt;::value || std::is_constructible&lt;hydra::thrust::complex&lt;double&gt;,Return_Type&gt;::value &gt;::type&gt; </td></tr>
<tr class="memitem:a06f0f7278adec0e18aa797ff500aeec5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> Return_Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a06f0f7278adec0e18aa797ff500aeec5">hydra::detail::product2</a> (ArgType1 const &amp;x, ArgType2 const &amp;y, <a class="el" href="namespacehydra.html#ac3486502b2db72187626125cea971683">hydra::thrust::tuple</a>&lt; Tp... &gt; const &amp;t)</td></tr>
<tr class="separator:a06f0f7278adec0e18aa797ff500aeec5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c82b9ba250e8b4c956796040a58e828"><td class="memTemplParams" colspan="2">template&lt;typename Return_Type , typename ArgType1 , typename ArgType2 , typename ... Tp, typename  = typename hydra::thrust::detail::enable_if&lt;std::is_convertible&lt;Return_Type, double&gt;::value || std::is_constructible&lt;hydra::thrust::complex&lt;double&gt;,Return_Type&gt;::value &gt;::type&gt; </td></tr>
<tr class="memitem:a5c82b9ba250e8b4c956796040a58e828"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> Return_Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a5c82b9ba250e8b4c956796040a58e828">hydra::detail::product2</a> (ArgType1 &amp;x, ArgType2 &amp;y, <a class="el" href="namespacehydra.html#ac3486502b2db72187626125cea971683">hydra::thrust::tuple</a>&lt; Tp... &gt; &amp;t)</td></tr>
<tr class="separator:a5c82b9ba250e8b4c956796040a58e828"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adabaf23bc5b2f9f9c80cbd757274ce52"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename Return_Type , typename ArgType , typename ... Tp&gt; </td></tr>
<tr class="memitem:adabaf23bc5b2f9f9c80cbd757274ce52"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::detail::enable_if&lt; I==sizeof...(Tp), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#adabaf23bc5b2f9f9c80cbd757274ce52">hydra::detail::product_tuple</a> (Return_Type &amp;, <a class="el" href="namespacehydra.html#ac3486502b2db72187626125cea971683">hydra::thrust::tuple</a>&lt; Tp... &gt; const &amp;, ArgType const &amp;)</td></tr>
<tr class="separator:adabaf23bc5b2f9f9c80cbd757274ce52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09a64a12d8e0efe71a16254afed3ce51"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename Return_Type , typename ArgType , typename ... Tp&gt; </td></tr>
<tr class="memitem:a09a64a12d8e0efe71a16254afed3ce51"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::detail::enable_if&lt;(I&lt; sizeof...(Tp)), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a09a64a12d8e0efe71a16254afed3ce51">hydra::detail::product_tuple</a> (Return_Type &amp;r, <a class="el" href="namespacehydra.html#ac3486502b2db72187626125cea971683">hydra::thrust::tuple</a>&lt; Tp... &gt; const &amp;t, ArgType const &amp;arg)</td></tr>
<tr class="separator:a09a64a12d8e0efe71a16254afed3ce51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7ce3d4782e6cc3741d7c22a0a1e6ff4"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename Return_Type , typename ArgType , typename ... Tp&gt; </td></tr>
<tr class="memitem:ab7ce3d4782e6cc3741d7c22a0a1e6ff4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::detail::enable_if&lt; I==sizeof...(Tp), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#ab7ce3d4782e6cc3741d7c22a0a1e6ff4">hydra::detail::product_tuple</a> (Return_Type &amp;, <a class="el" href="namespacehydra.html#ac3486502b2db72187626125cea971683">hydra::thrust::tuple</a>&lt; Tp... &gt; &amp;&amp;, ArgType &amp;&amp;)</td></tr>
<tr class="separator:ab7ce3d4782e6cc3741d7c22a0a1e6ff4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ddfad88876786c74e596db9c81b2850"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename Return_Type , typename ArgType , typename ... Tp&gt; </td></tr>
<tr class="memitem:a4ddfad88876786c74e596db9c81b2850"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::detail::enable_if&lt;(I&lt; sizeof...(Tp)), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a4ddfad88876786c74e596db9c81b2850">hydra::detail::product_tuple</a> (Return_Type &amp;r, <a class="el" href="namespacehydra.html#ac3486502b2db72187626125cea971683">hydra::thrust::tuple</a>&lt; Tp... &gt; &amp;&amp;t, ArgType &amp;&amp;arg)</td></tr>
<tr class="separator:a4ddfad88876786c74e596db9c81b2850"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dd180e5db52df8b603f54eccec23540"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename Return_Type , typename ArgType1 , typename ArgType2 , typename ... Tp&gt; </td></tr>
<tr class="memitem:a9dd180e5db52df8b603f54eccec23540"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::detail::enable_if&lt; I==sizeof...(Tp), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a9dd180e5db52df8b603f54eccec23540">hydra::detail::product_tuple2</a> (Return_Type &amp;, <a class="el" href="namespacehydra.html#ac3486502b2db72187626125cea971683">hydra::thrust::tuple</a>&lt; Tp... &gt; const &amp;, ArgType1 const &amp;, ArgType2 const &amp;)</td></tr>
<tr class="separator:a9dd180e5db52df8b603f54eccec23540"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab889266aba923c3d948f60ed385743f5"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename Return_Type , typename ArgType1 , typename ArgType2 , typename ... Tp&gt; </td></tr>
<tr class="memitem:ab889266aba923c3d948f60ed385743f5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::detail::enable_if&lt;(I&lt;(sizeof...(Tp))), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#ab889266aba923c3d948f60ed385743f5">hydra::detail::product_tuple2</a> (Return_Type &amp;r, <a class="el" href="namespacehydra.html#ac3486502b2db72187626125cea971683">hydra::thrust::tuple</a>&lt; Tp... &gt; const &amp;t, ArgType1 const &amp;arg1, ArgType2 const &amp;arg2)</td></tr>
<tr class="separator:ab889266aba923c3d948f60ed385743f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a439342ca452238b86683172c616af275"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename Return_Type , typename ArgType1 , typename ArgType2 , typename ... Tp&gt; </td></tr>
<tr class="memitem:a439342ca452238b86683172c616af275"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::detail::enable_if&lt; I==sizeof...(Tp), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a439342ca452238b86683172c616af275">hydra::detail::product_tuple2</a> (Return_Type &amp;, <a class="el" href="namespacehydra.html#ac3486502b2db72187626125cea971683">hydra::thrust::tuple</a>&lt; Tp... &gt; &amp;&amp;, ArgType1 &amp;&amp;, ArgType2 &amp;&amp;)</td></tr>
<tr class="separator:a439342ca452238b86683172c616af275"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae57819631ed091712bbf07475ead232"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename Return_Type , typename ArgType1 , typename ArgType2 , typename ... Tp&gt; </td></tr>
<tr class="memitem:aae57819631ed091712bbf07475ead232"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::detail::enable_if&lt;(I&lt;(sizeof...(Tp))), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#aae57819631ed091712bbf07475ead232">hydra::detail::product_tuple2</a> (Return_Type &amp;r, <a class="el" href="namespacehydra.html#ac3486502b2db72187626125cea971683">hydra::thrust::tuple</a>&lt; Tp... &gt; &amp;&amp;t, ArgType1 &amp;&amp;arg1, ArgType2 &amp;&amp;arg2)</td></tr>
<tr class="separator:aae57819631ed091712bbf07475ead232"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a3a2145b19503fed123dff2196155c3"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, size_t N, typename Return_Type , typename ArgType1 , typename ArgType2 , typename ... Tp&gt; </td></tr>
<tr class="memitem:a5a3a2145b19503fed123dff2196155c3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::detail::enable_if&lt; I==N, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a5a3a2145b19503fed123dff2196155c3">hydra::detail::product_tuple3</a> (Return_Type &amp;, <a class="el" href="namespacehydra.html#ac3486502b2db72187626125cea971683">hydra::thrust::tuple</a>&lt; Tp... &gt; const &amp;, ArgType1 const &amp;, ArgType2 const &amp;)</td></tr>
<tr class="separator:a5a3a2145b19503fed123dff2196155c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6561fc8b52118b1c2139a976128cb4e"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, size_t N, typename Return_Type , typename ArgType1 , typename ArgType2 , typename ... Tp&gt; </td></tr>
<tr class="memitem:af6561fc8b52118b1c2139a976128cb4e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::detail::enable_if&lt;(I&lt; N), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#af6561fc8b52118b1c2139a976128cb4e">hydra::detail::product_tuple3</a> (Return_Type &amp;r, <a class="el" href="namespacehydra.html#ac3486502b2db72187626125cea971683">hydra::thrust::tuple</a>&lt; Tp... &gt; const &amp;t, ArgType1 const &amp;arg1, ArgType2 const &amp;arg2)</td></tr>
<tr class="separator:af6561fc8b52118b1c2139a976128cb4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf3f3a459fd81baba8d17ad3db69aae9"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, size_t N, typename Return_Type , typename ArgType1 , typename ArgType2 , typename ... Tp&gt; </td></tr>
<tr class="memitem:aaf3f3a459fd81baba8d17ad3db69aae9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::detail::enable_if&lt; I==N, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#aaf3f3a459fd81baba8d17ad3db69aae9">hydra::detail::product_tuple3</a> (Return_Type &amp;, <a class="el" href="namespacehydra.html#ac3486502b2db72187626125cea971683">hydra::thrust::tuple</a>&lt; Tp... &gt; &amp;&amp;, ArgType1 &amp;&amp;, ArgType2 &amp;&amp;)</td></tr>
<tr class="separator:aaf3f3a459fd81baba8d17ad3db69aae9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b12b4c186d19a36238c7e82cd8d4348"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, size_t N, typename Return_Type , typename ArgType1 , typename ArgType2 , typename ... Tp&gt; </td></tr>
<tr class="memitem:a6b12b4c186d19a36238c7e82cd8d4348"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::detail::enable_if&lt;(I&lt; N), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a6b12b4c186d19a36238c7e82cd8d4348">hydra::detail::product_tuple3</a> (Return_Type &amp;r, <a class="el" href="namespacehydra.html#ac3486502b2db72187626125cea971683">hydra::thrust::tuple</a>&lt; Tp... &gt; &amp;&amp;t, ArgType1 &amp;&amp;arg1, ArgType2 &amp;&amp;arg2)</td></tr>
<tr class="separator:a6b12b4c186d19a36238c7e82cd8d4348"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9108ba6cbf5144a048fa7c2ed068d5ba"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a9108ba6cbf5144a048fa7c2ed068d5ba"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a9108ba6cbf5144a048fa7c2ed068d5ba">hydra::detail::ptr_setter</a> (T1 *&amp;ptr, typename hydra::thrust::detail::enable_if&lt; hydra::thrust::detail::is_same&lt; T1, T2 &gt;::value, T2 &gt;::type *el)</td></tr>
<tr class="separator:a9108ba6cbf5144a048fa7c2ed068d5ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a607a6a529236b69164e1a4a446a6e8c7"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a607a6a529236b69164e1a4a446a6e8c7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a607a6a529236b69164e1a4a446a6e8c7">hydra::detail::ptr_setter</a> (T1 *&amp;, typename hydra::thrust::detail::enable_if&lt;!hydra::thrust::detail::is_same&lt; T1, T2 &gt;::value, T2 &gt;::type *)</td></tr>
<tr class="separator:a607a6a529236b69164e1a4a446a6e8c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa21b24762fe6b3793d99a9c02bd523c1"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename ... Tp&gt; </td></tr>
<tr class="memitem:aa21b24762fe6b3793d99a9c02bd523c1"><td class="memTemplItemLeft" align="right" valign="top">hydra::thrust::detail::enable_if&lt; I==sizeof...(Tp), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#aa21b24762fe6b3793d99a9c02bd523c1">hydra::detail::set_functors_in_tuple</a> (<a class="el" href="namespacehydra.html#ac3486502b2db72187626125cea971683">hydra::thrust::tuple</a>&lt; Tp... &gt; &amp;, const std::vector&lt; <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt; &amp;)</td></tr>
<tr class="separator:aa21b24762fe6b3793d99a9c02bd523c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc2e3e251a1ba97b903c37dcf6b7614d"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename ... Tp&gt; </td></tr>
<tr class="memitem:afc2e3e251a1ba97b903c37dcf6b7614d"><td class="memTemplItemLeft" align="right" valign="top">hydra::thrust::detail::enable_if&lt;(I&lt; sizeof...(Tp)), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#afc2e3e251a1ba97b903c37dcf6b7614d">hydra::detail::set_functors_in_tuple</a> (<a class="el" href="namespacehydra.html#ac3486502b2db72187626125cea971683">hydra::thrust::tuple</a>&lt; Tp... &gt; &amp;t, const std::vector&lt; <a class="el" href="namespace_3globalScope_4.html#classdouble">double</a> &gt; &amp;parameters)</td></tr>
<tr class="separator:afc2e3e251a1ba97b903c37dcf6b7614d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57a43797825f305b178079f80fc79d11"><td class="memTemplParams" colspan="2">template&lt;unsigned int I, typename Ptr , typename ... Tp&gt; </td></tr>
<tr class="memitem:a57a43797825f305b178079f80fc79d11"><td class="memTemplItemLeft" align="right" valign="top">hydra::thrust::detail::enable_if&lt; I==sizeof...(Tp), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a57a43797825f305b178079f80fc79d11">hydra::detail::set_ptr_to_tuple_element</a> (const <a class="el" href="namespace_3globalScope_4.html#classint">int</a>, std::tuple&lt; Tp... &gt; &amp;, Ptr *&amp;)</td></tr>
<tr class="separator:a57a43797825f305b178079f80fc79d11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed57cabad1c9b745eafc489910884b2c"><td class="memTemplParams" colspan="2">template&lt;unsigned int I = 0, typename Ptr , typename ... Tp&gt; </td></tr>
<tr class="memitem:aed57cabad1c9b745eafc489910884b2c"><td class="memTemplItemLeft" align="right" valign="top">hydra::thrust::detail::enable_if&lt;(I&lt; sizeof...(Tp)), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#aed57cabad1c9b745eafc489910884b2c">hydra::detail::set_ptr_to_tuple_element</a> (const <a class="el" href="namespace_3globalScope_4.html#classint">int</a> index, std::tuple&lt; Tp... &gt; &amp;t, Ptr *&amp;ptr)</td></tr>
<tr class="separator:aed57cabad1c9b745eafc489910884b2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fc1f520b1120b2292937669d6c66505"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename Array_Type , typename T &gt; </td></tr>
<tr class="memitem:a2fc1f520b1120b2292937669d6c66505"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::detail::enable_if&lt;(I==<a class="el" href="namespacehydra.html#a58298133d4826dc6f35253762a7d6788">hydra::thrust::tuple_size</a>&lt; T &gt;::value) &amp;&amp;is_homogeneous&lt; Array_Type, T &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a2fc1f520b1120b2292937669d6c66505">hydra::detail::set_ptrs_to_tuple</a> (T &amp;, Array_Type **)</td></tr>
<tr class="separator:a2fc1f520b1120b2292937669d6c66505"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abced9457fd3703a8bf8b1a5d762ffb4b"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename Array_Type , typename T &gt; </td></tr>
<tr class="memitem:abced9457fd3703a8bf8b1a5d762ffb4b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::detail::enable_if&lt;(I&lt; <a class="el" href="namespacehydra.html#a58298133d4826dc6f35253762a7d6788">hydra::thrust::tuple_size</a>&lt; T &gt;::value) &amp;&amp;is_homogeneous&lt; Array_Type, T &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#abced9457fd3703a8bf8b1a5d762ffb4b">hydra::detail::set_ptrs_to_tuple</a> (T &amp;t, Array_Type **Array)</td></tr>
<tr class="separator:abced9457fd3703a8bf8b1a5d762ffb4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54539a1b1cee55ab70dc738bc89a5180"><td class="memTemplParams" colspan="2">template&lt;unsigned int I = 0, typename T , typename ... Tp&gt; </td></tr>
<tr class="memitem:a54539a1b1cee55ab70dc738bc89a5180"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::detail::enable_if&lt; I==sizeof...(Tp), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a54539a1b1cee55ab70dc738bc89a5180">hydra::detail::set_tuple_element</a> (const <a class="el" href="namespace_3globalScope_4.html#classint">int</a>, <a class="el" href="namespacehydra.html#ac3486502b2db72187626125cea971683">hydra::thrust::tuple</a>&lt; Tp... &gt; const &amp;, T &amp;)</td></tr>
<tr class="separator:a54539a1b1cee55ab70dc738bc89a5180"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8d27d3aecd240e4d7d3300bfc2ee63b"><td class="memTemplParams" colspan="2">template&lt;unsigned int I = 0, typename T , typename ... Tp&gt; </td></tr>
<tr class="memitem:ad8d27d3aecd240e4d7d3300bfc2ee63b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::detail::enable_if&lt;(I&lt; sizeof...(Tp)), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#ad8d27d3aecd240e4d7d3300bfc2ee63b">hydra::detail::set_tuple_element</a> (const <a class="el" href="namespace_3globalScope_4.html#classint">int</a> index, <a class="el" href="namespacehydra.html#ac3486502b2db72187626125cea971683">hydra::thrust::tuple</a>&lt; Tp... &gt; &amp;t, const T &amp;x)</td></tr>
<tr class="separator:ad8d27d3aecd240e4d7d3300bfc2ee63b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0125c53a3b2aac1cab9e83d65b6494f6"><td class="memTemplParams" colspan="2">template&lt;typename ... T1, typename ... T2&gt; </td></tr>
<tr class="memitem:a0125c53a3b2aac1cab9e83d65b6494f6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a0125c53a3b2aac1cab9e83d65b6494f6">hydra::detail::split_tuple</a> (<a class="el" href="namespacehydra.html#ac3486502b2db72187626125cea971683">hydra::thrust::tuple</a>&lt; T1... &gt; &amp;t1, <a class="el" href="namespacehydra.html#ac3486502b2db72187626125cea971683">hydra::thrust::tuple</a>&lt; T2... &gt; &amp;t2, <a class="el" href="namespacehydra.html#ac3486502b2db72187626125cea971683">hydra::thrust::tuple</a>&lt; T1..., T2... &gt; const &amp;t)</td></tr>
<tr class="separator:a0125c53a3b2aac1cab9e83d65b6494f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ab8d8856893dad2e11b1293005e5d35"><td class="memTemplParams" colspan="2">template&lt;size_t N, typename ... T&gt; </td></tr>
<tr class="memitem:a1ab8d8856893dad2e11b1293005e5d35"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a1ab8d8856893dad2e11b1293005e5d35">hydra::detail::split_tuple</a> (<a class="el" href="namespacehydra.html#ac3486502b2db72187626125cea971683">hydra::thrust::tuple</a>&lt; T... &gt; &amp;t) -&gt; decltype(split_tuple_helper(t, make_index_sequence&lt; N &gt;</td></tr>
<tr class="separator:a1ab8d8856893dad2e11b1293005e5d35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa93f2fd80191b1999092757e023a29c"><td class="memTemplParams" colspan="2">template&lt;typename ... T1, typename ... T2, size_t... I1, size_t... I2&gt; </td></tr>
<tr class="memitem:aaa93f2fd80191b1999092757e023a29c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#aaa93f2fd80191b1999092757e023a29c">hydra::detail::split_tuple_helper</a> (<a class="el" href="namespacehydra.html#ac3486502b2db72187626125cea971683">hydra::thrust::tuple</a>&lt; T1... &gt; &amp;t1, <a class="el" href="namespacehydra.html#ac3486502b2db72187626125cea971683">hydra::thrust::tuple</a>&lt; T2... &gt; &amp;t2, <a class="el" href="namespacehydra.html#ac3486502b2db72187626125cea971683">hydra::thrust::tuple</a>&lt; T1..., T2... &gt; const &amp;t, index_sequence&lt; I1... &gt;, index_sequence&lt; I2... &gt;)</td></tr>
<tr class="separator:aaa93f2fd80191b1999092757e023a29c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93552a3e6c3a7d409faf3ad676479465"><td class="memTemplParams" colspan="2">template&lt;typename ... T, size_t... I1, size_t... I2&gt; </td></tr>
<tr class="memitem:a93552a3e6c3a7d409faf3ad676479465"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a93552a3e6c3a7d409faf3ad676479465">hydra::detail::split_tuple_helper</a> (<a class="el" href="namespacehydra.html#ac3486502b2db72187626125cea971683">hydra::thrust::tuple</a>&lt; T... &gt; &amp;t, index_sequence&lt; I1... &gt;, index_sequence&lt; I2... &gt;) -&gt; decltype(<a class="el" href="namespacehydra.html#a2b1f7cf97347cb7e8ab8db38f9ed466e">hydra::thrust::make_pair</a>(<a class="el" href="namespacehydra.html#a9654f2c52c92ba7219bfc4e6edb9ef58">hydra::thrust::tie</a>(<a class="el" href="namespacehydra.html#a2658beb74af1f617373f6f640e2949e4">hydra::thrust::get</a>&lt; I1 &gt;(t)...), <a class="el" href="namespacehydra.html#a9654f2c52c92ba7219bfc4e6edb9ef58">hydra::thrust::tie</a>(<a class="el" href="namespacehydra.html#a2658beb74af1f617373f6f640e2949e4">hydra::thrust::get</a>&lt; I2++sizeof...(I1)&gt;(t)...)))</td></tr>
<tr class="separator:a93552a3e6c3a7d409faf3ad676479465"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a0afb276fe05c1beafcecc2e0f2b9e6"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename Return_Type , typename ArgType , typename ... Tp&gt; </td></tr>
<tr class="memitem:a1a0afb276fe05c1beafcecc2e0f2b9e6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::detail::enable_if&lt; I==sizeof...(Tp), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a1a0afb276fe05c1beafcecc2e0f2b9e6">hydra::detail::sum_tuple</a> (Return_Type &amp;, <a class="el" href="namespacehydra.html#ac3486502b2db72187626125cea971683">hydra::thrust::tuple</a>&lt; Tp... &gt; &amp;&amp;, ArgType &amp;&amp;)</td></tr>
<tr class="separator:a1a0afb276fe05c1beafcecc2e0f2b9e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a88f79d07aa17ce1978e5685ab4e6a1"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename Return_Type , typename ArgType , typename ... Tp&gt; </td></tr>
<tr class="memitem:a6a88f79d07aa17ce1978e5685ab4e6a1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::detail::enable_if&lt;(I&lt; sizeof...(Tp)), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a6a88f79d07aa17ce1978e5685ab4e6a1">hydra::detail::sum_tuple</a> (Return_Type &amp;r, <a class="el" href="namespacehydra.html#ac3486502b2db72187626125cea971683">hydra::thrust::tuple</a>&lt; Tp... &gt; &amp;&amp;t, ArgType &amp;&amp;arg)</td></tr>
<tr class="separator:a6a88f79d07aa17ce1978e5685ab4e6a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aceecb8b30f5203c57207c892d3ceb4c3"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename Return_Type , typename ArgType , typename ... Tp&gt; </td></tr>
<tr class="memitem:aceecb8b30f5203c57207c892d3ceb4c3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::detail::enable_if&lt; I==sizeof...(Tp), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#aceecb8b30f5203c57207c892d3ceb4c3">hydra::detail::sum_tuple</a> (Return_Type &amp;, <a class="el" href="namespacehydra.html#ac3486502b2db72187626125cea971683">hydra::thrust::tuple</a>&lt; Tp... &gt; const &amp;, ArgType const &amp;)</td></tr>
<tr class="separator:aceecb8b30f5203c57207c892d3ceb4c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecd4cf8b1f9353041de1f411389ab66d"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename Return_Type , typename ArgType , typename ... Tp&gt; </td></tr>
<tr class="memitem:aecd4cf8b1f9353041de1f411389ab66d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::detail::enable_if&lt;(I&lt; sizeof...(Tp)), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#aecd4cf8b1f9353041de1f411389ab66d">hydra::detail::sum_tuple</a> (Return_Type &amp;r, <a class="el" href="namespacehydra.html#ac3486502b2db72187626125cea971683">hydra::thrust::tuple</a>&lt; Tp... &gt;const &amp;t, ArgType const &amp;arg)</td></tr>
<tr class="separator:aecd4cf8b1f9353041de1f411389ab66d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ad8cca28a9c44ae90b5db186e5cd7ea"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename Return_Type , typename ArgType1 , typename ArgType2 , typename ... Tp&gt; </td></tr>
<tr class="memitem:a6ad8cca28a9c44ae90b5db186e5cd7ea"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::detail::enable_if&lt; I==sizeof...(Tp), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a6ad8cca28a9c44ae90b5db186e5cd7ea">hydra::detail::sum_tuple2</a> (Return_Type &amp;, <a class="el" href="namespacehydra.html#ac3486502b2db72187626125cea971683">hydra::thrust::tuple</a>&lt; Tp... &gt; &amp;&amp;, ArgType1 &amp;&amp;, ArgType2 &amp;&amp;)</td></tr>
<tr class="separator:a6ad8cca28a9c44ae90b5db186e5cd7ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7177c6a22b6fa4af64a6b0a27d80b984"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename Return_Type , typename ArgType1 , typename ArgType2 , typename ... Tp&gt; </td></tr>
<tr class="memitem:a7177c6a22b6fa4af64a6b0a27d80b984"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::detail::enable_if&lt;(I&lt; sizeof...(Tp)), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a7177c6a22b6fa4af64a6b0a27d80b984">hydra::detail::sum_tuple2</a> (Return_Type &amp;r, <a class="el" href="namespacehydra.html#ac3486502b2db72187626125cea971683">hydra::thrust::tuple</a>&lt; Tp... &gt; &amp;&amp;t, ArgType1 &amp;&amp;arg1, ArgType2 &amp;&amp;arg2)</td></tr>
<tr class="separator:a7177c6a22b6fa4af64a6b0a27d80b984"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cb4a9045ea6dd505cf04d74c52e61f4"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename Return_Type , typename ArgType1 , typename ArgType2 , typename ... Tp&gt; </td></tr>
<tr class="memitem:a9cb4a9045ea6dd505cf04d74c52e61f4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::detail::enable_if&lt; I==sizeof...(Tp), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a9cb4a9045ea6dd505cf04d74c52e61f4">hydra::detail::sum_tuple2</a> (Return_Type &amp;, <a class="el" href="namespacehydra.html#ac3486502b2db72187626125cea971683">hydra::thrust::tuple</a>&lt; Tp... &gt;const &amp;, ArgType1 const &amp;, ArgType2 const &amp;)</td></tr>
<tr class="separator:a9cb4a9045ea6dd505cf04d74c52e61f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e41539382f482a4d344b87c7f7a46e5"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename Return_Type , typename ArgType1 , typename ArgType2 , typename ... Tp&gt; </td></tr>
<tr class="memitem:a4e41539382f482a4d344b87c7f7a46e5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::detail::enable_if&lt;(I&lt; sizeof...(Tp)), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a4e41539382f482a4d344b87c7f7a46e5">hydra::detail::sum_tuple2</a> (Return_Type &amp;r, <a class="el" href="namespacehydra.html#ac3486502b2db72187626125cea971683">hydra::thrust::tuple</a>&lt; Tp... &gt; const &amp;t, ArgType1 const &amp;arg1, ArgType2 const &amp;arg2)</td></tr>
<tr class="separator:a4e41539382f482a4d344b87c7f7a46e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c77a410602498524dfb5844857c84dc"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename FistType , typename ... OtherTypes&gt; </td></tr>
<tr class="memitem:a3c77a410602498524dfb5844857c84dc"><td class="memTemplItemLeft" align="right" valign="top">hydra::thrust::detail::enable_if&lt; I==(sizeof...(OtherTypes)+1) &amp;&amp;are_all_same&lt; FistType, OtherTypes... &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a3c77a410602498524dfb5844857c84dc">hydra::detail::tupleToArray</a> (<a class="el" href="namespacehydra.html#ac3486502b2db72187626125cea971683">hydra::thrust::tuple</a>&lt; FistType, OtherTypes... &gt; const &amp;, std::array&lt; FistType, sizeof...(OtherTypes)+1 &gt; &amp;)</td></tr>
<tr class="separator:a3c77a410602498524dfb5844857c84dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0af1f330ae7d29bf0b1e33eb3f655af"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename FistType , typename ... OtherTypes&gt; </td></tr>
<tr class="memitem:ae0af1f330ae7d29bf0b1e33eb3f655af"><td class="memTemplItemLeft" align="right" valign="top">hydra::thrust::detail::enable_if&lt;(I&lt; sizeof...(OtherTypes)+1) &amp;&amp;are_all_same&lt; FistType, OtherTypes... &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#ae0af1f330ae7d29bf0b1e33eb3f655af">hydra::detail::tupleToArray</a> (<a class="el" href="namespacehydra.html#ac3486502b2db72187626125cea971683">hydra::thrust::tuple</a>&lt; FistType, OtherTypes... &gt; const &amp;t, std::array&lt; FistType, sizeof...(OtherTypes)+1 &gt; &amp;Array)</td></tr>
<tr class="separator:ae0af1f330ae7d29bf0b1e33eb3f655af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a811265beb04612913fec71efc6c97af4"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename FistType , typename ... OtherTypes&gt; </td></tr>
<tr class="memitem:a811265beb04612913fec71efc6c97af4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::detail::enable_if&lt; I==(sizeof...(OtherTypes)+1) &amp;&amp;are_all_same&lt; FistType, OtherTypes... &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a811265beb04612913fec71efc6c97af4">hydra::detail::tupleToArray</a> (<a class="el" href="namespacehydra.html#ac3486502b2db72187626125cea971683">hydra::thrust::tuple</a>&lt; FistType, OtherTypes... &gt; const &amp;, typename std::remove_reference&lt; FistType &gt;::type *)</td></tr>
<tr class="separator:a811265beb04612913fec71efc6c97af4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89c1bed6272c8b2efecbe3032ab769a4"><td class="memTemplParams" colspan="2">template&lt;size_t I = 0, typename FistType , typename ... OtherTypes&gt; </td></tr>
<tr class="memitem:a89c1bed6272c8b2efecbe3032ab769a4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::detail::enable_if&lt;(I&lt; sizeof...(OtherTypes)+1) &amp;&amp;are_all_same&lt; FistType, OtherTypes... &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a89c1bed6272c8b2efecbe3032ab769a4">hydra::detail::tupleToArray</a> (<a class="el" href="namespacehydra.html#ac3486502b2db72187626125cea971683">hydra::thrust::tuple</a>&lt; FistType, OtherTypes... &gt; const &amp;t, typename std::remove_reference&lt; FistType &gt;::type *Array)</td></tr>
<tr class="separator:a89c1bed6272c8b2efecbe3032ab769a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01f6c991c9345e0ef585f5c1e85773a3"><td class="memTemplParams" colspan="2">template&lt;typename TupleType , typename ArrayType &gt; </td></tr>
<tr class="memitem:a01f6c991c9345e0ef585f5c1e85773a3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> hydra::thrust::detail::enable_if&lt;(detail::is_instantiation_of&lt; <a class="el" href="namespacehydra.html#ac3486502b2db72187626125cea971683">hydra::thrust::tuple</a>, TupleType &gt;::value||detail::is_instantiation_of&lt; hydra::thrust::detail::tuple_of_iterator_references, TupleType &gt;::value), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a01f6c991c9345e0ef585f5c1e85773a3">hydra::detail::tupleToArray</a> (TupleType const &amp;_tuple, ArrayType *_array)</td></tr>
<tr class="separator:a01f6c991c9345e0ef585f5c1e85773a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a6e5ce23b23364c64166f4c390f0f5f03"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a6e5ce23b23364c64166f4c390f0f5f03">hydra::detail::make_index_sequence&lt; sizeof...(T) -N &gt;</a></td></tr>
<tr class="separator:a6e5ce23b23364c64166f4c390f0f5f03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50b277339704a9d22de5802abfd3ff22"><td class="memTemplParams" colspan="2">template&lt;typename T , typename C , size_t N, size_t I = 1&gt; </td></tr>
<tr class="memitem:a50b277339704a9d22de5802abfd3ff22"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Config_8h.html#abfd8a70679d1a0c531e1d38cc798a228">__hydra_host__</a> <a class="el" href="Config_8h.html#a438c5ef47bf121b2c5efb75836bcc865">__hydra_device__</a> std::enable_if&lt; I&lt; N, void &gt;::type max_helper(T const  &amp;tuple, <a class="el" href="basic__distributions_8inl.html#a4900ef306eb9271438791f1a98b8ccba">C</a> &amp;max_value, size_t &amp;max_index){ max_index=max_value &gt; <a class="el" href="namespacehydra.html#a2658beb74af1f617373f6f640e2949e4">hydra::thrust::get</a>&lt; I &gt;(tuple) ? max_index&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehydra_1_1detail.html#a50b277339704a9d22de5802abfd3ff22">hydra::detail::max_value</a> = max_value &gt; <a class="el" href="namespacehydra.html#a2658beb74af1f617373f6f640e2949e4">hydra::thrust::get</a>&lt;I&gt;(tuple) ? max_value : <a class="el" href="namespacehydra.html#a2658beb74af1f617373f6f640e2949e4">hydra::thrust::get</a>&lt;I&gt;(tuple)</td></tr>
<tr class="separator:a50b277339704a9d22de5802abfd3ff22"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<hr/><h2 class="groupheader">Data Structure Documentation</h2>
<a name="structhydra_1_1detail_1_1references__tuple__type" id="structhydra_1_1detail_1_1references__tuple__type"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1detail_1_1references__tuple__type">&#9670;&nbsp;</a></span>hydra::detail::references_tuple_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::detail::references_tuple_type</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;size_t N, typename T&gt;<br />
struct hydra::detail::references_tuple_type&lt; N, T &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::detail::references_tuple_type&lt; N, T &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1references__tuple__type__coll__graph.svg" width="174" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a5b7b28f3038efea5e16af361c761c1b4"></a>typedef <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1repeat">repeat</a>&lt; T, N, tuple_of_iterator_references &gt;::<a class="el" href="namespacehydra_1_1detail.html#a5b7b28f3038efea5e16af361c761c1b4">type</a></td>
<td class="fieldname">
type</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structhydra_1_1detail_1_1tuple__cat__type" id="structhydra_1_1detail_1_1tuple__cat__type"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1detail_1_1tuple__cat__type">&#9670;&nbsp;</a></span>hydra::detail::tuple_cat_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::detail::tuple_cat_type</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename Tuple1, typename Tuple2&gt;<br />
struct hydra::detail::tuple_cat_type&lt; Tuple1, Tuple2 &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::detail::tuple_cat_type&lt; Tuple1, Tuple2 &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1tuple__cat__type__coll__graph.svg" width="200" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a name="structhydra_1_1detail_1_1tuple__cat__type_3_01hydra_1_1thrust_1_1detail_1_1tuple__of__iterator__e875b1e0f0d98602461f9d0c3462aad3" id="structhydra_1_1detail_1_1tuple__cat__type_3_01hydra_1_1thrust_1_1detail_1_1tuple__of__iterator__e875b1e0f0d98602461f9d0c3462aad3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1detail_1_1tuple__cat__type_3_01hydra_1_1thrust_1_1detail_1_1tuple__of__iterator__e875b1e0f0d98602461f9d0c3462aad3">&#9670;&nbsp;</a></span>hydra::detail::tuple_cat_type&lt; hydra::thrust::detail::tuple_of_iterator_references&lt; T1... &gt;, hydra::thrust::detail::tuple_of_iterator_references&lt; T2... &gt; &gt;</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::detail::tuple_cat_type&lt; hydra::thrust::detail::tuple_of_iterator_references&lt; T1... &gt;, hydra::thrust::detail::tuple_of_iterator_references&lt; T2... &gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename ... T1, typename ... T2&gt;<br />
struct hydra::detail::tuple_cat_type&lt; hydra::thrust::detail::tuple_of_iterator_references&lt; T1... &gt;, hydra::thrust::detail::tuple_of_iterator_references&lt; T2... &gt; &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::detail::tuple_cat_type&lt; hydra::thrust::detail::tuple_of_iterator_references&lt; T1... &gt;, hydra::thrust::detail::tuple_of_iterator_references&lt; T2... &gt; &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1tuple__cat__type_3_01hydra_1_1thrust_1_1detail_1_1tuple__of__iterator__96485e536c385bbaa94572426173ea38.svg" width="214" height="162"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a781c6cbc7da3f23f4d93ffd8186a428f"></a></td>
<td class="fieldname">
type</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structhydra_1_1detail_1_1tuple__cat__type_3_01hydra_1_1thrust_1_1tuple_3_01T1_8_8_8_01_4_00_01hy02a3f5f695c9d282a0a9beeb429a18a4" id="structhydra_1_1detail_1_1tuple__cat__type_3_01hydra_1_1thrust_1_1tuple_3_01T1_8_8_8_01_4_00_01hy02a3f5f695c9d282a0a9beeb429a18a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1detail_1_1tuple__cat__type_3_01hydra_1_1thrust_1_1tuple_3_01T1_8_8_8_01_4_00_01hy02a3f5f695c9d282a0a9beeb429a18a4">&#9670;&nbsp;</a></span>hydra::detail::tuple_cat_type&lt; hydra::thrust::tuple&lt; T1... &gt;, hydra::thrust::tuple&lt; T2... &gt; &gt;</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::detail::tuple_cat_type&lt; hydra::thrust::tuple&lt; T1... &gt;, hydra::thrust::tuple&lt; T2... &gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename ... T1, typename ... T2&gt;<br />
struct hydra::detail::tuple_cat_type&lt; hydra::thrust::tuple&lt; T1... &gt;, hydra::thrust::tuple&lt; T2... &gt; &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::detail::tuple_cat_type&lt; hydra::thrust::tuple&lt; T1... &gt;, hydra::thrust::tuple&lt; T2... &gt; &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1tuple__cat__type_3_01hydra_1_1thrust_1_1tuple_3_01T1_8_8_8_01_4_00_01hy6031fe0c723fbad6bf33d4c2f9170f20.svg" width="175" height="132"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="aa4ac0ad3146b152db625579432b36de0"></a></td>
<td class="fieldname">
type</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structhydra_1_1detail_1_1tuple__type" id="structhydra_1_1detail_1_1tuple__type"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhydra_1_1detail_1_1tuple__type">&#9670;&nbsp;</a></span>hydra::detail::tuple_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hydra::detail::tuple_type</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;size_t N, typename T&gt;<br />
struct hydra::detail::tuple_type&lt; N, T &gt;</h3>

</div><div class="dynheader">
Collaboration diagram for hydra::detail::tuple_type&lt; N, T &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structhydra_1_1detail_1_1tuple__type__coll__graph.svg" width="140" height="103"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a9ba5c4622ec78b2832b30043bb95fed5"></a>typedef <a class="el" href="namespacehydra_1_1detail.html#structhydra_1_1detail_1_1repeat">repeat</a>&lt; T, N, <a class="el" href="namespacehydra.html#ac3486502b2db72187626125cea971683">tuple</a> &gt;::<a class="el" href="namespacehydra_1_1detail.html#a9ba5c4622ec78b2832b30043bb95fed5">type</a></td>
<td class="fieldname">
type</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_92a1ff494355b06c14c0e1fe7b982d29.html">Hydra</a></li><li class="navelem"><a class="el" href="dir_108162cc96056bf8ace3602d16680a1c.html">hydra</a></li><li class="navelem"><a class="el" href="dir_3834ae61da54c887219d23c23fa56bea.html">detail</a></li><li class="navelem"><a class="el" href="dir_50b81e2dbdc2d397ec548125a86506fb.html">utility</a></li><li class="navelem"><a class="el" href="Utility__Tuple_8h.html">Utility_Tuple.h</a></li>
    <li class="footer">Generated on Sun Dec 3 2023 21:29:47 for Hydra by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.14 </li>
  </ul>
</div>
</body>
</html>
